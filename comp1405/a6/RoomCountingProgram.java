public class RoomCountingProgram {

	public static void displayMaze(byte[][] m) {
		for(int x = 0; x < m.length; x++) {
			for(int y = 0; y < m[0].length; y++) {
				if(m[x][y] == 1)
					System.out.print('*');
				else
					System.out.print(' ');
			}
		System.out.println();
		}
	}

	public static void resetMaze(byte[][] m) {
		for(int x = 0; x < m.length; x++) {
			for(int y = 0; y < m[0].length; y++) {
				if(m[x][y] != 1)
					m[x][y] = 0;
			}
		}
	}

	public static void floodFill(byte[][] m, int x, int y) {
		if(m[x][y] != 0)
			return;
		m[x][y] = 2;
		// since all mazes have an exterior wall no edge checks are needed
		floodFill(m, x - 1, y);
		floodFill(m, x, y - 1);
		floodFill(m, x + 1, y);
		floodFill(m, x, y + 1);
	}

	public static int countRooms(byte[][] m) {
		int count = 0;
		for(int x = 0; x < m.length; x++) {
			for(int y = 0; y < m[0].length; y++) {
				if(m[x][y] == 0) {
					floodFill(m, x, y);
					count++;
				}
			}
		}
		resetMaze(m);
		return count;
	}

	public static int spacesFilled(byte[][] m) {
		int total = 0;
		for(int x = 0; x < m.length; x++) {
			for(int y = 0; y < m[0].length; y++) {
				if(m[x][y] == 2)
					total++;
			}
		}
		return total;
	}

	public static int largestRoomSize(byte[][] m) {
		int size, oldSize, largest;
		size = oldSize = largest = 0;
		for(int x = 0; x < m.length; x++) {
			for(int y = 0; y < m[0].length; y++) {
				if(m[x][y] == 0) {
					floodFill(m, x, y);
					oldSize = size;
					size = spacesFilled(m);
					if(largest < size - oldSize)
						largest = size - oldSize;
				}
			}
		}
		resetMaze(m);
		return largest;
	}

	public static void main(String[] args) {
		byte[][][] maze = {{{1,1,1,1,1,1,1,1,1,1},{1,0,0,1,0,0,0,0,0,1},{1,0,1,1,1,0,1,1,0,1},{1,0,1,0,0,0,1,0,0,1},{1,0,1,0,1,1,1,0,1,1},{1,0,0,0,1,0,1,1,1,1},{1,0,1,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1,1}},{{1,1,1,1,1,1,1,1,1,1},{1,0,0,1,0,0,1,0,0,1},{1,0,1,1,1,0,1,1,0,1},{1,0,1,0,0,0,1,0,0,1},{1,0,1,1,1,1,1,0,1,1},{1,0,0,0,1,0,1,1,1,1},{1,0,1,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1,1}},{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,1,1,0,0,0,1},{1,0,1,0,1,0,0,1,0,1},{1,0,1,0,0,0,1,1,0,1},{1,0,0,0,0,1,1,0,0,1},{1,1,1,0,0,0,1,1,0,1},{1,0,0,1,0,0,0,1,0,1},{1,0,1,1,1,1,0,1,1,1},{1,0,0,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1,1}},{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,1,1,1,1,0,0,1},{1,0,0,1,0,0,1,0,0,1},{1,0,0,1,0,0,1,0,0,1},{1,0,0,1,1,1,1,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1,1}},{{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1,1}},{{1,1,1,1,1,1,1,1,1},{1,0,1,0,1,0,1,0,1},{1,0,1,0,1,0,1,0,1},{1,0,1,0,1,0,1,0,1},{1,0,1,0,1,0,1,0,1},{1,0,1,0,1,0,1,0,1},{1,0,1,0,1,0,1,0,1},{1,0,1,0,1,0,1,0,1},{1,0,1,0,1,0,1,0,1},{1,1,1,1,1,1,1,1,1}},{{1,1,1,1,1,1,1,1,1},{1,0,1,0,1,0,1,0,1},{1,1,1,1,1,1,1,1,1},{1,0,1,0,1,0,1,0,1},{1,1,1,1,1,1,1,1,1},{1,0,1,0,1,0,1,0,1},{1,1,1,1,1,1,1,1,1},{1,0,1,0,1,0,1,0,1},{1,1,1,1,1,1,1,1,1}},{{1,1,1,1,1,1,1,1,1},{1,0,0,0,1,0,0,0,1},{1,0,0,0,1,0,0,0,1},{1,0,0,0,1,0,0,0,1},{1,1,1,1,1,1,1,1,1},{1,0,0,0,1,0,0,0,1},{1,0,0,0,1,0,0,0,1},{1,0,0,0,1,0,0,0,1},{1,1,1,1,1,1,1,1,1}},{{1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,0,1},{1,0,0,0,0,0,1,0,1},{1,0,1,1,1,0,1,0,1},{1,0,1,0,0,0,1,0,1},{1,0,1,1,1,1,1,0,1},{1,0,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1}}};
		System.out.println("┌──────┬───────┬──────┐");
		System.out.println("│ Maze │ Rooms │ Area │");
		System.out.println("├──────┼───────┼──────┤");
		for(int i = 0; i < maze.length; i++)
			System.out.printf("│%4d  │%4d   │%4d  │%n", i + 1, countRooms(maze[i]), largestRoomSize(maze[i]));
		System.out.println("└──────┴───────┴──────┘");
	}
}