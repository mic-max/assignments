"3.0.0.152"
!
  
Smalltalk at: #WBDevelopmentBitmaps ifAbsentPut: [ Dictionary new ]!  
WBDevelopmentBitmaps at: 'ActionButtonSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'ButtonSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'CheckBoxSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'CP3DCheckBoxSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'CP3DRadioButtonSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'CPBitmapPaneSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'CPCircularGaugeSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'CPDateEditorSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'CPHorizontalBarGaugeSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'CPNumericEditorSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'CPTableEditorSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'CPValueSetSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'CPVerticalSliderSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'EnhancedEntryFieldSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'EntryFieldSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'GroupBoxSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'ListBoxSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'MultipleSelectListBoxSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'RadioButtonSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'StaticBoxSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'StaticTextSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'TextEditSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'TextSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WB3DButtonSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBAddressPaneSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBAlignBottomSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBAlignCenterVerticalSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBAlignDistributeVerticalSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBAlignRightSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBAnimationPaneSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBAutosizeSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBBringToFrontSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBCheckBoxSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBCompositeSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'CPStaticGraphicSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBCreateNewSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBDictionaryEditorPaneSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBEditAppCodeSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBGroupSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBListEditorPaneSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBLittleDownArrowSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBMiscSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBOkCancelPaneSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBOsilogoSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBPasteSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBPositionSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBRadioButtonSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBReplicateWidthSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBSendToBackSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBSetDrawGridSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBSetFramingSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBSizeSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBTestWindowSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBToolPaneExampleSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBVerticalScrollBarSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBWindowBuilderToolbarBitmapSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'CheckBoxGroupSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'CP3DFrameSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'CPBitmapToggleSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'CPHierarchicalListBoxSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'CPSpinButtonSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'CPVerticalBarGaugeSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'EntryFieldGroupSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'LinkButtonSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'RadioButtonGroupSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'StaticGraphicSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'TextPaneSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBAddressEditorPaneSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBAlignCenterHorizontalSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBAlignLeftSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBArrowToolSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBCheckBoxOnSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBCopySysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBCutSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBEditTabbingSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBListSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBNamePaneSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBOtherSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBRadioButtonOnSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBSaveSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBSetFontSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBSteelPatternSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBValuatorSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBWindowSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'ComboBoxSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'CPColumnarListBoxSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'CPTimeEditorSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'GraphPaneSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'SexPaneSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'ThreeStateButtonSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBAlignDistributeHorizontalSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBBitmapManagerToolbarSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBCreateNewDialogSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBHorizontalScrollBarSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBOpenNewSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBReplicateHeightSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBSetMenuSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBWbproSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'CPBitmapButtonSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'CPHorizontalSliderSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'DrawnButtonSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'ListPaneSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'StatusPaneSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBAddressSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBAlignTopSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBClearSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBDuplicateSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBLittleUpArrowSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBPersonPaneSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBSetColorSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBToolBarSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBPartsButtonSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBDUMMYSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'VideoPaneSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'RichEditSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'UpDownSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'HeaderSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'SpinButtonSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'ColumnListBoxSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'ProgressBarSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'TreeViewSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'ButtonListBoxSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'TabControlSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'TrackBarSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'ListViewSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBWindows95SysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBFramingAttachAllSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBFramingAttachLeftBottomSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBFramingAttachRightBottomSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBFramingAttachLeftTopSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBFramingAttachRightTopSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBFramingAttachPercentSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBEventEditorSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBPropertyEditorSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBTemplateEditorSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBFramingAttachLeftBottomRightSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBFramingAttachLeftTop2SysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBFramingAttachLeftBottomRight2SysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'WBFramingAttachLeftTopRight2SysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBFramingAttachLeftTopBottomSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'WBFramingAttachRightTopBottomSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'WBFramingAttachLeftTopRightSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'CPTablePaneSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'StatusWindowSysBitmap' ifAbsentPut: [ nil ]!
WBDevelopmentBitmaps at: 'ToolbarSysBitmap' ifAbsentPut: [ nil ]! 
WBDevelopmentBitmaps at: 'OLEClientSitePaneSysBitmap' ifAbsentPut: [ nil ]!   
WBDevelopmentBitmaps at: 'OLEControlPartSysBitmap' ifAbsentPut: [ nil ]!  
WBDevelopmentBitmaps at: 'WBDUMMY2SysBitmap' ifAbsentPut: [ nil ]!

ScrollBar subclass: #WBHorizontalScrollBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

ScrollBar subclass: #WBVerticalScrollBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WindowDialog subclass: #WBDevelopmentDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

ViewManager subclass: #WBDevelopmentWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBObject subclass: #WBDevelopmentObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

SubPane subclass: #WBDevelopmentSubPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

GroupBox subclass: #WBGroupBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

CompositePane subclass: #WBCompositePaneScratchWindow
  instanceVariableNames: 
    ' model '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!  

WBToolPalette subclass: #WBMultiToolPalette
  instanceVariableNames: 
    ' pages '
  classVariableNames: ''
  poolDictionaries: ''!

EntryField subclass: #WBKeyEntryField
  instanceVariableNames: 
    ' accelerator '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '! 

WBDevelopmentDialog subclass: #WBAboutDialog
  instanceVariableNames: ''
  classVariableNames: 
    ' InitTranscript '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '!  

EntryField subclass: #WBListEntryField
  instanceVariableNames: 
    ' owningListBox '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '!  

TextWindow subclass: #WBTextEditWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBDevelopmentDialog subclass: #WBCreateClassDialog
  instanceVariableNames: 
    ' newClass limitTo cache '
  classVariableNames: 
    ' DefaultPackage DefaultSuperClass DefaultType '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '! 

WBDevelopmentDialog subclass: #WBDefaultDialogScratchWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

CompositePane subclass: #WBDefaultCompositePaneScratchWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

WBDevelopmentDialog subclass: #WBFramingEditor
  instanceVariableNames: 
    ' result beforeScaleFactor hasFramed currentRect currentRectList parentRect largeParentRect framingParameters originXAnchor originYAnchor cornerXAnchor cornerYAnchor originYStyleFixed originYStyleScaled originXStyleFixed originXStyleScaled cornerXStyleFixed cornerXStyleScaled cornerYStyleFixed cornerYStyleScaled xCenteredCheckBox yCenteredCheckBox beforeRect afterRect leftRelative rightRelative topRelative bottomRelative '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '! 

ListBox subclass: #WBTreeListBox
  instanceVariableNames: 
    ' noSelect owningEditBox previousSelection cachedFlatList '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

WBDevelopmentObject subclass: #WBKeyAccel
  instanceVariableNames: 
    ' keyCode text isControl isShift isAlt '
  classVariableNames: 
    ' KeyConstantsDict '
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants '!   

WBDevelopmentWindow subclass: #WBScratchWindow
  instanceVariableNames: 
    ' model '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBDevelopmentWindow subclass: #WBMenuTester
  instanceVariableNames: 
    ' menus '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '! 

WBDevelopmentDialog subclass: #WBDialogScratchWindow
  instanceVariableNames: 
    ' model '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WBBitmaps '! 

WBDevelopmentDialog subclass: #WBMenuEditor
  instanceVariableNames: 
    ' warnedAboutAccelerators editedMenu shiftLeftButton shiftUpButton shiftDownButton shiftRightButton result hasAccelCheckBox keyShortCutEditor menuItemsEditor testItButton selectorEditor dividerState isAlt isShift isCtrl '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants ColorConstants OperatingSystemConstants '!  

TopPane subclass: #WBTopPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

WBDevelopmentDialog subclass: #WBScrapbookRetrieve
  instanceVariableNames: 
    ' layoutPane removedQuick chapter page scrapbook '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '! 

WBDevelopmentDialog subclass: #WBScrapbookStore
  instanceVariableNames: 
    ' layoutPane isQuick '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBDevelopmentWindow subclass: #WBDefaultScratchWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBMenuEditor subclass: #WBMenubarEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

WBDevelopmentObject subclass: #WBTabPosition
  instanceVariableNames: 
    ' basicTabPosition groupPosition '
  classVariableNames: ''
  poolDictionaries: ''!  

WBDevelopmentWindow subclass: #WindowBuilder
  instanceVariableNames: 
    ' prototype geometryManager undoManager scrollingForm currentLayoutForm name instVar styleEditor status sizeButton positionButton toolBar attributeBar groups entries outboards dirty editPalette cleanedOutCode customSubMenu editedClass titleText styleText titleEditor when perform thePane currentWhen sizePane positionPane '
  classVariableNames: 
    ' CustomPanes DevBitmapFileName EditorClass Extras HelpDict Properties Scrapbook ToolbarTool UserBitmapFileName WBClasses WBClipboard WBIcon '
  poolDictionaries: 
    ' CharacterConstants ColorConstants CommonDialogConstants OperatingSystemConstants VirtualKeyConstants WBDevelopmentBitmaps '!  

WBDevelopmentObject subclass: #WBTreeNode
  instanceVariableNames: 
    ' listString parent currentString children owner '
  classVariableNames: ''
  poolDictionaries: ''! 

WBDevelopmentWindow subclass: #BitEditor
  instanceVariableNames: 
    ' bitPen bitColor bitPoint scale copy imagePen imageForm imageRect windowSize '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

WBDevelopmentSubPane subclass: #WBFramerExample
  instanceVariableNames: 
    ' frameRect paneRect extent '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

WBTreeNode subclass: #WBPMenu
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

WBDevelopmentSubPane subclass: #WBScrollingPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

WBPMenu subclass: #WBPMenubar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

BitEditor subclass: #ButtonEditor
  instanceVariableNames: 
    ' fileName '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!   

WBTreeNode subclass: #WBPMenuItem
  instanceVariableNames: 
    ' isDivider keyAccel selector submenu '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '!  

DrawnButton subclass: #WBDrawnButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBDevelopmentWindow subclass: #WBAttributeWindow
  instanceVariableNames: 
    ' owner hasChanged ownerChanged '
  classVariableNames: ''
  poolDictionaries: ''!   

WBDevelopmentDialog subclass: #WBEditClassDialog
  instanceVariableNames: 
    ' selectedClass alt mostRecent mostFrequent filter package list ok '
  classVariableNames: 
    ' Filter FilterList FrequentClasses PackageChoice RecentClasses '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBDevelopmentWindow subclass: #WBTemplateEditor
  instanceVariableNames: 
    ' template templateList removeButton attributePalette styleLabel textLabel sample textEditor styleEditor sizeLabel templateGroup sizeButton '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '!

WBDevelopmentObject subclass: #WBDescriptor
  instanceVariableNames: 
    ' name commonName comment flags '
  classVariableNames: ''
  poolDictionaries: ''!

WBDescriptor subclass: #WBResourceDescriptor
  instanceVariableNames: 
    ' value '
  classVariableNames: ''
  poolDictionaries: ''!   

WBDevelopmentObject subclass: #WBLocator
  instanceVariableNames: 
    ' receiver selector arguments '
  classVariableNames: 
    ' CopiedFigures '
  poolDictionaries: ''!

WBDevelopmentObject subclass: #WBHandle
  instanceVariableNames: 
    ' locator '
  classVariableNames: 
    ' HandleSize '
  poolDictionaries: 
    ' OperatingSystemConstants '!

WBDevelopmentObject subclass: #WBUndoAction
  instanceVariableNames: 
    ' label undoAction redoAction '
  classVariableNames: ''
  poolDictionaries: ''!  

WBDevelopmentObject subclass: #WBUndoManager
  instanceVariableNames: 
    ' owner undoMenu redoMenu undoList current inUndo '
  classVariableNames: 
    ' MaxUndoLevels '
  poolDictionaries: 
    ' CharacterConstants '!  

Menu subclass: #WBMenu
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '!   

MenuItem subclass: #WBMenuItem
  instanceVariableNames: 
    ' menu owner enableSelector toggleSelector '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '!   

WBDevelopmentObject subclass: #WBGeometryManager
  instanceVariableNames: 
    ' owner '
  classVariableNames: ''
  poolDictionaries: ''!   

GroupPane subclass: #WBLayoutForm
  instanceVariableNames: 
    ' selections handles redrawMovingWidget dragOutline cursorOffset bandRect currentNib cursorSelectPoint allowMove motionState releaseState popupMenu loadedWidgets cursors minSize maxSize duplicateOffset duplicateWidgets directEditor showOrder targetIsFirst useFence useDirectSelect shellHandles drawingBitmap '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '!   

WBDevelopmentObject subclass: #WBPrototype
  instanceVariableNames: 
    ' owner shell windows properties targetObject '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '!

WBDevelopmentDialog subclass: #WBUndoRedoDialog
  instanceVariableNames: 
    ' undoManager undoList redoList undoButton redoButton levels '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBDevelopmentWindow subclass: #WBPropertyEditor
  instanceVariableNames: 
    ' categoryList propertyList valueTrue valueFalse valueString comment changes '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBLayoutForm subclass: #WBTabOrderLayoutForm
  instanceVariableNames: 
    ' widgets soloWidgets groups dragWidget largeFont smallFont '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '!

WBDevelopmentObject subclass: #WBPlaceHolderObject
  instanceVariableNames: 
    ' owner '
  classVariableNames: ''
  poolDictionaries: ''! 

WBPlaceHolderObject subclass: #WBTargetObject
  instanceVariableNames: 
    ' modelObjects eventsTriggered instVarMap realClass invalidInstVars oldHandlers '
  classVariableNames: ''
  poolDictionaries: ''!  

WBDevelopmentWindow subclass: #WBSystemBitmapViewer
  instanceVariableNames: 
    ' graphic list '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

ViewManager subclass: #WBCompositePaneTester
  instanceVariableNames: 
    ' classToTest frame '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBDevelopmentObject subclass: #WBCodeGenBase
  instanceVariableNames: 
    ' owner '
  classVariableNames: ''
  poolDictionaries: ''!   

WBCodeGenBase subclass: #WBClassDefinition
  instanceVariableNames: 
    ' classField poolNames nlsPools allInstVarNames instVarNames '
  classVariableNames: ''
  poolDictionaries: ''!

WBDevelopmentDialog subclass: #WBCallOutEditor
  instanceVariableNames: 
    ' owner callOutMap callOutList panesList selector '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

Object subclass: #WBGraphicObject
  instanceVariableNames: 
    ' rect lastRect properties '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!   

WBGraphicObject subclass: #WBInterfaceObject
  instanceVariableNames: 
    ' foreColor backColor contents style font menu framingBlock tabPosition realClass resID parentWindow isInstVar creationMethodSelector realWidget '
  classVariableNames: 
    ' ClassAndStyleDict Templates '
  poolDictionaries: 
    ' OperatingSystemConstants '!   

WBInterfaceObject subclass: #FrameObject
  instanceVariableNames: 
    ' editor lookPolicy '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!   

FrameObject subclass: #WindowFrameObject
  instanceVariableNames: 
    ' children iconFile createdBy modifiedBy '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!  

WindowFrameObject subclass: #CompositeFrameObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!   

WBInterfaceObject subclass: #PButton
  instanceVariableNames: 
    ' specialId '
  classVariableNames: 
    ' AutoRecognizeOkCancel '
  poolDictionaries: 
    ' OperatingSystemConstants '!  

WBInterfaceObject subclass: #PComboBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!  

PComboBox subclass: #PDropDownList
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBInterfaceObject subclass: #PCompositePane
  instanceVariableNames: 
    ' initialFraming children defaultBackColor '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

WBInterfaceObject subclass: #PDrawnButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!   

PDrawnButton subclass: #PActionButton
  instanceVariableNames: 
    ' action '
  classVariableNames: ''
  poolDictionaries: ''! 

PDrawnButton subclass: #PWBStaticGraphic
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

PDrawnButton subclass: #PLinkButton
  instanceVariableNames: 
    ' link type '
  classVariableNames: ''
  poolDictionaries: ''!

WBInterfaceObject subclass: #PEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

PEntryField subclass: #PEnhancedEntryField
  instanceVariableNames: 
    ' case character field getFocus justification maxSize autoTab '
  classVariableNames: ''
  poolDictionaries: ''!   

PEntryField subclass: #PFormattedEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBInterfaceObject subclass: #PEntryFieldGroup
  instanceVariableNames: 
    ' label children bestSize '
  classVariableNames: ''
  poolDictionaries: ''!

WBInterfaceObject subclass: #PGenericSubpane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBInterfaceObject subclass: #PGraphPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

PGraphPane subclass: #PAnimationPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

PGraphPane subclass: #PTextPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

WBInterfaceObject subclass: #PGroupbox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!  

PGroupbox subclass: #PGroupBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBInterfaceObject subclass: #PListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!   

PListBox subclass: #PListPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

PListBox subclass: #PMultipleSelectListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!  

WBInterfaceObject subclass: #PRadioButtonGroup
  instanceVariableNames: 
    ' label numColumns children '
  classVariableNames: ''
  poolDictionaries: ''! 

PRadioButtonGroup subclass: #PCheckBoxGroup
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBInterfaceObject subclass: #PScrollBar
  instanceVariableNames: 
    ' minimum maximum lineIncrement pageIncrement '
  classVariableNames: ''
  poolDictionaries: ''!  

PScrollBar subclass: #PWBHorizontalScrollBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

PScrollBar subclass: #PWBVerticalScrollBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!  

WBInterfaceObject subclass: #PStaticBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants SystemColorConstants '!

WBInterfaceObject subclass: #PStaticGraphic
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

WBInterfaceObject subclass: #PStaticText
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '! 

WBInterfaceObject subclass: #PStatusPane
  instanceVariableNames: 
    ' statusBoxes '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

WBInterfaceObject subclass: #PTextEdit
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!  

WBInterfaceObject subclass: #PToggle
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

PToggle subclass: #PCheckBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

PToggle subclass: #PRadioButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '! 

PToggle subclass: #PThreeStateButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

WBInterfaceObject subclass: #PWBInvisibleGroupPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBInterfaceObject subclass: #PWBToolBar
  instanceVariableNames: 
    ' cellSize elements useSystem '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!  

WBInterfaceObject subclass: #PRealWidgetControl
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBDevelopmentObject subclass: #WBManagedPValue
  instanceVariableNames: 
    ' owner key value association '
  classVariableNames: ''
  poolDictionaries: ''!   

WBManagedPValue subclass: #WBManagedPNLSString
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBManagedPValue subclass: #WBManagedPFont
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

PListBox subclass: #PButtonListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

PListBox subclass: #PColumnListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

PRealWidgetControl subclass: #PVideoPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

WBDevelopmentObject subclass: #WBLookPolicy
  instanceVariableNames: 
    ' menuFont menuBarHeight titleBarHeight systemMenuWidth frameWidthBorder frameWidthSizable frameWidthDialog scrollBarArrowHeight scrollBarArrowWidth scrollBarHeight scrollBarWidth scrollBarThumbHeight scrollBarThumbWidth '
  classVariableNames: 
    ' Current Default '
  poolDictionaries: 
    ' OperatingSystemConstants '!

WBLookPolicy subclass: #WBLookPolicyOS2
  instanceVariableNames: 
    ' pmWindowLibrary hwndDesktop '
  classVariableNames: 
    ' Down Left RadioBitmap Right Up '
  poolDictionaries: 
    ' OperatingSystemConstants '!

WBLookPolicy subclass: #WBLookPolicyWin31
  instanceVariableNames: 
    ' userLibrary '
  classVariableNames: 
    ' Down Left Right Up '
  poolDictionaries: 
    ' OperatingSystemConstants '!  

WBLookPolicy subclass: #WBLookPolicyWin95
  instanceVariableNames: 
    ' userLibrary '
  classVariableNames: 
    ' RadioBitmap SystemMenuBitmap '
  poolDictionaries: 
    ' OperatingSystemConstants '!

CompositePane subclass: #WBDevelopmentCompositePane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBDevelopmentDialog subclass: #WBCreateBitmap
  instanceVariableNames: 
    ' okButton result widthField heightField keyField initialKey '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  
WBCreateBitmap class instanceVariableNames: ' lastBitmapType lastBitmapWidth lastBitmapHeight bitmapTypes '!  

WBCreateBitmap subclass: #WBCreateButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '!

WBDevelopmentDialog subclass: #WBResizeBitmap
  instanceVariableNames: 
    ' okButton newWidthField newHeightField newExtent oldExtent isButtonBitmap isResizeAll isScaled '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBWindowDialog subclass: #WBAbstractPrompter
  instanceVariableNames: 
    ' result deferred '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBDevelopmentDialog subclass: #WBListChooser
  instanceVariableNames: 
    ' reply sel '
  classVariableNames: ''
  poolDictionaries: ''!   

WBListChooser subclass: #WBMultiListChooser
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBDevelopmentDialog subclass: #WBChooseClassDialog
  instanceVariableNames: 
    ' result classList classListBox default allowOthers '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBChooseClassDialog subclass: #WBChoosePaneDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBDevelopmentDialog subclass: #WBColorDialog
  instanceVariableNames: 
    ' result foreColor backColor thePane colors '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBColorDialog subclass: #WBRGBColorDialog
  instanceVariableNames: 
    ' elements defaults tempColors '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBDevelopmentDialog subclass: #WBUserInfoDialog
  instanceVariableNames: 
    ' companyField serialNumberField nameField '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

Message subclass: #WBEventMessage
  instanceVariableNames: 
    ' source event '
  classVariableNames: ''
  poolDictionaries: ''!   

WBDevelopmentWindow subclass: #WBOutboardWindow
  instanceVariableNames: 
    ' owner ownerChanged '
  classVariableNames: ''
  poolDictionaries: ''!   

WBOutboardWindow subclass: #WBTabOrderEditor
  instanceVariableNames: 
    ' layoutForm status result removeGroupButton '
  classVariableNames: 
    ' IncludeOuter '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBOutboardWindow subclass: #WBOutboardAttributeWindow
  instanceVariableNames: 
    ' currentWidget dirty currentWidgets '
  classVariableNames: ''
  poolDictionaries: ''! 

WBOutboardAttributeWindow subclass: #WBStyleEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBOutboardAttributeWindow subclass: #WBFontSelectionWindow
  instanceVariableNames: 
    ' selectedFont selectedPool poolManager sampleGroupBox sampleTextEdit '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBOutboardAttributeWindow subclass: #WBLayoutFrameEditor
  instanceVariableNames: 
    ' topAttachField leftAttachField bottomAttachField rightAttachField exampleAfter exampleBefore labels groups currentFramingBlocks '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '! 
WBLayoutFrameEditor class instanceVariableNames: ' verticalRatioStrings horizontalRatioStrings '! 

WBOutboardWindow subclass: #WBLayoutWizard
  instanceVariableNames: 
    ' sourceInstance widgetType modelList attributesList '
  classVariableNames: 
    ' DefaultButtons DefaultMenus LabelJustification MenuDefinitions StandardButtons StandardMenus WidgetMap '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBOutboardWindow subclass: #WBModelObjectEditor
  instanceVariableNames: 
    ' objectList editButton removeButton nameLabel name instVar style when send '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '! 

WBOutboardWindow subclass: #WBModelDefinitionEditor
  instanceVariableNames: 
    ' dirty selectedModel attributes events models myClass hasAccessors name initializeValue lazy initialized hasEvent '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBDevelopmentObject subclass: #WBModelInstVar
  instanceVariableNames: 
    ' name myClass hasAccessors initialized lazy valueClass initializeValue hasEvent properties '
  classVariableNames: ''
  poolDictionaries: ''!  

WBDevelopmentDialog subclass: #WBAddInManager
  instanceVariableNames: 
    ' changed selection '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBDevelopmentObject subclass: #WBAbstractAddInModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!
WBAbstractAddInModule class instanceVariableNames: ' loaded '!

WBAbstractAddInModule subclass: #WBActionLinkAddInModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBAbstractAddInModule subclass: #WBToolMenuAddInModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBDevelopmentDialog subclass: #WBAttributeEditor
  instanceVariableNames: 
    ' thePane '
  classVariableNames: ''
  poolDictionaries: ''! 

WBAttributeEditor subclass: #WBActionEditor
  instanceVariableNames: 
    ' action method changed author history '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBAttributeEditor subclass: #WBDialogEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBAttributeEditor subclass: #WBEnhancedEntryFieldEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBAttributeEditor subclass: #WBFileSelectorEditor
  instanceVariableNames: 
    ' title filters descriptions fileDialog '
  classVariableNames: ''
  poolDictionaries: ''!  

WBAttributeEditor subclass: #WBLinkEditor
  instanceVariableNames: 
    ' link type '
  classVariableNames: 
    ' Descriptions '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBAttributeEditor subclass: #WBListEditor
  instanceVariableNames: 
    ' list listBox item '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBAttributeEditor subclass: #WBScrollBarEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBAttributeEditor subclass: #WBStaticTextEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBAttributeEditor subclass: #WBStatusPaneEditor
  instanceVariableNames: 
    ' boxes list clipboard '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBAttributeEditor subclass: #WBToolBarEditor
  instanceVariableNames: 
    ' elements list useSystem clipboard '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '!   

WBAttributeEditor subclass: #WBWindowEditor
  instanceVariableNames: 
    ' iconFile iconEditor '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBAttributeEditor subclass: #WBEnhancedAttributeEditor
  instanceVariableNames: 
    ' thePropertyManager '
  classVariableNames: ''
  poolDictionaries: ''!

WBDevelopmentObject subclass: #WBPropertyManager
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!
WBPropertyManager class instanceVariableNames: ' managers cacheManagers '!

Association subclass: #WBEventDescription
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

Association subclass: #WBEventArgumentDescription
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

WBResourceDescriptor subclass: #WBPropertyDescriptor
  instanceVariableNames: 
    ' category default resourceValues changeBlock '
  classVariableNames: ''
  poolDictionaries: ''! 

WBPlaceHolderObject subclass: #WBInstVarObject
  instanceVariableNames: 
    ' name '
  classVariableNames: ''
  poolDictionaries: ''!  

WBAbstractAddInModule subclass: #WBPowerViewAddInModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBAbstractAddInModule subclass: #WBMultiViewAddInModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBCodeGenBase subclass: #WBCodeStream
  instanceVariableNames: 
    ' stream indent lineStartPos maxLineSize endChar parenthesis noParenthesis '
  classVariableNames: 
    ' ActiveCodeModules '
  poolDictionaries: 
    ' CharacterConstants '!

WBCodeGenBase subclass: #WBCodeGenerator
  instanceVariableNames: 
    ' properties policy useInstVars modules modulesToProcess classDefinitions '
  classVariableNames: 
    ' CurrentCodePolicy GenerateDirectBitmapRefs '
  poolDictionaries: ''!   

WBCodeGenBase subclass: #WBAbstractCodeModule
  instanceVariableNames: 
    ' object stream targetClass selector arguments comment targetClassDefinition category targetObject '
  classVariableNames: 
    ' ActiveCodeModules '
  poolDictionaries: 
    ' CharacterConstants '!

WBCodeGenBase subclass: #WBCodePolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '! 

WBCodePolicy subclass: #WBStandardCodePolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBAbstractCodeModule subclass: #WBVersionCodeModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBAbstractCodeModule subclass: #WBCodeModule
  instanceVariableNames: 
    ' varNames temporaries localFonts '
  classVariableNames: ''
  poolDictionaries: ''! 

WBAbstractCodeModule subclass: #WBCreateViewsStubModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBCodeModule subclass: #WBCreateMenuModule
  instanceVariableNames: 
    ' menu menuIndex '
  classVariableNames: ''
  poolDictionaries: ''!

WBCreateMenuModule subclass: #WBCreatePowerMenuModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

WBAbstractCodeModule subclass: #WBMethodStubModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBMethodStubModule subclass: #WBMenuItemStub
  instanceVariableNames: 
    ' title '
  classVariableNames: ''
  poolDictionaries: ''!   

WBCreateMenuModule subclass: #WBCompositeMenuModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBCodePolicy subclass: #WBTeamVCodePolicy
  instanceVariableNames: ''
  classVariableNames: 
    ' WBAnnotationManager WBTeamVInterface WBTeamVToolInterface '
  poolDictionaries: ''!  

WBCreateMenuModule subclass: #WBApplicationCoordinatorMenuModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBCodePolicy subclass: #WBENVYCodePolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBAbstractCodeModule subclass: #WBBasicCodeModule
  instanceVariableNames: 
    ' sourceString '
  classVariableNames: ''
  poolDictionaries: ''!   

WBMethodStubModule subclass: #WBEventHandlerStubModule
  instanceVariableNames: 
    ' source event eventDescription '
  classVariableNames: ''
  poolDictionaries: ''! 

WBMethodStubModule subclass: #WBOldEventHandlerStubModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

WBMethodStubModule subclass: #WBInstVarGetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBMethodStubModule subclass: #WBInstVarSetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBCodePolicy subclass: #WBXoteryXCodePolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBMethodStubModule subclass: #WBOpenMethodModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBOutboardWindow subclass: #WBPoolManagerWindow
  instanceVariableNames: 
    ' poolManager poolListBox poolListBoxFramingBlock poolPathField categoryListBox categoryListBoxFramingBlock categoryPathField showAllCategories keyListBox editorCompositePane activeCategoryField updateKeys '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBDevelopmentCompositePane subclass: #WBPoolEditorCompositePane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  

WBPoolEditorCompositePane subclass: #WBNLSEditorCompositePane
  instanceVariableNames: 
    ' categoryEditLabel categoryEditField keyEditLabel keyEditField valueEditLabel valueEditField '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '! 

WBPoolManagerWindow subclass: #WBNLSManagerWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBPoolEditorCompositePane subclass: #WBFontEditorCompositePane
  instanceVariableNames: 
    ' nameField nameLabel styleField styleLabel sizeField sizeLabel strikeOutCheckBox italicCheckBox boldCheckBox underscoreCheckBox fixedWidthCheckBox selectButton sampleTextEdit sampleGroupBox '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBPoolManagerWindow subclass: #WBFontManagerWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!   

WBPoolEditorCompositePane subclass: #WBBitmapEditorCompositePane
  instanceVariableNames: 
    ' bitmapPane editBitmapButton editButtonButton sizeButton sizePane sameBitmapButton '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '!   

WBPoolManagerWindow subclass: #WBBitmapManagerWindow
  instanceVariableNames: 
    ' showDimensions keyDimensionInset '
  classVariableNames: 
    ' LastRCFileName SameValueForAllCategories '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '! 

WBAbstractPrompter subclass: #WBEntryListPrompter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!

WBOutboardWindow subclass: #WBEventManagerWindow
  instanceVariableNames: 
    ' widgetList widgetFilterBox widgetListBox eventListBox handlerShowAll handlerListBox handlerListBoxFramingBlock handlerListBoxDragEnabled toLabel toField sendLabel sendField sendFieldShowAll methodTextEdit methodTextEditFramingBlock methodTextUpdateMsg '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '!  
WBEventManagerWindow class instanceVariableNames: ' widgetFilters toFieldExtensions warningClasses '! 

WBAttributeEditor subclass: #WBTimerEditor
  instanceVariableNames: 
    ' period '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '! 

WBAbstractCodeModule subclass: #WBModelCodeModule
  instanceVariableNames: 
    ' toBeRemoved '
  classVariableNames: ''
  poolDictionaries: ''!

WBModelCodeModule subclass: #WBModelEventsTriggeredModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

WBModelCodeModule subclass: #WBModelGetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

WBModelCodeModule subclass: #WBModelInitializeModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBModelCodeModule subclass: #WBModelSetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

WBModelCodeModule subclass: #WBModelTriggerEventModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBAbstractCodeModule subclass: #WBPrimaryModelInitializeModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBAbstractCodeModule subclass: #WBPrimaryModelModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBAbstractCodeModule subclass: #WBPrimaryModelOpenOnModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBCodeModule subclass: #WBLayoutCodeModule
  instanceVariableNames: 
    ' frames '
  classVariableNames: ''
  poolDictionaries: ''!

WBLayoutCodeModule subclass: #WBAbstractCreateViewsModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

WBModelCodeModule subclass: #WBModelBasicSetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBAbstractCreateViewsModule subclass: #WBCreateViewModule
  instanceVariableNames: 
    ' view viewIndex '
  classVariableNames: ''
  poolDictionaries: ''! 

WBAbstractCreateViewsModule subclass: #WBCreateViewsModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!  

WBCreateViewModule subclass: #WBCreatePowerViewModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!   

WBCreateViewsModule subclass: #WBCreatePowerViewsModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBCreateViewModule subclass: #WBCompositePaneModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''! 

WBCreateViewModule subclass: #WBApplicationCoordinatorModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

WBCreateViewModule subclass: #WBCallOutModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

!WBLookPolicyOS2 methods ! 
drawComboBox: aComboBox with: aPen clipRect: clipRect

    | style rect topRect bottomRect buttonRect innerRect
     buttonWidth list region newPoint backColor |
    style := aComboBox style.
    rect := aComboBox rect.
    topRect := rect leftTop extentFromLeftTop: rect width @ (aComboBox font height + 8).
    backColor :=  (self class isDefault not
        and: [(self asRGBColor: aComboBox backColor) = (self asRGBColor: aComboBox defaultBackColor)])
        ifTrue: [self defaultWidgetBackColor]
        ifFalse: [aComboBox backColor].
    innerRect := self
        displayWithBorder: aPen
        rect: topRect
        backColor: backColor.
    aPen
		rgbColorMode;
		fill: innerRect color: backColor;
		resetColorMode.
    buttonWidth := self scrollBarWidth.
    buttonRect := (innerRect rightTop leftAndUp: buttonWidth @ 1)
        extentFromLeftTop: (buttonWidth @ (innerRect height + 2)).
    style == #simpleList
        ifTrue: [
            bottomRect := topRect leftBottom rightBottom: rect rightBottom.
            "Must be an increment of font height"
            bottomRect := bottomRect leftTop extentFromLeftTop:
                (bottomRect width @ ((bottomRect height - 4 truncateTo: aPen font height)+4)).
            innerRect := self
                displayWithMinorBorder: aPen
                rect: bottomRect
                backColor: backColor.
            aPen fill: innerRect color: backColor.
            (list := aComboBox contents) isNil
                ifFalse: [
                    aPen
                        foreColor: aComboBox foreColor;
                        backColor: backColor;
                        font: aComboBox font.
                    region := aPen setClipRect: (innerRect intersect: clipRect).
                    newPoint := innerRect leftTop right: 2.
                    1 to: list size do: [:i |
                        aPen displayText: (list at: i) at: newPoint.
                        newPoint := newPoint down: aPen font height].
                    aPen destroyRegion: region]]
        ifFalse: [
            self draw3DBoxWith: aPen at: buttonRect.
            aPen
                foreColor: Color black;
                wbLineFrom: (buttonRect center leftAndUp: 2@3) to: (buttonRect center rightAndUp: Rectangle leftBottomUnit y @	Rectangle leftTopUnit y);
                wbLineFrom: (buttonRect center leftAndUp: 3@3) to: (buttonRect center rightAndDown: Rectangle leftBottomUnit y);
                wbLineFrom: (buttonRect center rightAndUp: 2@3) to: (buttonRect center leftAndUp: Rectangle leftBottomUnit y @ Rectangle leftTopUnit y);
                wbLineFrom: (buttonRect center rightAndUp: 3@3) to: (buttonRect center leftAndDown: Rectangle leftBottomUnit y);
                wbLineFrom: (buttonRect center leftAndDown: 2@2) to: (buttonRect center rightAndDown: (3 - Rectangle leftTopUnit y) @ 2);
                wbLineFrom: (buttonRect center leftAndDown: 2@4) to: (buttonRect center rightAndDown: (3 - Rectangle leftTopUnit y) @ 4)].! !

!WBLookPolicy methods !  
drawGroupBox: aGroupBox with: aPen clipRect: clipRect

    | rect top textRect bottom |
    rect := aGroupBox rect.
    top := rect top down: aGroupBox font height // 2.
    bottom := rect bottom up: 1.
    aPen font: aGroupBox font.
    textRect := (rect leftTop right: 7) extentFromLeftTop:
        (aGroupBox font wbStringWidth: aGroupBox contents) @ aGroupBox font height.
    aPen
        wbLineFrom: rect left @ top to: rect left @ bottom;
        wbLineFrom: (rect right left: 1) @ top to: (rect right left: 1) @ bottom;
        wbLineFrom: rect left @ bottom to: rect right @ bottom;
        wbLineFrom: rect left @ top to: (rect left right: 5) @ top;
        wbLineFrom: (rect left right: ((aPen stringWidthOf: aGroupBox contents) + 12)) @ top to: rect right @ top;
        foreColor: aGroupBox foreColor;
        backColor: aGroupBox backColor;
        setTextAlign: WBDisplayContext defaultTextAlign;
        winDrawText: aGroupBox contents at: textRect leftTop.! !

!WindowBuilder methods !
menuToolsBrowseClasses

    self mainView openClassBrowser! !

!WindowBuilder class methods ! 
runtimeLessPoolManagerWarning

    self runtimeLessCode
        ifTrue: [MessageBox warning: 'Keep in mind that advanced pool management functions are not supported for runtime-less code generation.']. ! !

!WBCompositePaneScratchWindow methods !   
perform: selector with: arg
    "Scratch windows should not perform any events"
    ^self perform: selector! !

!WBFramerExample methods !
display

	| region |
	self pen fill: self rectangle color: (self backColor ifNil: [self superWindow backColor]).
	frameRect notNil ifTrue: [
		self pen
			drawRectangle: frameRect;
			fill: (frameRect insetBy: 1) color: Color white.
		region := self pen setClipRect: (frameRect insetBy: 1).
		paneRect notNil ifTrue: [
			(paneRect isRectangle ifTrue: [Array with: paneRect] ifFalse: [paneRect])
				do: [:eachRect | self pen fill: (eachRect insetBy: 1) color: Color blue];
				do: [:eachRect | self pen drawRectangle: eachRect]].
		self pen 
			setClipRect: nil;
			destroyRegion: region].! !

!WBLayoutWizard methods ! 
setWidgetType: selectedItem

    attributesList selectedItem object
        propertyAt: #widgetType
        put: selectedItem
! !

!WBModelDefinitionEditor methods !  
analyzeInstVars

    | names |
    names := attributes contents collect: [:instVar | instVar name].
    names do: [:instVarName |
        (names occurrencesOf: instVarName) > 1
            ifTrue: [
                MessageBox message:
                    'Duplicate attribute name detected [', instVarName,
                    ']. All attribute names must be unique.'.
                ^false]].
    names := self localInstVars collect: [:instVar | instVar name].
    names do: [:instVarName |
        instVarName first isUpperCase | instVarName first isDigit
            ifTrue: [
                MessageBox message:
                    'All attributes must have valid instVar names and may not be capitalized or start with number [',
                    instVarName, '].'.
                ^false].
        (instVarName
            detect: [:char | char isAlphaNumeric not]
            ifNone: [nil]) notNil
            ifTrue: [
                MessageBox message:
                    'All attributes must have valid instVar names and may only include alpha-numeric characters [',
                    instVarName, '].'.
                ^false]].
    ^true! !

!WBFramerExample methods !  
defaultStyle
        "Private - Answer an Integer with appropriate styles in it."
    ^WsChild   |
    WsVisible! !

!WBAbstractCodeModule methods ! 
defaultShouldLogMethodSource
        "Answer true if the receiver's source should be logged."
    ^self targetClass isScratchWindow not or: [self wbEditorClass logScratch]! !

!WBLookPolicy methods !   
drawLeftArrowWith: aPen at: aRect

    | innerRect side |
    innerRect := self draw3DBoxWith: aPen at: aRect.
    side := (innerRect width min: innerRect height) // 7.
    aPen
        polygonFilled: (Array
            with: (innerRect center left: side + 1)
            with: (innerRect center rightAndUp: side @ (side * 2 + 1))
            with: (innerRect center rightAndDown: side @ (side * 2 + 1))).! !

!WindowBuilder class methods !   
xoteryxIsInstalled
    " Private - answer whether XoteryX is currently installed. "

    ^Smalltalk includesKey: #XoPackage! !

!PVideoPane methods !
styles

    ^#(#defaultStyle #stretch #noBorder #stretchNoBorder)! !

!WBEventManagerWindow methods ! 
methodTextNeedsContentsDeferred: aPane

    "Callback for the #needsContents event triggered in the TextEdit named 'methodTextEdit'.
     (Generated by WindowBuilder)"

	| text |
	methodTextUpdateMsg := nil.
	(text := self methodTextFor: self handlerSelected) notNil
		ifTrue: [
			aPane
				enable;
				contents: text]
		ifFalse: [
			aPane
				disable;
				contents: '
	*** Cannot edit methods in scratch window ***'].! !

!WindowBuilder methods !   
drawGrid: aBoolean
	"Store into DrawGrid property of WindowBuilder"

	self class drawGrid: aBoolean.
	self layoutForm display.! !

!PWBToolBar methods !
style: aStyle

	super style: aStyle.
	aStyle == #mdiToolBar
		ifTrue: [
			self vertical
				ifTrue: [
					framingBlock := LayoutFrame new
						leftRatio: 0; leftInset: 0;
						topRatio: 0; topInset: 0;
						rightRatio: 0; rightInset: self cellSize x;
						bottomRatio: 1; bottomInset: 0]
				ifFalse: [
					framingBlock := LayoutFrame new
						leftRatio: 0; leftInset: 0;
						topRatio: 0; topInset: 0;
						rightRatio: 1; rightInset: 0;
						bottomRatio: 0; bottomInset: self cellSize y].
			self parent notNil ifTrue: [self reframe: self parent rect].
			^nil].
! !

!WBLayoutForm methods ! 
duplicateOffset
	"Answer the value of duplicateOffset."

	duplicateOffset isNil
		ifTrue: [duplicateOffset := 16@16].
	^self useGrid
		ifTrue: [
			(duplicateOffset x roundTo: self gridSize x) @
			(duplicateOffset y roundTo: self gridSize y)]
		ifFalse: [duplicateOffset]! !

!WBToolBarEditor class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBFramerExample methods !   
frameRect

    ^frameRect! !

!PScrollBar methods !   
realClass

	^ScrollBar! !

!WBLookPolicy methods !
drawDownArrowWith: aPen at: aRect

    | innerRect side |
    innerRect := self draw3DBoxWith: aPen at: aRect.
    side := (innerRect width min: innerRect height) // 7.
    aPen
        polygonFilled: (Array
            with: (innerRect center down: side)
            with: (innerRect center rightAndUp: (side * 2 + 1) @ (side + 1))
            with: (innerRect center leftAndUp: (side * 2 + 1) @ (side + 1))).! !

!WBResourceDescriptor methods ! 
printOn: aStream indent: indentString

    super printOn: aStream indent: indentString.
    aStream cr; tab; nextPutAll: indentString; nextPutAll: 'value: '; nextPutAll: value printString.! !

!WBTabOrderLayoutForm methods ! 
button1DoubleClick: aPoint
        "Do Nothing"! !

!WindowBuilder methods !   
menuEditBrowseWidgetClass

    self hasSelections
        ifFalse: [
            ^self shell realClass isWBInternalClass
                ifTrue: [ViewManager edit]
                ifFalse: [self shell realClass edit]].

    ((self selections collect: [:pWidget | pWidget realClass])
        asSet asSortedCollection: [:a :b | a name <= b name])
        do: [:realClass | realClass edit].! !

!WBCompositePaneScratchWindow methods !   
when: anEvent perform: aSelector
    "Scratch windows should not perform any events"! !

!WBFontManagerWindow methods !
addEditorCompositePaneTo: aModel

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	
	(editorCompositePane := WBFontEditorCompositePane new)
		definedIn: #addEditorCompositePaneTo:;
		owner: aModel;
		setName: 'editorCompositePane';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 2 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1; bottomInset: 3 * yDU);
		startGroup.
	^editorCompositePane! !

!WBEventManagerWindow methods !   
methodTextNeedsContents: aPane

    "Callback for the #needsContents event triggered in the TextEdit named 'methodTextEdit'.
     (Generated by WindowBuilder)"

	methodTextUpdateMsg isNil ifTrue: [
		aPane contents: ''.
		(methodTextUpdateMsg :=
			Message
				receiver: self
				selector: #methodTextNeedsContentsDeferred:
				arguments: (Array with: aPane)) performDeferred].! !

!WindowBuilder methods !   
menuOptionsLookPolicyWin31

    self class lookPolicy: WBLookPolicyWin31.
    self shell backColor asRGBColor = Color gray asRGBColor
        ifTrue: [self shell backColor: Color white].
    self updateLookPolicy! !

!WBPrimaryModelInitializeModule methods ! 
targetClass
        "Answer the receiver's target class."
    ^super targetClass instanceClass! !

!PVideoPane methods !  
readSpecificsFrom: aPane

    self style: (aPane stretch
        ifTrue: [
            aPane hasBorderStyle
                ifTrue: [#stretch]
                ifFalse: [#noBorder]]
        ifFalse: [
            aPane hasBorderStyle
                ifTrue: [#defaultStyle]
                ifFalse: [#stretchNoBorder]]).! !

!WindowBuilder class methods !
instVarNameCheck: aBoolean

    ^self editorClass
        propertyValueAt: #InstVarNameCheck
        category: self editorPropertyString
        put: aBoolean! !

!WBResourceDescriptor methods ! 
deriveValue

    self value: (self lookupDictionary at: self name ifAbsent: [0]).! !

!WBLookPolicy methods ! 
drawMenuBar: aFrameObject with: aPen in: aRect

    | menuRect xPos yPos space |
    aFrameObject menu notNil
        ifTrue: [
            menuRect := (aRect leftTop down: (self titleBarHeightFrom: aFrameObject))
                extentFromLeftTop: aRect width @ self menuBarHeight.
            aPen
                fill: menuRect color: Color white;
                foreColor: Color black;
                wbLineFrom: menuRect left @ (menuRect bottom up: 1) to: menuRect right @ (menuRect bottom up: 1).
            xPos := menuRect left right: 6.
            yPos := menuRect origin y down: 2.
            space := aPen stringWidthOf: '  '.
            aPen
                font: SysFont;
                backColor: Color white;
                foreColor: Color black.
            aFrameObject menu allTitles do: [:title |
                aPen winDrawText: title at: xPos @ yPos.
                xPos := xPos right: (aPen stringWidthOf: title) + space]].! !

!WBUndoRedoDialog methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| exitButton levelsLabel mainView redoLabel undoLabel xDU 
	yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	levels := EntryField new.
	redoButton := Button new.
	redoList := MultipleSelectListBox new.
	undoButton := Button new.
	undoList := MultipleSelectListBox new.
	
		"Temporary Variables"
	exitButton := Button new.
	levelsLabel := StaticText new.
	redoLabel := StaticText new.
	undoLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Undo/Redo List';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -110 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -65 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -110 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -65 * yDU).
	self addView: mainView.
	
	undoList "MultipleSelectListBox"
		owner: self;
		setName: 'undoList';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -86 * xDU;
				bottomRatio: 0; bottomInset: -128 * yDU);
		extendedSelect;
		startGroup;
		font: SysFont.
	mainView
		addSubpane: undoList;
		subPaneWithFocus: undoList.
	
	undoButton "Button"
		owner: self;
		setName: 'undoButton';
		when: #clicked send: #undo to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 90 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -130 * xDU;
				bottomRatio: 0; bottomInset: -30 * yDU);
		contents: '&Undo>>';
		startGroup;
		font: SysFont.
	mainView addSubpane: undoButton.
	
	redoButton "Button"
		owner: self;
		setName: 'redoButton';
		when: #clicked send: #redo to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 90 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -130 * xDU;
				bottomRatio: 0; bottomInset: -50 * yDU);
		contents: '<<&Redo';
		startGroup;
		font: SysFont.
	mainView addSubpane: redoButton.
	
	redoList "MultipleSelectListBox"
		owner: self;
		setName: 'redoList';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -218 * xDU;
				bottomRatio: 0; bottomInset: -128 * yDU);
		extendedSelect;
		startGroup;
		font: SysFont.
	mainView addSubpane: redoList.
	
	levels "EntryField"
		owner: self;
		setName: 'levels';
		when: #textChanged: send: #levelsChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 90 * xDU;
				topRatio: 0; topInset: 84 * yDU;
				rightRatio: 0; rightInset: -130 * xDU;
				bottomRatio: 0; bottomInset: -96 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: levels.
	
	exitButton "Button"
		owner: self;
		setName: 'exitButton';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 90 * xDU;
				topRatio: 0; topInset: 110 * yDU;
				rightRatio: 0; rightInset: -130 * xDU;
				bottomRatio: 0; bottomInset: -128 * yDU);
		contents: 'E&xit';
		startGroup;
		font: SysFont.
	mainView addSubpane: exitButton.
	
	undoLabel "StaticText"
		owner: self;
		setName: 'undoLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -86 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		centered;
		contents: 'Undo List';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: undoLabel.
	
	redoLabel "StaticText"
		owner: self;
		setName: 'redoLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -218 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		centered;
		contents: 'Redo List';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: redoLabel.
	
	levelsLabel "StaticText"
		owner: self;
		setName: 'levelsLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 90 * xDU;
				topRatio: 0; topInset: 74 * yDU;
				rightRatio: 0; rightInset: -130 * xDU;
				bottomRatio: 0; bottomInset: -82 * yDU);
		centered;
		contents: 'Levels';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: levelsLabel! !

!Stream methods !   
skipToWhitespace
        "Advance the receiver position beyond the next
         occurrence of whitespace, or if none, to the end of
         stream.  Answer true if whitespace occurred, else
         answer false."
	#addedByOSI.
    [self atEnd]
        whileFalse: [
            self next isWhitespace
                ifTrue: [^true]].
    ^false! !

!WBEventManagerWindow methods !  
menuHandlerAdd

    "Callback for the menu item titled 'Add'.
     (Generated by WindowBuilder)"

    self widgetSelected isNil ifTrue: [
        self widgetSelected: (
            self widgetSelections notEmpty
                ifTrue: [self widgetSelections first]
                ifFalse: [self targetObject])].
    self eventSelected isNil ifTrue: [
        self eventList notEmpty ifTrue: [
            self eventSelected: (
                self eventSelections notEmpty
                    ifTrue: [self eventSelections first]
                    ifFalse: [self eventList first])]].
    self handlerSelections: #( ).
    sendField text: ''.
    sendField setFocus.! !

!WBPrimaryModelInitializeModule methods !   
generateComment
        "Private - Generate the comment."

    super generateComment.
    self stream cr.! !

!PVideoPane methods ! 
displayWith: aPen clipRect: clipRect

    self hasBorder
        ifTrue: [
            self lookPolicy
                displayWithBorder: aPen
                rect: self rect
                backColor: self backColor]
        ifFalse: [self displayWithNoBorder: aPen].! !

!WindowBuilder class methods ! 
clearWBClasses
	"  WindowBuilder clearWBClasses   "

	WBClasses := nil.! !

!WBLookPolicyWin95 methods ! 
drawTitleBarText: aFrameObject with: aPen in: aRect

    | titleRect |
    titleRect := aRect leftTop extentFromLeftTop: aRect width @ self titleBarHeight.
    aFrameObject hasTitleBar
        ifTrue: [
            aPen
                fill: titleRect color: Color activeTitleBar;
                font: aFrameObject font;
                setTextAlign: WBDisplayContext defaultTextAlign;
                foreColor: Color titleBarText;
                setBackgroundModeTransparent;
                winDrawText: aFrameObject contents in: (titleRect insetBy: 1) format: self titleJustification;
                setBackgroundModeOpaque].! !

!WBEventManagerWindow methods !   
menuHandlerDown

    "Callback for the menu item titled 'Down'.
     (Generated by WindowBuilder)"

	| aHandler |
	self mustHaveOneHandlerSelected ifFalse: [^self].
	(aHandler := self handlerSelected) moveDown.
	self owner updateSendField.
	handlerListBox update.
	self handlerSelected: aHandler.! !

!WBCompositePaneScratchWindow methods !  
perform: selector
    "Scratch windows should not perform any events"
    ^MessageBox messageNote: 'Scratch windows cannot do anything. You must first create a new view manager class with the "Save As..." command in order to add behavior.'! !

!PGraphPane methods ! 
styleMap

    ^super styleMap
        at: #noScrollBars put: #(#removeHorizontalScrollbarStyle #removeVerticalScrollbarStyle);
        at: #noBorders put: #(#removeHorizontalScrollbarStyle #removeVerticalScrollbarStyle #removeBorderStyle);
        yourself.! !

!PGraphPane methods !
mutationExceptions

    ^#(#FreeDrawPane)! !

!WBNLSManagerWindow methods !   
menuPoolReplaceStrings
	"Use a custom translator to replace strings in windows."

	| translatorClass |
	self selectedPools isEmpty ifTrue: [
		^MessageBox message:
			'Select one or more pools to use in string replacement'].
	self selectedCategory isNil ifTrue: [
		^MessageBox message:
			'Select exactly one category to which the strings will be matched'].
	(translatorClass := Smalltalk at: #WBNLSReplacementTranslator ifAbsent: [nil]) isNil ifTrue: [
		^MessageBox message:
			'Please install the translators first.'].
	self selectedCategory = self poolManager activeCategory ifFalse: [
		(MessageBox confirm:
			'For string replacement to take place, ',
			self selectedCategory printString,
			' must be the active category.  Continue?'
		) ifFalse: [^self].
		self poolManager activeCategory: self selectedCategory].
	translatorClass
		translateFor: self poolManager
		pools: self selectedPools
		category: self selectedCategory.! !

!PGraphPane methods !   
styles

    ^#(#defaultStyle #noScrollBars #noBorders)! !

!WBLayoutForm methods !
moveTolerance
    "Number of pixels the mouse must move with the button down
     before moving the widget."

    ^4! !

!WBPoolEditorCompositePane class methods ! 
wbPartEventItems

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your wb-parts definition."

	#generated.
	^#(#rightClicked #tabbed)! !

!WBMenuEditor methods !
commitSelection: previousSelection

    previousSelection notNil ifTrue: [
        self updateItem: previousSelection.
    ].

    ^true! !

!WBInterfaceObject methods ! 
childrenInBuildOrder

	^#( )! !

!WBCodeStream methods !  
backup: numberOfCharacters
        "Backup the specified numer of characters"
    stream position: (stream position - numberOfCharacters max: 0)! !

!WBEditClassDialog methods ! 
removeFilter

    "Callback for the #clicked event triggered in the Button named 'removeFilter'.
     (Generated by WindowBuilder)"

    Notifier isAltKeyDown
        ifTrue: [self class clearFilterList]
        ifFalse: [
            (self class defaultFilterList includes: self filterChoice) ifTrue: [^self].
            self class removeFromFilterList: self filterChoice].
    filter
        contents: self class filterList;
        selectItem: self class defaultChoice.
    self class filter: self class defaultChoice.
    self updateListContents.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!FrameObject methods !   
frameLeftTop

	^(self layoutForm ifNil: [^0@0])
		extent * Rectangle leftTopUnit rightAndDown: self margin! !

!WBLookPolicyWin31 methods !  
drawEntryField: anEntryField with: aPen clipRect: clipRect

	| innerRect contents region displayContents justification backColor |
	backColor := (self class isDefault not
		and: [(self asRGBColor: anEntryField backColor) = (self asRGBColor: anEntryField defaultBackColor)])
		ifTrue: [self defaultWidgetBackColor]
		ifFalse: [anEntryField backColor].
	innerRect := (self
		displayWithBorder: aPen
		rect: anEntryField rect
		backColor: backColor) insetBy: 1.
	"Draw the initialization text"
	(contents := anEntryField contents) isNil
		ifFalse: [
			displayContents := (anEntryField style == #password)
				ifTrue: [contents copy atAllPut: $*]
				ifFalse: [contents].
			justification := anEntryField justification == #left
				ifTrue: [self class default leftJustification]
				ifFalse: [
					anEntryField justification == #right
						ifTrue: [self class default rightJustification]
						ifFalse: [self class default centerJustification]].
			region := aPen setClipRect: innerRect.
			aPen
				font: anEntryField font;
				foreColor: anEntryField foreColor;
				backColor: backColor;
				setTextAlign: WBDisplayContext defaultTextAlign;
				winDrawText: displayContents in: innerRect format: justification.
			aPen destroyRegion: region].! !

!PRadioButton methods !   
winUserStyle

	style == #radioButton
		ifTrue: [^BsRadiobutton].
	^BsAutoradiobutton! !

!WBAttributeWindow methods !   
update
		"Update the receiver."
	! !

!WBAttributeWindow methods !
shell
		"Answer the pane being edited."
	^self prototype shell! !

!WBModelDefinitionEditor methods ! 
activateClassBrowserOnClass: aClass

    | chb |
    chb := Notifier windows values detect: [:window |
            window isApplicationWindow
                and: [window owner isWBClassBrowser
                and: [window owner selectedClass == aClass]]]
        ifNone: [nil].
    chb notNil
        ifTrue: [
            (chb := chb owner) activate.
            "Make sure the open method gets refreshed"
            (chb textModified)
                ifFalse: [
                    chb
                        changed: #selectors:
                            with: #restoreSelected:
                            with: chb selectedMethod;
                        changed: #text:].
            ^self].
    ^nil! !

!WBBitmapManagerWindow methods !
showDimensions: aBoolean
	"Set true if the dimensions should be show in the key and category lists."

	showDimensions := aBoolean.
	categoryListBox redraw.
	keyListBox redraw.
	self updateOptionMenu.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutForm methods !  
ungroupComposite

	| composite newWidgets |
	composite := self selections first.
	newWidgets := composite children collect: [:widget |
		widget wbCloneWithParent: self shell].
	(self
		clearSelections;
		noRedraw: true;
		placeNewWidgets: newWidgets
		at: composite rect leftTop;
		createUndoRedoForNewWidgets: newWidgets
			oldWidgets: (Array with: composite)
			named: 'Ungroup Composite')
			redoAction value.
	self 
		noRedraw: false;
		showHandles.! !

!LayoutFrame methods !   
wbBottomProportional: aBoolean
	"Set true if the receiver is bottom proportional (inset = 0)."

	self propertyAt: #wbBottomProportional put: aBoolean.
	^aBoolean! !

!WBManagedPValue methods !
pools
	"Answer the pools to search."

	^#( )! !

!PListBox methods ! 
mutationTypes

    ^#(#ListBox #CPScrollingPane #RadioButtonGroup)! !

!WindowBuilder methods !   
commentForExtra: aWidget

	^'Callback for ' , (self statusDescriptionFor: aWidget) , '.'.! !

!WBLayoutForm methods ! 
selection: aWidget

    self selections: (OrderedCollection with: aWidget)! !

!PEnhancedEntryField methods ! 
character

    ^character! !

!PWBInvisibleGroupPane methods !
wbNameAndClass

    ^'Grouper'! !

!WBPoolManagerWindow methods ! 
selectedKey
	"Answer the selected key if exactly one is selected,
		else answer nil."

	^(self selectedKeyAndPool ifNil: [^nil]) key! !

!WBPoolEditorCompositePane methods !   
selectedCategory

	^self owner selectedCategory! !

!WBInterfaceObject methods !  
font: aFont

    font := aFont wbManagedValueFor: self.! !

!WBCodeGenerator methods !
initialize

    super initialize.
    modules := IdentityDictionary new.
    modulesToProcess := OrderedCollection new.! !

!WBEntryListPrompter class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBTemplateEditor class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!PStaticBox methods !
defaultStyle

    ^#whiteRectangle! !

!WBLayoutForm methods !
undoManager

    ^self model undoManager! !

!WBScrollingPane methods !   
getScrollRanges

    | h v minPtr maxPtr |

    minPtr := ExternalBuffer new: 2.
    maxPtr := ExternalBuffer new: 2.

    UserLibrary
        getScrollRange: self asParameter
        bar: SbHorz
        lpMinPos: minPtr asParameter
        lpMaxPos: maxPtr asParameter.

    h := maxPtr uShortAtOffset: 0.

    UserLibrary
        getScrollRange: self asParameter
        bar: SbVert
        lpMinPos: minPtr asParameter
        lpMaxPos: maxPtr asParameter.

    v := maxPtr uShortAtOffset: 0.

    ^h@v! !

!WBResizeBitmap methods !  
isScaled: aBoolean

    isScaled := aBoolean! !

!WBDialogEditor methods !
initWindow

    | theStyle |

    theStyle := thePane style.

    (self paneNamed: 'systemMenu') selection: (theStyle includes: #sysmenu).
    (self paneNamed: 'systemModal') selection: (theStyle includes: #sysmodal).
    (self paneNamed: 'titleBar') selection: (theStyle includes: #titlebar).
    (self paneNamed: 'modal') selection: (theStyle includes: #modal).! !

!Bitmap methods !  
isOperatingSystemBitmap
	"Private - WBPro Development."

	#addedByOSI.
	^self archive isArray and: [self archive first isNil]! !

!WindowBuilder methods !  
menuToolsViewSystemBitmaps

    WBSystemBitmapViewer new open! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBMultiToolPalette methods !  
on: name add: aBitmapFile selector: aSelector

    ^self add: aBitmapFile selector: aSelector on: name! !

!WindowBuilder methods !   
menuEditBrowseClass

	| toolInterface browser globalList global |
	self editedClass isScratchWindow
		ifTrue: [self menuFileSaveAs isNil ifTrue: [^nil]].
	self tryToSaveChanges.
	self inENVY
		ifTrue: [^self editedClass edit].
	(self inTeamV and: [self wbEditorClass useClassHierarchyBrowser not xor: Notifier isAltKeyDown])
		ifTrue: [
			browser := (toolInterface := Smalltalk at: #ToolInterface) current subsystemBrowserClass openHierarchyOn: toolInterface currentSubsystem.
			globalList := browser globalList.
			global := globalList subsystem definitionOfGlobalNamed: self editedClass symbol.
			globalList selectionHolder value: global.
			globalList container packageList module: global package.
			browser classEditor categoryList category: '** all **']
		ifFalse: [
			(self activateClassBrowserOnClass: self editedClass) isNil
				ifTrue: [
					(Message
						receiver: ClassHierarchyBrowser new open
						selector: #wbFindClass:
						arguments: (Array with: self editedClass symbol)) performDeferred]].
	! !

!WindowBuilder methods ! 
propertyAt: aSymbol ifAbsent: aBlock

	^self class 
		propertyAt: aSymbol 
		ifAbsent: aBlock! !

!WBDescriptor methods !   
hasFlag: aSymbol

    flags isNil ifTrue: [^false].
    ^flags includes: aSymbol! !

!WindowBuilder class methods !  
clearWBIcon
	"  WindowBuilder clearWBIcon   "

	WBIcon := nil.! !

!WBModelDefinitionEditor methods !
setDirty

    dirty := true.
    (self paneNamed: 'updateButton') enable.! !

!WBCreateViewModule methods !  
generateMenus
		"Private - Generate all the menu definitions."
	| menu menuSelector |
	(menu := self view menu) notNil ifTrue: [
		menuSelector := self menuModuleClass defaultMessageSelector.
		self viewIndex notNil ifTrue: [
			menuSelector := self
				constructMessageSelector: menuSelector
				index: self viewIndex ].
		self
			generateMenuMessage: menuSelector;
			generateMenu: menu selector: menuSelector ].! !

!WBPoolEditorCompositePane methods !  
selectedValue

	| keyAndPool |
	keyAndPool := self selectedKeyAndPool ifNil: [^nil].
	^keyAndPool value
		at: keyAndPool key
		in: (self selectedCategory ifNil: [^nil])
		ifAbsent: [nil]! !

!WBAbstractPrompter methods ! 
list: aCollection

	self listField contents: aCollection.! !

!WBVersionCodeModule methods !  
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self stream
            cr;
            nextPut: $^;
            nextPutAll: self wbVersionString].! !

!WBClassDefinition methods ! 
targetClass
		"Answer the receiver's target class or nil if not defined yet."
	^Smalltalk
		at: self className asSymbol
		ifAbsent: [ nil ]! !

!WBLookPolicy class methods !   
isWindows95

    ^OperatingSystem isWindows95! !

!WBOutboardWindow methods ! 
shell

	^self owner shell! !

!WBLookPolicyWin31 methods !
initialize

	super initialize.
	self class isDefault
		ifTrue: [userLibrary := Smalltalk at: #UserLibrary ifAbsent: [nil]]! !

!WBTabOrderLayoutForm methods !  
normalizeTabOrder

	| sortBlock groupedPanes tabPosition |
	sortBlock := self shell class tabOrderSortBlock.
	"Sort and set the tab positions for the outermost level panes,
      including the groups"
	self soloWidgets: (self soloWidgets asSortedCollection: sortBlock) asOrderedCollection.
	tabPosition := WBTabPosition fromTabPosition: 1.
	self soloWidgets do: [:widget |
		(widget usesFocus and: [widget tabPosition notNil])
			ifTrue: [
				widget tabPosition: tabPosition.
				tabPosition := tabPosition nextTabPosition]].
	"Sort and set the tab positions for the panes within each group"
	self groups keysDo: [:group |
		groupedPanes := self groups at: group.
		groupedPanes := (groupedPanes asSortedCollection: sortBlock) asOrderedCollection.
		group tabPosition isNil
			ifTrue: [group tabPosition: tabPosition].
		tabPosition := group tabPosition copy makeFirstInGroup.
		groupedPanes do: [:widget |
			(widget usesFocus and: [widget tabPosition notNil])
				ifTrue: [
					widget tabPosition: tabPosition.
					tabPosition := tabPosition nextTabPosition]].
		self groups at: group put: groupedPanes].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPoolManagerWindow methods !  
poolManager
	"Answer the pool manager."

	^poolManager ifNil: [poolManager := self defaultPoolManager]! !

!PRadioButtonGroup methods !  
font: aFont

	super font: aFont.
	self children do: [:each | each font: aFont].! !

!WindowFrameObject methods ! 
drawTitleTextWith: aPen in: aRect

    self lookPolicy
        drawTitleBarText: self
        with: aPen
        in: aRect! !

!PCompositePane methods !   
storeColorOn: aStream indentString: indentString! !

!WBBitmapManagerWindow methods !   
uniqueIdsFor: aCollection category: aCategory
	"Answer a mapping of keys to unqiue ids."

	| lastId answer allIds aBitmap id |
	lastId := 100.
	answer := Dictionary new.
	allIds := Set new.
	aCollection do: [:eachKeyAndPool |
		aBitmap := eachKeyAndPool value
			at: eachKeyAndPool key
			in: aCategory
			ifAbsent: [nil].
		aBitmap archive isArray ifTrue: [
			id := aBitmap archive last.
			(allIds includes: id) ifFalse: [
				allIds add: id.
				answer at: eachKeyAndPool key put: id.
				lastId := lastId max: id]]].
	aCollection do: [:eachKeyAndPool |
		answer at: eachKeyAndPool key ifAbsentPut: [
			lastId := lastId + 1]].
	^answer! !

!WBPoolEditorCompositePane methods !  
poolManager

	^self owner poolManager! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBMenuEditor methods !
updateTestButton

    self pMenu hasChildren ifTrue: [
        testItButton enable.
    ] ifFalse: [
        testItButton disable.
    ].! !

!WBPrototype methods !  
wbPartMessages: aWBPartMessagesList
		"Answer the wbPartMessages for the receiver."
	self propertyAt: #WBPartMessages put: aWBPartMessagesList.! !

!WBModelDefinitionEditor methods !
down

    | selectedItem index |
    selectedItem := attributes selectedItem.
    index := attributes contents indexOf: selectedItem.
    attributes contents
        remove: selectedItem;
        add: selectedItem afterIndex: index.
    attributes
        contents: attributes contents;
        selectItem: selectedItem.
    self
        setDirty;
        updateUpDownButtons.

! !

!WindowBuilder methods !  
openStyleDialog

	self invoke: WBStyleEditor.! !

!WBScrollingPane methods !  
resizeWindow

    super resizeWindow.
    topCorner := 0@0.
    self scrollIfNecessaryRedraw: false.
    self setScrollRanges.
    self updateSliders! !

!WBEntryListPrompter methods !  
deferredInitWindow

	self listField entryField
		setFocus;
		selectAll.! !

!WBCreateBitmap class methods ! 
bitmapTypes
	"Answer a mapping of pane names to bitmap types."

	^bitmapTypes ifNil: [
		bitmapTypes := Dictionary new
			at: 'monoButton' put: #width:height: ;
			at: 'colorButton' put: #screenWidth:height: ;
			at: 'color4BitButton' put: #screenWidth4:height: ;
			at: 'color8BitButton' put: #screenWidth8:height: ;
			yourself]! !

!PStatusPane methods !  
styles

    ^self wbEditorClass runtimeLessCode
        ifTrue: [#(#rightJustified #leftJustified)]
        ifFalse: [#(#rightJustified #leftJustified #rightJustifiedFixed #leftJustifiedFixed)]! !

!LayoutFrame methods !
wbLeftProportional
	"Answer true if the receiver is left proportional (inset = 0)."

	^(self propertyAt: #wbLeftProportional) ifNil: [
		self wbLeftProportional:
			(self leftInset = 0) & (self leftRatio ~= 0) & (self leftRatio ~= 1)]! !

!PEnhancedEntryField methods !  
maximumSize

	^maxSize ifNil: [maxSize := 0]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBDescriptor methods ! 
comment: aString
    "Set the value of comment."

    comment := aString! !

!WBPoolEditorCompositePane methods !
selectedKeysAndPools

	^self owner selectedKeysAndPools! !

!Bitmap methods ! 
wbOutputToFileStream: aFileStream
        "Private - WB Development.
			Output the receiver in DIB format to aFileName.
			Work around digitalks problem not being able to output
			bitmaps loaded from a resource DLL."
    #addedByOSI.
	self archive isArray
		ifTrue: [
			self cpCopy
				outputToFileStream: aFileStream;
				release ]
		ifFalse: [
			self
				outputToFileStream: aFileStream ].! !

!WindowBuilder methods !
openCompositePane: aCompositePaneClass from: aWindowBuilder

	self editedClass: aCompositePaneClass.
	self openWithParent: aWindowBuilder.
	self mainView propertyAt: #parentWB put: aWindowBuilder.! !

!WBPoolManagerWindow methods ! 
selectedKeysAndPools: aCollectionOfKeysAndPools
	"Set the collection of selected keys."

	keyListBox selection: aCollectionOfKeysAndPools.
	self selectedKeysChanged.! !

!WindowBuilder methods !  
addWidget: paneName

    | addPane className class |
    className := paneName reject: [:c | c = $~].
    className = 'ArrowTool'
        ifTrue: [^self geometryManager addWidgetOfClass: nil].
	self class editorClass licensed ifFalse: [
		self shell children size >= 10 ifTrue: [
			^self class editorClass buyACopy]].
    #osiHack. "Substitute WBComboBox for ComboBox because ComboBox has problems..."
    (className = 'ComboBox' and: [self class useWBComboBox])
        ifTrue: [className := 'WBComboBox'].
    (class := Smalltalk at: className asSymbol ifAbsent: [nil]) isNil
        ifTrue: [
            ^MessageBox warning:
                'The class ', className,
                ' is not in this image.  You must load it in first.'].
	self class editorClass runtimeLessCode ifTrue: [
		(WBCodePolicy current inBaseImage: class) ifFalse: [
			(MessageBox confirm:
				class name, ' is not part of the base image.  Do you still wish to add this widget?'
			) ifFalse: [^self]]].
    className = self editedClass name
        ifTrue: [
            ^MessageBox warning:
                'You cannot add ',className,
                ' to itself. This would result in infinite recursion.'].
    addPane := class wbPseudoClass exampleFrom: className.
    addPane supportedInDialogs not & self shell isDialog
        ifTrue: [
            ^MessageBox warning:
                'Sorry. ', className,
                ' widgets are not supported in WindowDialogs due to base image limitations. Create your window as a subclass of WBWindowDialog instead.'].
    addPane isComposite & self shell isDialog
        ifTrue: [
            MessageBox messageNote:
                'Sorry. WindowDialogs do not support nested tabbing within children (including GroupPanes and CompositePanes). Create your window as a subclass of WBWindowDialog instead.'].
    self geometryManager addWidgetOfClass: class.! !

!WBTreeListBox methods !   
contents: aTree

        "Set the receiver's contents to aCollection."
    list := aTree.
    handle = NullHandle
        ifFalse: [
            self noRedraw: true;
                deleteAll;
                insertArray: (list asFlatList collect: [ :i | i listString ]);
                noRedraw: false ].
    ^list! !

!WBPrimaryModelInitializeModule methods !
defaultCategory
        "Answer the default category for the receiver."
    ^'primary model'! !

!WBUndoManager class methods !   
maxUndoLevels

    ^MaxUndoLevels ifNil: [MaxUndoLevels := WindowBuilder maxUndoLevels]! !

!WBLayoutForm methods !   
setupInWhiteSpace: aPoint
    "Setup for clicking in white space."

    self cursorSelectPoint: aPoint.
    self allowMove: false.
    self bandRect: (aPoint extent: 0@0).
    self cursorOffset: self initialCursorOffset.
    self drawBand.! !

!WindowBuilder methods ! 
setPaneNameIsInstVar: aBoolean
	"Set thePane to have an inst var name."

	self
		paneNameIsInstVar: aBoolean;
		layoutFormChanged.! !

!Bitmap methods !   
displayLeftTopAt: aPoint with: aPen
		"Private - Display the receiver at aPoint using aPen."
    #addedByOSI.
	self
		displayAt: aPoint
		with: aPen! !

!WBDialogEditor methods ! 
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel mainView modal ok separator systemMenu systemModal 
	titleBar xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	modal := CheckBox new.
	ok := Button new.
	separator := StaticBox new.
	systemMenu := CheckBox new.
	systemModal := CheckBox new.
	titleBar := CheckBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Window Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -72 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -25 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -72 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -25 * yDU).
	self addView: mainView.
	
	systemMenu "CheckBox"
		owner: self;
		setName: 'systemMenu';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -145/2 * xDU;
				bottomRatio: 0; bottomInset: -14 * yDU);
		contents: '&System menu';
		startGroup;
		font: SysFont.
	mainView
		addSubpane: systemMenu;
		subPaneWithFocus: systemMenu.
	
	titleBar "CheckBox"
		owner: self;
		setName: 'titleBar';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 31/2 * yDU;
				rightRatio: 0; rightInset: -145/2 * xDU;
				bottomRatio: 0; bottomInset: -51/2 * yDU);
		contents: '&Title bar';
		startGroup;
		font: SysFont.
	mainView addSubpane: titleBar.
	
	systemModal "CheckBox"
		owner: self;
		setName: 'systemModal';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 74 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -285/2 * xDU;
				bottomRatio: 0; bottomInset: -14 * yDU);
		contents: 'S&ystem modal';
		startGroup;
		font: SysFont.
	mainView addSubpane: systemModal.
	
	modal "CheckBox"
		owner: self;
		setName: 'modal';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 74 * xDU;
				topRatio: 0; topInset: 31/2 * yDU;
				rightRatio: 0; rightInset: -285/2 * xDU;
				bottomRatio: 0; bottomInset: -51/2 * yDU);
		contents: '&Modal';
		startGroup;
		font: SysFont.
	mainView addSubpane: modal.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 50 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -92 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	separator "StaticBox"
		owner: self;
		setName: 'separator';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 0; rightInset: -140 * xDU;
				bottomRatio: 0; bottomInset: -29 * yDU);
		blackRectangle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: separator! !

!WBResizeBitmap methods !  
preInitWindow

    | extent |
    extent := oldExtent.
    self isButtonBitmap ifTrue: [
        self mainView labelWithoutPrefix: 'Resize Button'.
        extent := extent x // 2 @ extent y].
    self
        oldWidth: extent x;
        oldHeight: extent y;
        newWidth: extent x;
        newHeight: extent y.
    (self paneNamed: 'sameExtentRadioButton') selection: true.
    (self paneNamed: 'buttonBitmap') selection: self isButtonBitmap.
    (self paneNamed: 'scaledButton') selection: self isScaled.! !

!WBAbstractPrompter methods !  
default: aString

	^self implementedBySubclass! !

!WBPropertyDescriptor methods !
value: anObject
    "Set the value of value."

    super value: anObject.
    self changeBlock isNil
        ifFalse: [changeBlock value: anObject]! !

!WBLayoutForm methods !
buttonReleaseResizingShell: aPoint
    "Process a button release event after resizing a widget."

    | width height gridSize |
    self drawBand.
    width := (aPoint x left: self cursorOffset first x) left: self handleSize x // 2.
    height := (self rectangle top distanceDown: (aPoint y up: self cursorOffset first y)) left: self handleSize y // 2.
    self shell isDialog
        ifTrue: [
            width := width - (self shell borderWidth * 2).
            height := height - (self shell borderWidth * 2) - self shell titleHeight].
    self useGrid
        ifTrue: [
            gridSize := self gridSize.
            width := width roundTo: gridSize x.
            height := height roundTo: gridSize y].
    self model isNil
        ifFalse: [
            self model
                setWindowSize: width @ height;
                setDirty].! !

!WBPoolEditorCompositePane class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBInterfaceObject methods ! 
realClassName

    ^realClass name! !

!PWBInvisibleGroupPane methods !   
isGrouper

    ^true! !

!WBGraphicObject methods !   
rect: aRect

    lastRect := self hitRect.
    rect := aRect! !

!WBBitmapManagerWindow methods !
menuKeyFileOutRCFile: copySelector

	| path aCategory fileNameMap idMap keysAndPools existingFiles |
	(keysAndPools := self selectedKeysAndPools) isEmpty ifTrue: [^self].
	aCategory := self selectedCategoryOrPrompt: 'File out which category'.
	path := FileDialog new
		saveTitle: 'Save RC file...' fileName: '*.rc';
		file.
	path isNil ifTrue: [^self].
	path := path asLowercase.
	LastRCFileName := path fileNameLessPath.
	fileNameMap := self uniqueFilesNamesFor: keysAndPools.
	idMap := self uniqueIdsFor: keysAndPools category: aCategory.
	existingFiles := ((Directory fromPath: path fileNamePath) allFiles
		collect: [:each | each pathName fileNameLessPath asLowercase])
		select: [:each |
			(fileNameMap
				detect: [:eachName | eachName, '.bmp' = each]
				ifNone: [nil]) notNil].
	existingFiles notEmpty ifTrue: [
		(MessageBox confirm:
			'Overwrite ', existingFiles size printString, ' bitmap files?'
		) ifFalse: [^self]].
	self
		writeRCFile: path for: keysAndPools category: aCategory ids: idMap fileNames: fileNameMap;
		writeBPLFile: path for: keysAndPools category: aCategory ids: idMap fileNames: fileNameMap;
		writeBMPFiles: path fileNamePath for: keysAndPools category: aCategory
			fileNames: fileNameMap copySelector: copySelector.! !

!PListBox class methods !   
styleFrom: style

	(style bitIsOn: LbsOwnerdrawfixed)
		ifTrue: [^#ownerDrawFixed].
	(style bitIsOn: LbsOwnerdrawvariable)
		ifTrue: [^#ownerDrawVariable].
	^#defaultStyle! !

!PEntryField class methods !  
styleFrom: style

    (style bitIsOn: EsPassword) ifTrue: [^#password].
    (style bitIsOn: EsReadonly) ifTrue: [^#readOnly].
    ^#defaultStyle! !

!WBUndoRedoDialog methods !
preInitWindow

    | items isEmpty |
    undoList contents: (items := self undoManager undoableActions reverse).
    (isEmpty := items isEmpty)
        ifFalse: [undoList selectItem: items first].
    isEmpty
        ifTrue: [undoButton disable]
        ifFalse: [undoButton enable].
    redoList contents: (items := self undoManager redoableActions).
    (isEmpty := items isEmpty)
        ifFalse: [redoList selectItem: items first].
    isEmpty
        ifTrue: [redoButton disable]
        ifFalse: [redoButton enable].! !

!WBModelObjectEditor methods ! 
currentEvent
        "Answer the currently selected event symbol."
    | event |
    event := when selectedItem.
    event isNil ifTrue: [^nil].
    event first == $*
        ifTrue: [event := event copyFrom: 2 to: event size].
    ^event asSymbol! !

!PRadioButtonGroup methods ! 
buttonClass

    ^self wbRealWidget buttonClass! !

!WBPropertyEditor methods !   
selectedProperty

    | selectedItem propertyName |
    selectedItem := propertyList selectedItem ifNil: [^nil].
    propertyName := selectedItem copyFrom: 1 to: (selectedItem indexOf: $:) - 2.
    ^WindowBuilder propertyNamed: propertyName category: self selectedCategory.! !

!WBLayoutCodeModule methods !
generatePaneClipStyle: aPane frames: aCollectionOfFrames
        "Private - If aPane is overlapping any of its siblings higher
			in the z-order, then generate the #addClipsiblingsStyle code."
    | childFrame |
    childFrame := aPane frameRelativeRectangle.
    aPane realClass new hasClipsiblingsStyle ifFalse: [
        (aCollectionOfFrames
            detect: [ :frame | frame intersects: childFrame ]
            ifNone: [ nil ]
        ) notNil ifTrue: [
            self stream
                cr;
				nextPutAll: #addClipsiblingsStyle;
				endMessage ] ].
    aCollectionOfFrames add: childFrame.
! !

!WBUndoAction methods !   
redoAction: aBlock

    redoAction := aBlock! !

!WBModelObjectEditor methods !   
updateObjectList

    | selectedObject |
    selectedObject := self selectedObject.
    objectList contents: (self owner prototype modelObjects asSortedCollection: [:a :b |
        (a paneName ifNil: ['zzzz']) <= (b paneName ifNil: ['zzzz'])]).
    (self owner prototype modelObjects includes: selectedObject)
        ifTrue: [objectList selectItem: selectedObject].! !

!WBEventManagerWindow methods !   
targetShell

	^self prototype shell wbRealWidget! !

!WBLookPolicyWin31 methods ! 
borderWidthFrom: aFrameObject

    ^aFrameObject isModal
        ifTrue: [self frameWidthDialog]
        ifFalse: [
            (aFrameObject style includes: #sizable)
                ifTrue: [self frameWidthSizable]
                ifFalse: [self frameWidthBorder]].! !

!WBEnhancedEntryFieldEditor methods !
supportsAutoTab

    ^OperatingSystem name = 'OS/2'! !

!PButton methods !
defaultForeColor

    ^Color buttonText! !

!WBMultiListChooser methods ! 
listClass

    ^MultipleSelectListBox! !

!WBMultiToolPalette methods !   
bitmapFileAt: key on: name
    | element |
    ^(element := self elementAt: key on: name) isNil
        ifTrue: [ nil ]
        ifFalse: [ element file ]! !

!WBLookPolicyWin95 methods !  
frameWidthDialog

    ^frameWidthDialog ifNil: [
        frameWidthDialog := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxdlgframe" 7]
            ifFalse: [super frameWidthDialog]]! !

!WBEditClassDialog methods ! 
initWindow

	| filterChoice |

	alt := Notifier isAltKeyDown.
	self class cleanClassLists.
	self
		loadMostRecent;
		loadMostFrequent.

	self inTeamV
		ifTrue: [
			package
				contents: self packageList;
				selectItem: self class packageChoice]
		ifFalse: [
			self inENVY
				ifTrue: [
					(self paneNamed: 'packageLabel') contents: 'Application:'.
					package
						contents: self envyApplicationList;
						selectItem: self class packageChoice]
				ifFalse: [
					self inXoteryX
						ifTrue: [
							(self paneNamed: 'packageLabel') contents: 'Xo Package:'.
							package
								contents: self xoteryxPackageList;
								selectItem: self class packageChoice]
						ifFalse: [
							package disable.
							(self paneNamed: 'packageLabel') disable.
							(self paneNamed: 'anyPackage') disable]]].

	filter
		contents: self class filterList;
		selectItem: (filterChoice := self class filter = self class nonWBChoice
			ifTrue: [self class defaultChoice]
			ifFalse: [self class filter]).

	self updateListContents.

	selectedClass := self class recentClasses notEmpty
		ifTrue: [self class recentClasses first]
		ifFalse: [nil].

	self setWindowTitle.! !

!WBResizeBitmap methods !   
oldExtent: aPoint

	oldExtent := aPoint.! !

!WBFramingEditor methods !   
initializeOnFramer: aFramer
rects: thePanesRects
parentRect: theParentsRect

    framingParameters := aFramer.
    currentRectList := thePanesRects.
    parentRect := theParentsRect.
    hasFramed := false.
    "Initialize all uninitialized combo boxes"
    originXAnchor
        contents: #('Window left' 'Window right' 'Window center' 'Pane right');
        enable.
    originYAnchor
        contents: #('Window top' 'Window bottom' 'Window center' 'Pane bottom');
        enable.
    cornerXAnchor
        contents: #('Window left' 'Window right' 'Window center' 'Pane left');
        enable.
    cornerYAnchor
        contents: #('Window top' 'Window bottom' 'Window center' 'Pane top');
        enable.
    originXAnchor selectIndex: 1.
    originYAnchor selectIndex: 1.
    cornerXAnchor selectIndex: 1.
    cornerYAnchor selectIndex: 1.
    originXStyleFixed
        selection: false;
        enable.
    originXStyleScaled
        selection: false;
        enable.
    originYStyleFixed
        selection: false;
        enable.
    originYStyleScaled
        selection: false;
        enable.
    cornerXStyleFixed
        selection: false;
        enable.
    cornerXStyleScaled
        selection: false;
        enable.
    cornerYStyleFixed
        selection: false;
        enable.
    cornerYStyleScaled
        selection: false;
        enable.
    bottomRelative enable.
    topRelative enable.
    rightRelative enable.
    leftRelative enable.
    "For initialization only - the y coordinate needs to be configured
     to a legal value for setExampleRects to work"
    yCenteredCheckBox selection: true.
    framingParameters isNil
        ifTrue:
            [originXStyleFixed selection: true.
            originXAnchor selectItem: 'Window left'.
            originXAnchor disableItem: 'Pane right'.
            originYStyleFixed selection: true.
            originYAnchor selectItem: 'Window top'.
            originYAnchor disableItem: 'Pane bottom'.
            cornerXStyleFixed selection: true.
            cornerXAnchor selectItem: 'Pane left'.
            cornerYStyleFixed selection: true.
            cornerYAnchor selectItem: 'Pane top'.
            xCenteredCheckBox selection: false.
            yCenteredCheckBox selection: false.
            ]
        ifFalse:
            [framingParameters centerX
                ifTrue:
                    [xCenteredCheckBox selection: true.
                    self xCenteredToggled: true "xCenteredCheckBox".
                    ]
                ifFalse:
                    [xCenteredCheckBox selection: false.
                    framingParameters left isNil
                        ifTrue:
                            [originXStyleFixed selection: true.
                            originXAnchor selectItem: 'Pane right'.
                            cornerXAnchor disableItem: 'Pane left'.
                            ]
                        ifFalse:
                            [framingParameters left isInteger
                                ifFalse:
                                    [originXStyleScaled selection: true.
                                    self originXStyleChanged: originXStyleScaled.
                                    ]
                                ifTrue:
                                    [originXStyleFixed selection: true.
                                    originXAnchor selectItem: 'Window ' , framingParameters leftRel asCUAPresentableString.
                                    self originXStyleChanged: originXStyleScaled.
                                    ].
                            ].
                    framingParameters right isNil
                        ifTrue:
                            [cornerXStyleFixed selection: true.
                            cornerXAnchor selectItem: 'Pane left'.
                            originXAnchor disableItem: 'Pane right'.
                            ]
                        ifFalse:
                            [framingParameters right isInteger
                                ifFalse:
                                    [cornerXStyleScaled selection: true.
                                    self cornerXStyleChanged: cornerXStyleScaled.
                                    ]
                                ifTrue:
                                    [cornerXStyleFixed selection: true.
                                    cornerXAnchor selectItem: 'Window ' , framingParameters rightRel asCUAPresentableString.
                                    self cornerXStyleChanged: cornerXStyleFixed.
                                    ].
                            ].
                    ].
            framingParameters centerY
                ifTrue:
                    [yCenteredCheckBox selection: true.
                    self yCenteredToggled: true "yCenteredCheckBox".
                    ]
                ifFalse:
                    [yCenteredCheckBox selection: false.
                    framingParameters top isNil
                        ifTrue:
                            [originYStyleFixed selection: true.
                            originYAnchor selectItem: 'Pane bottom'.
                            cornerYAnchor disableItem: 'Pane top'.
                            ]
                        ifFalse:
                            [framingParameters top isInteger
                                ifFalse:
                                    [originYStyleScaled selection: true.
                                    self originYStyleChanged: originYStyleScaled.
                                    ]
                                ifTrue:
                                    [originYStyleFixed selection: true.
                                    originYAnchor selectItem: 'Window ' , framingParameters topRel asCUAPresentableString.
                                    self originYStyleChanged: originYStyleFixed.
                                    ].
                            ].
                    framingParameters bottom isNil
                        ifTrue:
                            [cornerYStyleFixed selection: true.
                            cornerYAnchor selectItem: 'Pane top'.
                            originYAnchor disableItem: 'Pane bottom'.
                            ]
                        ifFalse:
                            [framingParameters bottom isInteger
                                ifFalse:
                                    [cornerYStyleScaled selection: true.
                                    self cornerYStyleChanged: cornerYStyleScaled.
                                    ]
                                ifTrue:
                                    [cornerYStyleFixed selection: true.
                                    cornerYAnchor selectItem: 'Window ' , framingParameters bottomRel asCUAPresentableString.
                                    self cornerYStyleChanged: cornerYStyleFixed.
                                    ].
                            ].
                    ].
            ].
    "Since several PM events will have been queued up at this point,
     we have to flush them out before continuing..."
    Smalltalk platformIsOS2 ifTrue: [
        Notifier empty ].
    hasFramed := true.
    self initializeExampleRects.
    self setExampleRects.! !

!WBInterfaceObject methods !  
storeContentsOn: aStream indentString: spaceString

	(self usesTitle and: [self contents notNil])
		ifTrue: [
			aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'contents: '.
			self contents isString
				ifTrue: [aStream nextPutStringConstant: self contents]
				ifFalse: [self contents printOn: aStream]].! !

!PEnhancedEntryField methods ! 
getFocus: aSymbol

    getFocus := aSymbol! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBAbstractCodeModule methods !   
initialize
		"Private - Initialize the receiver."
	super initialize.
	stream := WBCodeStream new.
	stream owner: self.! !

!WBUndoManager methods ! 
initialize

    inUndo := false.! !

!WBVersionCodeModule methods !   
canInheritMethod
		"Answer true if the method can be inherited from the superclass."
	^false! !

!WBLayoutWizard class methods !  
defaultButtons: aCollectionOfStrings

    DefaultButtons := aCollectionOfStrings! !

!WBLookPolicyWin95 methods ! 
drawMinimizeButtonDisabledWith: aPen at: aRect

    | innerRect leftBottom |
    innerRect := self
        drawTitleBarBoxWith: aPen
        at: aRect.
    leftBottom := innerRect leftBottom.
    aPen
        foreColor: Color darkGray;
        lineFrom: (leftBottom rightAndUp: 3@(2+Rectangle leftTopUnit y)) to: (leftBottom rightAndUp: 9@(2+Rectangle leftTopUnit y));
        lineFrom: (leftBottom rightAndUp: 3@(3+Rectangle leftTopUnit y)) to: (leftBottom rightAndUp: 9@(3+Rectangle leftTopUnit y));
        foreColor: Color white;
        lineFrom: (leftBottom rightAndUp: 3@(1)+Rectangle leftTopUnit y) to: (leftBottom rightAndUp: 9@(1+Rectangle leftTopUnit y));
        lineFrom: (leftBottom rightAndUp: 9@(3+Rectangle leftTopUnit y)) to: (leftBottom rightAndUp: 9@(1+Rectangle leftTopUnit y)).! !

!WBLookPolicy methods !
drawButton: aButton with: aPen clipRect: clipRect

    self
        draw3DBoxWith: aPen
        at: aButton rect.
    aPen
        font: SysFont;
        foreColor: Color black;
        backColor: Color gray;
        setTextAlign: TaTop;
        centerWinText: aButton contents at: aButton rect center! !

!WBCallOutEditor methods !  
checkForDups: suggested

    ^callOutMap includes: suggested! !

!WBEnhancedEntryFieldEditor methods !
getCase: aPane

    aPane contents: self caseDict keys asSortedCollection asArray! !

!PActionButton methods !
storeContentsOn: aStream indentString: spaceString

	super storeContentsOn: aStream indentString: spaceString.
	(self action notNil and: [self action notEmpty])
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'action: #',self action].! !

!WBCreateMenuModule methods !   
generateBody
		"Private - Generate all the menu definitions."
	self stream indentBy: 1 during: [
		self
			generateGeneratedSymbol;
			generateMenuBody ].! !

!WBTabOrderLayoutForm methods ! 
soloWidgets

	^soloWidgets! !

!WBPMenuItem methods ! 
deleteMessage

    ^
'Deleting this item will cause submenus to be irretrievably destroyed. Do you wish to do so?'! !

!WBTreeNode methods ! 
previousSibling

    self isRoot ifTrue: [
        ^nil
    ].

    ^parent childBefore: self.! !

!WBPoolEditorCompositePane methods !   
selectedCategories

	^self owner selectedCategories! !

!WBDevelopmentWindow methods !
shellContentRect

	^self shell contentRect! !

!PWBStaticGraphic methods !
displayWith: aPen clipRect: clipRect

	| labelOrFileName bitmap |
	labelOrFileName := self contents.
	(labelOrFileName isNil or: [labelOrFileName isEmpty])
		ifTrue: [^self displayGenericWith: aPen clipRect: clipRect].
	(self fileExists: labelOrFileName)
		ifTrue: [bitmap := WBBitmapClass fromFile: labelOrFileName]
		ifFalse: [
			bitmap := WBBitmapClass
				screenWidth: self extent x
				height: self extent y.
			bitmap pen
				fill: self realBackColor;
				foreColor: self foreColor;
				backColor: self realBackColor;
				setBackgroundModeTransparent;
				setTextAlign: WBDisplayContext defaultTextAlign;
				font: (self font isNil ifTrue: [self defaultFont] ifFalse: [self font]);
				centerWinText: labelOrFileName at: bitmap boundingBox center].
	(style == #fixedSize)
		ifTrue: [
			aPen
				copyBitmap: bitmap
					from: bitmap boundingBox
					at: rect origin]
		ifFalse: [
			aPen
				copyBitmap: bitmap
					from: bitmap boundingBox
					to: rect].
	bitmap release.! !

!WBTemplateEditor methods ! 
preEditCheck

	^true! !

!WBAttributeWindow methods ! 
preInitWindow
		"Link the receiver to its owner."
	ownerChanged := false.
	self owner
		when: #aboutToClose send: #ownerAboutToClose to: self;
		when: #closed send: #ownerClosed to: self;
		when: #aboutToOpen: send: #ownerAboutToOpen: to: self;
		when: #aboutToChange send: #ownerAboutToChange to: self;
		when: #changed send: #ownerChanged to: self.
	self mainView
		when: #activated send: #activated to: self;
		when: #closed send: #closed to: self.
	self mainView children
		do: [:eachChild |
			eachChild font: SysFont].
	self mainView backColor: Color gray.! !

!Bitmap methods ! 
wbButtonDown: aBitmap
	"Private - WBPro Development."

	| srcBox dstBox ratio |
	srcBox := aBitmap boundingBox.
	dstBox := self wbButtonDownBox.
	srcBox extent < dstBox extent
		ifTrue: [ratio := 1]
		ifFalse: [
			ratio := dstBox extent / srcBox extent.
			ratio := ratio x min: ratio y].
	dstBox := (dstBox center leftAndUp: srcBox extent * ratio // 2)
		extentFromLeftTop: (srcBox extent * ratio) truncated.
	self pen copyBitmap: aBitmap from: srcBox to: dstBox.! !

!WBTreeNode methods !
fullCopy

    | copy |

    copy := self class new.
    self fullCopyTo: copy withParent: nil.

    ^copy! !

!WBLayoutFrameEditor methods ! 
attachLeftTopBottom

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: #(0 0 0 1).! !

!WBMenu methods ! 
add: aSelector label: aLabelString

    ^self
        add: aSelector
        label: aLabelString
        mnemonic: nil
        enable: nil
        toggle: nil
        for: nil
        accelerator: ''.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBBitmapManagerWindow methods ! 
sameValueForAllCategories: aBoolean
	"Set true if the same bitmap should be used
		for all categories."

	SameValueForAllCategories := aBoolean.
	self updateOptionMenu.! !

!WBMenuEditor methods !   
openOn: aMenu

    aMenu isNil ifTrue: [
        editedMenu := self newMenuClass new.
    ] ifFalse: [
        editedMenu := aMenu fullCopy.
    ].
    ^self open.! !

!WindowBuilder class methods !   
maxUndoLevels: anInteger

    ^self editorClass
        propertyValueAt: #MaxUndoLevels
        category: self editorPropertyString
        put: anInteger! !

!WBBitmapManagerWindow methods !
menuOptionShowDimensions

	self showDimensions: self showDimensions not.! !

!WindowFrameObject methods ! 
update

	self children do: [:each | each update].
	super update.! !

!WBRGBColorDialog methods ! 
rgbChanged: aString
    "Callback for the #textChanged: event triggered in the EntryField named 'blue'.
     (Generated by WindowBuilder)"

    | theColor rgbColor indexedColor selectedElement |
    theColor := rgbColor := self rgbColor.
    indexedColor := rgbColor asIndexedColor.
    (rgbColor = ([indexedColor asRGBColor]
        on: Error
        do: [RGBColor fromInteger: indexedColor asInteger]))
        ifTrue: [theColor := indexedColor].
    elements at: (selectedElement := self selectedElement) put: theColor.
    self updateColorList: selectedElement.
    self fillColorPaneWith: rgbColor! !

!WBModelObjectEditor methods !  
popupTargetMenu: sendPane

    | menu panesMenu objectMenu iVarMenu eventHandlerTarget
    global checkItem array answer |

    menu := Menu new
        owner: self;
        selector: #popupEventTarget:;
        appendItem: (
            self editedClass isScratchWindow
                ifTrue: ['Self'] ifFalse: ['Self [', self editedClass name, ']'])
            selector: "#self" self prototype targetObject;
        yourself.
    self shell isCompositePane
        ifFalse: [menu appendItem: 'Top Pane' selector: self shell wbRealWidget].
    (self hasChildren or: [self prototype targetInstVarNames notEmpty])
        ifTrue: [menu appendSeparator].
    self hasChildren
        ifTrue: [
            menu appendSubMenu:
                (panesMenu := Menu new
                    title: 'Widgets';
                    owner: self;
                    selector: #popupEventTarget:;
                    yourself).
            ((array := self children asArray) copyFrom: 1 to: (array size min: 24)) do: [:pane |
                panesMenu appendItem: pane wbNameAndClass selector: pane wbRealWidget].
            array size > 24
                ifTrue: [
                    panesMenu appendSeparator;
                        appendItem: 'Other Widget...' action:
                            (Message receiver: [
                                (answer := WBListChooser
                                    fromList: (array collect: [:pane | pane wbRealWidget])
                                    prompt: 'Select Pane') isNil
                                    ifFalse: [self popupEventTarget: answer]] selector: #value)]].
    self hasModelObjects
        ifTrue: [
            menu appendSubMenu:
                (objectMenu := Menu new
                    title: 'Model Objects';
                    owner: self;
                    selector: #popupEventTarget:;
                    yourself).
            ((array := self owner prototype modelObjects asArray) copyFrom: 1 to: (array size min: 24)) do: [:object |
                objectMenu appendItem: object wbNameAndClass selector: object].
            array size > 24
                ifTrue: [
                    objectMenu appendSeparator;
                        appendItem: 'Other Model Object...' action:
                            (Message receiver: [
                                (answer := WBListChooser
                                    fromList: array
                                    prompt: 'Select Model Object') isNil
                                    ifFalse: [self popupEventTarget: answer]] selector: #value)]].
    self prototype targetInstVarNames notEmpty
        ifTrue: [
            menu appendSubMenu:
                    (iVarMenu := Menu new
                        title: 'Inst Vars';
                        owner: self;
                        selector: #popupEventTarget:;
                        yourself).
            ((array := self prototype targetInstVars asSortedCollection asArray)
                copyFrom: 1 to: (array size min: 24)) do: [:iVarAssoc |
                iVarMenu appendItem: iVarAssoc key asString selector: iVarAssoc value].
            array size > 24
                ifTrue: [
                    iVarMenu appendSeparator;
                        appendItem: 'Other I-Var...' action:
                            (Message receiver: [
                                (answer := WBListChooser
                                    fromList: (array collect: [:each | each key])
                                    prompt: 'Select I-Var') isNil
                                    ifFalse: [self popupEventTarget: (array detect: [:each | each key = answer]) value]] selector: #value)]].
    eventHandlerTarget := ((self selectedObject eventHandlerTargetAt: self currentEvent) 
		ifNil: [self prototype targetObject]) wbRealWidget.

    Smalltalk associationsDo: [:each |
        each value == eventHandlerTarget ifTrue: [
            global := each]].
    menu
        appendSeparator;
        appendItem:     'Window',
            ((global notNil and: [global value wbCreated])
                ifTrue: [checkItem := #window:. ' [',global key,']'] ifFalse: ['']),'...' selector: #window:;
        appendItem:     'Global',
            ((global notNil and: [global value wbCreated not])
                ifTrue: [checkItem := #global:. ' [',global key,']'] ifFalse: ['']),'...' selector: #global:.

    checkItem isNil
        ifTrue: [
            menu checkItem: eventHandlerTarget.
            panesMenu isNil ifFalse: [panesMenu checkItem: eventHandlerTarget].
            objectMenu isNil ifFalse: [objectMenu checkItem: eventHandlerTarget].
            iVarMenu isNil ifFalse: [iVarMenu checkItem: eventHandlerTarget]]
        ifFalse: [menu checkItem: checkItem].

    sendPane setPopupMenu: menu.! !

!WBBitmapManagerWindow methods ! 
menuKeyFromScreen

    "Callback for the menu item titled 'New...'.
     (Generated by WindowBuilder)"

	| newBitmap newKey |
	newBitmap := WBBitmapClass fromUser ifNil: [^self].
	newKey := Prompter prompt: 'Enter new key' default: self defaultNewKey.
	newKey isNil ifTrue: [^self].
	newKey := self checkNewKey: newKey.
	newKey isNil ifTrue: [^self].
	self menuKeyNew: (Array with: newKey => newBitmap).! !

!WBPoolManagerWindow methods !   
menuCategoryRename: oldCategory to: newCategory

	self poolManager addCategory: newCategory.
	self poolManager pools do: [:eachPool |
		eachPool keys do: [:eachKey |
			eachPool at: eachKey in: newCategory put: (
				eachPool at: eachKey in: oldCategory)]].
	self poolManager activeCategory = oldCategory ifTrue: [
		self poolManager activeCategory: newCategory].
	self poolManager removeCategory: oldCategory.! !

!WBHandle methods ! 
initialize
    "Private - Initialize the reciever"! !

!WBTabOrderLayoutForm methods ! 
destroySelectedWidgets

	| groupers |
	(groupers := self selections select: [:widget | 
		widget isGrouper]) isEmpty ifTrue: [^self].
	groupers do: [:grouper |
		self children remove: grouper ifAbsent: [nil]].
	self
		hideHandles;
		clearHandles;
		clearSelections;
		resetGroups;
		normalizeTabOrder;
		updateWidget;
		triggerEvent: #deletedGroup.! !

!WBInterfaceObject methods ! 
eventHandlersDo: aBlock
	"Evaluate aBlock with each of the event handlers of the receiver.
		NOTE: Event handlers can have an empty string as a selector
		indicating that the handler is not a valid handler"

	self wbRealWidget eventTable associationsDo: [:assoc |
		assoc value asActionSequence do: [:msg |
			msg receiver notNil & msg selector notEmpty
				ifTrue: [aBlock value: assoc key => msg]]].! !

!WBCodeStream methods !   
nextPutVarNameFor: anObject
	"Append the var name for anObject to the stream."

	self owner notNil
		ifTrue: [self nextPutAll: (self owner varNameFor: anObject)]
		ifFalse: [self nextPutAll: anObject asString].! !

!WBTreeListBox methods !
exdentSelection

    self performOnSelection: #exdent
        selectionDelta: nil
        moveWithSelection: false.
    self setEditBox.
    self event: #select! !

!WBInterfaceObject methods ! 
generateTabStopsAndGroups

	^self tabPosition isNil or: [self tabPosition firstInGroup]! !

!WindowBuilder methods !  
stopTimer

	Time stopTimer: 99 forWindow: self mainView.! !

!WBFramerExample class methods ! 
isWBInternalClass

    ^true! !

!WBUndoManager class methods !   
maxUndoLevels: anInteger

    MaxUndoLevels := anInteger! !

!WBLayoutForm methods !  
widget: aWidget containsPoint: aPoint

    ^aWidget rect containsPoint: aPoint.! !

!WBDescriptor methods !   
name
    "Answer the value of name."

    ^name! !

!WBFramingEditor methods !   
cornerYStyleChanged: styleRadio

    (styleRadio contents = 'Scaled') & (styleRadio selection)
        ifTrue:
            [cornerYAnchor selection: 'Window top'.
            cornerYAnchor disable.
            bottomRelative disable.
            ]
        ifFalse:
            [bottomRelative enable.
            cornerYAnchor enable.
            ].
    self setExampleRects.! !

!WBMenuEditor methods ! 
checkKeyAccels

    | currentItem  accelerator |

    currentItem := menuItemsEditor selectedItem.
    accelerator := currentItem accelerator.
    currentItem allRelations do: [ :p |
        p ~= currentItem ifTrue: [
            (accelerator notNil and: [ p accelerator = accelerator ]) ifTrue: [
                ^MessageBox messageNote:  ' Another menu item (', p title stripMnemonic trimBlanks asQuotedString, ') already uses the accelerator ', accelerator fullKeyName,'.  Please choose another.'
            ].
        ].
    ].! !

!WBLayoutForm methods !
maxSize: aPoint
    "Set the value of maxSize."

    maxSize := aPoint.! !

!WindowBuilder methods ! 
defaultCodeGenerator
	"Private - Answer the code generator."

	^self 	class codeGeneratorClass new 
		policy: self codePolicy;
		yourself! !

!PEnhancedEntryField methods !   
autoTab: aBoolean

    autoTab := aBoolean! !

!Bitmap methods !  
wbCopy
	"Private - WBPro Development."

	| newBitmap |
	#addedByOSI.
	newBitmap := WBBitmapClass
		width: self width
		height: self height
		planes: self planes
		bitCount: self bitCount.
	self displayAt: 0@0 with: newBitmap pen.
	^newBitmap! !

!WBInterfaceObject methods !   
mutateSpecificsFrom: aPane! !

!WBModelDefinitionEditor methods !   
loadAttributesForClass: aClass

	| instance classes instVars allInstVarNames get
	 accessors initValue isLazy |
	instance := aClass new.
	classes := aClass allSuperclasses
		addFirst: aClass;
		yourself.
	instVars := OrderedCollection new.
	allInstVarNames := aClass allInstVarNames.
	classes do: [:cls |
		instVars addAll: (cls instVarNames collect: [:str |
			get := str asSymbol.
			accessors := cls canUnderstand: get.
			isLazy := (initValue := instance instVarAt: (allInstVarNames indexOf: str)) isNil & accessors.
			initValue := accessors
				ifTrue: [[instance perform: get] on: Error do: [nil]]
				ifFalse: [initValue].
			WBModelInstVar new
				name: (cls == aClass
					ifTrue: [str]
					ifFalse: [str, ' [', cls name, ']']);
				myClass: cls;
				hasAccessors: accessors;
				initialized: initValue notNil;
				lazy: initValue notNil & isLazy;
				valueClass: initValue class;
				initializeValue: (self setInitValue: initValue);
				hasEvent: (instance canTriggerEvent: (str, 'Changed:') asSymbol);
				yourself])].
	attributes contents: instVars.
	events := ((aClass constructEventsTriggered 
		removeAll: aClass superclass constructEventsTriggered;
		yourself) collect: [:sym | sym asString]) asSortedCollection asOrderedCollection.
	instVars do: [:instVar |
		events remove: instVar eventName ifAbsent: []].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBScrollingPane methods !   
updateHorizontalSlider

    self updateHorizontalSliderTo: topCorner x.! !

!WBPrimaryModelOpenOnModule methods ! 
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self stream
            cr; nextPutAll: #generated storeString; nextPut: $.;
            cr; nextPutAll: #model;
            nextPutAll: ' := '; nextPutAll: self messageArguments first; nextPut: $.;
                cr; nextPutAll: #self; space; nextPutAll: #open; endExpression].! !

!WBMenuItemStub methods !   
titleString
		"Answer the title as a quoted string."
	^title printString! !

!WBInterfaceObject methods ! 
mutationRotationList

    ^#()! !

!WBLayoutWizard methods !  
expressionChanged: aString

    | first |
    sourceInstance := aString trimBlanks isEmpty
        ifTrue: [nil]
        ifFalse: [
            ((first := aString asArrayOfSubstrings first) first isUppercase
            and: [(Smalltalk includesKey: first asSymbol) not])
            ifTrue: [nil]
            ifFalse: [self compilerEvaluate: aString]].
    sourceInstance isClass ifTrue: [sourceInstance := nil].
    (self paneNamed: 'expressionButton') selection: true.
    self
        updateSourceButtons;
        disableFields;
        loadAttributes! !

!WBModelInstVar methods !
initializeValue: aValue

    initializeValue := aValue! !

!WBMenuItem methods !  
enable
        "Enable the receiver."
	self hasSubmenu
		ifTrue: [^self submenu enableAll].
	self isDisabled ifFalse: [^self].
	self attribute: (self attribute bitAnd: (MfGrayed bitXor: 16rFFFF)).
	self updateAttributes: MfGrayed.! !

!WBPoolManagerWindow methods ! 
menuPoolAddExisting: existingPoolNames

	| aPool |
	existingPoolNames do: [:each |
		aPool := self poolManager addPoolNamed: each.
		self allCategories do: [:eachCat |
			aPool keys do: [:eachKey |
				aPool at: eachKey in: eachCat ifAbsentPut: [
					aPool at: eachKey]]]].! !

!WBResizeBitmap methods !
oldWidth

    ^(self paneNamed: 'oldWidthField') contents asInteger! !

!ComboEntryField class methods !  
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbRemoveEventNamed: #dragTargetEnter: ;
        wbRemoveEventNamed: #dragTargetEraseEmphasis: ;
        wbRemoveEventNamed: #help ;
        wbRemoveEventNamed: #mouseMoved: ;
        wbRemoveEventNamed: #dragTargetLeave: ;
        wbRemoveEventNamed: #dragSourceNeedsCursors: ;
        wbRemoveEventNamed: #textChanged: ;
        wbRemoveEventNamed: #dragTargetDrawEmphasis: ;
        wbRemoveEventNamed: #changed: ;
        wbRemoveEventNamed: #resized ;
        wbRemoveEventNamed: #gettingFocus ;
        wbRemoveEventNamed: #needsMenu ;
        wbRemoveEventNamed: #dragTargetOver: ;
        wbRemoveEventNamed: #dragTargetDrop: ;
        wbRemoveEventNamed: #needsSelection ;
        wbRemoveEventNamed: #dragSourceCut: ;
        wbRemoveEventNamed: #losingFocus ;
        wbRemoveEventNamed: #needsContents ;
        wbRemoveEventNamed: #dragSourceNeedsObject: ;
        wbRemoveEventNamed: #rightClicked ;
        wbRemoveEventNamed: #backTabbed ;
        wbRemoveEventNamed: #dragTargetNeedsOperations: ;
        wbRemoveEventNamed: #display ;
        wbRemoveEventNamed: #tabbed ;
        wbRemoveEventNamed: #needsPopupMenu ;
        wbRemoveEventNamed: #aboutToChangeTo: ;
        wbRemoveEventNamed: #entered: ;
        yourself! !

!WBToolBarEditor methods !  
setSelector: aString

	list selection isNil ifTrue: [ ^self ].
    (elements at: list selection) selector: aString.
    list invalidateRect: nil! !

!WBMenuEditor methods !
newMenuClass

    ^WBPMenu! !

!WBInterfaceObject methods !   
wbDuplicateTo: copy

	super wbDuplicateTo: copy.
	self == copy
		ifFalse: [copy wbRealWidget: self wbRealWidget wbDuplicate].
	^copy! !

!WindowBuilder methods !  
menuToolsInspectPrototype

    self prototype inspect! !

!WBEventManagerWindow methods ! 
menuHandlerTop

    "Callback for the menu item titled 'Top'.
     (Generated by WindowBuilder)"

	| aHandler |
	self mustHaveOneHandlerSelected ifFalse: [^self].
	(aHandler := self handlerSelected) moveTop.
	self owner updateSendField.
	handlerListBox update.
	self handlerSelected: aHandler.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPrototype methods ! 
layoutForm

	^self owner layoutForm! !

!WBAbstractPrompter methods ! 
ok

    "Callback for the #clicked event triggered in the Button named 'ok'.
     (Generated by WindowBuilder)"

	result := self resultPrim.
	self close.! !

!PWBInvisibleGroupPane methods !
displayWith: aPen clipRect: clipRects

	aPen drawFocusRect: self rect.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventManagerWindow methods !   
zap

	self mainView children do: [:each | Notifier removeEventsFor: each].! !

!WBPoolManagerWindow methods ! 
menuCategoryNew

    "Callback for the menu item titled 'New...'.
     (Generated by WindowBuilder)"

	| suggested newCategoryName |
	suggested := self suggestedCategories.
	newCategoryName := WBEntryListPrompter
		prompt: 'Enter name of new category'
		title: 'New category...'
		list: suggested
		default: (
			suggested notEmpty
				ifTrue: [suggested first]
				ifFalse: [self defaultNewCategory]).
	newCategoryName isNil ifTrue: [^self].
	newCategoryName := self checkNewCategory: newCategoryName.
	newCategoryName isNil ifTrue: [^self].
	[self menuCategoryNew: (Array with: newCategoryName)]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].
	self selectedCategory: newCategoryName.! !

!PTextEdit methods !  
usesFocus

    ^false! !

!PRadioButtonGroup methods !
style: aStyle

    super style: aStyle.
    self numColumns: aStyle first asString asInteger.! !

!WBOutboardWindow methods !
zOrderChanged: aCollectionOfWidgets
    "The owner's widget z-order changed."! !

!PStatusPane methods !   
colorButtonShadow

    ^Color buttonShadow! !

!WBLookPolicyWin31 methods !   
displayWithRightBottomScrollBars: aPen rect: aRect backColor: aColor

	| innerRect newInnerRect backColor |
	backColor := (self class isDefault not 
		and: [(self asRGBColor: aColor) = (self asRGBColor: self defaultOS2WidgetBackColor)])
		ifTrue: [self defaultWidgetBackColor]
		ifFalse: [aColor].
	innerRect := self displayWithBorder: aPen rect: aRect backColor: backColor.
	newInnerRect := innerRect leftTop
		rightBottom: (innerRect rightBottom leftAndUp: (self scrollBarWidth @ self scrollBarHeight)).
	self
		drawVScrollBarWith: aPen
		at: ((newInnerRect rightTop up: 1)
			rightBottom: (innerRect rightBottom rightAndUp: 1 @ (self scrollBarHeight - 1)));
		drawHScrollBarWith: aPen
		at: ((newInnerRect leftBottom left: 1)
			rightBottom: (innerRect rightBottom leftAndDown: self scrollBarWidth - 1 @ 1)).
	aPen
		fill: ((newInnerRect rightBottom rightAndDown: 1) rightBottom: innerRect rightBottom)
		color: Color gray.
	^newInnerRect! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!ButtonEditor methods !  
openOn: aBitmap clipRect: aRect
        "Open a BitEditor on aBitmap."
    | graphPane groupPane size imageSize |
    scale := 8.
    imageForm := aBitmap.
    imageSize := (aRect extent min: imageForm extent) min:
        (Display width - 80 // scale @
            (Display height - 20 // scale)).
    imageRect := aRect origin extent:
        (aRect extent min: imageSize).
    imageSize := imageSize * scale + (5 @ 5).
    size := 76 @ (300 max: imageSize y).
    copy := WBBitmapClass screenExtent: aRect extent.
    copy pen copyBitmap: aBitmap
        from: aRect
        at: 0 @ 0.
    self addSubpane: (
        (graphPane := GraphPane new)
            owner: self;
            when: #display send: #displayImage: to: self withArgument: graphPane;
            style: GraphPane noScrollbarsFrameStyle;
            framingBlock: [: box |
                box origin extent: (size x @ (box height // 2))]).
    self addSubpane:
        (groupPane := GroupPane new
            framingBlock: [: box |
                box origin x @ (box origin y + (box height // 2))
                    extent: (size x @ (box height // 2))]).
    groupPane addSubpane:
        (Button new
            owner: self;
            contents: 'Save';
            pushButton;
            when: #clicked send: #save to: self;
            framingBlock: [: box |
                (box origin x + (box width // 6)) @ (box origin y + (box height // 6))
                    extent: (box width * 2 // 3) @ (box height // 3)]).
   groupPane addSubpane:
        (Button new
            owner: self;
            contents: 'Exit';
            pushButton;
            when: #clicked send: #exit to: self;
            framingBlock: [: box |
                (box origin x + (box width // 6)) @ (box origin y + (box height // 2))
                    extent: (box width * 2 // 3) @ (box height  // 3)]).
    self addSubpane:
        ((graphPane := GraphPane new)
            owner: self;
            when: #needsPopupMenu send: #editMenu: to: self withArgument: graphPane;
            when: #display send: #displayBits: to: self withArgument: graphPane;
            when: #button1Down send: #changeBits: to: self withArgument: graphPane;
            when: #button1Moved send: #changeBits: to: self withArgument: graphPane;
            style: GraphPane noScrollbarsFrameStyle;
            framingBlock: [: box |
                box origin x + (size x @ 0)  extent: (
                    (box width - size x) @ box height)]).
    windowSize := 80 + imageSize x + 4 @
        (( 200 max: imageSize y) + SysFont height + 12).
    self openWindow.
    self menuWindow addMenu: (
        Menu colorMenu: self selector: #colorSelected:)! !

!WindowBuilder class methods !  
autoSize

    ^self editorClass
        propertyValueAt: #AutoSize
        category: self editorPropertyString! !

!WBEditClassDialog methods ! 
addFilter

    "Callback for the #clicked event triggered in the Button named 'addFilter'.
     (Generated by WindowBuilder)"

    selectedClass isNil ifTrue: [^self].
    self class addToFilterList: selectedClass.
    filter
        contents: self class filterList;
        selectItem: selectedClass name.
    self class filter: selectedClass name.
    self updateListContents.! !

!WBEventManagerWindow methods !   
handlerListUpdate

	handlerListBox update.
	self toFieldUpdate.
	self zap.! !

!WBPoolManagerWindow methods !   
menuCategoryAddSuggested: aCollection

	self menuCategoryNew: aCollection.! !

!WBToolBarEditor methods ! 
ok

    | vertical changed theOwner |

    vertical := (self paneNamed: 'vertical') selection.
    changed := vertical ~~ thePane vertical.
    thePane
        cellSize: self cellSize;
        vertical: vertical.

    elements := elements select: [ :element |
        element bitmapSelector notNil and: [ element bitmapSelector notEmpty ]].
    elements isEmpty ifFalse: [
        elements first rectangle:
            (Rectangle
                origin: (vertical
                    ifTrue: [0 @ (elements first numSpaces - 1
                        + (Rectangle leftTopUnit y *
                            ((elements size - 1) * thePane cellSize y)))]
                    ifFalse: [elements first numSpaces @ 0])
                extent: thePane cellSize).

        2 to: elements size do: [ :i |
            (elements at: i) rectangle: (Rectangle
                origin: (vertical
                    ifTrue: [ ((elements at: i - 1) rectangle) leftBottom down: (elements at: i) numSpaces - 1
                        + (Rectangle leftTopUnit y * thePane cellSize y) ]
                    ifFalse: [ (((elements at: i - 1) rectangle)
                        perform: (
                            Smalltalk platformIsWin32
                                ifTrue: [ #rightTop ]
                                ifFalse: [ #rightBottom ])) right: (elements at: i) numSpaces - 1 ])
                extent: thePane cellSize)
        ].
    ].
    thePane elements: elements.
    thePane useSystem: useSystem.

    changed ifTrue: [
        theOwner := Smalltalk platformIsWin32
            ifTrue: [ self mainView parent owner ]
            ifFalse: [ self mainView pmOwner owner ].
        theOwner
            sendInputEvent: #drawGrid:
            with: theOwner drawGrid ].

    self close! !

!WBLayoutForm methods !  
handlesRejecting: aWidget

    ^self handles reject: [:aHandle | aHandle owner == aWidget].! !

!WBBitmapManagerWindow methods !  
menuKeyResize

	self menuKeyResize: nil.! !

!WBChooseClassDialog methods !   
ok

    result := classListBox selectedItem.
    result notNil ifTrue: [
        result := Smalltalk at: result asSymbol.
    ].

    self close.! !

!WindowBuilder methods !   
menuFileSelectPrimaryModel

    | newObject modelObject |
    modelObject := self primaryModel.
    newObject := (WBListChooser
        fromList: #(#'<none>'), (EventManager allSubclasses reject: [:cls | cls isWBInternalClass])
        prompt: 'Select Primary Model'
        selection: (modelObject isNil
            ifTrue: [#'<none>']
            ifFalse: [modelObject class])) ifNil: [^self].
    newObject == modelObject class
        ifTrue: [^self].
    modelObject isNil
        ifFalse: [self prototype modelObjects remove: modelObject ifAbsent: []].
    newObject == #'<none>'
        ifTrue: [
            modelObject ifNil: [^self].
            ^self setDirty].
    (newObject := newObject new)
        propertyAt: #primaryModel put: true;
        setName: 'model';
        isInstVar: true.
    self prototype modelObjects add: newObject.
    self setDirty.! !

!WindowBuilder methods !
toolCollection

	| menus target tools |
	menus := self class wbMenus.
	target := menus detect: [:m |
			(m at: 1) stripMnemonic = 'Add']
		ifNone: [nil].
	target isNil ifTrue: [^nil].
	tools := OrderedCollection new.
	(target at: 3) do: [:mi |
		mi == #separator ifTrue: [^tools].
		tools 	add:
			(Association
				key: (mi at: 1) stripMnemonic
				value: ((mi at: 3) collect: [:msi | msi at: 2]))].
	^tools! !

!WBCodePolicy methods !  
updateSourceFor: aKey inPoolNamed: aPoolName sourceString: aString
	"Update the source for the specified pool key."! !

!WindowBuilder methods !   
setStatusForWidgets: aCollectionOfWidgets

    self setStatus:
        ((aCollectionOfWidgets isNil or: [aCollectionOfWidgets isEmpty])
            ifTrue: [
                self prototype realClass isScratchWindow
                    ifTrue: ['This is an unnamed application']
                    ifFalse: ['This is the application named ''', self prototype realClass name, '''']]
            ifFalse: [
                aCollectionOfWidgets size == 1
                    ifTrue: ['This is ', (self statusDescriptionFor: aCollectionOfWidgets first)]
                    ifFalse: ['Multiple widgets selected. The first is ', (self statusDescriptionFor: aCollectionOfWidgets first)]]).! !

!PStaticText methods !   
autoSizeFrom

    ^self style! !

!Symbol methods !   
wbEvaluateWithReceiver: anObject arguments: anArray
    "Private - this method is part of the development environment and cannot be relied on in a run-time image.
    Answer the result of evaluating the receiver using <anObject> as the message receiver. "

	#addedByOSI.
    ^anObject perform: self withArguments: anArray! !

!WBAbstractAddInModule class methods !   
modifiesProperties
    "Does this add-in modify properties?"

    ^false! !

!WBAbstractCodeModule methods ! 
addModule: aCodeModule
	"Add a code module to the list of code modules to be processed."

	aCodeModule owner ifNil: [aCodeModule owner: self].
	aCodeModule targetClass ifNil: [aCodeModule targetClass: self targetClass].
	aCodeModule targetObject ifNil: [aCodeModule targetObject: self targetObject].
	^self owner addModule: aCodeModule! !

!WBOutboardAttributeWindow methods !  
update
    "The receiver has been activated and the
        owner has changed, so update the receiver's content's
        to reflect the change in the owner."

	super update.
	self currentWidgets: self owner selections.
	self dirty: false.! !

!WindowBuilder class methods !   
companyName: aString
	"Answer the window builder company's name."

	self editorClass
		propertyValueAt: #CompanyName
		category: self userPropertyString
		put: aString.! !

!WindowBuilder class methods !   
wbScrapbookFileName
	"Answer the scrapbook file name."

	^'wb31usrw.sbk'! !

!WindowBuilder methods !
menuToolsInspectClipboard

	self clipboard size == 1
		ifTrue: [self clipboard first inspect]
		ifFalse: [self clipboard inspect]! !

!WindowBuilder class methods !
autoSave

    ^self editorClass
        propertyValueAt: #AutoSave
        category: self editorPropertyString! !

!WBLayoutForm methods !  
allowMove
    "Answer the value of allowMove."

    ^allowMove! !

!WBWindowEditor methods ! 
initWindow

    | theStyle |

    theStyle := thePane style.
    iconFile := thePane iconFile.

    (self paneNamed: 'systemMenu') selection: (theStyle includes: #sysmenu).
    (self paneNamed: 'maximizeBox') selection: (theStyle includes: #maximize).
    (self paneNamed: 'minimizeBox') selection: (theStyle includes: #minimize).
    thePane isModal ifTrue: [
        (self paneNamed: 'sizingFrame') hideWindow.
        (self paneNamed: 'mainViewChild') hideWindow
    ] ifFalse: [
        (self paneNamed: 'sizingFrame') selection: (theStyle includes: #sizable).
    ].
    self supportsNoTitlebar ifTrue: [
        (self paneNamed: 'titleBar') selection: (theStyle includes: #titlebar).
    ] ifFalse: [
        (self paneNamed: 'titleBar') selection: true; disable.
    ].
    (self paneNamed: 'mainViewChild') selection: (theStyle includes: #mainViewChild).

    "Support for MainView children"
    (thePane paneName = 'mainView') ifTrue: [
        (self paneNamed: 'mainViewChild') hideWindow
    ].! !

!WBMenuItem methods !   
update
        "Private - Send a message to the receiver to update itself."
    | pos posFlag miFlags |
    self window isNil ifTrue: [ ^self].
    self style & MfPopup = MfPopup
        ifTrue: [
            posFlag := MfByposition.
            pos := self position]
        ifFalse: [
            posFlag := MfBycommand.
            pos := self id].
    miFlags := self style | self attribute.
    (UserLibrary
        modifyMenu: self window handle
        position: pos
        flags: miFlags | posFlag
        newId: pos
        newContents: self label asParameter )
            ifFalse: [self osWarning]! !

!PCompositePane methods !   
isCompositePane

    ^true! !

!WBLayoutForm methods !
buttonReleasePlacing: aPoint
    "Process a button release event after placing a widget."

    | newWidgets size |
    [newWidgets := (self checkAllowMove: aPoint)
        ifTrue: [
            size := ((self cursorSelectPoint distanceRightAndDown: aPoint)
                max: self loadedWidgets first wbMinSize)
                min: self loadedWidgets first wbMaxSize.
            self loadedWidgets collect: [:aWidget |
                aWidget wbCloneWithParent: self shell width: size x height: size y]]
        ifFalse: [
            self loadedWidgets collect: [:aWidget |
                aWidget wbCloneWithParent: self shell]]]
        on: Error do: [:ex |
			"Report an error only if..."
			self wbHalt.
            newWidgets isNil
                ifFalse: [
                    newWidgets do: [:widget |
                        widget isDestroyed ifFalse: [widget wbDestroyWidget]]].
            self loadedWidgets: nil.
            ^self].
    self
        placeNewWidgets: newWidgets
        at: self cursorSelectPoint;
        createUndoRedoForNewWidgets: newWidgets
            oldWidgets: #()
            named: (newWidgets size == 1
                ifTrue: ['Add New Widget']
                ifFalse: ['Add New Widgets']);
        selections: newWidgets";
        redraw".

    self isLeftButton ifTrue: [self loadedWidgets: nil].! !

!WindowBuilder methods !  
menuFileNewDialog

    self confirmSaveChanges
        ifTrue: [
            self inENVY ifFalse: [WBDialogScratchWindow resetToDefault].
            self editClass: WBDialogScratchWindow].! !

!ButtonEditor methods !  
openOn: file
    file isString ifTrue: [
        fileName := file.
        self label: 'ButtonEditor [',file,']'.
        super openOn: (WBBitmapClass fromFile: file)
    ] ifFalse: [
        self label: 'ButtonEditor [Untitled]'.
        super openOn: file
    ]! !

!WBBitmapManagerWindow methods !
menuKeyFileInBitmapFile

	"Callback for the menu item titled 'New...'.
	 (Generated by WindowBuilder)"

	| newKey newBitmap path stream |
	path := FileDialog new
		title: 'File in bitmap...';
		addFilter: '*.bmp' description: 'Bitmap Files (*.bmp)';
		defFilter: '*.bmp';
		openFile: '*.bmp';
		file.
	path isNil ifTrue: [^self].
	stream := File pathNameReadOnly: path.
	[[newBitmap := WBBitmapClass fromFileStream: stream]
		on: Error
		do: [:exception | ^self menuErrorHandler: exception]]
		ensure: [stream close].
	newKey := Prompter prompt: 'Enter new key' default: (
		path fileNameLessPath fileName, (
			self poolManager == self poolManager class current
				ifTrue: ['Bitmap']
				ifFalse: ['SysBitmap'])).
	newKey isNil ifTrue: [^self].
	newKey := self checkNewKey: newKey.
	newKey isNil ifTrue: [^self].
	self menuKeyNew: (Array with: newKey => newBitmap).! !

!WBLookPolicyOS2 methods !
scrollBarArrowWidth

	^scrollBarArrowWidth ifNil: [
		scrollBarArrowWidth := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCxhscrollarrow" 25]
			ifFalse: [super scrollBarArrowWidth]]! !

!Bitmap methods !   
wbResizeButton: newExtent
    "Answer a new bitmap containing the contents of the receiver."

    | newBitmap srcBox dstBox |
    #addedByOSI.
    newBitmap := WBBitmapClass
        width: newExtent x
        height: newExtent y
        planes: self planes
        bitCount: self bitCount.
    newBitmap wbInitButton.
    srcBox := self wbButtonUpBox.
    dstBox := newBitmap wbButtonUpBox.
    srcBox extent < dstBox extent
        ifTrue: [
            dstBox :=
                (dstBox center leftAndUp: srcBox extent // 2)
                    extentFromLeftTop: srcBox extent]
        ifFalse: [
            srcBox :=
                (srcBox center leftAndUp: dstBox extent // 2)
                    extentFromLeftTop: dstBox extent].
    newBitmap pen
        copyBitmap: self from: srcBox to: dstBox.
    srcBox := self wbButtonDownBox.
    dstBox := newBitmap wbButtonDownBox.
    srcBox extent < dstBox extent
        ifTrue: [
            dstBox :=
                (dstBox center leftAndUp: srcBox extent // 2)
                    extentFromLeftTop: srcBox extent]
        ifFalse: [
            srcBox :=
                (srcBox center leftAndUp: dstBox extent // 2)
                    extentFromLeftTop: dstBox extent].
    newBitmap pen
        copyBitmap: self from: srcBox to: dstBox.
    ^newBitmap! !

!WBLookPolicy methods ! 
drawCloseButtonWith: aPen at: aRect

    ^self draw3DBoxWith: aPen at: aRect.! !

!WindowBuilder class methods !  
useInstVars
	"Answer true if the code generator is to reference instance variables."

	^self 
		propertyAt: #UseInstVars 
		ifAbsent: [true].! !

!PStaticBox class methods !  
styleFrom: style

	| symbolStyles frameStyle |
	frameStyle := style bitAnd: 15.
	symbolStyles := Dictionary new.
	symbolStyles
		at: SsWhiterect put: #whiteRect;
		at: SsWhiteframe put: #whiteFrame;
		at: SsBlackframe put: #blackFrame;
		at: SsBlackrect put: #blackRectangle;
		at: SsGrayrect put: #grayRectangle;
		at: SsGrayframe put: #grayFrame.
	^symbolStyles at: frameStyle ifAbsent: [#blackFrame].! !

!WBModelInstVar methods !   
okToGenerateMethod: methodName

    ^(self myClass methodDictionary
        at: methodName asSymbol
        ifAbsent: [^true]) references: self generatedSymbol.! !

!WBInterfaceObject methods !   
isDestroyed

	^self parent isNil! !

!PCompositePane methods !
displayWith: aPen clipRect: inRect
	| region aRect clipRect |
	aRect := self rect.
	aPen fill: self rect color: self backColor.
	self style == #scrollbars
		ifTrue: [
			self lookPolicy
				displayWithRightBottomScrollBars: aPen
				rect: aRect
				backColor: self backColor.
			aRect := self rect insetBy: 1.
			aRect := Rectangle
				leftTop: aRect leftTop
				extent: ((aRect extent x - self lookPolicy scrollBarWidth + 1) @ 
					(aRect extent y - self lookPolicy scrollBarHeight + 1)).
			aRect := aRect intersect: self rect]
	ifFalse: [
		self style == #verticalScrollBar
			ifTrue: [
				self lookPolicy
					displayWithRightScrollBar: aPen
					rect: aRect
					backColor: backColor.
				aRect := self rect insetBy: 1.
				aRect := Rectangle
					leftTop: aRect leftTop
					extent: ((aRect extent x - self scrollBarWidth + 1) @ (aRect extent y)).
				aRect := aRect intersect: self rect]
			ifFalse: [
				(self style == #borders or: [self style == #mdiToolBarBordered])
					ifTrue: [
						self lookPolicy
							displayWithBorder: aPen
							rect: aRect
							backColor: backColor.
						aRect := self rect insetBy: 1]]].
	self children do: [:child | child reframe: aRect].
	aRect := aRect intersect: inRect.
	self children reverseDo: [:child |
		(aRect intersects: child rect)
			ifTrue: [
				region := aPen setClipRect: (clipRect := aRect intersect: child rect).
				child resetPen: aPen.
				child displayWith: aPen clipRect: clipRect.
				aPen destroyRegion: region]].! !

!WindowBuilder methods !
updateMenuView

	(self menuTitled: 'View') updateEnabled.! !

!WBTreeNode methods !   
initialize

    children := OrderedCollection new.
	self setListString: ''.
    currentString := ''.! !

!String methods !  
asLowerCaseFirstCaps
		"Answer the receiver with the first capitals converted to lower case."
	| index |
	#addedByOSI.
	self isEmpty ifTrue: [ ^self ].
	index := 2.
	[ index <= self size
		and: [ (self at: index) isUpperCase ]
			] whileTrue: [ index := index + 1].
	^(self copyFrom: 1 to: index - 1) asLowerCase,
		(self copyFrom: index to: self size)! !

!PButton methods !   
defaultSize

    ^self suggestedSize! !

!WBPrototype methods !   
windows: aCollection

	windows := aCollection! !

!WindowBuilder class methods !  
updateForMDI

	self
		addToolbarTool;
		addWindowBuilderMenuHelpItems.! !

!ClassHierarchyBrowser methods ! 
isWBClassBrowser
        "Private - WBPro Development."
    #addedByOSI.
    ^true! !

!Bitmap methods ! 
wbResize: newExtent
    "Answer a new bitmap containing the contents of the receiver."

    | newBitmap srcBox dstBox |
    #addedByOSI.
    newBitmap := WBBitmapClass
        width: newExtent x
        height: newExtent y
        planes: self planes
        bitCount: self bitCount.
    srcBox := self boundingBox.
    dstBox := newBitmap boundingBox.
    srcBox extent < dstBox extent
        ifTrue: [
            dstBox :=
                (dstBox center leftAndUp: srcBox extent // 2)
                    extentFromLeftTop: srcBox extent]
        ifFalse: [
            srcBox :=
                (srcBox center leftAndUp: dstBox extent // 2)
                    extentFromLeftTop: dstBox extent].
    newBitmap pen
        copyBitmap: self from: srcBox to: dstBox.
    ^newBitmap! !

!WBTabOrderLayoutForm methods !  
useGrid

	^false! !

!WBLookPolicy methods !  
drawRadioButton: aRadioButton with: aPen clipRect: clipRect

    | aPoint |
    self
        drawToggle: aRadioButton
        with: aPen
        clipRect: clipRect.
    aPoint := aRadioButton rect left @ (aRadioButton rect center y up: self iconExtent y // 2).
    aPen foreColor: Color black.
    OperatingSystem isOS2
        ifTrue: [aPen place: (aPoint rightAndDown: 6); down; circle: 6]
        ifFalse: [aPen ellipse: (aPoint extentFromLeftTop: 12@12)]! !

!WBEventManagerWindow methods !   
warningClasses

	^self class warningClasses! !

!WBLookPolicy class methods ! 
isDefault

    ^false! !

!WBScrapbookRetrieve methods !  
loadPages: aPane

    aPane contents: self pages.
    (self paneNamed: 'ok') disable.
    page := nil.! !

!WBEventManagerWindow methods !  
sendFieldUpdate

	sendField update.
	self methodTextUpdate.
	self zap.! !

!WBEventManagerWindow methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| addButton mainView removeButton saveButton xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	eventListBox := MultipleSelectListBox new.
	handlerListBox := MultipleSelectListBox new.
	methodTextEdit := SmalltalkToolInterface current textPaneClass new.
	sendField := WBComboBox new.
	sendLabel := StaticText new.
	toField := WBComboBox new.
	toLabel := StaticText new.
	widgetFilterBox := WBComboBox new.
	widgetListBox := MultipleSelectListBox new.
	
		"Temporary Variables"
	addButton := Button new.
	removeButton := Button new.
	saveButton := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Event Manager';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -150 * xDU;
				topRatio: 1/2; topInset: -109 * yDU;
				rightRatio: 1/2; rightInset: -150 * xDU;
				bottomRatio: 1/2; bottomInset: -91 * yDU).
	self addView: mainView.
	
	widgetFilterBox "WBComboBox"
		owner: self;
		setName: 'widgetFilterBox';
		when: #changed: send: #widgetListUpdate to: self;
		when: #needsContents send: #widgetFilterNeedsContents: to: self withArgument: widgetFilterBox;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 11/37; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -14 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView
		addSubpane: widgetFilterBox;
		subPaneWithFocus: widgetFilterBox.
	
	widgetListBox "MultipleSelectListBox"
		owner: self;
		setName: 'widgetListBox';
		when: #changed: send: #eventListUpdate to: self;
		when: #drawItem: send: #widgetListDrawItem:pane: to: self withArgument: widgetListBox;
		when: #needsContents send: #widgetListBoxNeedsContents: to: self withArgument: widgetListBox;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 16 * yDU;
				rightRatio: 11/37; rightInset: 0 * xDU;
				bottomRatio: 1/2; bottomInset: 19/4 * yDU);
		extendedSelect;
		startGroup;
		font: SysFont.
	mainView addSubpane: widgetListBox.
	
	eventListBox "MultipleSelectListBox"
		owner: self;
		setName: 'eventListBox';
		when: #changed: send: #handlerListUpdate to: self;
		when: #doubleClicked: send: #eventListDoubleClick: to: self;
		when: #drawItem: send: #eventListDrawItem:pane: to: self withArgument: eventListBox;
		when: #needsContents send: #eventListBoxNeedsContents: to: self withArgument: eventListBox;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 45/148; leftInset: 0 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 81/148; rightInset: 0 * xDU;
				bottomRatio: 1/2; bottomInset: 19/4 * yDU);
		extendedSelect;
		startGroup;
		font: SysFont.
	mainView addSubpane: eventListBox.
	
	handlerListBox "MultipleSelectListBox"
		owner: self;
		setName: 'handlerListBox';
		when: #changed: send: #toFieldUpdate to: self;
		when: #dragSourceNeedsObject: send: #handlerListDrag:pane: to: self withArgument: handlerListBox;
		when: #drawItem: send: #handlerListBoxDrawItem:pane: to: self withArgument: handlerListBox;
		when: #needsContents send: #handlerListBoxNeedsContents: to: self withArgument: handlerListBox;
		dragSource: true;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 41/74; leftInset: 0 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1/2; bottomInset: 131/4 * yDU);
		extendedSelect;
		startGroup;
		font: SysFont.
	mainView addSubpane: handlerListBox.
	
	toField "WBComboBox"
		owner: self;
		setName: 'toField';
		when: #changed: send: #toFieldChanged:pane: to: self withArgument: toField;
		when: #changed: send: #sendFieldUpdate to: self;
		when: #needsContents send: #toFieldNeedsContents: to: self withArgument: toField;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 40 * xDU;
				topRatio: 1/2; topInset: -123/4 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1/2; bottomInset: 75/4 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: toField.
	
	sendField "WBComboBox"
		owner: self;
		setName: 'sendField';
		when: #changed: send: #methodTextUpdate to: self;
		when: #changed: send: #sendFieldTextChanged:pane: to: self withArgument: sendField;
		when: #needsContents send: #sendFieldNeedsContents: to: self withArgument: sendField;
		when: #textChanged: send: #sendFieldTextChanged:pane: to: self withArgument: sendField;
		when: #textChanged: send: #methodTextUpdate to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 40 * xDU;
				topRatio: 1/2; topInset: -67/4 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1/2; bottomInset: 19/4 * yDU);
		dropDown;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: sendField.
	
	addButton "Button"
		owner: self;
		setName: 'addButton';
		when: #clicked send: #menuHandlerAdd to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -42 * xDU;
				topRatio: 1; topInset: -107/2 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1; bottomInset: 75/2 * yDU);
		contents: 'Add';
		startGroup;
		font: SysFont.
	mainView addSubpane: addButton.
	
	removeButton "Button"
		owner: self;
		setName: 'removeButton';
		when: #clicked send: #menuHandlerRemove to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -42 * xDU;
				topRatio: 1; topInset: -71/2 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1; bottomInset: 39/2 * yDU);
		contents: 'Remove';
		startGroup;
		font: SysFont.
	mainView addSubpane: removeButton.
	
	saveButton "Button"
		owner: self;
		setName: 'saveButton';
		when: #clicked send: #menuMethodSave to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -42 * xDU;
				topRatio: 1; topInset: -35/2 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1; bottomInset: 3/2 * yDU);
		contents: 'Save';
		startGroup;
		font: SysFont.
	mainView addSubpane: saveButton.
	
	toLabel "StaticText"
		owner: self;
		setName: 'toLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 81/148; leftInset: 0 * xDU;
				topRatio: 1/2; topInset: -115/4 * yDU;
				rightRatio: 1/2; rightInset: -38 * xDU;
				bottomRatio: 1/2; bottomInset: 83/4 * yDU);
		rightJustified;
		contents: 'To:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: toLabel.
	
	sendLabel "StaticText"
		owner: self;
		setName: 'sendLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 81/148; leftInset: 0 * xDU;
				topRatio: 1/2; topInset: -59/4 * yDU;
				rightRatio: 1/2; rightInset: -38 * xDU;
				bottomRatio: 1/2; bottomInset: 27/4 * yDU);
		rightJustified;
		contents: 'Send:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sendLabel.
	
	methodTextEdit "TextPaneControl"
		owner: self;
		setName: 'methodTextEdit';
		when: #needsContents send: #methodTextNeedsContents: to: self withArgument: methodTextEdit;
		when: #saved send: #methodTextSaved: to: self withArgument: methodTextEdit;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 1/2; topInset: -11/4 * yDU;
				rightRatio: 1; rightInset: 44 * xDU;
				bottomRatio: 1; bottomInset: 3/2 * yDU);
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: methodTextEdit.
	
	self createMenus: mainView! !

!WBGeometryManager methods !
owner

    ^owner! !

!WBCallOutEditor methods !  
owner

    ^owner! !

!WBPrimaryModelInitializeModule methods !   
okToGenerate

    ^(self object primaryModel class methodDictionary
        at: self defaultMessageSelector
        ifAbsent: [^true]) references: self generatedSymbol.! !

!WBPowerViewAddInModule class methods !
modifyProperties: theProperties
	"Modify the properties"

	self wbEditorClass 
		propertyAt: #OpenMethodType put: #createViewsFor:owner:;
		propertyAt: #ViewManagerCodeModule put: WBCreatePowerViewsModule.! !

!WBCodeGenerator methods !   
createMethodsError: aCodeModule

	MessageBox message:
		'The method #', aCodeModule messageSelector,
		' is too large to be compiled by the Visual Smalltalk compiler.  ',
		' Please split the window definition into smaller pieces via using the Call Out Editor or CompositePanes.'.! !

!WBPoolEditorCompositePane methods !  
selectedKeyAndPool

	^self owner selectedKeyAndPool! !

!PVideoPane methods ! 
usesForeColor

    ^false! !

!WBLookPolicyWin95 methods !
titleJustification

    ^self class default leftJustification! !

!WindowFrameObject methods !
usesTitle

    ^self hasTitleBar! !

!WBListEntryField methods !  
owningListBox: aListBox

    owningListBox := aListBox.
    aListBox owningEditBox: self.! !

!WBLookPolicy methods !
scrollBarArrowWidth

    ^self class default scrollBarArrowWidth! !

!WBPMenuItem methods !   
link: aString

    (aString isNil or: [ aString isEmpty ]) ifTrue: [ ^nil ].
    selector isMessage ifFalse: [
        selector := (Message new)
                            receiver: (Smalltalk at: aString asSymbol);
                            selector: nil;
                            arguments: #();
                            yourself
    ] ifTrue: [
        selector receiver: (Smalltalk at: aString asSymbol)
    ]! !

!PListBox methods !   
winUserStyle

	style == #defaultStyle
		ifFalse: [
			style == #ownerDrawFixed
				ifTrue: [^LbsOwnerdrawfixed]
				ifFalse: [^LbsOwnerdrawvariable]].
	^0! !

!WBPoolEditorCompositePane methods !  
atleastOneKeyAndCategorySelected

	^self selectedKeysAndPools notEmpty
		& self selectedCategories notEmpty! !

!WBLookPolicyWin31 methods ! 
scrollBarWidth

    ^scrollBarWidth ifNil: [
        scrollBarWidth := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxvscroll" 2]
            ifFalse: [super scrollBarWidth]]! !

!PEntryField methods !
defaultSize

    ^140 @ self suggestedSize y! !

!LayoutFrame methods !   
wbTopProportional: aBoolean
	"Set true if the receiver is top proportional (inset = 0)."

	self propertyAt: #wbTopProportional put: aBoolean.
	^aBoolean! !

!PTextEdit class methods ! 
styleFrom: style

	^(style bitIsOn: WsBorder)
		ifFalse: [#noBorders]
		ifTrue: [
			(style bitIsOn: WsHscroll)
				ifTrue: [#scrollBars]
				ifFalse: [
					(style bitIsOn: WsVscroll)
						ifTrue: [#wordWrap]
						ifFalse: [#noScrollBars]]].! !

!WBLayoutForm methods !  
currentDragSession: aPartsDragDropSession
		"Store the drag drop session."
	#osiHack.
	"Needed to support drag/drop to parts workbench."! !

!WindowBuilder methods !
menuFileLayoutWizard

    self invoke: WBLayoutWizard! !

!WBAttributeWindow methods !
prototype
		"Answer the prototype being edited."
	^self owner prototype! !

!WBModelObjectEditor methods !
add

    | newObject |
    newObject := ((WBListChooser
        fromList: (EventManager allSubclasses reject: [:cls | cls isWBInternalClass])
        prompt: 'Select Model Object') ifNil: [^self]) new.
    self owner prototype modelObjects add: newObject.
    self updateObjectList.
    self owner setDirty.

! !

!WBPoolManagerWindow methods !  
categoryPathChanged: aString pane: aPane

    "Callback for the #textChanged: event triggered in the EntryField named 'categoryPathField'.
     (Generated by WindowBuilder)"

	self categoryPath: aString.! !

!PRadioButtonGroup methods !   
reframe: parentRect

	super reframe: parentRect.
	self addSubpanes.! !

!PEntryFieldGroup methods !  
label

	^label ifNil: [label := 'EntryFieldGroup']! !

!WBLayoutCodeModule methods !  
layoutTemporaries
	"Private - Answer the variable names."

	^#(#xDU #yDU)! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCodeStream methods !   
backupOver: previousObject

    self backup: 1.! !

!Bitmap methods ! 
fromSysID: id
        "Private - WBPro Development."
    ^self fromModule: nil id: id! !

!PropertyAccessor methods ! 
wbStoreAction

	#addedByOSI.
	^self propertyTable at: #wbStoreAction ifAbsent: [self wbDefaultStoreAction]! !

!WBChooseClassDialog methods !
openNonWBView

    |className wbCreatedClasses |
    wbCreatedClasses := ViewManager wbCreatedClasses.
    className := WBListChooser fromList: ((
        (Notifier isAltKeyDown ifFalse: [
            (ViewManager allSubclasses select: [ :c |
            (c canUnderstand: #open) and: [
            ((wbCreatedClasses includes: c) not) and: [
            c isWBInternalClass not ]]])
        ] ifTrue: [
            "Hold down ALT key to get access to WindowBuilder windows"
            (ViewManager allSubclasses select: [ :c | c isWBInternalClass ])
        ])
        collect: [ :class |
            class name
        ])) asSortedCollection asOrderedCollection prompt: 'Which ViewManager?'.
    className isNil ifTrue: [ ^self ].
    result := Smalltalk at: className asSymbol.
    self close.! !

!PToggle methods ! 
iconExtent

    ^13@13! !

!WBInterfaceObject methods !   
mutateTo: aClassName
	"Mutate a pane into another type"

	| class mutation size |
	(class := Smalltalk at: aClassName asSymbol ifAbsent: [nil]) notNil
		ifTrue: [
			(mutation := class wbPseudoClass new)
				initialize;
				isInstVar: self isInstVar;
				realClass: class;
				wbRealWidget: (self wbRealWidget wbMutateToInstanceOf: class).
			(mutation styles notNil and: [mutation styles includes: self style])
				ifTrue: [mutation style: self style]
				ifFalse: [mutation style: mutation defaultStyle].
			mutation usesMenu & self usesMenu
				ifTrue: [
					mutation menu: (self menu notNil
						ifTrue: [self menu fullCopy]
						ifFalse: [nil])].
			mutation usesColor & self usesColor
				ifTrue: [
					(self foreColor = self defaultForeColor)
						ifFalse: [mutation foreColor: self foreColor]
						ifTrue: [mutation foreColor: mutation defaultForeColor].
					(self realBackColor = self defaultBackColor)
						ifFalse: [mutation backColor: self realBackColor]
						ifTrue: [mutation backColor: mutation defaultBackColor]].
			mutation usesFont & self usesFont
				ifTrue: [mutation font: self font].
			mutation usesTitle & self usesTitle
				ifTrue: [
					self contents isNil
						ifTrue: [mutation text: '']
						ifFalse: [
							self text = self defaultRealClassName
								ifTrue: [mutation text: mutation defaultRealClassName]
								ifFalse: [mutation text: self text]]].
			mutation
				parent: self parent;
				paneName: self paneName;
				framingBlock: self framingBlock;
				tabPosition: self tabPosition;
				rect: self rect deepCopy;
				lastRect: self lastRect deepCopy.
			(mutation changesSize and: [(size := mutation suggestedSize) notNil])
				ifTrue: [mutation rect: (mutation rect extent: size)].
			self mutationRotationList isEmpty
				ifFalse: [
					(self mutationRotationList includes: aClassName asSymbol)
						ifTrue: [mutation rect: (mutation rect extent: mutation rect extent transpose)]].
			mutation mutateSpecificsFrom: self.
			^mutation]
	ifFalse: [^nil].! !

!WBLookPolicyWin31 methods !
draw3DBoxWith: aPen at: aRect

    aPen drawRectangle: aRect.
    ^self
        draw3DBoxWith: aPen
        at: (aRect insetBy: 1)
        color: Color darkGray! !

!WBMenu methods !
appendSubMenu: aMenu
        "Append a submenu aMenu to the receiver menu."
    | mi |
    mi := self menuItemClass new.
    mi
        position: nil;
        style: MfPopup + MfString;
        attribute: 0;
        id: 0;
        label: aMenu title;
        selector: nil;
        submenu: aMenu;
        menu: self.
    items add: mi.
    accel add: nil.! !

!WBCreateClassDialog methods !   
inXoteryX

    ^self wbEditorClass xoteryxIsInstalled! !

!WBMenu methods !   
menuItemClass

	^WBMenuItem! !

!WBEnhancedEntryFieldEditor methods ! 
ok

    | function |
    thePane case: (self caseDict at: (self paneNamed: 'case') selectedItem).
    thePane justification: (self justificationDict at: (self paneNamed: 'justification') selectedItem).
    thePane getFocus: (self getFocusDict at: (self paneNamed: 'getFocus') selectedItem).

    thePane maximumSize: (self paneNamed: 'size') contents asInteger.
    thePane autoTab: (self paneNamed: 'autoTab') selection.

    function := (self paneNamed: 'character') selectedItem.
    function = self noneString ifTrue: [
        thePane character: nil
    ] ifFalse: [
        thePane character: ('ok',function,':') asSymbol
    ].

    function := (self paneNamed: 'field') selectedItem.
    function = self noneString ifTrue: [
        thePane field: nil
    ] ifFalse: [
        thePane field: ('ok',function) asSymbol
    ].

    self close! !

!WBLayoutFrameEditor methods !  
attachAll

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: #(0 0 1 1).! !

!Font methods ! 
wbFontDescription
	"Answer a one line description of the receiver."

	| stream |
	(stream := WriteStream on: (String new: 20))
		nextPutAll: self faceName;
		nextPut: $ ;
		nextPutAll: self pointSize printString.
	self bold | self italic | self strikeOut | self underscore | self fixedWidth ifTrue: [
		stream nextPut: $ .
		self bold ifTrue: [stream nextPut: $B].
		self italic ifTrue: [stream nextPut: $I].
		self strikeOut ifTrue: [stream nextPut: $S].
		self underscore ifTrue: [stream nextPut: $U].
		self fixedWidth ifTrue: [stream nextPut: $F]].
	^stream contents! !

!WindowBuilder methods !  
initializePalettesMapDefault
    "Answer a mapping of names to bitmap names
     for those bitmaps not named in a standard fashion."

    ^Dictionary
        new at: '3D Button' put: 'WB3DButtonSysBitmap';
        at: 'WBStaticGraphic' put: 'StaticGraphicSysBitmap';
        at: 'CUA ''91' put: 'Cua91SysBitmap';
        at: 'OLEControlPart' put: 'OLEControlSitePaneSysBitmap';
        yourself! !

!WBMenuEditor methods ! 
allowAttributesFor: anItem

    ^anItem hasChildren not & anItem isSeparator not! !

!WBTreeListBox methods ! 
virtualKeyInput: aChar

    (Notifier isKeyDown: VkControl) ifTrue: [
        aChar = VkUp ifTrue: [     self shiftSelectionUp. ^nil ].
        aChar = VkDown ifTrue: [  self shiftSelectionDown.  ^nil ].
        aChar = VkLeft ifTrue: [     self exdentSelection.  ^nil ].
        aChar = VkRight ifTrue: [   self indentSelection.  ^nil ].
        aChar = VkBack ifTrue: [ self deleteSelection. ^nil ].
    ] ifFalse: [
        aChar = VkUp ifTrue: [ self moveSelectionUp. ^nil ].
        aChar = VkDown ifTrue: [ self moveSelectionDown. ^nil ].
    ].! !

!WindowBuilder class methods !   
newWindowBuilder

	self wbEditorClass preOpen.
	self wbEditorClass new open.! !

!WBTabOrderLayoutForm methods ! 
checkHideHandles

	^false! !

!WBMultiToolPalette methods !   
elementAt: key on: name
    ^(self pageNamed: name) at: key ifAbsent: [ nil ]! !

!WBEnhancedEntryFieldEditor methods !
supportsJustification

    ^true! !

!WBPoolManagerWindow methods !   
categoryListDraw: aKey value: aString pane: aPane

	self listDraw: aKey value: aString pane: aPane.! !

!WBLookPolicyWin95 methods !  
scrollBarThumbHeight

    ^scrollBarThumbHeight ifNil: [
        scrollBarThumbHeight := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCyvthumb" 9]
            ifFalse: [super scrollBarThumbHeight]]! !

!WBGraphicObject methods ! 
isWindows95

    ^OperatingSystem isWindows95! !

!WBEventManagerWindow methods ! 
toFieldUpdate

	toField update.
	self sendFieldUpdate.
	self zap.! !

!PColumnListBox methods ! 
storeSpecificsOn: aStream indentString: aString
    "Do Nothing"! !

!WBFramingEditor methods !
xCenteredToggled: isCentered

    isCentered
        ifTrue:
            [originXStyleFixed selection: true.
            originXStyleScaled selection: false.
            cornerXStyleFixed selection: true.
            cornerXStyleScaled selection: false.
            originXAnchor selection: 'Window left'.
            cornerXAnchor selection: 'Window left'.
            originXStyleFixed disable.
            originXStyleScaled disable.
            cornerXStyleFixed disable.
            cornerXStyleScaled disable.
            originXAnchor disable.
            cornerXAnchor disable.
            leftRelative disable.
            rightRelative disable.
            ]
        ifFalse:
            [originXStyleFixed enable.
            originXStyleScaled enable.
            cornerXStyleFixed enable.
            cornerXStyleScaled enable.
            originXAnchor enable.
            cornerXAnchor enable.
            leftRelative enable.
            rightRelative enable.
            ].
    self setExampleRects.! !

!WBBitmapManagerWindow methods !  
menuBitmapPasteIntoButton

	| aBitmap selectedBitmap |
	selectedBitmap := self selectedValue ifNil: [^self].
	(aBitmap := Clipboard getBitmap) isBitmap
		ifTrue: [
			selectedBitmap wbInitButton: aBitmap.
			self updateEditor]
		ifFalse: [
			MessageBox message:
				'The clipboard does not contain a bitmap'].! !

!PToggle methods ! 
mutationExceptions

    ^#(#Toggle #CPHorizontalPictureButton)! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBRGBColorDialog methods !   
elements: elementDict defaults: defaultDict paneEdited: aPane

    elements := elementDict.
    defaults := defaultDict.
    thePane := aPane.
    self open.
    ^result! !

!WBBitmapManagerWindow methods !
menuBitmapFileOutBitmapFile

	| aBitmap |
	(aBitmap := self selectedValue) isBitmap ifFalse: [^self].
	self menuBitmapFileOutBitmapFile: aBitmap key: self selectedKey.! !

!WBTreeNode methods !   
listString

    (self isRoot) ifTrue: [
        ^'ROOT'
    ] ifFalse: [
        ^currentString
    ].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPoolManagerWindow methods !
selectedCategories
	"Answer the selected categories."

	^categoryListBox selectedItems! !

!WBEditClassDialog class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBInterfaceObject methods ! 
getSysColor: aColorIndex

    ^Color getSystemColor: aColorIndex! !

!WindowBuilder class methods !   
dragOutlines

    ^self editorClass
        propertyValueAt: #DragOutlines
        category: self editorPropertyString! !

!WBScrollingPane methods !   
gettingFocus

    self firstChild setFocus.! !

!WBHandle methods !   
displayBox

	^self origin extentFromLeftTop: self extent! !

!WBGeometryManager methods ! 
collectForward
    "Collect the selected widgets forward in the z-order"

    self collectForward: self selections.
    self owner updateOutboardZOrderChange: self selections! !

!WBPoolManagerWindow methods !   
selectedCategoriesChanged
	"The selected categories have changed."

	self
		redrawKeys;
		updateCategoryPath;
		updateEditor.! !

!WBLookPolicyWin95 methods !
drawMaximizeButtonDisabledWith: aPen at: aRect

    | innerRect |
    innerRect := self
        drawTitleBarBoxWith: aPen
        at: aRect.
    aPen
        foreColor: Color white;
        drawRectangle: (innerRect insetBy: (3@3 extent: -2@-3));
        foreColor: Color darkGray;
        drawRectangle: (innerRect insetBy: (2 @ (2 + Rectangle leftTopUnit y) extent: 0 @ (-1 - (Rectangle leftTopUnit y))));
        wbLineFrom: (innerRect leftTop rightAndDown: 2@(1-Rectangle leftTopUnit y)) 
			to: (innerRect rightTop leftAndDown: (2 + Rectangle leftTopUnit y) @(1 - Rectangle leftTopUnit y)).! !

!PTextEdit methods !
backColor

    ^backColor.! !

!WBCallOutEditor methods ! 
initializeCallOutMap

    callOutMap := IdentityDictionary new.
    self shellChildren do: [:child |
        callOutMap
            at: child
            put: (child creationMethodSelector isNil
                ifTrue: [nil] ifFalse: [child creationMethodSelector asString])].! !

!WBCodeStream methods ! 
nextPutPropertyIgnoreDefault: aWBProperty style: aBoolean for: anObject
	"Store the property in the receiver."

	| setAction poolName poolKey |
	(setAction := aBoolean
		ifTrue: [aWBProperty wbAddStyleAction]
		ifFalse: [aWBProperty wbRemoveStyleAction]) ifNil: [^self].
	(setAction isArray
		ifTrue: [setAction]
		ifFalse: [Array with: setAction])
			do: [:each |
				each last = $:
					ifTrue: [
						poolName := aWBProperty wbPoolName ifNil: [^self].
						poolKey := aWBProperty wbPoolKey ifNil: [^self].
						self
							cr;
							nextPutAll: each;
							space;
							nextPutPoolKey: poolKey in: poolName;
							endMessage]
					ifFalse: [
						self
							cr;
							nextPutAll: each;
							endMessage]].! !

!Object methods !  
wbHalt
	"Halt if developing window builder."

	(Smalltalk at: #OSITool ifAbsent: [nil]) notNil ifTrue: [self halt].! !

!WBTreeListBox methods ! 
validate
        "Private - The host window for the receiver was
         just created or recreated... create the graphicsTool."
    super validate.
    graphicsTool isNil ifTrue: [ graphicsTool := self getGraphicsTool ].! !

!PActionButton methods !  
action: aString

    action := aString! !

!Object methods !  
wbManagedValue
	"Answer the value being managed."

	^self! !

!WBBitmapManager class methods !   
loadStandardWBBitmaps
	"Load the standard window builder user bitmaps."

	"
	WBBitmapManager loadStandardWBBitmaps.
	"

	self current load: self wbEditorClass userBitmapFileName.! !

!WBFontSelectionWindow methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| applyButton cancelButton fontList mainView managerButton 
	okButton poolLabel poolList selectFontButton xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	sampleGroupBox := GroupBox new.
	sampleTextEdit := TextEdit new.
	
		"Temporary Variables"
	applyButton := Button new.
	cancelButton := Button new.
	fontList := ListBox new.
	managerButton := Button new.
	okButton := Button new.
	poolLabel := StaticText new.
	poolList := WBComboBox new.
	selectFontButton := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Font';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -120 * xDU;
				topRatio: 1/2; topInset: -199/2 * yDU;
				rightRatio: 1/2; rightInset: -120 * xDU;
				bottomRatio: 1/2; bottomInset: -181/2 * yDU).
	self addView: mainView.
	
	fontList "ListBox"
		owner: self;
		setName: 'fontList';
		when: #changed: send: #fontSelected:pane: to: self withArgument: fontList;
		when: #drawItem: send: #fontDrawItem:pane: to: self withArgument: fontList;
		when: #needsContents send: #fontNeedsContents: to: self withArgument: fontList;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 87 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: fontList;
		subPaneWithFocus: fontList.
	
	poolList "WBComboBox"
		owner: self;
		setName: 'poolList';
		addClipsiblingsStyle;
		when: #changed: send: #poolSelected:pane: to: self withArgument: poolList;
		when: #needsContents send: #poolNeedsContents: to: self withArgument: poolList;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 87/2 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 1; rightInset: 9/2 * xDU;
				bottomRatio: 0; bottomInset: -62 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: poolList.
	
	managerButton "Button"
		owner: self;
		setName: 'managerButton';
		when: #clicked send: #openFontManager to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 9/2 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 0; rightInset: -101/2 * xDU;
				bottomRatio: 1; bottomInset: 4 * yDU);
		contents: 'Manager...';
		startGroup;
		font: SysFont.
	mainView addSubpane: managerButton.
	
	selectFontButton "Button"
		owner: self;
		setName: 'selectFontButton';
		when: #clicked send: #selectFont to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 54 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 0; rightInset: -88 * xDU;
				bottomRatio: 1; bottomInset: 4 * yDU);
		contents: 'Select...';
		startGroup;
		font: SysFont.
	mainView addSubpane: selectFontButton.
	
	applyButton "Button"
		owner: self;
		setName: 'applyButton';
		when: #clicked send: #apply to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -114 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 1; rightInset: 80 * xDU;
				bottomRatio: 1; bottomInset: 4 * yDU);
		contents: 'Apply';
		startGroup;
		font: SysFont.
	mainView addSubpane: applyButton.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -76 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 1; rightInset: 42 * xDU;
				bottomRatio: 1; bottomInset: 4 * yDU);
		defaultPushButton;
		contents: 'OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: okButton.
	
	cancelButton "Button"
		owner: self;
		setName: 'cancelButton';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -38 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 4 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancelButton.
	
	poolLabel "StaticText"
		owner: self;
		setName: 'poolLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 7 * yDU;
				rightRatio: 0; rightInset: -40 * xDU;
				bottomRatio: 0; bottomInset: -15 * yDU);
		rightJustified;
		contents: 'Font Pool';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: poolLabel.
	
	sampleTextEdit "TextEdit"
		owner: self;
		setName: 'sampleTextEdit';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 10 * xDU;
				topRatio: 1; topInset: -71 * yDU;
				rightRatio: 1; rightInset: 12 * xDU;
				bottomRatio: 1; bottomInset: 33 * yDU);
		removeHorizontalScrollbarStyle;
		removeVerticalScrollbarStyle;
		addBorderStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sampleTextEdit.
	
	sampleGroupBox "GroupBox"
		owner: self;
		setName: 'sampleGroupBox';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 1; topInset: -83 * yDU;
				rightRatio: 1; rightInset: 6 * xDU;
				bottomRatio: 1; bottomInset: 27 * yDU);
		contents: 'Sample';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sampleGroupBox! !

!WBGeometryManager class methods !   
on: aWindowBuilder

    ^self new owner: aWindowBuilder! !

!WBLayoutWizard methods ! 
down

    | selectedItem index |
    selectedItem := attributesList selectedItem.
    index := attributesList contents indexOf: selectedItem.
    attributesList contents
        remove: selectedItem;
        add: selectedItem afterIndex: index.
    attributesList
        contents: attributesList contents;
        selectItem: selectedItem.
    self updateUpDownButtons.! !

!WBBitmapSubPool methods !
convertBitmapsFromModuleToImage
		"Convert all bitmaps that are loaded from a module (resource DLL)
			to bitmaps that are stored in the image."
		"
		To convert ALL window builder bitmaps, evaluate
			WBBitmapManager convertBitmapsFromModuleToImage.

		To convert the window builder SYSTEM bitmaps, evaluate
			WBBitmapManager system convertBitmapsFromModuleToImage.

		To convert the window builder USER bitmaps, evaluate
			WBBitmapManager current convertBitmapsFromModuleToImage.
		"

	| newBitmap |
	self do: [:eachBitmap |
		eachBitmap archive isArray ifTrue: [
			newBitmap := eachBitmap cpCopy.
			eachBitmap release.
			eachBitmap wbBecome: newBitmap]].! !

!PRadioButtonGroup methods !  
text

    ^self label! !

!WBStandardCodePolicy methods ! 
basicCreateClassFor: aWBClassDefinition
		"Define and answer a new class.
		Answer nil if one could not be created."
	^aWBClassDefinition superclass
		subclass: aWBClassDefinition className asSymbol
		instanceVariableNames: aWBClassDefinition instVarNamesString
		classVariableNames: aWBClassDefinition classVarNamesString
		poolDictionaries: aWBClassDefinition poolNamesString.! !

!WBAddInManager methods ! 
updateProperties

	self wbEditorClass
		initializePrivateProperties;
		initializePropertiesAddIns.! !

!WBPrototype methods !   
modelObjects

    ^self targetObject modelObjects! !

!PStatusPane methods !  
colorButtonFace

    ^Color buttonFace! !

!WBNLSDictionaryReader class methods ! 
fileOutCategoryBeginOn: aStream
	"File out a token/value pair inside a comment."

	^self
		fileOutToken: 'STRINGTABLE' on: aStream;
		fileOutToken: 'BEGIN' on: aStream! !

!PMultipleSelectListBox class methods !
styleFrom: style

	(style bitIsOn: LbsExtendedsel)
		ifTrue: [^#extendedSelect].
	(style bitIsOn: LbsOwnerdrawfixed)
		ifTrue: [^#ownerDrawFixed].
	(style bitIsOn: LbsOwnerdrawvariable)
		ifTrue: [^#ownerDrawVariable].
	^#defaultStyle! !

!PButton methods !   
contents

    ^super contents ifNil: ['']! !

!WBLayoutForm methods ! 
bandRect
    "Answer the value of bandRect."

    ^bandRect! !

!WBModelObjectEditor methods !   
nameChanged: aString

    | selectedObject badName newName |
    selectedObject := self selectedObject.
    selectedObject isNil ifTrue: [^nil].
    (newName := name contents) = selectedObject paneName
        ifTrue: [^self].
    "The names are changing so..."
    selectedObject isInstVar
        ifTrue: [self setIsInstVar: false].
    self setIsValidInstVar: newName.
    newName hasContent
        ifTrue: [
            newName do: [:c |
                c isAlphaNumeric
                    ifFalse: [badName := true]].
            ((self wbEditorClass instVarNameCheck ifNil: [false]) and: [newName first isUpperCase | (badName = true)])
                ifTrue: [
                    MessageBox messageNote: '''' , newName , ''' is an invalid name.'.
                    name contents: '']
                ifFalse: [
                    selectedObject setName: newName.
                    self wbEditorClass partsSupportIsInstalled
                        ifTrue: [
                            self prototype wbPartEvents updatePaneNames: self prototype windows.
                            self prototype wbPartMessages updatePaneNames: self prototype windows]]]
        ifFalse: [
            selectedObject setName: nil.
            self wbEditorClass partsSupportIsInstalled
                ifTrue: [
                    self prototype wbPartEvents updatePaneNames: self prototype windows.
                    self prototype wbPartMessages updatePaneNames: self prototype windows]].
    self updateObjectList.
    self owner setDirty.! !

!WBTreeListBox methods ! 
setSelectionText: newText

    self basicSelectionText: newText.
    self setEditBox.! !

!PRadioButtonGroup methods !   
addSubpanes
    | extent numRows index rb fontHeight inset inner |
    fontHeight := SysFont height + 6.
    self children: nil.
    self children add:
        (PGroupBox new
            parent: self;
            realClass: GroupBox;
                framingBlock: (
                    LayoutFrame new
                        leftRatio: 0; leftInset: 0;
                        topRatio: 0; topInset: 0;
                        rightRatio: 1; rightInset: 0;
                        bottomRatio: 1; bottomInset: 0);
            paneName: 'group';
            font: self font;
            contents: self label;
            backColor: self backColor;
            yourself).
    inset := 8 @ fontHeight.
    inner := self rect extent - inset.
    numRows := ((self contents size +  self numColumns - 1) // self numColumns) max: 1.
    extent := (inner x // numColumns) @ fontHeight.
    1 to: self numColumns do: [:column |
        1 to: numRows do: [:row |
            index := (column - 1) * numRows + row.
            index > self contents size
                ifFalse: [
                    self children add:
                       (rb := self buttonPClass new
                            parent: self;
                            realClass: self buttonClass;
                            framingBlock: (
                                LayoutFrame new
                                    leftRatio: ((column - 1) / self numColumns) * 0.9 + (((self numColumns - column + 1) / self numColumns) * 0.1); leftInset: 0;
                                    topRatio: 0; topInset: (inset y + ((row - 1) * extent y));
                                    rightRatio: (column / self numColumns) * 0.9 + (((self numColumns - column) / self numColumns) * 0.1); rightInset: 0;
                                    bottomRatio: 0; bottomInset: (inset y + (row * extent y)) negated);
                            font: self font;
                            contents: (self contents at: index);
                            paneName: (self contents at: index);
                            backColor: self backColor;
                            yourself)]]].
    self foreColor: self foreColor.
    self backColor: self realBackColor.! !

!WBPoolManagerWindow methods !  
menuCategoryFileOut

    "Callback for the menu item titled 'File out...'.
     (Generated by WindowBuilder)"

	| path |
	self selectedPools isEmpty ifTrue: [^self].
	path := self promptForNewFileName: 'File out categories...'.
	path isNil ifTrue: [^self].
	[self menuCategoryFileOut: path]
		on: Error
		do: [:exception | ^self menuErrorHandler: exception].! !

!WBInterfaceObject methods !  
mutationTypes

    ^#()! !

!WBTabOrderEditor methods !   
layoutFormClass

	^WBTabOrderLayoutForm! !

!WBMenuEditor methods !   
testMenu

    testItButton setPopupMenu:  nil.
    testItButton doPopupMenuAt: testItButton cursorWindowPosition! !

!WBVersionCodeModule methods !  
targetClass
		"Answer the receiver's target class."
	^super targetClass isMetaClass
		ifTrue: [super targetClass]
		ifFalse: [super targetClass class]! !

!WBDialogScratchWindow methods ! 
perform: selector
    "Scratch windows should not perform any events"
    ^MessageBox messageNote: 'Scratch windows cannot do anything. You must first create a new view manager class with the "Save As..." command in order to add behavior.'! !

!WBLookPolicyOS2 methods !
centerJustification

    ^"DtCenter" 256! !

!WBLookPolicyOS2 methods !   
displayWithRightBottomScrollBars: aPen rect: aRect backColor: aColor

    | innerRect newInnerRect backColor |
    backColor := (self class isDefault not
        and: [(self asRGBColor: aColor) = (self asRGBColor: Color white)])
        ifTrue: [self defaultWidgetBackColor]
        ifFalse: [aColor].
    innerRect := self displayWithBorder: aPen rect: aRect backColor: backColor.
    newInnerRect := innerRect leftTop
        rightBottom: (innerRect rightBottom leftAndUp: (self scrollBarWidth @ self scrollBarHeight)).
    self
        drawVScrollBarWith: aPen
        at: (newInnerRect rightTop
            rightBottom: (innerRect rightBottom rightAndUp: 1 @ (self scrollBarHeight - 1)));
        drawHScrollBarWith: aPen
        at: (newInnerRect leftBottom
            rightBottom: (innerRect rightBottom leftAndDown: self scrollBarWidth - 1 @ 1)).
    aPen
        fill: ((newInnerRect rightBottom rightAndDown: 1) rightBottom: innerRect rightBottom)
        color: Color gray.
    ^newInnerRect! !

!WBModelObjectEditor methods !   
setIsValidInstVar: aString
    "Determine if aString is a valid inst var name, and enable/disable the i-var check box."

    instVar perform:
        ((self editedClass wbGenerateInstVars
            and: [(self editedClass wbReservedInstVarNames includes: aString) not
            and: [aString = aString asInstVarToken]])
            ifTrue: [#enable]
            ifFalse: [#disable]).! !

!WBTreeListBox methods !
commitSelection

    noSelect ifTrue: [
        noSelect := false.
        ^true
    ].

    ^self triggerEvent: #preSelect: with: self previousSelection! !

!WBCodeGenerator methods ! 
forceUpdate: aBoolean

    self propertyAt: #forceUpdate put: aBoolean! !

!WBUndoManager methods !   
undo: aCount

    | newRedo |
    self deferRedraw:
        [self setInUndo.
        1 to: aCount do: [:i |
            current == 0
                ifFalse: [
                    (newRedo := undoList at: current) undo.
                    current := current - 1]].
        newRedo isNil
            ifFalse: [
                current == 0
                    ifTrue: [self setCantUndo]
                    ifFalse: [self setUndoLabel: self undoString, ' ', (undoList at: current) label].
                self
                    setRedoLabel: self redoString, ' ', newRedo label;
                    setRedoState: true].
        self resetInUndo]! !

!WBEntryListPrompter methods !
initWindow

	(Message receiver: self selector: #deferredInitWindow) performDeferred.! !

!WBBitmapPool methods !  
fileOutHeaderOn: aStream
	"File out the receiver's header."

	aStream
		nextPutAll: self managerClass tagPoolName;
		nextPut: $ ;
		nextPutAll: self poolName;
		cr.
	self fileName notEmpty ifTrue: [
		aStream
			nextPutAll: self managerClass tagFileName;
			nextPut: $ ;
			nextPutAll: self fileName;
			cr].! !

!WBPlaceHolderObject methods !
prototype

	^self owner prototype! !

!WindowBuilder methods !
outboards: aCollection

    outboards := aCollection! !

!PScrollBar class methods !  
defaultRealClassName

    ^'ScrollBar'! !

!WBLookPolicyOS2 methods ! 
displayWithBorder: aPen rect: aRect backColor: backColor

    | innerRect |
    aPen
        foreColor: Color darkGray;
        wbLineFrom: aRect topLeft to: (aRect topRight left: 1);
        wbLineFrom: aRect topLeft to: (aRect bottomLeft up: 1);
        wbLineFrom: (aRect topRight left: 1) to: (aRect bottomRight leftAndUp: 1);
        wbLineFrom: (aRect bottomLeft up: 1) to: (aRect bottomRight leftAndUp: 1);
        rgbColorMode;
        fill: (innerRect := aRect insetBy: 1) color: backColor;
        resetColorMode.
    ^innerRect! !

!WBCodeModule methods !  
varNameFor: anObject
        "Answer the variable name (temporary variable or instance variable)
            for the specified object."
    ^self varNameFor: anObject ifAbsent: [
        self error: 'no var name for ', anObject printString ].! !

!WindowBuilder methods ! 
close: ignore
    "Detect that Smalltalk is shutting down. Prevent our
     Save Changes query from coming up at shutdown. "

    #osiHack.
    "This method should not be needed anymore...but it is!!"
    self obsoleteMethod.
    Transcript isNil ifTrue: [^nil].
    self confirmSaveChanges ifFalse: [^self].
    self mainView parent isNil
        ifFalse: [
            self mainView parent isMDIClient
                ifFalse: [self mainView parent mainView bringToTop]].
     self stopTimer.
    ^nil! !

!PStatusPane methods !
updateBoxesLeftJustifiedFixed

	| xPos aRect |
	xPos := rect left.
	self statusBoxes do: [:box |
		xPos := xPos right: box space.
		aRect := Rectangle leftTop: xPos @ rect top rightBottom: (xPos + box width + 6) @ (rect bottom down: 2).
		aRect := aRect insetBy: (0 @ self inset).
		box rectangle: aRect.
		xPos := xPos right: box width + 6].
	^xPos! !

!WBPMenuItem methods !  
link

    (selector isNil or: [ (selector isMessage) not or: [ selector receiver isNil ]]) ifTrue: [
        ^nil
    ] ifFalse: [
        selector receiver isWBAction ifTrue: [
            ^nil
        ] ifFalse: [
            ^selector receiver asString
        ].
    ]! !

!WBUndoManager methods ! 
bindToOwner

    self owner isNil
        ifTrue: [
            undoMenu := redoMenu := nil]
        ifFalse: [
            undoMenu := redoMenu := self owner menuTitled: 'Edit'.
            self setCantUndo; setCantRedo].
    undoList := OrderedCollection new: self class maxUndoLevels + 1.
    current := 0.! !

!WBDevelopmentDialog methods !   
openWindow

	self mainView children do: [:each |
		each font: SysFont].
	self mainView backColor: Color gray.
	^super openWindow! !

!WBListEditor methods !   
change

	listBox selection isNil ifTrue: [^nil].
	list at: listBox selection put: item contents.
	listBox 
		contents: list;
		selectItem: item contents.
	item selectAll; setFocus.
	self enable! !

!WBGraphicObject methods !
origin

	^rect leftTop! !

!WBTreeNode methods !  
nlsPools

    ^(self owner ifNil: [^Set new]) nlsPools! !

!WBPoolManagerWindow methods ! 
menuCategoryRename

    "Callback for the menu item titled 'Rename...'.
     (Generated by WindowBuilder)"

	| newCategoryName aCategory |
	aCategory := self selectedCategoryOrPrompt: 'Rename which category?'.
	aCategory isNil ifTrue: [^self].
	newCategoryName := WBEntryListPrompter
		prompt: 'Rename ', aCategory, ' to'
		title: 'Rename category...'
		list: self suggestedCategories
		default: aCategory.
	newCategoryName isNil ifTrue: [^self].
	newCategoryName = aCategory ifTrue: [^self].
	newCategoryName := self checkNewCategory: newCategoryName.
	newCategoryName isNil ifTrue: [^self].
	[self menuCategoryRename: aCategory to: newCategoryName]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].! !

!WindowBuilder class methods !  
minWindowSize

    ^16 @ 16! !

!WBLayoutForm methods !   
updateRect: aRect

    | clipRect region |
    self pen isNil ifTrue: [^self].
    (aRect intersects: self shell frameContentRect)
        ifFalse: [^self]
        ifTrue: [clipRect := (aRect expandBy: self handleSize // 2) intersect: self shell frameContentRect].
    region := self pen setClipRect: clipRect.
    self pen fill: clipRect color: self shell backColor.
    self model drawGrid ifTrue: [self drawGrid: self pen rect: clipRect].
    self pen destroyRegion: region.
    self children reverseDo: [:widget |
        (widget hitRect intersects: clipRect)
            ifTrue: [self displayWidget: widget clipRect: clipRect]].
    self showHandles.! !

!WBSubPool methods !  
fileOutFooterOn: aStream
	"File out the receiver's footer."! !

!WBPoolManagerWindow methods ! 
categoryPopupMenu

	^categoryListBox popupMenu! !

!WBFramingEditor methods ! 
ok

    result := currentRectList
        collect:
            [:rect |
            framingParameters initialExtent: rect extent.
            self newFramerForRect: rect parentRect: parentRect.
            ].
    self close! !

!WBEditClassDialog methods !
xoteryxPackageChoices

    ^(Smalltalk at: #XoPackage) names! !

!PropertyAccessor methods !  
wbMutateValue: aValue for: anObject
	"Mutate the property's value."

	#addedByOSI.
	^self setValue: aValue for: anObject! !

!WBCodeStream methods !
wrapDuring: aBlock
        "Set the maximum number of characters per line during aBlock."
    ^self
        maxLineSize: (self maxLineSize ifNil: [self defaultMaxLineSize])
        during: aBlock! !

!WBAbstractPrompter methods !   
title: aString

	self mainView labelWithoutPrefix: aString.! !

!Object methods ! 
wbRealWidget

	^self! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBInterfaceObject methods !
changesSize

    ^false! !

!PEnhancedEntryField methods !
field: aSymbol

    field := aSymbol! !

!WBGraphicObject methods !   
suggestedSize

    ^nil! !

!FrameObject methods !
prototype

	^self editor prototype! !

!WindowBuilder methods !   
invoke: aClass using: aWidgetOrCollectionOfWidgets

    | existing |
    (existing := outboards detect: [:window |
        window class == aClass]
        ifNone: [nil]) isNil
        ifTrue: [
            aClass new
                openOn: aWidgetOrCollectionOfWidgets
                owner: self]
        ifFalse: [existing activate].! !

!WBAbstractAddInModule class methods !   
insertMenu: anArray in: menus after: menuNameString

	| target oc aString |
	aString := menuNameString replaceEscapeCharacters stripMnemonic.
	oc := anArray asOrderedCollectionRecursively.
	target := menus detect: [:m | 	(m at: 1) stripMnemonic = aString] 	ifNone: [nil].
	target isNil ifFalse: [^menus add: oc after: target].
	menus do: [:menu |
		(menu at: 3) do: [:mi |
			mi isSymbol
				ifFalse: [
					(mi at: 1) stripMnemonic = aString
						ifTrue: [^(menu at: 3) add: oc after: mi].
					(mi at: 3) isString
						ifFalse: [
							(mi at: 3) do: [:msi |
								msi isSymbol
									ifFalse: [
										(msi at: 1) stripMnemonic = aString
											ifTrue: [^(mi at: 3) add: oc after: msi]]]]]]]! !

!WBAbstractPrompter class methods ! 
isWBInternalClass

    ^true! !

!WBTextEditWindow methods !  
openOn: aString
        "Open the receiver with aString as its initial contents."
    | tp |
    file := aString.
    self addSubpane:
        ((tp := TextPane new)
            owner: self;
            font: TextFont;
            when: #needsContents send: #stringContents: to: self withArgument: tp;
            framingBlock: [ :box | box]).
    self openWindow.
    partial := false.! !

!WBUndoManager methods !   
redoString

    ^'\uRedo'! !

!WBPrototype methods !  
wbPartEvents
		"Answer the part event list for the receiver."
	^(self propertyAt: #WBPartEvents) ifNil: [super wbPartEvents]! !

!WBAbstractPrompter methods !
result

	^result! !

!WBPoolManagerWindow methods !   
updateKey: oldKey to: newKey pool: aPool
	"Update the list of keys."

	self updateKeys.
	updateKeys := updateKeys collect: [:each |
		(each key = oldKey and: [each value == aPool])
			ifTrue: [newKey => aPool]
			ifFalse: [each]].! !

!WBBitmapManagerWindow methods !  
uniqueFilesNamesFor: aCollection
	"Answer a mapping of keys to unqiue file names."

	| answer allFileNames fileName index base eachKey |
	answer := Dictionary new.
	allFileNames := Set new.
	aCollection do: [:eachKeyAndPool |
		eachKey := eachKeyAndPool key.
		fileName := eachKey.
		(fileName beginsWith: 'WB') ifTrue: [fileName := fileName copyFrom: 3 to: fileName size].
		(fileName beginsWith: 'CP') ifTrue: [fileName := fileName copyFrom: 3 to: fileName size].
		(fileName endsWith: 'SysBitmap') ifTrue: [fileName := fileName copyFrom: 1 to: fileName size - 9].
		(fileName endsWith: 'Bitmap') ifTrue: [fileName := fileName copyFrom: 1 to: fileName size - 6].
		fileName isEmpty ifTrue: [fileName := 'BMP'].
		fileName := fileName asLowercase.
		fileName := File safeFileName: fileName.
		index := 0.
		base := fileName copyFrom: 1 to: (fileName size min: 5).
		[allFileNames includes: fileName] whileTrue: [
			index := index + 1.
			fileName := base, (index printPaddedWith: $0 to: 3 base: 10)].
		allFileNames add: fileName.
		answer at: eachKey put: fileName].
	^answer! !

!WBDescriptor methods !   
name: aString
    "Set the value of name."

    name := aString! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PTextEdit methods !   
importantEvents

    ^super importantEvents
        addFirst: #textChanged:;
        yourself! !

!PEnhancedEntryField methods !
defaultWizardEvent

    ^#objectChanged:! !

!WBLayoutForm methods !  
selections: aCollection
    "Set the value of selections."

    self hideHandles.
    selections := aCollection.
    selections isEmpty
        ifTrue: [self clearHandles]
        ifFalse: [
            self handles: (OrderedCollection new: selections size * 4).
            selections do: [:aWidget | self addHandlesFor: aWidget].
            self showHandles].

    self notifyModelOfSelectionChange! !

!WBMethodStubModule methods ! 
indentSuccessiveCommentLines

	^true! !

!WBEventHandlerStubModule methods !  
defaultEventDescription
	"Private - Answer the default event description."

	^self source class wbPropertyManager
		wbEventNamed: self event! !

!WindowBuilder class methods ! 
register: extraName menu: anArray after: aString

	| slot |
	slot := self extras at: extraName ifAbsent: [OrderedCollection new].
	slot add:
		(Message new
			receiver: self wbEditorClass
			selector: #insertMenu:after:
			arguments: (Array with: anArray with: aString)).
	self extras at: extraName put: slot.! !

!WBENVYCodePolicy methods !  
removeScratchSelectorsFor: aWBClassDefinition
		"Don't do this in ENVY."! !

!WBLayoutForm methods !   
useLeftButton

	self propertyAt: #buttonUsed put: #left! !

!PEnhancedEntryField methods !
initializeForDataType: aClass

    (aClass inheritsFrom: Integer)
        ifTrue: [^self character: #okInteger:; justification: #right].
    (aClass inheritsFrom: Number)
        ifTrue: [^self character: #okNumeric:; justification: #right].
    (aClass inheritsFrom: Boolean)
        ifTrue: [^self character: #okBoolean:].
    (aClass inheritsFrom: Date)
        ifTrue: [^self field: #okDate].! !

!WBTargetObject methods ! 
wbInstVarMap: aDictionary

	instVarMap notNil ifTrue: [
		invalidInstVars copy associationsDo: [:each |
			(aDictionary at: each key ifAbsent: [nil]) == each value
				ifTrue: [invalidInstVars remove: each]].
		instVarMap associationsDo: [:each |
			((aDictionary at: each key ifAbsent: [nil]) ~~ each value
				and: [each value isWBInstVarObject])
					ifTrue: [invalidInstVars add: each]]].
	instVarMap := aDictionary.! !

!WBEventManagerWindow methods !  
sendFieldTextChanged: aString pane: aPane

	"Callback for the #textChanged: event triggered in the WBComboBox named 'sendField'.
	 (Generated by WindowBuilder)"

	| newString oldSelection aHandler |
	(RecursiveSet includes: self) ifTrue: [^self].
	newString := aString wbValidTriggeredSelectorFor: (self eventSelected ifNil: [^self]).
	RecursiveSet add: self.
	newString = aString ifFalse: [
		oldSelection := aPane entryField selection.
		aPane text: newString.
		aPane entryField
			selectFrom: (oldSelection x min: newString size + 1)
			to: (oldSelection y min: newString size)].
	(aHandler := self handlerSelected) notNil
		ifTrue: [
			newString notEmpty
				ifTrue: [
					aHandler changeSelector: newString.
					handlerListBox redraw]
				ifFalse: [
					aHandler remove.
					handlerListBox
						contents: (handlerListBox contents copyWithout: aHandler);
						selection: #( ).
					eventListBox update.
					widgetListBox redraw]]
		ifFalse: [
			newString notEmpty
				ifTrue: [
					self mustHaveOneActionListSelected ifTrue: [
						(aHandler := WBEventMessage new)
							source: self widgetSelected;
							event: self eventSelected;
							receiver: self toFieldSelection;
							selector: newString;
							add.
						handlerListBox
							contents: (handlerListBox contents copyWith: aHandler);
							selection: (Array with: aHandler).
						eventListBox update.
						widgetListBox redraw]]].
	self owner setDirty.
	RecursiveSet remove: self ifAbsent: [ ].! !

!WBPMenuItem methods !   
isSeparator

    ^isDivider! !

!WBCodeGenerator class methods !  
defaultPolicy
	"Answer the default code policy."

	^WBCodePolicy currentClass! !

!WindowBuilder methods !   
textEditor

	^titleEditor! !

!WBCodeStream methods ! 
nextPutProperty: aWBProperty eventTable: anEventTable for: anObject
	"Store the property in the receiver."

	self nextPutEventTable: anEventTable for: anObject.! !

!Bitmap methods !   
wbOutputToFile: aFileName
        "Private - WB Development.
			Output the receiver in DIB format to aFileName.
			Work around digitalks problem not being able to output
			bitmaps loaded from a resource DLL."
    #addedByOSI.
	self archive isArray
		ifTrue: [
			self cpCopy
				outputToFile: aFileName;
				release ]
		ifFalse: [
			self
				outputToFile: aFileName ].! !

!String methods !   
asMessage
        "Private - WBPro Development."
    | array semiArray result |
    self isEmpty ifTrue:[ ^nil ].
    #addedByOSI.
    array := self asArrayOfSubstrings.
    semiArray := array select: [ :s |
        (s last == $: and:
        [ s size > 1 and:
        [(s at: s size - 1) ~= $$ ]])].
    semiArray size > 0
        ifTrue: [
            result := ''.
            semiArray do: [ :s | result := result, s trimBlanks ]]
        ifFalse: [
            result := (ReadStream on: array first) nextWord.
            result isNil ifTrue: [ result := array first ].
            (result first isUpperCase and: [ array size > 1 ])
                ifTrue: [ result := (ReadStream on: (array at: 2)) nextWord ]].
    ^result asSymbol! !

!WBAbstractCodeModule methods !   
constructMessageSelector: aSymbol index: anInteger
        "Answer the view message selector."
    | answer index |
    answer := aSymbol.
    index := answer indexOf: $: ifAbsent: [ answer size + 1 ].
    ^(    (answer copyFrom: 1 to: index - 1),
            anInteger printString,
            (answer copyFrom: index to: answer size)
        ) asSymbol! !

!WBTemplateEditor methods !  
attributePalette

	^attributePalette! !

!WBLookPolicy methods !  
drawUpArrowWith: aPen at: aRect

    | innerRect side |
    innerRect := self draw3DBoxWith: aPen at: aRect.
    side := (innerRect width min: innerRect height) // 7.
    aPen
        polygonFilled: (Array
            with: (innerRect center up: side + 1)
            with: (innerRect center rightAndDown: (side * 2 + 1) @ side)
            with: (innerRect center leftAndDown: (side * 2 + 1) @ side)).! !

!WBAbstractCodeModule methods ! 
filterEventTable: anEventTable for: anObject
	"Answer the event table for anObject."

	^anEventTable! !

!WBModelDefinitionEditor methods !  
updateUpDownButtons

    | selectedItem localAttributes |
    selectedItem := attributes selectedItem.
    localAttributes := self localInstVars.
    (selectedItem isNil
        or: [localAttributes isEmpty
        or: [(localAttributes includes: selectedItem) not]])
        ifTrue: [
            (self paneNamed: 'upButton') disable.
            (self paneNamed: 'downButton') disable]
        ifFalse: [
            selectedItem == localAttributes first
                ifTrue: [(self paneNamed: 'upButton') disable]
                ifFalse: [(self paneNamed: 'upButton') enable].
            selectedItem == localAttributes last
                ifTrue: [(self paneNamed: 'downButton') disable]
                ifFalse: [(self paneNamed: 'downButton') enable]].
! !

!WindowBuilder class methods !  
constructEventsTriggered
	"Private - answer the set of events that instances of the
	  receiver can trigger."

	^super constructEventsTriggered 
		addAll: #(#aboutToClose #closed #aboutToOpen: #aboutToChange);
		yourself! !

!WBScrollingPane methods !   
hasChildren

    ^ children notNil and: [ children size > 0 ]! !

!WBEventHandlerStubModule methods ! 
event: aString

	event := aString.! !

!WBPrimaryModelOpenOnModule methods !  
okToGenerate

    ^(self object primaryModel class methodDictionary
        at: self defaultMessageSelector
        ifAbsent: [^true]) references: self generatedSymbol.! !

!WBStatusPaneEditor methods !  
ok

    thePane statusBoxes: boxes.

    self close! !

!PButton methods !  
mutationExceptions

    ^#(#Toggle #CPHorizontalPictureButton)! !

!WBCreatePowerViewModule methods ! 
defaultTargetName
		"Answer the default target name."
	^'wbTarget'! !

!WBLayoutWizard methods !  
setModelInitializesWidget: aBoolean

    attributesList selectedItem object
        propertyAt: #modelInitializesWidget
        put: aBoolean! !

!ButtonEditor methods !   
offset
    "OS/2 Version"
    ^(imageForm width // 2)+2
        @ (2 * Rectangle topBottomUnit)! !

!WBTabOrderLayoutForm methods !  
drawOrderSymbols
    "Draw the tab order symbols"

    ^self drawTabOrderSymbolsFor: self children! !

!WBTeamVCodePolicy methods !  
annotationManager
		"Answer the annotation manager."
	^self class annotationManager! !

!BitEditor methods !  
editMenu: aPane
    aPane setMenu: (
        (Menu
            labels: 'Clear\Fill' withCrs
            lines: #()
            selectors: #(#clear #fill))
            owner: self;
            title: '&Edit';
            yourself)! !

!WBCreateClassDialog methods !
initialize

    limitTo := 'Window'.
    cache := IdentityDictionary new.
    super initialize.! !

!WBModelInstVar methods !   
propertyAt: key put: aValue
        "Set the value associated with key
        in the properties dictionary."
    properties isNil ifTrue: [properties := IdentityDictionary new].
    aValue isNil ifTrue: [^properties removeKey: key ifAbsent: [nil]].
    ^properties at: key put: aValue! !

!Object class methods !  
wbCreatedClasses
         "Private - WBPro Development."
    #addedByOSI.
    ^self allSubclasses select: [:aClass |
        aClass wbCreated].! !

!WBMenuItem methods !   
isDisabled

	^(self attribute bitAnd: MfGrayed) ~= 0! !

!WBResizeBitmap methods !
isResizeAll

	^isResizeAll! !

!PColumnListBox methods !  
contents: aCollectionOfIntegers

    ^self wbRealWidget columnWidths:
        ((aCollectionOfIntegers ifNil: [#( )]) collect: [:width |
            width asNumber asInteger]) asArray! !

!WBToolBarEditor methods !   
selectBitmap: selectedItem

    | element selector index newSelector |

    index := list selection.
    index isNil ifTrue: [ ^nil ].
    element := elements at: index.
    element bitmapSelector: selectedItem key.
    element bitmapSelector isNil ifTrue: [ ^nil ].
    element bitmap: selectedItem value.
    element boundingBox: nil.

    newSelector := self selectorFromBitmapName: element bitmapSelector.
    selector := self paneNamed: 'selector'.
    selector setContents: newSelector.
    element selector: newSelector.

    list redraw.
! !

!WBToolBarEditor methods ! 
highlightItem: drawIndex pane: aPane

    | element |

    element := elements at: drawIndex.
    aPane pen 
		reverse: 
			(Rectangle
				leftTop: (aPane drawBox leftTop + ((element rectangle width + 4) @ 0))
				rightBottom: aPane drawBox rightBottom)! !

!WBFontSelectionWindow methods ! 
selectedPool: aPool
	"Set the currently selected pool."

	selectedPool := aPool.! !

!WBMenuEditor methods ! 
insertItem

    menuItemsEditor insertAfterSelection.
    self fillInCurrentItem.! !

!WindowFrameObject methods !   
storeOn: aStream indentString: indentString

	aStream cr;
		nextPutAll: indentString, 'labelWithoutPrefix: ';
		nextPutStringConstant: self contents;
		nextPut: $;; cr;
		nextPutAll: indentString, 'noSmalltalkMenuBar'.
	self storeColorOn: aStream indentString: indentString.
	self iconFile notNil
		ifTrue: [
			aStream nextPutAll: ';'; cr;
				nextPutAll:  indentString, 'iconFile: ';
				nextPutStringConstant: self iconFile].
	"aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'pStyle: #', self  style asArray asString."
	aStream endMessage.
	framingBlock isNil
		ifTrue: [
			framingBlock := LayoutFrame new.
	"
			framingBlock := FramingParameters new.
			rect origin = (0@0)
				ifTrue: [framingBlock xC; yC]
				ifFalse: [framingBlock left: rect left relativeTo: #left; top: rect top relativeTo: #top].
	"	].
	self storeRectOn: aStream indentString: indentString.

	#osiHack.
	"Rework this createdBy stuff?"
	"self createdBy isNil ifTrue: [
		aStream nextPutAll: ';'; cr; nextPutAll:  indentString, 'createdBy: ',
			((Smalltalk at: #WindowBuilderUser ifAbsent: ['']), ', ',
			(Smalltalk at: #WindowBuilderCompany ifAbsent: ['']), ' - ',
			Date today asString,' ',Time now asString) asQuotedString
	] ifFalse: [
		aStream nextPutAll: ';'; cr; nextPutAll:  indentString, 'createdBy: ', self createdBy asQuotedString.
		aStream nextPutAll: ';'; cr; nextPutAll:  indentString, 'modifiedBy: ',
			((Smalltalk at: #WindowBuilderUser ifAbsent: ['']), ', ',
			(Smalltalk at: #WindowBuilderCompany ifAbsent: ['']), ' - ',
			Date today asString,' ',Time now asString) asQuotedString
	]."! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PGroupbox methods !
staysWayBack

    ^true! !

!WindowBuilder methods !  
setStatus: aString

	(status statusBoxAt: #status) contents: aString! !

!PListBox methods !  
importantEvents

    ^super importantEvents
        addFirst: #doubleClicked:;
        addFirst: #clicked:;
        yourself! !

!WBPMenuItem methods !
accelKey

    keyAccel isNil ifTrue: [ ^nil ].

    ^keyAccel accelKey! !

!WBLayoutFrameEditor methods !   
applyChange
	"Perform the action."

	| widgets newFramingBlocks oldFramingBlocks shellFrameContentRect redo |
	widgets := self currentWidgets.
	oldFramingBlocks := widgets collect: [:each | each framingBlock].
	newFramingBlocks := self currentFramingBlocks collect: [:each | each wbCopy].
	shellFrameContentRect := self owner shellFrameContentRect.
	self owner layoutFormChanged.
	self owner undoManager
		add: 'Set Framing'
		undo: [
			widgets with: oldFramingBlocks do: [:eachWidget :eachFramingBlock |
				eachWidget
					framingBlock: eachFramingBlock;
					reframe: shellFrameContentRect]]
		redo: (redo := [
			widgets with: newFramingBlocks do: [:eachWidget :eachFramingBlock |
				eachWidget
					framingBlock: eachFramingBlock;
					reframe: shellFrameContentRect]]).
	redo evaluate.! !

!WBEventMessage methods !
asEventMessage

	^self! !

!WindowFrameObject methods !   
storeFramingBlockOn: aStream indentString: spaceString

	"DialogTopPane expects its framingBlock to return dialog units,
		whereas TopPane expects its framingBlock to return pixels.
		In addition, the framingBlock for the DialogTopPane must
		accept a rectangle expressed in *pixels* and answer a framing
		rectangle in *dialog units*.  This requires special code generation."

	self isDialog
		ifTrue: [
			self framingBlock asFramingBlockForDialogTopPaneFromWindow
				storeForDialogTopPaneOn: aStream indentString: spaceString]
		ifFalse: [
			super storeFramingBlockOn: aStream indentString: spaceString].! !

!WBGeometryManager methods ! 
useGrid

    ^self owner useGrid! !

!WBGeometryManager methods ! 
sizeByPixelDown
    "Size the selected widgets down one pixel"

    | selections |
    (selections := self selections copy) isEmpty
        ifTrue: [^self owner setWindowSize: (self shell width @ (self shell height + 1))].
    (self undoManager
        add: 'Size Pixel Down'
        undo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    configureWidget: aWidget x
                    y: aWidget y
                    width: aWidget width
                    height: (aWidget height - 1 max: 0)
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections]
        redo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    configureWidget: aWidget x
                    y: aWidget y
                    width: aWidget width
                    height: aWidget height + 1
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections])
        redoAction value.
    self updateWidget.! !

!WBToolBarEditor methods !  
updateButtons

    elements isEmpty ifTrue: [
        (self paneNamed: 'remove') disable.
        (self paneNamed: 'copy') disable.
        (self paneNamed: 'up') disable.
        (self paneNamed: 'down') disable.
        ^nil
    ] ifFalse: [
        (self paneNamed: 'remove') enable.
        (self paneNamed: 'copy') enable.
    ].
    list selection == elements size ifTrue: [
        (self paneNamed: 'down') disable
    ] ifFalse: [
        (self paneNamed: 'down') enable
    ].
    list selection == 1 ifTrue: [
        (self paneNamed: 'up') disable
    ] ifFalse: [
        (self paneNamed: 'up') enable
    ].! !

!WBLayoutFrameEditor methods !
openOnFramer: aFramingBlock rects: rects parentRect: parentRect owner: anOwner

	anOwner invoke: self class.! !

!WBLayoutFrameEditor methods !   
attachProportionalLeftBottomRight

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: (
		Array
			with: self proportional
			with: 1
			with: self proportional
			with: 1).! !

!WBDefaultDialogScratchWindow class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBResizeBitmap methods !
oldWidth: anInteger

	(self paneNamed: 'oldWidthField') contents: anInteger asString.! !

!WBClassDefinition methods !
addPoolNamed: aSymbol
		"Add to the receiver's poolNames."
	self poolNames add: aSymbol.
	nlsPools notNil ifTrue: [
		(self class nonNLSPoolNames includes: aSymbol) ifFalse: [
			nlsPools add: (Smalltalk at: aSymbol) ] ].! !

!Stream methods !
nextString: s
        "Private - WBPro Development."
    #addedByOSI.
    [ self atEnd ] whileFalse: [
        self nextWord = s ifTrue: [
            ^self
        ].
    ].
    ^nil! !

!WBInterfaceObject methods !
paneName: aString

	self wbRealWidget paneName: aString.! !

!WBTabOrderLayoutForm methods !  
groupPaneClass

	^PWBInvisibleGroupPane! !

!WBApplicationCoordinatorModule methods ! 
generateTemporaries: aCollectionOfTempNames
        "Private - Generate the temporary variables."
    aCollectionOfTempNames isNil ifTrue: [ ^self ].
    aCollectionOfTempNames isEmpty ifTrue: [ ^self ].
    self stream
       cr;
        nextPut: $| ;
        space.
    aCollectionOfTempNames asSortedCollection do: [ :eachTempName |
        self stream
            nextPutAll: eachTempName;
            space ].
    self stream nextPutNoWrap: $|.! !

!WBCreateBitmap class methods !   
defaultBitmapType

	^#width:height:! !

!WBDevelopmentWindow methods !
activateClassBrowserOnClass: aClass

    | chb |
    chb := Notifier windows values detect: [:window |
            window isApplicationWindow
                and: [window owner isWBClassBrowser
                and: [window owner selectedClass == aClass]]]
        ifNone: [nil].
    chb notNil
        ifTrue: [
            (chb := chb owner) activate.
            "Make sure the open method gets refreshed"
            (chb textModified)
                ifFalse: [
                    chb
                        changed: #selectors:
                            with: #restoreSelected:
                            with: chb selectedMethod;
                        changed: #text:].
            ^self].
    ^nil! !

!WBAbstractCodeModule methods ! 
generateCode
        "Generate the code..."
    ^self
        initCodeGeneration;
        generateMessagePattern;
        generateComment;
        generatePreCopyright;
        generateTemporaries;
        generateBody;
        generatePostCopyright.! !

!WBBitmapManagerWindow methods !
showDimensions
	"Answer true if the dimensions should be show in the key and category lists."

	^showDimensions ifNil: [false]! !

!WBMenuItemStub methods ! 
title: aString
		"Set the receiver's title."
	title := aString.! !

!WBAbstractCodeModule methods !   
messageArguments
		"Private - Answer the message selector arguments."
	^arguments ifNil: [ self defaultMessageArguments ]! !

!WBEventMessage methods !   
selector
	"Answer the message selector."

	^super selector ifNil: ['']! !

!WBLookPolicyWin31 methods !  
titleRectFrom: aFrameObject

    | aPoint titleRect leftIndent rightIndent |
    aPoint := aFrameObject frameLeftTop.
    titleRect := (aPoint extentFromLeftTop: aFrameObject extent) insetBy: (self borderWidthFrom: aFrameObject).
    titleRect := titleRect leftTop extentFromLeftTop: titleRect width @ (self titleBarHeightFrom: aFrameObject).
    leftIndent := rightIndent := 0.
    (aFrameObject style includes: #sysmenu)
        ifTrue: [leftIndent := self systemMenuWidth].
    (aFrameObject style includes: #maximize)
        ifTrue: [rightIndent := self maximizeButtonSize x].
    (aFrameObject style includes: #minimize)
        ifTrue: [rightIndent := rightIndent + self minimizeButtonSize x].
    ^(titleRect left right: leftIndent) @ titleRect top
        extentFromLeftTop: (titleRect width - rightIndent - leftIndent) @ titleRect height.! !

!WBEditClassDialog methods ! 
setWindowTitle

    self labelWithoutPrefix: (selectedClass isNil
        ifTrue: ['Edit Class']
        ifFalse: ['Edit Class: ', selectedClass name]).
    self updateOK.! !

!WindowBuilder class methods ! 
wbInitializeRegistry
	"Initialize the OSI Product registry"

	self osiProductRegistry
		register: 'WindowBuilder Pro'
		withName: #WindowBuilder
		version: self basicVersionNumberString.
	ServiceRegistry globalRegistry
		register: self
		withName: #WindowBuilderPro
		version: self basicVersionNumberString.! !

!PEntryFieldGroup methods !   
fieldPClass

    ^PEntryField! !

!BitEditor methods !
displayImage: aPane
    imagePen := aPane pen.
    copy displayAt: 0 @ 0
        with: imagePen! !

!WBLayoutForm methods !  
totalLength

	self shell isNil
		ifTrue: [^self margin * 2].
	^self shell margin * 2 + self shell frameExtent y! !

!WBPropertyEditor methods ! 
valueBooleanChanged: labelString

    | property newValue |
    newValue := labelString = 'True'.
    valueTrue selection: newValue.
    valueFalse selection: newValue not.
    (property := self selectedProperty) isNil ifTrue: [^nil].
    (changes at: property ifAbsent: [property value]) = newValue
        ifFalse: [
            changes at: property put: newValue.
            (self paneNamed: 'revertButton') enable.
            self updateItems].! !

!WBMenuEditor methods !   
popupNlsMenu: aPane

    | menu subMenu subMenus nlsPool nlsPools checkItem assoc array answer |

    (nlsPools := self nlsPools) isEmpty
        ifTrue: [^aPane setPopupMenu: nil].

    menu := Menu new
        owner: aPane;
        selector: #contents:;
        yourself.

    nlsPools size == 1
        ifTrue: [
            ((array := (nlsPool := Smalltalk at: nlsPools first) keys asSortedCollection asArray) 
				copyFrom: 1 to: (array size min: 24)) do: [:key |
                assoc := nlsPool associationAt: key.
                menu appendItem: ('#',assoc key, ' - ', assoc value printString) selector: ('#', assoc key) asSymbol].
			array size > 24
				ifTrue: [
					menu appendSeparator;
						appendItem: 'Other...' action:
							(Message receiver: [
								(answer := WBListChooser 
									fromList: (array collect: [:key |
										assoc := nlsPool associationAt: key.
										('#',assoc key, ' - ', assoc value printString)])
									prompt: 'Select NLS Key') isNil
									ifFalse: [aPane contents: (answer upTo: $ )]] selector: #value)]]
        ifFalse: [
            subMenus := OrderedCollection new: nlsPools size.
            nlsPools do: [:sym |
                menu appendSubMenu:
                    (subMenu := Menu new
                        title: sym;
                        owner: aPane;
                        selector: #contents:;
                        yourself).
                subMenus add: subMenu.
                ((array := (nlsPool := Smalltalk at: sym) keys asSortedCollection asArray) 
					copyFrom: 1 to: (array size min: 24)) do: [:key |
                    assoc := nlsPool associationAt: key.
                    subMenu appendItem: ('#',assoc key, ' - ', assoc value printString) selector: ('#', assoc key) asSymbol].
				array size > 24
					ifTrue: [
						subMenu appendSeparator;
							appendItem: 'Other...' action:
								(Message receiver: [
									(answer := WBListChooser 
										fromList: (array collect: [:key |
											assoc := nlsPool associationAt: key.
											('#',assoc key, ' - ', assoc value printString)])
										prompt: 'Select NLS Key') isNil
										ifFalse: [aPane contents: (answer upTo: $ )]] selector: #value)]]].
    checkItem := ((self nlsKeyFor: aPane contents) ifNil: ['']) asSymbol.
    subMenus isNil
        ifTrue: [menu checkItem: checkItem]
        ifFalse: [
            subMenus do: [:sub |
                sub checkItem: checkItem]].

    aPane setPopupMenu: menu.! !

!WBModelObjectEditor methods !   
popupEventTarget: anObject

    | targetObject |
    send setPopupMenu: nil.
    targetObject := anObject.
    targetObject == #window: ifTrue: [
        targetObject := WBEditClassDialog new open selectedClass ifNil: [^self]].
    targetObject == #global: ifTrue: [
        targetObject := WBListChooser promptForGlobal ifNil: [^self]].
    self selectedObject
        eventHandlerTargetAt: self currentEvent
        put: targetObject
        prototype: self prototype.! !

!WBPoolManagerWindow methods !   
selectedPool
	"Answer the selected pool if exactly one is selected,
		else answer nil."

	^self selectedPools size = 1
		ifTrue: [self selectedPools first]
		ifFalse: [nil]! !

!Font methods !  
wbFontLongDescription
	"Answer a one line description of the receiver."

	| stream |
	(stream := WriteStream on: (String new: 20))
		nextPutAll: self faceName;
		nextPut: $ ;
		nextPutAll: self pointSize printString.
	self bold ifTrue: [stream nextPutAll: ' Bold'].
	self italic ifTrue: [stream nextPutAll: ' Italic'].
	self strikeOut ifTrue: [stream nextPutAll: ' StrikeOut'].
	self underscore ifTrue: [stream nextPutAll: ' Underscore'].
	self fixedWidth ifTrue: [stream nextPutAll: ' FixedWidth'].
	^stream contents! !

!WindowBuilder class methods !   
maxUndoLevels

    ^self editorClass
        propertyValueAt: #MaxUndoLevels
        category: self editorPropertyString! !

!PButton methods ! 
copySpecificsTo: aPane

    aPane specialId: self specialId.! !

!FrameObject methods !   
isFrameObject

    ^true! !

!PStaticText methods !   
changesTitle

    ^true! !

!WBHandle methods !   
locator
        ^locator! !

!WBLayoutFrameEditor methods !
rightAttachmentFor: aCollection
	"Answer the right attachment for the specified framing blocks."

	| ratio |
	aCollection do: [:each |
		ratio notNil
			ifTrue: [
				each wbRightProportional
					ifTrue: [ratio = self proportional ifFalse: [^'']]
					ifFalse: [
						each wbRightAttachedToLeft
							ifTrue: [ratio = self paneLeft ifFalse: [^'']]
							ifFalse: [ratio = each rightRatio asRational ifFalse: [^'']]]]
			ifFalse: [
				each wbRightProportional
					ifTrue: [ratio := self proportional]
					ifFalse: [
						each wbRightAttachedToLeft
							ifTrue: [ratio := self paneLeft]
							ifFalse: [ratio := each rightRatio asRational]]]].
	ratio ifNil: [^''].
	ratio isString ifTrue: [^ratio].
	^self class horizontalRatioStrings at: ratio ifAbsent: [ratio printString]! !

!WBModelObjectEditor methods !
hasChildren

    ^self owner hasChildren! !

!WBLayoutForm methods !  
showShellHandles

    self shellHandles do: [:aHandle |
        aHandle displayOn: self pen color: Color blue].! !

!WBCreateViewsModule methods !   
generateCode
        "Generate the code..."
    self wbEditorClass runtimeLessCode
        ifTrue: [
            self addModule: (WBOpenMethodModule new
                targetClass: self targetClass;
                targetObject: self targetObject;
                object: self object;
                yourself)].
    self objectHasMultipleViews
        ifTrue: [super generateCode]
        ifFalse: [
            self
                generateView: self object windows first
                selector: self createMultipleViewsSelector
                index: nil].! !

!PComboBox methods !  
maxSize

    ^32000@32000! !

!WBCreateBitmap methods !   
bitmapHeight

	^heightField contents asInteger! !

!WindowBuilder methods !   
useGrid

    ^self class useGrid! !

!WindowBuilder methods ! 
instVarNameCheck

	^self class instVarNameCheck ifNil: [false].! !

!Bitmap methods ! 
wbCopy4

    "Added by OSI"

    | newBitmap |

    #addedByOSI.
	newBitmap := WBBitmapClass new
            screenWidth4: self width
            height: self height.
	self displayIn: newBitmap boundingBox with: newBitmap pen.

    ^newBitmap! !

!WBLookPolicy class methods !
current: aWBLookPolicy

    Current := aWBLookPolicy! !

!WBLayoutForm methods !  
updateRects: oldRect and: newRect

	(oldRect intersects: newRect)
		ifFalse: [
			self
				updateRect: oldRect;
				updateRect: newRect]
		ifTrue: [
			self updateRect: 
				((oldRect leftTop leftMostAndHighest: newRect leftTop) rightBottom: 
					(oldRect rightBottom rightMostAndLowest: newRect rightBottom))].! !

!WBBitmapManagerWindow methods ! 
menuBitmapPasteIntoButtonDown

	| aBitmap selectedBitmap |
	selectedBitmap := self selectedValue ifNil: [^self].
	(aBitmap := Clipboard getBitmap) isBitmap
		ifTrue: [
			selectedBitmap wbButtonDown: aBitmap.
			self updateEditor]
		ifFalse: [
			MessageBox message:
				'The clipboard does not contain a bitmap'].! !

!WBPoolManagerWindow methods ! 
selectedPools
	"Answer a collection of pools."

	^poolListBox selectedItems! !

!WBEditClassDialog methods ! 
cancel

    "Callback for the #clicked event triggered in the Button named 'cancel'.
     (Generated by WindowBuilder)"

    selectedClass := nil.
    self close! !

!WBKeyAccel class methods ! 
clearKeyConstants

    "     WBKeyAccel clearKeyConstants    "

    KeyConstantsDict := nil.! !

!WBLookPolicy methods !
defaultWidgetBackColor

    ^Color white! !

!WBResizeBitmap methods !
defaultButtonExtents

	^Array
		with: 50 @ 22
		with: 56 @ 28! !

!WBChooseClassDialog methods !
result

    ^result! !

!WBLayoutFrameEditor methods !
updateLabel

	self currentWidgets isEmpty
		ifTrue: [^self labelWithoutPrefix: 'Framing Editor'].
	self labelWithoutPrefix: 
		'Framing Editor - ', 
		(self currentWidgets size == 1
			ifTrue: [self currentWidgets first wbNameAndClass]
			ifFalse: ['Multiple Widgets'])! !

!WBGeometryManager methods !  
distributeHorizontally
    "Distribute the selected widgets horizontally"

    | first last start distance aWidget useGrid x gridX
    selections origins redoBlock |
    (selections := self selections copy) size > 2 ifFalse: [^self].
    (self isAltKeyDown and: [self isShiftKeyDown not])
        ifTrue: [selections := (selections asSortedCollection: [:a :b | a x <= b x]) asArray].
    first := selections first.
    last := selections last.
    origins := selections collect: [:widget | widget origin].
    distance := ((last x + (last width // 2)) - (start := first x + (first width // 2))) // (selections size - 1).
    useGrid := self useGrid.
    self undoManager
        add: 'Distribute Horizontal'
        undo:
            [self hideHandles: (self handles reject: [:handle |
                handle owner == first or: [handle owner == last]]).
            2 to: selections size - 1 do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (origins at: i) x
                    y: (origins at: i) y;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandles: (self handles reject: [:handle |
                handle owner == first or: [handle owner == last]]).
            useGrid ifTrue: [gridX := self gridSize x].
            2 to: selections size - 1 do: [:i |
                aWidget := selections at: i.
                x := start + (i - 1 * distance) - (aWidget width // 2).
                useGrid ifTrue: [x := x roundTo: gridX].
                aWidget
                    moveWidget: x
                    y: aWidget y;
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!WBCreateClassDialog methods !  
xoteryxPackageChoices
    "Compute the list of packages in which the user could save the window"
    ^(Smalltalk at: #XoPackage) names asSortedCollection asArray! !

!WBKeyAccel methods !   
= aKeyAccel

    ^keyCode notNil and: [
		aKeyAccel isAlt = isAlt and: [
		aKeyAccel isCtrl = isControl and: [
		aKeyAccel isShift = isShift and: [
		aKeyAccel accelKey = keyCode]]]].! !

!WBModelDefinitionEditor methods !
localInstVars

    ^attributes contents select: [:instVar |
        instVar myClass == selectedModel].! !

!WBOutboardWindow class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBMenuItem methods !
setLabel: aString
        "Change the label for the receiver to aString."
	self label: aString.
	self update! !

!WBTabOrderLayoutForm methods ! 
setByRowMajorOrder

	| tabPosition |
	self removeGroupingPanes.
	self groups: Dictionary new.
	tabPosition := WBTabPosition fromTabPosition: 1.
	((self children select: [:widget | 
		widget isGrouper not 
		and: [widget usesFocus 
		and: [widget staysToBack not]]]) asSortedCollection: [:a :b |
			(a hitRect bottomRight y isAboveEqual: b hitRect topLeft y)
				or: [(a hitRect topLeft y isAboveEqual: b hitRect bottomRight y)
					and: [a hitRect bottomRight x isLeftEqualOf: b hitRect topLeft x]]]) do: [:widget |
			widget tabPosition: tabPosition.
			tabPosition := tabPosition nextTabPosition].
	self setSmartGroups.! !

!WBCodePolicy methods !
existingMethodFor: aCodeModule
		"Private - Answer the compiled method in the specified class or nil.
			Search class then superclasses for a method with that selector."
	| cls stopCls answer |
	cls := aCodeModule targetClass.
	aCodeModule canInheritMethod ifFalse: [
		stopCls := aCodeModule targetClass superclass ].
	[ cls = stopCls ] whileFalse: [
		(answer := cls compiledMethodAt: aCodeModule messageSelector
			) notNil ifTrue: [ ^answer ].
		cls := cls superclass ].
	^nil! !

!WBEventManagerWindow methods ! 
toFieldSelection

	^toField selectedItem! !

!WindowBuilder methods ! 
setNLSPools

    | nlsPools |
    (nlsPools := WBMultiListChooser new
        fromList: (Smalltalk allNLSDictionaries keys asSortedCollection)
        prompt: 'Set NLS Pools'
        selection: self shell nlsPools asArray) notNil
            ifTrue: [self shell nlsPools: nlsPools asSet].! !

!WBModelTriggerEventModule methods !
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self generateGeneratedSymbol.
        self stream
            cr; nextPutAll: 'self triggerEvent: #'; nextPutAll: self object eventName;
            nextPutAll: ' with: self '; nextPutAll: self object name].! !

!WBAttributeWindow methods ! 
cancel
		"Close the receiver."
	self close.! !

!FrameObject methods !
contentRect

	^rect insetBy: 1! !

!WBTabOrderLayoutForm methods !
setWidgets: aCollectionOfWidgets
    "Set the collection of the children of the receiver."

	self 
		children: aCollectionOfWidgets;
		saveOldTabPositions;
		insertGroupingPanes;
		moveGroupboxesToBack;
		resetGroups;
		normalizeTabOrder.! !

!WBAbstractAddInModule class methods !  
setLoaded: aBoolean
    "Set the state of the add-in."

    aBoolean
        ifTrue: [self loadAddIn]
        ifFalse: [self unloadAddIn]! !

!WBInterfaceObject methods ! 
text: aString

    self contents: aString! !

!WBCreateViewModule methods !   
generatePaneHandlersOnly: aPane
		"Private - Generate the pane definition."
	| anEventTable |
	(anEventTable := aPane wbRealWidget eventTable) notEmpty ifTrue: [
		self stream cr.
		(self isInstVar: (self varNameFor: aPane)) & self useInstVars not
			ifTrue: [self stream nextPutAll: (self varNameFor: #owner); space].
		self stream
			nextPutAll: (self varNameFor: aPane);
			indentBy: 1;
			nextPutEventTable: anEventTable for: aPane;
			endExpression;
			indentBy: -1].! !

!PButton methods ! 
readSpecificsFrom: aWidget

	"OLD"
	specialId := aWidget propertyAt: #id.
	(aWidget propertyAt: #cancelPushButton) isNil 
		ifFalse: [self style: #cancelPushButton].

	"NEW"
	(aWidget respondsTo: #isDefaultPushButton) 
		ifTrue: [
			aWidget isDefaultPushButton
				ifTrue: [self style: #defaultPushButton]].
	(aWidget respondsTo: #isCancelPushButton)
		ifTrue: [
			aWidget isCancelPushButton
				ifTrue: [self style: #cancelPushButton]].! !

!WBGeometryManager methods ! 
layoutForm

    ^self owner layoutForm! !

!WindowBuilder class methods ! 
targetIsFirst

    ^self editorClass
        propertyValueAt: #TargetIsFirst
        category: self editorPropertyString! !

!WBLookPolicyOS2 methods ! 
titleRectFrom: aFrameObject

    | aPoint titleRect leftIndent rightIndent |
    aPoint := aFrameObject frameLeftTop.
    titleRect := (aPoint extentFromLeftTop: aFrameObject extent) insetBy: (self borderWidthFrom: aFrameObject).
    titleRect := titleRect leftTop extentFromLeftTop: titleRect width @ (self titleBarHeightFrom: aFrameObject).
    leftIndent := rightIndent := 0.
    (aFrameObject style includes: #sysmenu)
        ifTrue: [leftIndent := self systemMenuWidth].
    (aFrameObject style includes: #maximize)
        ifTrue: [rightIndent := self maximizeButtonSize x].
    (aFrameObject style includes: #minimize)
        ifTrue: [rightIndent := rightIndent + self minimizeButtonSize x].
    ^(titleRect left right: leftIndent) @ titleRect top
        extentFromLeftTop: (titleRect width - rightIndent - leftIndent) @ titleRect height.! !

!WBPrototype methods !   
realClass: realClass
		"Set the real class."
	self shell realClass: realClass.! !

!WBTreeNode methods !  
insertNode: aNode

    children notEmpty ifTrue: [
        self addChild: aNode beforeNode: children first
    ] ifFalse: [
        parent addChild: aNode afterNode: self.
    ].! !

!WindowBuilder class methods ! 
useWBComboBox

	^self runtimeLessCode not and: [
		self editorClass
			propertyValueAt: #UseWBComboBox
			category: self editorPropertyString]! !

!WBModelDefinitionEditor methods !  
removeAttribute

    (MessageBox confirm: 'Are you sure you want to remove the selected attribute [', attributes selectedItem name,']?')
        ifTrue: [
            attributes contents remove: attributes selectedItem ifAbsent: [].
            attributes contents: attributes contents.
            self
                enableModelFields;
                disableFields;
                setDirty].! !

!WBInterfaceObject methods !  
importantEvents

    ^OrderedCollection with: #needsContents.! !

!StylePropertyAccessor methods !
setValue: aBoolean for: anObject

    "Private - Set the value of the property."

    OperatingSystem isOS2 ifTrue: [
        self wbFrameStyle notNil ifTrue: [
            aBoolean
                ifTrue: [ anObject addFrameCreationFlags: ( self pool at: self wbFrameStyle ifAbsent: [ ^self error: 'Unknown style' ] ) ]
                ifFalse: [ anObject removeFrameCreationFlags: ( self pool at: self wbFrameStyle ifAbsent: [ ^self error: 'Unknown style' ] ) ].
            "anObject setStyle: anObject style"   "force the new style to show up"
            ^self]].

    aBoolean
        ifTrue: [ anObject addStyle: ( self pool at: self style ifAbsent: [ ^self error: 'Unknown style' ] ) ]
        ifFalse: [ anObject removeStyle: ( self pool at: self style ifAbsent: [ ^self error: 'Unknown style' ] ) ].
    anObject setStyle: anObject style   "force the new style to show up"! !

!WBGeometryManager methods !  
clipboardHasItems

    ^self clipboard notNil! !

!WBAbstractPrompter class methods ! 
defaultTitle

	^'Query'! !

!WBModelDefinitionEditor methods !
setLazy: aBoolean

    | selectedItem |
    selectedItem := attributes selectedItem ifNil: [^nil].
    selectedItem lazy == aBoolean ifTrue: [^self].
    selectedItem lazy: aBoolean.
    self setDirty.! !

!WBTreeNode methods !   
setParent: aParent

    parent := aParent! !

!WBLookPolicy methods ! 
drawMinimizeButtonWith: aPen at: aRect

    ^self draw3DBoxWith: aPen at: aRect.! !

!WBCreateViewModule methods !
primaryModel
        "Answer the primaryModel."
    ^self object primaryModel! !

!Object class methods ! 
wbPropertyManager
    "Answer the window builder property manager for the receiver."

    ^WBPropertyManager current for: self! !

!WindowBuilder methods !  
initialize
    "Private - Initialize the reciever"

    super initialize.
    self geometryManager: (WBGeometryManager on: self).
    self undoManager: WBUndoManager new.
    dirty := false.
    self outboards: Set new.! !

!WBLayoutForm methods !  
showHandles

    self checkHideHandles ifTrue: [^self].
    self
        showHandles: self handles;
        drawOrderSymbols.! !

!WindowBuilder class methods !   
wbMenus

	| menus |
	menus := self propertyAt: #WBMenus.
	menus isNil
		ifTrue: [
			(menus := self wbMenuArray asOrderedCollectionRecursively) do: [:m |
				m at: 1 put: (m at: 1) replaceEscapeCharacters.
				(m at: 3) do: [:mi |
					mi == #separator
						ifFalse: [
							mi at: 1 put: (mi at: 1) replaceEscapeCharacters.
							(mi at: 3) isString
								ifFalse: [
									(mi at: 3) do: [:msi |
										msi == #separator
											ifFalse: [msi at: 1 put: (msi at: 1) replaceEscapeCharacters]]]]]].
			self 
				propertyAt: #WBMenus put: menus;
				installExtras;
				installAddInModules: menus].
	^menus! !

!WBEventManagerWindow class methods !
toFieldExtensions

	^toFieldExtensions ifNil: [
		toFieldExtensions := self defaultToFieldExtensions]! !

!WBLinkEditor methods !
initWindow

    | listPane |
    link := thePane link.
    type := thePane type.
    (self paneNamed: 'typeDescription') disable.
    (listPane := self paneNamed: 'list') contents: self viableClasses.
    link isNil ifFalse: [
        listPane selectItem: link.
        self select: listPane
    ].! !

!WBEventManagerWindow methods !
handlerListBoxDragTargetEnabled

	^self handlerListBoxDragEnabled
		& (self handlerList size > 1)
		& self eventSelected notNil
		& self widgetSelected notNil
		& self handlerShowAll not! !

!WBLayoutForm methods !
cursorSelectPoint
    "Answer the value of cursorSelectPoint."

    ^cursorSelectPoint! !

!WBModelEventsTriggeredModule methods !   
targetClass
        "Answer the receiver's target class."
    ^super targetClass class! !

!PColumnListBox methods !  
listEditorLabel

    ^'Column Width Editor'! !

!WBGeometryManager methods !  
replicateWidth
    "Replicate the widths of the selected widgets"

    | target selections widths aWidget redoBlock |
    (selections := self selections copy) size > 1 ifFalse: [^self].
    target := selections first.
    widths := selections collect: [:widget | widget width].
    self undoManager
        add: 'Replicate Width'
        undo:
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    configureWidget: aWidget x
                    y: aWidget y
                    width: (widths at: i)
                    height: aWidget height
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    configureWidget: aWidget x
                    y: aWidget y
                    width: target width
                    height: aWidget height
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!WBDialogScratchWindow class methods !  
isWBInternalClass

    ^true! !

!WBMenuItem methods !
disable
        "Disable the receiver."
	self hasSubmenu
		ifTrue: [^self submenu disableAll].
	self isDisabled ifTrue: [^self].
	self attribute: self attribute | MfGrayed.
	self updateAttributes: MfGrayed.! !

!PCompositePane methods !  
style: aStyle

	super style: aStyle.
	(aStyle == #mdiToolBar or: [aStyle == #mdiToolBarBordered])
		ifTrue: [
			framingBlock := LayoutFrame new
				leftRatio: 0; leftInset: 0;
				topRatio: 0; topInset: 0;
				rightRatio: 1; rightInset: 0;
				bottomRatio: 0; bottomInset: self rect height negated.
			self parent notNil ifTrue: [self reframe: self parent rect].
			^nil].! !

!WBOutboardWindow methods !
owner

	^owner! !

!WBTeamVCodePolicy methods !   
renameKey: oldKey to: newKey inPoolNamed: aSymbol
	"Rename the specified key in a pool in the system."

	(self currentSubsystem unpackagedPackage subsystem 
		definitionOfPoolNamed: aSymbol asSymbol) isNil
		ifTrue: [super renameKey: oldKey to: newKey inPoolNamed: aSymbol]
		ifFalse: [
			((self currentSubsystem
				definitionOfPoolNamed: aSymbol)
					definitionOfPoolVariableNamed: oldKey)
						renameTo: newKey].! !

!Object methods !  
wbEventTable: anEventTable
	"Set the receiver's event table from anEventTable."

	anEventTable associationsDo: [:each |
		(self canTriggerEvent: each key) ifTrue: [
			each value asActionSequence do: [:eachAction |
				self when: each key evaluate: eachAction copy]]].! !

!WBCompositePaneModule methods ! 
menuModuleClass
		"Answer the menu code module class."
	^WBCompositeMenuModule! !

!WBLayoutForm methods !
drawGrid: aPen

	self 
		drawGrid: aPen 
		rect: self shell frameContentRect! !

!WBCodeGenerator methods ! 
addModuleToProcess: aCodeModule
		"Add a code module to the list of code modules to be processed."
	aCodeModule owner ifNil: [ aCodeModule owner: self ].
	modulesToProcess add: aCodeModule.! !

!PStaticText methods ! 
styles

    ^#(#leftJustified #leftJustifiedWordWrap #rightJustified #centered )! !

!WBLookPolicyWin95 methods ! 
scrollBarArrowHeight

    ^scrollBarArrowHeight ifNil: [
        scrollBarArrowHeight := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCyvscroll" 20]
            ifFalse: [super scrollBarArrowHeight]]! !

!WindowBuilder methods ! 
menuFileEditModelObjects

    self invoke: WBModelObjectEditor! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutForm methods !   
selections
    "Answer the value of selections."

    ^selections! !

!Object methods !  
wbMutateToInstanceOf: aClass
	"Answer a mutation of the receiver."

	#addedByOSI.
	^self wbMutateTo: (
		aClass isVariable
			ifTrue: [aClass new: self basicSize]
			ifFalse: [aClass new])! !

!LayoutFrame methods !  
wbRightAttachedToLeft: aBoolean
	"Set true if the receiver's right is attached to the receiver's left."

	self propertyAt: #wbRightAttachedToLeft put: aBoolean.
	^aBoolean! !

!PEntryFieldGroup methods ! 
text: aString

    ^self label: aString! !

!WBInterfaceObject methods !  
menu: aMenu

	menu notNil ifTrue: [menu owner: nil].
	(menu := aMenu) notNil ifTrue: [menu owner: self].! !

!WBLookPolicyOS2 methods !  
drawTitleBar: aFrameObject with: aPen in: aRect

    | titleRect titleTextRect |
    titleRect := aRect leftTop extentFromLeftTop: aRect width @ (self titleBarHeightFrom: aFrameObject).
    aFrameObject hasTitleBar
        ifTrue: [
            aPen fill: titleRect color: Color activeTitleBar.
             self
                drawTitleBarText: aFrameObject
                with: aPen
                in: (titleTextRect := self titleRectFrom: aFrameObject).
            aPen
                foreColor: Color windowBorder;
                wbLineFrom: titleRect left @ (titleRect bottom up: 1) to: titleRect right @ (titleRect bottom up: 1)].
    (aFrameObject style includes: #sysmenu)
        ifTrue: [
            self
                drawSystemMenuWith: aPen
                at: ((titleRect leftTop leftAndUp: 1)
                    extentFromLeftTop: (self systemMenuWidth @ (self titleBarHeightFrom: aFrameObject)) + 1)].
    (aFrameObject style includes: #maximize)
        ifTrue: [
            self
                drawMaximizeButtonWith: aPen
                at: ((titleRect rightTop leftAndUp: self maximizeButtonSize x @ 1)
                    extentFromLeftTop: self maximizeButtonSize + 1)].
    (aFrameObject style includes: #minimize)
        ifTrue: [
            (aFrameObject style includes: #maximize)
                ifTrue: [
                    self
                        drawMinimizeButtonWith: aPen
                        at: ((titleRect rightTop leftAndUp: self minimizeButtonSize x + self maximizeButtonSize x @ 1)
                            extentFromLeftTop: self minimizeButtonSize + 1)]
                ifFalse: [
                    self
                        drawMinimizeButtonWith: aPen
                        at: ((titleRect rightTop leftAndUp: self minimizeButtonSize x @ 1)
                            extentFromLeftTop: self minimizeButtonSize + 1)]].! !

!WBTeamVCodePolicy methods ! 
packageFor: aCodeModule
		"Answer the package that contains the specified class."
	| aClass |
	aClass := aCodeModule targetClass instanceClass.
	aClass isScratchWindow ifTrue: [^self wbScratchPackage].
	"aClass wbCreated not ifTrue: [^self currentSubsystem unpackagedPackage]."
	^(self currentSubsystem
		definitionOfClassNamed: aClass symbol
			) package! !

!WBLookPolicy class methods !   
ctl3dEnabled

    OperatingSystem isOS2 ifTrue: [^false].
	^Window ctl3dEnabled! !

!WBEditClassDialog methods ! 
isValidPackage: aPackage
    "Answer whether <aPackage> should appear in the package list"

    ^true! !

!WBTabOrderEditor methods !
setByRowMajorOrder

	layoutForm setByRowMajorOrder.
	self setFirstStatus.! !

!PRadioButtonGroup methods !   
numColumns

	^numColumns ifNil: [numColumns := 1]! !

!WBInterfaceObject methods !
hasOtherEditor

    ^self attributeEditor notNil! !

!WindowBuilder methods ! 
geometryManager: aWBGeometryManager

    geometryManager := aWBGeometryManager! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!Object methods ! 
isWBInstVarObject

	^false! !

!WBModelInstVar methods !  
eventName

    ^self name, 'Changed:'! !

!WBCodeModule methods ! 
initTemporaries
		"Private - Initialize the variable names."! !

!WindowBuilder methods !  
quickReferenceMenu

	^self mainView menuWindow wbMenuTitled: 'Quick Reference'.! !

!PAnimationPane methods ! 
displayWithBothScrollBars: aPen! !

!WBEditClassDialog methods !
xoteryxPackageList

    ^OrderedCollection new
        add: self class defaultChoice;
        addAll: self xoteryxPackageChoices asSortedCollection;
        yourself.! !

!WBCompositePaneTester methods !
openOn: aCompositePaneClass in: aRectangle
	"Open the receiver to test the specified class."

	classToTest := aCompositePaneClass.
	frame := aRectangle.
	self open.! !

!WBAboutDialog methods !  
getUser: aPane
	"Show the user and company information."

	aPane contents: 
		(self wbEditorClass userName , '\' , 
		self wbEditorClass companyName) withCrs.! !

!WBENVYCodePolicy methods ! 
basicLogMethodFor: aCodeModule
		"Private - Log the specified method source."
	"Don't log methods because they are logged as part of basicCompileMethod..."! !

!WindowBuilder methods !  
styleEditor

	^styleEditor! !

!WindowBuilder methods !   
setDefaultFonts

	(self propertyAt: #StoredFonts) notNil ifTrue: [^self].
	self
		propertyAt: #StoredFonts
		put:
			(Array
				with: ListFont
				with: TextFont
				with: ButtonFont
				with: SysFont).
	ListFont := TextFont := ButtonFont := SysFont := self class wbDefaultFont.! !

!WBLayoutForm methods !   
cursorOffset: aPoint
    "Set the value of cursorOffset."

    cursorOffset := aPoint.! !

!WBInterfaceObject methods !  
backColor

	^backColor = self defaultBackColor 
		ifTrue: [
			self parent notNil 
				ifTrue: [self parent backColor]
				ifFalse: [backColor]]
		ifFalse: [backColor].! !

!WindowBuilder methods !
open

	Notifier cleanUpWindows.
	super open.! !

!WBVersionCodeModule methods !  
defaultComment
		"Answer the default comment string."
	^'Private - Answer the WindowBuilder Pro version.
		Generated in: ', Smalltalk product, ' ', Smalltalk version, ' ', Smalltalk platform! !

!StaticText methods ! 
showHelp: aString
        "Private - WBPro Development."
    #addedByOSI.
    self contents: aString! !

!WBCreateViewsStubModule methods !  
defaultMessageSelector
		"Private - Answer the default message selector."
	^#createViews! !

!WBTargetObject methods !
validInstVars
	"Answer an orderedCollection mapping objects to valid inst var names."

	| answer oldInstVar |
	self updateInstVars.
	answer := IdentityDictionary new.
	self wbInstVarMap associationsDo: [:each |
		answer at: each value put: each key.
		(oldInstVar := self invalidInstVars at: each key ifAbsent: [nil])
			notNil ifTrue: [answer at: oldInstVar put: each key]].
	^answer! !

!PEntryField methods !   
usesTitle

    ^true! !

!WBTabOrderEditor methods !  
clearAll

	layoutForm clearTabOrder.
	self setFirstStatus.! !

!WBTabOrderLayoutForm methods !   
dragWidget
    "Answer the dragWidget."

    ^dragWidget
! !

!WBEnhancedAttributeEditor methods !  
saveField: anAccessor pane: aPane
	"Store the contents of aPane."

	| value |
	anAccessor isNil | aPane isNil ifTrue: [^self].
	value := aPane value.
	anAccessor wbSetValue: value for: thePane wbRealWidget.! !

!WBToolBarEditor methods ! 
editBitmaps

    (Smalltalk includesKey: #MDISystem) ifTrue: [
        (Smalltalk at: #MDISystem) isActive ifTrue: [
            ^MessageBox message: 'Due to limitations in the implementation of MDI, the bitmap manager cannot be launched from within MDI.  Either use the toolbar, or switch out of MDI first.'
        ].
    ].
	self wbEditorClass openBitmapManager.! !

!Object methods !  
paneName

    ^self propertyAt: #name! !

!WindowBuilder methods !
label

    ^self class labelName , ': [' , (self classNameFor: self editedClass) , ']'.! !

!WBMenuItem methods ! 
updateToggled
	"Update the receiver's toggled status"
	self hasSubmenu
		ifTrue: [^self submenu updateToggled].
	self owner notNil & self toggleSelector isSymbol
		ifTrue: [
			(self owner perform: self toggleSelector)
				ifTrue: [self check]
				ifFalse: [self uncheck]].! !

!WindowBuilder methods !  
nlsKeyFor: aString

    | nlsKey nlsText |
    nlsText := aString.
    self shell nlsPools notEmpty
        ifTrue: [
            self shell nlsPools detect: [:sym |
               (nlsKey := (Smalltalk at: sym) associationsSelect: [:assoc |
                    assoc value == aString]) notEmpty
                    ifTrue: [nlsKey := nlsKey keyAtValue: aString]
                    ifFalse: [nlsKey := nil].
                nlsKey notNil] ifNone: [nil].
            nlsKey notNil
                ifTrue: [nlsText := '#', nlsKey]].
    ^nlsText! !

!PEntryFieldGroup methods !  
styles

    ^#(#defaultStyle #noGroupBox #verticalScrollBar)! !

!WBLookPolicyOS2 methods !   
scrollBarArrowHeight

	^scrollBarArrowHeight ifNil: [
		scrollBarArrowHeight := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCyvscrollarrow" 24]
			ifFalse: [super scrollBarArrowHeight]]! !

!WBOutboardWindow methods ! 
update
    "The receiver has been activated and the
        owner has changed, so update the receiver's content's
        to reflect the change in the owner."

	ownerChanged := false.! !

!WBTabOrderEditor methods !
setFirstStatus

	self setStatus: 'Click to set tabs. Alt click to remove tabs. Drag to reorder tabs.'! !

!WindowBuilder methods !
outboards

    ^outboards! !

!PStatusPane methods !  
displayWith: aPen clipRect: clipRects

    aPen
        font: self font;
        fill: rect color: self realBackColor;
        wbLineFrom: rect leftTop to: rect rightTop;
        foreColor: Color white;
        wbLineFrom: (rect leftTop down: 1) to: (rect rightTop down: 1);
        backColor: self colorButtonFace;
        foreColor: self colorButtonText.
    self statusBoxes do: [:each | self displayBox: each with: aPen].! !

!PStatusPane methods !  
reframe: parentRect

    super reframe: parentRect.
    self updateBoxes! !

!WBPropertyManager class methods !  
newFor: aClass
	"Answer the attribute manager for aClass."

	^aClass wbConstructPropertyManager
		wbInitializeDefaultFrom: aClass new;
		yourself! !

!WBTreeListBox methods ! 
basicSelectionText: newText

    |  r |

    self selectedItem title: newText.

    r := WinRectangle new.
    UserLibrary sendMessage: self asParameter
        msg: LbGetitemrect
        wparam: self selection - 1
        lparamStruct: r asParameter.

    self invalidateRect: r asRectangle
        erase: false;
        updateWindow.! !

!WBTabOrderLayoutForm methods !   
buttonReleaseResizing: aPoint
    "Process a button release event after resizing a widget."

	| theGrouper newGroupRect containedWidgets |
	theGrouper := self selections first.
	newGroupRect := bandRect.
	self groups keysDo: [:group |
		(group ~~ theGrouper and: [group rect intersects: newGroupRect])
			ifTrue: [
				self updateWidget.
				^MessageBox messageNote: 'Overlapping Grouping is not allowed.']].
	theGrouper rect: newGroupRect.

	(containedWidgets := self 
		widgetsFrom: self children 
		containedIn: theGrouper) isEmpty
		ifTrue: [
			theGrouper rect: theGrouper lastRect.
			self updateWidget.
			^MessageBox messageNote: 'A group must contain at least one groupable widget.'].
	newGroupRect := (self boundingBoxFor: containedWidgets) expandBy: 8.
	theGrouper rect: newGroupRect.

	self 
		resetGroups;
		normalizeTabOrder;
		updateRect: self shell frameContentRect.! !

!WBPoolManagerWindow methods ! 
updateCategoryPath

	categoryPathField update.! !

!WBLayoutForm methods !
button1DownShift: aPoint

    self 
        useLeftButton;
        buttonDown: aPoint.! !

!WindowBuilder class methods !   
userName
    "Answer the window builder user's name."

    | answer |
    self licensed ifFalse: [^'demo'].
    answer := self userNamePrim.
    "
    answer = '' | answer isNil ifTrue: [
        self promptForUserInfo.
        answer := self userNamePrim].
    "
    ^answer ifNil: [''].! !

!WBPoolManagerWindow methods !  
updateKeys
	"Update the list of keys."

	updateKeys isNil ifTrue: [
		updateKeys := self selectedKeysAndPools.
		(Message receiver: self selector: #updateKeysPrim) performDeferred].! !

!WindowBuilder class methods !   
clearMenus

	self removeProperty: #WBMenus.! !

!WBLocator methods !  
setReceiver: anObject selector: aSymbol arguments: anArray
    receiver := anObject.
    selector := aSymbol.
    arguments := anArray! !

!WBColorDialog class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBAttributeWindow methods ! 
ownerAboutToOpen: aClass
		"If the owner is about to open a window with the same class
			as the receiver, then abort it and bring self to top."
	self class == aClass ifTrue: [
		self owner abortOpen.
		self mainView bringToTop ].! !

!WBCodePolicy methods ! 
removeScratchSelectorsForClass: aClass
		"Remove all methods that have no source code."
	aClass selectors do: [ :eachSelector |
		(aClass compiledMethodAt: eachSelector) sourceString ifNil: [
			self removeSelector: eachSelector fromClass: aClass ] ].! !

!WindowBuilder methods !
methodHeaderFor: aSelectorString in: aPane event: eventSymbol

	| argNames argCount src dst |
	argNames := aPane eventHandlerArgNamesFor: eventSymbol.
	argCount := Message numberOfArgumentsFor: aSelectorString.
	src := ReadStream on: aSelectorString.
	dst := WriteStream on: (String new: 100).
	argCount > argNames size
		ifTrue: [argNames := argNames , #('aPane')].
	dst nextPutAll: (src upTo: $:).
	argNames do: [:arg |
		dst nextPutAll: ': ' , arg.
		src atEnd
			ifTrue: [^dst contents].
		dst nextPutAll: ' ' , (src upTo: $:)].
	^dst contents! !

!WBEventManagerWindow methods !  
promptForWindow

	^WBEditClassDialog new open selectedClass ifNil: [^self]! !

!WBPrototype methods ! 
propertyAt: key 
        "Answer the value associated with key
        in the properties dictionary."
    properties isNil ifTrue: [^nil].
    ^properties at: key ifAbsent: [nil]! !

!WBPMenuItem methods !   
appendTo: theMenu

    self isLeaf ifTrue: [
        self isSeparator ifTrue: [
            theMenu appendSeparator.
        ] ifFalse: [
            theMenu
                appendItem: self fullTitle
                selector: self realSelector
                accelKey: self accelKey
                accelBits: self accelBits.
        ].
    ] ifFalse: [
        theMenu appendSubMenu: self asMenu
    ].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PListBox methods !
genReceiveWindowMessagesOn: aStream indentString: spaceString
    "Don't generate method for EntryField or ListBox - they already have it"! !

!PButton methods !  
defaultBackColor

    ^Color buttonFace! !

!WBMenuEditor class methods ! 
isWBInternalClass

    ^true! !

!WBPoolManagerWindow methods !   
menuOptionAllowDuplicateKeys

    "Callback for the menu item titled 'Allow duplicate keys'.
     (Generated by WindowBuilder)"

	[self menuOptionAllowDuplicateKeys: self poolManager allowDuplicateKeys not]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].
	self updateOptionMenu.! !

!WBLayoutWizard methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| attributeClass attributesGroup browseClassButton 
	classLabel defineButton downButton expressionButton 
	expressionField generateButton inspectButton instVarButton 
	mainView modelButton modelInitializesWidgetButton 
	modelUpdatesWidgetButton otherButtonButton otherMenuButton 
	otherTypeButton setDefaultStandardButtonsButton 
	setDefaultStandardMenusButton setDefaultTypeButton 
	sourceGroup standardButtonsGroup standardButtonsList 
	standardMenusGroup standardMenusList upButton 
	widgetTypeLabel widgetUpdatesModelButton xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	attributesList := ButtonListBox new.
	modelList := WBComboBox new.
	widgetType := WBComboBox new.
	
		"Temporary Variables"
	attributeClass := EntryField new.
	attributesGroup := GroupBox new.
	browseClassButton := Button new.
	classLabel := StaticText new.
	defineButton := Button new.
	downButton := Button new.
	expressionButton := RadioButton new.
	expressionField := EntryField new.
	generateButton := Button new.
	inspectButton := Button new.
	instVarButton := CheckBox new.
	modelButton := RadioButton new.
	modelInitializesWidgetButton := CheckBox new.
	modelUpdatesWidgetButton := CheckBox new.
	otherButtonButton := Button new.
	otherMenuButton := Button new.
	otherTypeButton := Button new.
	setDefaultStandardButtonsButton := Button new.
	setDefaultStandardMenusButton := Button new.
	setDefaultTypeButton := Button new.
	sourceGroup := GroupBox new.
	standardButtonsGroup := GroupBox new.
	standardButtonsList := MultipleSelectListBox new.
	standardMenusGroup := GroupBox new.
	standardMenusList := MultipleSelectListBox new.
	upButton := Button new.
	widgetTypeLabel := StaticText new.
	widgetUpdatesModelButton := CheckBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		when: #activated send: #activated to: self;
		labelWithoutPrefix: 'Layout Wizard';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -145 * xDU;
				topRatio: 1/2; topInset: -209/2 * yDU;
				rightRatio: 1/2; rightInset: -145 * xDU;
				bottomRatio: 1/2; bottomInset: -191/2 * yDU).
	self addView: mainView.
	
	modelButton "RadioButton"
		owner: self;
		setName: 'modelButton';
		when: #clicked: send: #useSourceModel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 10 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -114 * xDU;
				bottomRatio: 0; bottomInset: -22 * yDU);
		contents: 'Model';
		startGroup;
		font: SysFont.
	mainView
		addSubpane: modelButton;
		subPaneWithFocus: modelButton.
	
	expressionButton "RadioButton"
		owner: self;
		setName: 'expressionButton';
		when: #clicked: send: #useSourceExpression to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 10 * xDU;
				topRatio: 0; topInset: 36 * yDU;
				rightRatio: 0; rightInset: -114 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		contents: 'Smalltalk Expression';
		noTabStop;
		font: SysFont.
	mainView addSubpane: expressionButton.
	
	modelList "WBComboBox"
		owner: self;
		setName: 'modelList';
		when: #changed: send: #selectModel: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 18 * xDU;
				topRatio: 0; topInset: 22 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 0; bottomInset: -34 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: modelList.
	
	expressionField "EntryField"
		owner: self;
		setName: 'expressionField';
		when: #textChanged: send: #expressionChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 18 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 0; bottomInset: -58 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: expressionField.
	
	inspectButton "Button"
		owner: self;
		setName: 'inspectButton';
		when: #clicked send: #inspectInstance to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 62 * yDU;
				rightRatio: 0; rightInset: -44 * xDU;
				bottomRatio: 0; bottomInset: -76 * yDU);
		contents: 'Inspect';
		startGroup;
		font: SysFont.
	mainView addSubpane: inspectButton.
	
	browseClassButton "Button"
		owner: self;
		setName: 'browseClassButton';
		when: #clicked send: #browseClass to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 48 * xDU;
				topRatio: 0; topInset: 62 * yDU;
				rightRatio: 0; rightInset: -84 * xDU;
				bottomRatio: 0; bottomInset: -76 * yDU);
		contents: 'Browse';
		startGroup;
		font: SysFont.
	mainView addSubpane: browseClassButton.
	
	defineButton "Button"
		owner: self;
		setName: 'defineButton';
		when: #clicked send: #defineModel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 88 * xDU;
				topRatio: 0; topInset: 62 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 0; bottomInset: -76 * yDU);
		contents: 'Define';
		startGroup;
		font: SysFont.
	mainView addSubpane: defineButton.
	
	standardButtonsList "MultipleSelectListBox"
		owner: self;
		setName: 'standardButtonsList';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 94 * yDU;
				rightRatio: 0; rightInset: -70 * xDU;
				bottomRatio: 128/187; bottomInset: 0 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: standardButtonsList.
	
	otherButtonButton "Button"
		owner: self;
		setName: 'otherButtonButton';
		when: #clicked send: #otherButton to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 72 * xDU;
				topRatio: 0; topInset: 94 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 0; bottomInset: -108 * yDU);
		contents: 'Other...';
		startGroup;
		font: SysFont.
	mainView addSubpane: otherButtonButton.
	
	setDefaultStandardButtonsButton "Button"
		owner: self;
		setName: 'setDefaultStandardButtonsButton';
		when: #clicked send: #setDefaultStandardButtons to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 72 * xDU;
				topRatio: 128/187; topInset: -14 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 128/187; bottomInset: 0 * yDU);
		contents: 'Set Default';
		startGroup;
		font: SysFont.
	mainView addSubpane: setDefaultStandardButtonsButton.
	
	standardMenusList "MultipleSelectListBox"
		owner: self;
		setName: 'standardMenusList';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 144/187; topInset: 0 * yDU;
				rightRatio: 0; rightInset: -70 * xDU;
				bottomRatio: 1; bottomInset: 9 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: standardMenusList.
	
	otherMenuButton "Button"
		owner: self;
		setName: 'otherMenuButton';
		when: #clicked send: #otherMenu to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 72 * xDU;
				topRatio: 144/187; topInset: 0 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 144/187; bottomInset: -14 * yDU);
		contents: 'Other...';
		startGroup;
		font: SysFont.
	mainView addSubpane: otherMenuButton.
	
	setDefaultStandardMenusButton "Button"
		owner: self;
		setName: 'setDefaultStandardMenusButton';
		when: #clicked send: #setDefaultStandardMenus to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 72 * xDU;
				topRatio: 1; topInset: -23 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 1; bottomInset: 9 * yDU);
		contents: 'Set Default';
		startGroup;
		font: SysFont.
	mainView addSubpane: setDefaultStandardMenusButton.
	
	attributesList "ButtonListBox"
		owner: self;
		setName: 'attributesList';
		when: #clicked: send: #selectAttribute: to: self;
		when: #checkedIndex: send: #checkedAttribute: to: self;
		when: #uncheckedIndex: send: #uncheckedAttribute: to: self;
		when: #needsStringFor: send: #stringFor: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 1; bottomInset: 107 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: attributesList.
	
	widgetType "WBComboBox"
		owner: self;
		setName: 'widgetType';
		when: #changed: send: #setWidgetType: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 182 * xDU;
				topRatio: 1; topInset: -91 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 1; bottomInset: 79 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: widgetType.
	
	instVarButton "CheckBox"
		owner: self;
		setName: 'instVarButton';
		when: #clicked: send: #setInstVar: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 136 * xDU;
				topRatio: 1; topInset: -73 * yDU;
				rightRatio: 0; rightInset: -178 * xDU;
				bottomRatio: 1; bottomInset: 63 * yDU);
		contents: 'Inst Var';
		startGroup;
		font: SysFont.
	mainView addSubpane: instVarButton.
	
	otherTypeButton "Button"
		owner: self;
		setName: 'otherTypeButton';
		when: #clicked send: #otherType to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -104 * xDU;
				topRatio: 1; topInset: -75 * yDU;
				rightRatio: 1; rightInset: 58 * xDU;
				bottomRatio: 1; bottomInset: 61 * yDU);
		contents: 'Other...';
		startGroup;
		font: SysFont.
	mainView addSubpane: otherTypeButton.
	
	setDefaultTypeButton "Button"
		owner: self;
		setName: 'setDefaultTypeButton';
		when: #clicked send: #setDefaultType to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -54 * xDU;
				topRatio: 1; topInset: -75 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 1; bottomInset: 61 * yDU);
		contents: 'Set Default';
		startGroup;
		font: SysFont.
	mainView addSubpane: setDefaultTypeButton.
	
	widgetUpdatesModelButton "CheckBox"
		owner: self;
		setName: 'widgetUpdatesModelButton';
		when: #clicked: send: #setWidgetUpdatesModel: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 136 * xDU;
				topRatio: 1; topInset: -59 * yDU;
				rightRatio: 1; rightInset: 58 * xDU;
				bottomRatio: 1; bottomInset: 49 * yDU);
		contents: 'Widget Updates Model';
		startGroup;
		font: SysFont.
	mainView addSubpane: widgetUpdatesModelButton.
	
	modelUpdatesWidgetButton "CheckBox"
		owner: self;
		setName: 'modelUpdatesWidgetButton';
		when: #clicked: send: #setModelUpdatesWidget: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 136 * xDU;
				topRatio: 1; topInset: -49 * yDU;
				rightRatio: 1; rightInset: 58 * xDU;
				bottomRatio: 1; bottomInset: 39 * yDU);
		contents: 'Model Updates Widget';
		startGroup;
		font: SysFont.
	mainView addSubpane: modelUpdatesWidgetButton.
	
	modelInitializesWidgetButton "CheckBox"
		owner: self;
		setName: 'modelInitializesWidgetButton';
		when: #clicked: send: #setModelInitializesWidget: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 136 * xDU;
				topRatio: 0; topInset: 148 * yDU;
				rightRatio: 0; rightInset: -228 * xDU;
				bottomRatio: 0; bottomInset: -158 * yDU);
		contents: 'Model Initializes Widget';
		startGroup;
		font: SysFont.
	mainView addSubpane: modelInitializesWidgetButton.
	
	upButton "Button"
		owner: self;
		setName: 'upButton';
		when: #clicked send: #up to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -54 * xDU;
				topRatio: 1; topInset: -59 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 1; bottomInset: 45 * yDU);
		contents: 'Up';
		startGroup;
		font: SysFont.
	mainView addSubpane: upButton.
	
	downButton "Button"
		owner: self;
		setName: 'downButton';
		when: #clicked send: #down to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -54 * xDU;
				topRatio: 1; topInset: -43 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 1; bottomInset: 29 * yDU);
		contents: 'Down';
		startGroup;
		font: SysFont.
	mainView addSubpane: downButton.
	
	generateButton "Button"
		owner: self;
		setName: 'generateButton';
		when: #clicked send: #generateLayout to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 130 * xDU;
				topRatio: 1; topInset: -21 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 5 * yDU);
		contents: 'Generate Layout';
		startGroup;
		font: SysFont.
	mainView addSubpane: generateButton.
	
	classLabel "StaticText"
		owner: self;
		setName: 'classLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 132 * xDU;
				topRatio: 1; topInset: -103 * yDU;
				rightRatio: 0; rightInset: -180 * xDU;
				bottomRatio: 1; bottomInset: 95 * yDU);
		rightJustified;
		contents: 'Class:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: classLabel.
	
	attributeClass "EntryField"
		owner: self;
		setName: 'attributeClass';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 182 * xDU;
				topRatio: 1; topInset: -105 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 1; bottomInset: 93 * yDU);
		readOnly;
		backColor: Color gray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: attributeClass.
	
	widgetTypeLabel "StaticText"
		owner: self;
		setName: 'widgetTypeLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 132 * xDU;
				topRatio: 1; topInset: -89 * yDU;
				rightRatio: 0; rightInset: -180 * xDU;
				bottomRatio: 1; bottomInset: 81 * yDU);
		rightJustified;
		contents: 'Widget Type:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: widgetTypeLabel.
	
	standardMenusGroup "GroupBox"
		owner: self;
		setName: 'standardMenusGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 269/374; topInset: 0 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 1; bottomInset: 9/2 * yDU);
		contents: 'Standard Menus';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: standardMenusGroup.
	
	standardButtonsGroup "GroupBox"
		owner: self;
		setName: 'standardButtonsGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 84 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 12/17; bottomInset: 0 * yDU);
		contents: 'Standard Buttons';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: standardButtonsGroup.
	
	sourceGroup "GroupBox"
		owner: self;
		setName: 'sourceGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 0; bottomInset: -80 * yDU);
		contents: 'Source Instance';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sourceGroup.
	
	attributesGroup "GroupBox"
		owner: self;
		setName: 'attributesGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 130 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 25 * yDU);
		contents: 'Attributes';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: attributesGroup! !

!PEntryField methods !   
readSpecificsFrom: aWidget

	(aWidget propertyAt: #readonly) isNil
		ifFalse: [self style: #readonly]! !

!LayoutFrame methods ! 
asFramingBlockForWindowFromDialogSubPane

	"The framingBlock for subpanes in a dialog are passed the dialog units
		of the parent and expected to return dialog units for the subpane.
		The framingBlock for subpanes in a window are passed pixels
		of the parent and expected to return pixels for the subpane.
		Convert the insets from dialog units to pixels."

	| xDU yDU xR yR |
	"xDU := (WindowDialog dialogUnit x / WindowDialog unitMultiplier x * 2) ceiling / 2."
	"xDU := WindowDialog dialogUnit x / WindowDialog unitMultiplier x."
	"yDU := WindowDialog dialogUnit y / WindowDialog unitMultiplier y."

	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	xR := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yR := 1.

	^self wbCopy
		leftInset: self leftInset * xDU / xR;
		topInset: self topInset * yDU / yR;
		rightInset: self rightInset * xDU / xR;
		bottomInset: self bottomInset * yDU / yR;
		yourself! !

!PToggle methods !  
suggestedSize

    ^(self contentsStringWidth + (self iconExtent x + 6)) @ ((self font height + 4) max: 16)! !

!WBUndoManager methods !  
showHandles

    self owner layoutForm showHandles.! !

!WBInterfaceObject methods !  
generateAllStyles

    ^false! !

!WBRGBColorDialog methods ! 
rgbColor

    ^RGBColor
            red: (self paneNamed: 'red') contents asInteger
            green: (self paneNamed: 'green') contents asInteger
            blue: (self paneNamed: 'blue') contents asInteger! !

!WBTabOrderEditor methods !  
cleanUpOk

	self cleanUp.
	result := true.
	self shell 
		children: layoutForm children;
		sortChildrenByTabOrder.! !

!WBMenubarEditor methods ! 
warnOfAccelerators

    (self wbEditorClass runtimeLessCode
        and: [keyShortCutEditor text size > 1])
        ifTrue: [
            OperatingSystem beep.
            MessageBox warning: 'Non alpha-numeric accelerators are not supported for runtime-less code generation.  Please enter either A-Z or 1-9.'].! !

!WindowBuilder methods !  
updateMenuFile

	(self menuTitled: 'File') updateEnabled.! !

!PRadioButtonGroup methods !
storeSpecificsOn: aStream indentString: indentString
    "Write out the list"
    self label isEmpty
        ifFalse: [
            aStream nextPutAll: ';'; cr;
                nextPutAll: indentString, 'label: ';
                nextPutStringConstant: self label].
    self numColumns > 1
        ifTrue: [
            aStream nextPutAll: ';'; cr;
                nextPutAll: indentString, 'numColumns: ', self numColumns asString].
    self contents isNil
        ifFalse: [
            (self contents isArray and: [self contents notEmpty])
                ifTrue: [
                    aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'contents: #( '.
                    self contents do: [:item |
                        aStream nextPutAll: item asQuotedString; space].
                    aStream nextPut: $)]].! !

!WBInterfaceObject methods !  
oldEventHandlerSelectorAt: aSymbol
	"Answer the first event handler at aSymbol as a string
		or an empty string if there is no handler defined."

	^((self wbRealWidget handlersOrNil ifNil: [^''])
		at: aSymbol asSymbol ifAbsent: [^''])
		asString! !

!WBModelObjectEditor methods ! 
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| addButton eventsButton eventsGroup mainView objectGroup 
	objectLabel sendLabel styleLabel whenLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	editButton := Button new.
	instVar := CheckBox new.
	name := WBEntryField new.
	nameLabel := StaticText new.
	objectList := ListBox new.
	removeButton := Button new.
	send := WBEntryField new.
	style := WBComboBox new.
	when := WBComboBox new.
	
		"Temporary Variables"
	addButton := Button new.
	eventsButton := Button new.
	eventsGroup := GroupBox new.
	objectGroup := GroupBox new.
	objectLabel := StaticText new.
	sendLabel := StaticText new.
	styleLabel := StaticText new.
	whenLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Model Object Editor';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -149 * xDU;
				topRatio: 1/2; topInset: -121/2 * yDU;
				rightRatio: 1/2; rightInset: -149 * xDU;
				bottomRatio: 1/2; bottomInset: -103/2 * yDU).
	self addView: mainView.
	
	objectList "ListBox"
		owner: self;
		setName: 'objectList';
		when: #changed: send: #objectSelected: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 22/49; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 49/2 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: objectList;
		subPaneWithFocus: objectList.
	
	addButton "Button"
		owner: self;
		setName: 'addButton';
		when: #clicked send: #add to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 2/147; leftInset: 0 * xDU;
				topRatio: 1; topInset: -41/2 * yDU;
				rightRatio: 22/147; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 9/2 * yDU);
		contents: 'Add';
		startGroup;
		font: SysFont.
	mainView addSubpane: addButton.
	
	editButton "Button"
		owner: self;
		setName: 'editButton';
		when: #clicked send: #edit to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 8/49; leftInset: 0 * xDU;
				topRatio: 1; topInset: -41/2 * yDU;
				rightRatio: 44/147; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 9/2 * yDU);
		contents: 'Edit';
		startGroup;
		font: SysFont.
	mainView addSubpane: editButton.
	
	removeButton "Button"
		owner: self;
		setName: 'removeButton';
		when: #clicked send: #remove to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 46/147; leftInset: 0 * xDU;
				topRatio: 1; topInset: -41/2 * yDU;
				rightRatio: 22/49; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 9/2 * yDU);
		contents: 'Remove';
		startGroup;
		font: SysFont.
	mainView addSubpane: removeButton.
	
	name "WBEntryField"
		owner: self;
		setName: 'name';
		when: #textChanged: send: #nameChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 83/147; leftInset: 0 * xDU;
				topRatio: 0; topInset: 18 * yDU;
				rightRatio: 45/49; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -30 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: name.
	
	styleLabel "StaticText"
		owner: self;
		setName: 'styleLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 10/21; leftInset: 0 * xDU;
				topRatio: 0; topInset: 34 * yDU;
				rightRatio: 82/147; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		rightJustified;
		contents: 'Style:';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: styleLabel.
	
	instVar "CheckBox"
		owner: self;
		setName: 'instVar';
		when: #clicked: send: #setIsInstVar: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 137/147; leftInset: 0 * xDU;
				topRatio: 0; topInset: 18 * yDU;
				rightRatio: 142/147; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -30 * yDU);
		contents: '';
		startGroup;
		font: SysFont.
	mainView addSubpane: instVar.
	
	nameLabel "StaticText"
		owner: self;
		setName: 'nameLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 10/21; leftInset: 0 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 82/147; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -32 * yDU);
		rightJustified;
		contents: 'Name:';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: nameLabel.
	
	sendLabel "StaticText"
		owner: self;
		setName: 'sendLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 24/49; leftInset: 0 * xDU;
				topRatio: 0; topInset: 72 * yDU;
				rightRatio: 86/147; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -84 * yDU);
		rightJustified;
		contents: 'Send:';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sendLabel.
	
	whenLabel "StaticText"
		owner: self;
		setName: 'whenLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 24/49; leftInset: 0 * xDU;
				topRatio: 0; topInset: 58 * yDU;
				rightRatio: 86/147; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -70 * yDU);
		rightJustified;
		contents: 'When:';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: whenLabel.
	
	style "WBComboBox"
		owner: self;
		setName: 'style';
		when: #changed: send: #setStyle: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 83/147; leftInset: 0 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 47/49; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -44 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: style.
	
	when "WBComboBox"
		owner: self;
		setName: 'when';
		when: #changed: send: #whenChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 29/49; leftInset: 0 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 46/49; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -68 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: when.
	
	send "WBEntryField"
		owner: self;
		setName: 'send';
		when: #needsPopupMenu send: #popupTargetMenu: to: self withArgument: send;
		when: #textChanged: send: #sendChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 29/49; leftInset: 0 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 130/147; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -82 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: send.
	
	eventsButton "Button"
		owner: self;
		setName: 'eventsButton';
		when: #clicked send: #setEvents to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 131/147; leftInset: 0 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 46/49; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -82 * yDU);
		contents: '...';
		startGroup;
		font: SysFont.
	mainView addSubpane: eventsButton.
	
	objectLabel "StaticText"
		owner: self;
		setName: 'objectLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 2/147; leftInset: 0 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 22/49; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Model Objects';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: objectLabel.
	
	eventsGroup "GroupBox"
		owner: self;
		setName: 'eventsGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 71/147; leftInset: 0 * xDU;
				topRatio: 0; topInset: 45 * yDU;
				rightRatio: 47/49; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -88 * yDU);
		contents: 'Events';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: eventsGroup.
	
	objectGroup "GroupBox"
		owner: self;
		setName: 'objectGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 68/147; leftInset: 0 * xDU;
				topRatio: 0; topInset: 8 * yDU;
				rightRatio: 48/49; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -94 * yDU);
		contents: 'Object';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: objectGroup! !

!WBTextEditWindow methods ! 
initWindowSize
        "Private - Answer the initial size of the receiver."
    ^20@20 extent: ((Display extent x - 40 min: 480) @ (Display extent y - 80))! !

!WindowBuilder methods !  
isMDIClient

	^false! !

!WBCodeModule methods !  
varNameFor: anObject put: aString
		"Set the variable name (temporary variable or instance variable)
			for the specified object."
	varNames at: anObject put: aString! !

!PStatusPane methods !
tabPosition: ignore! !

!WBBitmapManagerWindow methods !
writeBPLFile: path for: keysAndPools category: aCategory ids: idMap fileNames: fileNameMap

	| poolsAndKeys stream categories |
	categories := Array with: aCategory.
	poolsAndKeys := IdentityDictionary new.
	keysAndPools do: [:each |
		(poolsAndKeys at: each value ifAbsentPut: [SortedCollection new])
			add: each key].
	stream := File newFile: path fileName, '.bpl'.
	[poolsAndKeys associationsDo: [:each |
		each key
			fileOutBPL: stream pathName fileNameLessPath fileName, '.dll'
			keys: each value
			categories: categories
			ids: idMap
			on: stream.
	]] ensure: [stream close].! !

!PEntryFieldGroup methods ! 
attributeEditor

    ^WBListEditor! !

!WBScratchWindow class methods !   
defaultClass

    ^ WBDefaultScratchWindow! !

!WBInterfaceObject methods !   
layoutForm

	^(self parent ifNil: [^nil]) layoutForm! !

!WBEditClassDialog class methods !   
packageChoice: aString

    PackageChoice := aString! !

!WBLayoutForm methods !  
notifyModelOfSizeOrPositionChange

    self triggerEvent: #changed.
    self model isNil
        ifFalse: [self model newSizeOrPosition: self selections].! !

!Bitmap methods !
wbCopy8

    "Added by OSI"

    | newBitmap |

    #addedByOSI.
	newBitmap := WBBitmapClass new
            screenWidth8: self width
            height: self height.
	self displayIn: newBitmap boundingBox with: newBitmap pen.

    ^newBitmap! !

!PComboBox methods ! 
usesColor

    ^self isWindows95 or: [style ~~ #simpleList]! !

!PRadioButtonGroup methods !  
buttonPClass

    ^self buttonClass wbPseudoClass! !

!WBInterfaceObject methods !
isNonWindowParent

    ^self isComposite! !

!PropertyAccessor methods !  
wbDefaultAddStyleAction

	#addedByOSI.
	^nil! !

!WBTabPosition class methods !  
fromTabPosition: anInteger

    ^WBTabPosition new
        basicTabPosition: anInteger! !

!WBChooseClassDialog methods !
initWindow

    classListBox contents: (classList collect: [ :aClass |
                aClass name
            ]) asSortedCollection asOrderedCollection.

    default notNil ifTrue: [
        classListBox selection: default name.
    ] ifFalse: [
        classListBox contents notEmpty ifTrue: [
            classListBox selection: 1.
        ].
    ].

    allowOthers ifFalse: [
        (self paneNamed: 'nonWBView') hideWindow; disable.
    ].! !

!WBListEditor methods !  
sort

    list := list asSortedCollection asOrderedCollection.
    listBox  contents: list.! !

!PToggle methods !   
usesTitle

    ^true! !

!WBManagedPNLSString methods !   
extentFor: aFont
	"Answer the string extent of the receiver's value.
		If NLS-Autosize is enabled, then answer the maximum
		string extent of all NLS strings for that key."

	| pool extent string |
	extent := aFont wbStringExtent: self value.
	self nlsAutosize ifTrue: [
		(pool := self managedPool) notNil ifTrue: [
			pool categories do: [:each |
				(string := pool at: self key in: each ifAbsent: [nil]) isString ifTrue: [
					extent := extent max: (aFont wbStringExtent: string)]]]].
	^extent! !

!WBLayoutFrameEditor methods !   
currentFramingBlocks

	^currentFramingBlocks ifNil: [
		currentFramingBlocks := self currentWidgets collect: [:each |
			each framingBlock wbCopy]].! !

!WBPoolManagerWindow methods ! 
windowTitle

	^self class name! !

!WBLookPolicyWin31 methods !   
drawTitleBar: aFrameObject with: aPen in: aRect

    | titleRect titleTextRect |
    titleRect := aRect leftTop extentFromLeftTop: aRect width @ (self titleBarHeightFrom: aFrameObject).
    aFrameObject hasTitleBar
        ifTrue: [
            aPen fill: titleRect color: Color activeTitleBar.
             self
                drawTitleBarText: aFrameObject
                with: aPen
                in: (titleTextRect := self titleRectFrom: aFrameObject).
            aPen
                foreColor: Color windowBorder;
                wbLineFrom: titleRect left @ (titleRect bottom up: 1) to: titleRect right @ (titleRect bottom up: 1)].
    (aFrameObject style includes: #sysmenu)
        ifTrue: [
            self
                drawSystemMenuWith: aPen
                at: ((titleRect leftTop leftAndUp: 1)
                    extentFromLeftTop: (self systemMenuWidth @ (self titleBarHeightFrom: aFrameObject)) + 1)].
    (aFrameObject style includes: #maximize)
        ifTrue: [
            self
                drawMaximizeButtonWith: aPen
                at: ((titleRect rightTop leftAndUp: self maximizeButtonSize x @ 1)
                    extentFromLeftTop: self maximizeButtonSize + 1)].
    (aFrameObject style includes: #minimize)
        ifTrue: [
            (aFrameObject style includes: #maximize)
                ifTrue: [
                    self
                        drawMinimizeButtonWith: aPen
                        at: ((titleRect rightTop leftAndUp: self minimizeButtonSize x + self maximizeButtonSize x @ 1)
                            extentFromLeftTop: self minimizeButtonSize + 1)]
                ifFalse: [
                    self
                        drawMinimizeButtonWith: aPen
                        at: ((titleRect rightTop leftAndUp: self minimizeButtonSize x @ 1)
                            extentFromLeftTop: self minimizeButtonSize + 1)]].
    aFrameObject isDialog
        ifTrue: [
            aPen
                foreColor: Color white;
                wbLineFrom: titleRect leftTop to: titleRect leftBottom;
                wbLineFrom: titleRect leftTop to: (titleRect rightTop left: 1);
                wbLineFrom: (titleRect rightTop left: 1) to: (titleRect rightBottom left: 1)].! !

!WBMenu methods ! 
isDisabled: item
        "Answer true if item is disabled.
         item can be the label or the selector."
	^(self getMenuItem: item) isDisabled.! !

!WBLookPolicyWin95 methods !  
leftJustification

    ^"SsLeftnowordwrap" 12! !

!WBCreateClassDialog methods !  
envyApplicationChoices

    "Compute the list of applications in which the user could save the window
    class. Check that each such app:
      - is an edition
      - could be a scratch, iff that class already exists in that app
     -  it or its root application has WindowBuilderProRuntime has a prereq
     -  the current user is a group member in this application."

    | wbproApp appChoices user |
    CursorManager execute change.
    wbproApp := Smalltalk at: #WindowBuilderProRuntime.
    appChoices := (Smalltalk at: #Application) currentlyLoaded select: [:app |
        app allPrerequisites includes: wbproApp].
    appChoices := appChoices
        inject: appChoices asOrderedCollection
        into: [:apps :app | apps addAllLast: app allSubApplications; yourself].
    appChoices addAllLast: wbproApp withAllSubApplications.
    user := (Smalltalk at: #User) current.
    appChoices := appChoices select: [:each | each isEdition and: [
        each groupMembers includes: user]].
    CursorManager normal change.
    ^(appChoices collect: [:app | app name]) asSortedCollection asArray
! !

!WBMenu methods !  
getIndex: object ifAbsent: aBlock
        "Private - Answer the index for object.
         Evaluate aBlock if no such object.
         object can be the label or the selector or an index."
    | tempItem plainObject |
    ( object class == String)
        ifTrue: [
            plainObject := object reject: [:c | c = $& | ( c = $~)].
            tempItem := items
                detect: [:item |
                    item label isString
                    and: [( item label reject: [:c | c = $& | ( c = $~)]) = plainObject]]
                ifNone: [^aBlock value]]
        ifFalse: [
            tempItem := items
                detect: [:item |
                    item selector = object
                    or: [(item selector isMessage and: [item selector selector = object])
                    or: [item label = object]]]
                ifNone: [object isInteger ifTrue: [^object] ifFalse: [^aBlock value]]].
    ^items indexOf: tempItem! !

!WBEditClassDialog class methods ! 
defaultChoice

    ^'<Any>'! !

!WindowBuilder methods !  
newWindowSize: aPoint
    self updateSize: (self prototype shell origin extentFromLeftTop: aPoint).! !

!WBMenuEditor methods !
shiftRight

    menuItemsEditor indentSelection.! !

!WBEnhancedEntryFieldEditor methods !
getJustification: aPane

    aPane contents: self justificationDict keys asSortedCollection asArray! !

!WBTabOrderLayoutForm methods !   
shellHandles
    "Answer the value of shellHandles."
	^#()! !

!WBInterfaceObject methods !   
setStyleFrom: aRealStyle

	aRealStyle isNil
		ifTrue: [^self style: self defaultStyle].
	self style: (self class styleFrom: aRealStyle).! !

!PropertyAccessor methods !
wbPoolName

	#addedByOSI.
	^(self propertyAt: #wbPoolName) ifNil: [
		self wbPoolName: self wbDefaultPoolName]! !

!WBMultiToolPalette methods !
restoreAllBitmaps

    self pages do: [:page |
        page do: [:tool |
            tool bitmap handle]].! !

!WBTreeListBox methods ! 
usesFocus

    ^false! !

!WBTreeNode methods !   
moveUp

    | prevSibling parentSibling |

    self isRoot ifTrue: [
        ^self
    ].

    (prevSibling := self previousSibling) notNil ifTrue: [
        parent removeChild: self.
        parent addChild: self beforeNode: prevSibling.
    ] ifFalse: [
        parentSibling := parent previousSibling.
        (parentSibling notNil) ifTrue: [
            parent removeChild: self.
            (prevSibling := parentSibling lastChild) notNil ifTrue: [
                parentSibling addChild: self afterNode: prevSibling.
            ] ifFalse: [
                parentSibling addChild: self.
            ].
        ].
    ].! !

!WindowBuilder methods !
triggerAboutToChange
	"Trigger the about to change event."

	self triggerEvent: #aboutToChange.! !

!WBCreateClassDialog methods !   
inTeamV

	^self wbEditorClass teamIsInstalled! !

!WBResizeBitmap methods !   
isButtonBitmap: aBoolean pane: aPane

    "Callback for the #clicked: event in buttonBitmap [CheckBox].
        (Generated by WindowBuilder Pro)"

    self oldWidth: (
        aBoolean
            ifTrue: [self oldWidth // 2]
            ifFalse: [self oldWidth * 2]).
    self newWidth: (
        aBoolean
            ifTrue: [self newWidth // 2]
            ifFalse: [self newWidth * 2]).
    self mainView labelWithoutPrefix: (
        aBoolean
            ifTrue: ['Resize Button']
            ifFalse: ['Resize Bitmap']).! !

!WBModelCodeModule methods ! 
instVars

    ^self object! !

!WBLookPolicy class methods !  
isOS2

    ^OperatingSystem isOS2! !

!WindowBuilder methods !
statusPaneHelp: aKey
    "Answer the default dictionary used by
    the status bar for help support"

    ^self class helpDict
        at: (aKey ifNil: [^nil])
        ifAbsent: [
            self class helpDict
                at: aKey asString
                ifAbsent: [
                    self class helpDict
                        at: aKey asString asSymbol
                        ifAbsent: ['Execute the ', aKey asString, ' command.']]].! !

!WBGeometryManager methods ! 
resizeSelectedWidgets: aPoint
    "Resize the selected widgets to a size defined by <aPoint>"

    self selections isEmpty ifTrue: [^self].
    self hideHandles.
    self selections do: [:aWidget |
        aWidget
            configureWidget: aWidget x
            y: aWidget y
            width: ((aPoint x max: aWidget wbMinSize x) min: aWidget wbMaxSize x)
            height: ((aPoint y max: aWidget wbMinSize y) min: aWidget wbMaxSize y)
            borderWidth: aWidget borderWidth;
            wbUpdateConstraints].
    self updateWidget.! !

!WBCreateMenuModule methods !
defaultShouldLogMethodSource
	"Answer true if the receiver's source should be logged."

	^super defaultShouldLogMethodSource 
		and: [self wbEditorClass licensed]! !

!Class methods ! 
wbEdit
    "Open window builder on the receiver."

	^WindowBuilder new openOn: self! !

!WindowBuilder methods ! 
menuOptionsUseFence

	| aBoolean |
	aBoolean := self class togglePropertyValueAt: #UseFence.
	self updateOptionsMenu.
	self layoutForm isNil
		ifFalse: [self layoutForm useFence: aBoolean]! !

!PWBStaticGraphic methods !  
importantEvents

    ^super importantEvents
        remove: #clicked;
        yourself! !

!WBGeometryManager methods ! 
collectForward: targets
    "Collect the <targets> forward in the z-order"

    | index collection |
    targets size > 1 ifFalse: [^self].
    targets size == self children size
        ifTrue: [^self bringToFront: targets].

    index := self children indexOf: targets first.
    collection := self children select: [:child |
        (self children indexOf: child) < index
        and: [(targets includes: child) not]].
    collection
        addAllLast: targets;
        addAllLast: (self children select: [:child |
        (self children indexOf: child) > index
        and: [(targets includes: child) not]]).
    self bringToFront: collection! !

!CompositePane class methods ! 
wbReservedInstVarNames
		"Answer a collection of reserved inst var names."
	^CompositePane allInstVarNames! !

!WBLookPolicyWin31 methods !   
drawLeftArrowWith: aPen at: aRect

    | innerRect side |
    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class leftArrow
                from: self class leftArrow boundingBox
                to: aRect]
        ifFalse: [
            innerRect := self draw3DBoxWith: aPen at: aRect.
            side := (innerRect width min: innerRect height) // 7.
            aPen
                polygonFilled: (Array
                    with: (innerRect center left: side + 3)
                    with: (innerRect center rightAndUp: (side - 2) @ (side * 2 + 1))
                    with: (innerRect center rightAndDown: (side - 2) @ (side * 2 + 1)));
                fill: ((innerRect center rightAndUp: (side*2-2) @ (side + Rectangle leftTopUnit y))
                    extentFromLeftTop: (side*2+1) @ (side*2+1)) color: Color black].! !

!WBCompositePaneScratchWindow class methods !
defaultClass

    ^WBDefaultCompositePaneScratchWindow! !

!PStatusPane methods ! 
statusBoxes

	^statusBoxes ifNil: [statusBoxes := OrderedCollection new]! !

!WindowBuilder class methods !   
nlsAutosize

    ^self editorClass
        propertyValueAt: #NlsAutosize
        category: self editorPropertyString! !

!WBCreatePowerViewsModule methods !
createMultipleViewsSelector
		"Answer the create mulitple views selector."
	^#createViewsFor:owner:! !

!WBScrapbookRetrieve methods !
openOn: aPane

	scrapbook := self wbEditorClass scrapbook.
	layoutPane := aPane.
	self open! !

!WBEditClassDialog class methods !  
addToFrequentList: aClass

    self frequentClasses add: aClass! !

!WBAboutDialog methods !  
ok
	"If the property is set, then reinitalize the Notifier."

	self shouldInitTranscript
		ifTrue: [
			(Message 
				receiver: self wbEditorClass 
				selector: #initTranscriptMenuDelayed) 
					performDeferred].
	self close.! !

!WBAbstractPrompter class methods ! 
prompt: promptString default: defaultObject
	"Prompt for an entry in a list."

	^self new
		prompt: promptString
		title: self defaultTitle
		default: defaultObject! !

!WBEventManagerWindow class methods !
warningClasses: aCollection

	"
	WBEventManagerWindow warningClasses: nil.
	"

	warningClasses := aCollection.! !

!WBLayoutForm methods !
gridSize

    ^self model isNil
        ifTrue: [4 @ 4]
        ifFalse: [self model gridSize]! !

!WBPropertyEditor methods !  
ok

    changes associationsDo: [:assoc |
        assoc key value: assoc value].
    self close! !

!WBPoolManagerWindow methods !  
categoryPath
	"Answer the path of the currently selected category."

	^(self selectedPool ifNil: [^nil])
		fileNameFor: (self selectedCategory ifNil: [^nil])! !

!WBClassDefinition methods !  
createClass
        "Create/modify the class if necessary."
    self hasPoolNamesChanged
        | self hasInstVarsChanged
        | self forceUpdate
            ifTrue: [self basicCreateClass].! !

!Object class methods ! 
wbReservedInstVarNames
		"Answer a collection of reserved inst var names."
	^#( )! !

!WBFontManagerWindow methods !  
menuPoolFileOut: aPath
	"File out the selected pools."

	| stream fileStream |
	CursorManager execute changeFor: [
		stream := self newCodeStream.
		self selectedPools do: [:each | each fileOutOn: stream].
		fileStream := File newFile: aPath.
		[fileStream nextPutAll: stream contents] ensure: [fileStream close]].! !

!WBMenuEditor methods !  
accelCheckBoxChanged: selection

    selection ifFalse: [keyShortCutEditor text: ''].! !

!PropertyAccessor methods ! 
wbNLSAccessor: aBoolean
	"Set true if the receiver is an NLS accessor."

	^self propertyAt: #wbNLSAccessor put: aBoolean! !

!WBEventManagerWindow class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowFrameObject methods ! 
menuEditor

    ^WBMenubarEditor new! !

!WBCallOutModule methods !   
filterEventTable: anEventTable for: anObject
	"Answer the event table for anObject."

	| answer selfOrPane actions |
	answer := anObject wbRealWidget eventTableCreate.
	(selfOrPane := OrderedCollection new)
		add: #self;
		add: self view prototype targetObject;
		add: anObject wbWrapper;
		add: anObject wbRealWidget.

	"Cannot do this because the inst var may not be defined when the callout method is called."
	"
	self view prototype targetObject validInstVars associationsDo: [:each |
		selfOrPane
			add: each key wbWrapper;
			add: each key wbRealWidget].
	"

	anEventTable associationsDo: [:eachAssoc |
		actions := nil.
		eachAssoc value asActionSequence do: [:eachMsg |
			(selfOrPane includes: eachMsg receiver) ifTrue: [
				actions := actions isNil
					ifTrue: [eachMsg asActionSequence]
					ifFalse: [actions copyWith: eachMsg]]].
		actions notNil ifTrue: [
			answer at: eachAssoc key put: actions]].
	^answer! !

!WBEventMessage methods ! 
actionList
	"Answer the action list containing the receiver."

	^(self source ifNil: [^nil]) actionListForEvent: (self event ifNil: [^nil])! !

!WBCodeStream methods !  
endExpression
		"Signal end of expression."
	endChar := $. .! !

!WBNLSSubPool methods !  
fileOutHeaderOn: aStream
	"File out the receiver's header."

	super fileOutHeaderOn: aStream.
	aStream cr.
	self stringDictionaryReaderClass
		fileOutCategoryName: self category on: aStream;
		fileOutCategoryFileName: self fileName on: aStream;
		fileOutCategoryBeginOn: aStream.! !

!Message methods !  
wbCollectArguments: evaluationArguments
		"Private - answer the action arguments with which to evaluate
		the receiver, collecting from the <evaluationArguments>
		and the predefined arguments in the receiver. 
		NOTE: put evaluation arguments at the *end* of the predefined arguments"

	| predefinedArgs |
	#addedByOSI.
	predefinedArgs := self arguments.
	^(evaluationArguments size = predefinedArgs size)
		ifTrue: [evaluationArguments]
		ifFalse:
			[(predefinedArgs isNil
				ifTrue: [predefinedArgs := Array new: (self class numberOfArgumentsFor: selector)]
				ifFalse: [predefinedArgs copy])
					replaceFrom: (predefinedArgs size - evaluationArguments size + 1 max: 1)
					to: predefinedArgs size
					with: evaluationArguments
					startingAt: 1]! !

!WBKeyAccel methods !
isShift: bool

    isShift := bool! !

!EnhancedEntryField class methods !
okFieldMethods
		"Answer a collection of field validation selectors."
    ^((self methodDictionary keys select: [ :selector |
        (selector at: 1) = $o and: [
        (selector at: 2) = $k and: [
        (selector at: selector size) ~= $:]]])
            collect: [ :selector |
            selector asString copyFrom: 3 to: selector size ]) asSortedCollection! !

!PDrawnButton methods !  
bitmapExtent

    | bitmap extent |
    bitmap := WBBitmapClass fromFile: self contents.
    extent := bitmap extent.
    bitmap release.
    ^extent! !

!WindowFrameObject methods !
borderWidth

    ^self lookPolicy
        borderWidthFrom: self! !

!WBCallOutEditor methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| add callOutLabel cancel mainView ok panesLabel remove 
	selectorLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	callOutList := ListBox new.
	panesList := MultipleSelectListBox new.
	selector := EntryField new.
	
		"Temporary Variables"
	add := Button new.
	callOutLabel := StaticText new.
	cancel := Button new.
	ok := Button new.
	panesLabel := StaticText new.
	remove := Button new.
	selectorLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Call Out Editor';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -245/2 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -68 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -245/2 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -68 * yDU).
	self addView: mainView.
	
	panesList "MultipleSelectListBox"
		owner: self;
		setName: 'panesList';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -104 * xDU;
				bottomRatio: 0; bottomInset: -132 * yDU);
		extendedSelect;
		startGroup;
		font: SysFont.
	mainView
		addSubpane: panesList;
		subPaneWithFocus: panesList.
	
	add "Button"
		owner: self;
		setName: 'add';
		when: #clicked send: #add to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 106 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -140 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		contents: '>>';
		startGroup;
		font: SysFont.
	mainView addSubpane: add.
	
	remove "Button"
		owner: self;
		setName: 'remove';
		when: #clicked send: #remove to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 106 * xDU;
				topRatio: 0; topInset: 30 * yDU;
				rightRatio: 0; rightInset: -140 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		contents: '<<';
		startGroup;
		font: SysFont.
	mainView addSubpane: remove.
	
	callOutList "ListBox"
		owner: self;
		setName: 'callOutList';
		when: #clicked: send: #callOutSelected: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 142 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -242 * xDU;
				bottomRatio: 0; bottomInset: -98 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: callOutList.
	
	selector "EntryField"
		owner: self;
		setName: 'selector';
		when: #textChanged: send: #selectorChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 142 * xDU;
				topRatio: 0; topInset: 100 * yDU;
				rightRatio: 0; rightInset: -242 * xDU;
				bottomRatio: 0; bottomInset: -112 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: selector.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 142 * xDU;
				topRatio: 0; topInset: 114 * yDU;
				rightRatio: 0; rightInset: -190 * xDU;
				bottomRatio: 0; bottomInset: -132 * yDU);
		defaultPushButton;
		contents: 'OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 194 * xDU;
				topRatio: 0; topInset: 114 * yDU;
				rightRatio: 0; rightInset: -242 * xDU;
				bottomRatio: 0; bottomInset: -132 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	selectorLabel "StaticText"
		owner: self;
		setName: 'selectorLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 106 * xDU;
				topRatio: 0; topInset: 102 * yDU;
				rightRatio: 0; rightInset: -140 * xDU;
				bottomRatio: 0; bottomInset: -110 * yDU);
		rightJustified;
		contents: 'Selector:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: selectorLabel.
	
	callOutLabel "StaticText"
		owner: self;
		setName: 'callOutLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 142 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -242 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Call Outs';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: callOutLabel.
	
	panesLabel "StaticText"
		owner: self;
		setName: 'panesLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -94 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Objects';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: panesLabel! !

!WBMenuEditor methods !
shiftLeft

    menuItemsEditor exdentSelection.! !

!WBOutboardWindow methods !   
prototype

	^self owner prototype! !

!WBLookPolicy methods ! 
drawHorizontalScrollBar: aScrollBar with: aPen clipRect: clipRect

    self drawHScrollBarWith: aPen at: aScrollBar rect.! !

!WBVersionCodeModule methods !  
defaultCategory
		"Answer the default category for the receiver."
	^'WBPro Private'! !

!WBLayoutWizard methods ! 
enableFields

    #('attributeClass' 'widgetType' 'instVarButton' 'otherTypeButton' 'setDefaultTypeButton'
        'widgetUpdatesModelButton' 'modelUpdatesWidgetButton' 'modelInitializesWidgetButton') do: [:name |
        (self paneNamed: name) enable].
    (self paneNamed: 'classLabel') foreColor: Color black.
    (self paneNamed: 'widgetTypeLabel') foreColor: Color black.! !

!WBLookPolicyWin95 methods ! 
maximizeButtonSize

    ^16 @14! !

!PRadioButtonGroup methods !  
children: aCollection

    children := aCollection! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!DoubleByteSymbol methods !   
wbFullCopyReal: aDictionary
	"Answer a copy of the receiver which shares
		 the receiver instance variables.  Because
		 the receiver is unique (cannot be copied),
		 answer the receiver."

	#addedByOSI.
	^self! !

!WBLayoutWizard class methods !   
defaultMenus

    ^DefaultMenus ifNil: [DefaultMenus := self initializeDefaultMenus]! !

!PCompositePane methods !
framingBlock: framer
	| width |
	(self style == #mdiToolBar or: [self style == #mdiToolBarBordered])
		ifFalse: [^super framingBlock: framer].
	width := parentWindow isNil
		ifTrue: [300]
		ifFalse: [parentWindow rect width].
	framingBlock := LayoutFrame new
		leftRatio: 0; leftInset: 0;
		topRatio: 0; topInset: 0;
		rightRatio: 1; rightInset: 0;
		bottomRatio: 0; bottomInset: self suggestedSize y negated.! !

!PWBVerticalScrollBar methods !
winClassStyle

    ^SbsVert! !

!WBTreeNode methods ! 
listString: aString

   listString := aString wbManagedValueFor: self.
   currentString := listString wbManagedValue.

    self depth timesRepeat: [
        currentString := self indentString, currentString.
    ].! !

!WBModelDefinitionEditor methods !
isDirty

    ^dirty! !

!WBTreeNode methods ! 
deleteMessage

    ^
'Deleting this item will cause subitems to be irretrievably destroyed.                                 Do you wish to do so?'! !

!WBCodeGenerator methods !
addModule: aCodeModule
		"Add a code module to the list of code modules to be processed.
			If a code module already exists for that class and selector,
			then ignore."
	(modules
		at: (aCodeModule targetClass ifNil: [ ^self addModuleToProcess: aCodeModule ])
		ifAbsentPut: [ IdentityDictionary new ])
			at: (aCodeModule messageSelector ifNil: [ ^self addModuleToProcess: aCodeModule ])
			ifAbsentPut: [
				self addModuleToProcess: aCodeModule.
				aCodeModule ].! !

!PEnhancedEntryField methods !   
importantEvents

    ^super importantEvents
        add: #objectChanged: after: #changed:;
        add: #objectChanging: after: #changed:;
        yourself! !

!WBModelGetModule methods !
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self generateGeneratedSymbol.
        self stream cr; nextPut: $^; nextPutAll: self object name.
        self object initialized & self object lazy
            ifTrue: [
                self stream
                    space; nextPutAll: 'ifNil: [';
                    nextPutAll: self object name; nextPutAll: ' := '.
                self object initializeValue notNil
                    ifTrue: [self stream nextPutAll: self object initializeValue storeString; nextPut: $]]
                    ifFalse: [self stream nextPutAll: self object valueClass name; nextPutAll: ' new]']]].! !

!Window methods !  
wbDuplicateTo: anObject
	"Answer a duplicate of the receiver."

	#addedByOSI.
	^self wbPropertyManager wbDuplicateFrom: self to: anObject! !

!PropertyAccessor methods !   
wbGetValueFor: anObject
    "Private - Answer the value of the property."

	#addedByOSI.
	^self getValueFor: anObject! !

!WBCreateClassDialog methods !
defaultSuperClass

    ^self class defaultSuperClass! !

!WBBitmapManager methods !   
convertBitmapsFromModuleToImage
		"Convert all bitmaps that are loaded from a module (resource DLL)
			to bitmaps that are stored in the image."
		"
		To convert ALL window builder bitmaps, evaluate
			WBBitmapManager convertBitmapsFromModuleToImage.

		To convert the window builder SYSTEM bitmaps, evaluate
			WBBitmapManager system convertBitmapsFromModuleToImage.

		To convert the window builder USER bitmaps, evaluate
			WBBitmapManager current convertBitmapsFromModuleToImage.
		"

	self pools do: [:each | each convertBitmapsFromModuleToImage].! !

!WBLayoutForm methods !  
colorChange
        "Private - Window's color has changed."
	self shell notNil 
		ifTrue: [
			self shell resetColors.
			self children do: [:widget | widget resetColors].
			self invalidateRect: self rectangle].! !

!WBFontSelectionWindow methods ! 
openFontDialogOn: aWindowBuilder
	"No fonts/pools to select from, so open the font dialog."

	| aFont |
	owner := aWindowBuilder.
	self currentWidgets: self owner selections.
	self currentWidgets notEmpty ifTrue: [
		(aFont := self promptForFont: self currentWidgets first font) notNil ifTrue: [
			self
				selectedFont: aFont;
				applyChange]].! !

!WBCreateMenuModule methods ! 
defaultMessageSelector
		"Private - Answer the default message selector."
	^self class defaultMessageSelector! !

!RangeControl class methods !   
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        add: (SelectorPropertyAccessor new name: 'Minimum'; get: #minimum; set: #minimum: ; format: 'Integer');
        add: (SelectorPropertyAccessor new name: 'Maximum'; get: #maximum; set: #maximum: ; format: 'Integer');
        add: (SelectorPropertyAccessor new name: 'Position'; get: #position; set: #position: ; format: 'Integer');
        add: (SelectorPropertyAccessor new name: 'Line Increment'; get: #lineIncrement; set: #lineIncrement: ; format: 'Integer');
        addNames: #('Minimum' 'Maximum' 'Position' 'Line Increment') toPage: 'Range';
        wbAddEvent: (
            WBEventDescription new
                event: #previousLine;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #changed:;
                argumentNames: #('position'));
        wbAddEvent: (
            WBEventDescription new
                event: #nextLine;
                argumentNames: #( ));
        yourself! !

!WBTreeNode methods ! 
copySpecificsTo: copy! !

!Bitmap class methods !   
buttonWidth: w height: h
	"Private - WBPro Development.
		Create a new tool bar button bitmap template"

	#addedByOSI.
	^(self screenWidth: w * 2 height: h) wbInitButton! !

!WBPoolManagerWindow methods !   
updateActiveCategoryMenu

	| all |
	all := self allCategories.
	self activeCategoryMenu
		removeAllItemsDynamically.
	(all copyFrom: 1 to: (all size min: 24)) do: [:each |
		self activeCategoryMenu
			appendItemDynamically: each
			selector: (
				Message
					receiver: self
					selector: #menuActiveSet:
					arguments: (Array with: each))].
	all size > 24 ifTrue: [
		self activeCategoryMenu
			appendSeparator;
			appendItemDynamically: 'Other...' selector: #menuActiveSetOther].
	self updateActiveCategoryMenu: self poolManager activeCategory.! !

!WBLayoutWizard methods !   
inspectInstance

    sourceInstance inspect.
! !

!WBTreeListBox methods !   
defaultStyle

    "Private"

   ^style := self basicStyle |
                WsBorder |
                WsVscroll |
                WsHscroll |
                LbsNotify  |
                LbsNointegralheight  |
                LbsOwnerdrawfixed! !

!WBLocator methods ! 
object

        ^receiver! !

!WBUndoManager methods !
add: aString undo: aBlock redo: aBlock2

    ^self add:
        (WBUndoAction
            label: aString
            undo: aBlock
            redo: aBlock2)! !

!WBLayoutForm methods !  
addHandlesFor: aWidget

    | added |
    added := OrderedCollection
        with: (WBHandle on: aWidget at: #topLeft)
        with: (WBHandle on: aWidget at: #topRight)
        with: (WBHandle on: aWidget at: #bottomLeft)
        with: (WBHandle on: aWidget at: #bottomRight).

    self handles addAll: added.
    ^added! !

!WBEntryListPrompter methods !  
default: aString

	result := aString.
	self listField text: aString.! !

!String methods !   
wbValidTriggeredSelectorFor: anEvent
	"Answer a valid triggered method selector
		for anEvent based upon the receiver."

	| result src dst word |
	#addedByOSI.
	result := self select: [:char | char = $: | char isAlphaNumeric].
	result isEmpty ifTrue: [^''].
	result first isDigit ifTrue: [result := 'a', result].
	(Message numberOfArgumentsFor: result) = 0 ifTrue: [^result].
	src := ReadStream on: result.
	dst := WriteStream on: (String new: result size + 20).
	[src atEnd] whileFalse: [
		(word := src upTo: $:) notEmpty ifTrue: [
			word first isDigit ifTrue: [word := 'a', word].
			dst nextPutAll: word , ':']].
	^dst contents! !

!WBNLSDictionaryReader class methods ! 
commentStartString

	^'/* '! !

!WBBitmapPool methods !   
fileOutBPL: aFileName keys: keyCollection categories: categoryCollection
	ids: idMap on: aStream
	"File out the receiver's contents."

	| aSubPool |
	self fileOutHeaderOn: aStream.
	categoryCollection asSortedCollection do: [:each |
		(aSubPool := self subPoolFor: each) notNil ifTrue: [
			aSubPool
				fileOutBPL: aFileName
				keys: keyCollection
				ids: idMap
				on: aStream]].
	self fileOutFooterOn: aStream.! !

!PWBToolBar methods !  
storeSpecificsOn: aStream indentString: indentString

	| bitmapKey |
	self useSystem
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'useSystem: true']
		ifFalse: [
			self cellSize = self defaultCellSize
				ifFalse: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'cellSize: ', self cellSize printString]].
	aStream 
		nextPutAll: ';'; cr; nextPutAll: indentString, 'fontExtent: ', ((SysFont width @ SysFont height) / (16@32)) printString.  "alternately (WindowDialog unitMultiplier / WindowDialog dialogUnit)"
	self vertical
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'vertical'].
	self elements do: [:element |
		((element bitmapSelector notNil and: [element bitmapSelector notEmpty])
			or: [element bitmap isBitmap])
			ifTrue: [
				aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'add: '.
				element bitmap isBitmap
				ifTrue: [
					aStream
						nextPutBitmap: element bitmap;
						nextPutAll: ' selector: ']
				ifFalse: [
					bitmapKey isNil
						ifTrue: [
							element bitmapSelector trimBlanks = element selector trimBlanks
								ifFalse: [bitmapKey := '#', element bitmapSelector trimBlanks]].
					bitmapKey notNil
						ifTrue: [aStream nextPutAll: bitmapKey; nextPutAll: ' selector: ']].
				(element selector isNil or: [element selector isEmpty])
					ifTrue: [aStream nextPutAll: 'nil']
					ifFalse: [aStream nextPut: $#; nextPutAll: element selector asString].
				element numSpaces > 0
					ifTrue: [aStream nextPutAll: ' spaces: '; nextPutAll: element numSpaces asString].
				(element rbSelector notNil and: [element rbSelector notEmpty])
					ifTrue: [aStream nextPutAll: ' rbSelector: #'; nextPutAll: element rbSelector asString]]].! !

!WBEditClassDialog class methods !  
recentClassMaxSize

    ^12! !

!WindowBuilder methods !  
updateParent

    | parentWB |
    (parentWB := self mainView propertyAt: #parentWB) isNil
        ifFalse: [parentWB isMDIChild | parentWB isMDIClient ifTrue: [^nil].
            (self mainView propertyAt: #creatingNewComposite) == true
                ifTrue: [
                    (MessageBox confirm: 'Replace original widgets with new CompositePane?')
                        ifTrue: [parentWB layoutForm replaceSelectionsWithComposite: self editedClass].
                    self mainView propertyAt: #creatingNewComposite put: false]
                ifFalse: [
                    parentWB isMDIClient
                        ifFalse: [parentWB refresh]].
            self mainView setFocus].! !

!PScrollBar methods !  
readSpecificsFrom: aWidget

    self
        minimum: aWidget minimum;
        maximum: aWidget maximum;
        lineIncrement: aWidget lineIncrement;
        pageIncrement: aWidget pageIncrement.! !

!WBLayoutForm methods !  
nlsKeyFor: aString

    ^self model nlsKeyFor: aString! !

!WindowBuilder methods !   
setParts
	"Open a WB-PARTS Interface Window."

	| editorClass |
	self class partsSupportIsInstalled
		ifFalse: [^MessageBox message: 'PARTS support not installed'].
	self wbEditorClass partsSupportEnabled
		ifFalse: [^MessageBox message: 'PARTS support not enabled'].
	"self theEditedClass isScratchWindow ifTrue: [
		^MessageBox message: 'Save window before editing PARTS interface.']."
	editorClass := Smalltalk at: #WBPARTSInterfaceEditor.
	(self isOkToOpen: editorClass)
		ifFalse: [^self].
	self invoke: editorClass! !

!WBStandardCodePolicy methods !   
basicRemoveSelector: aSelector fromClass: aClass
		"Remove aSelector from the specified class."
	aClass removeSelector: aSelector.! !

!WBPoolManagerWindow methods ! 
checkNewCategory: aCategory
	"Answer the new category or nil."

	^aCategory! !

!WBNLSManager methods !  
codeKeyClass
	"Answer the named method class field, so that the
		code generator can generate expressions such as
		'Bitmap named: <aKey>'   or   'Font named: <aKey>'."

	^self == self class current
		ifTrue: [String] ifFalse: [nil]! !

!PToggle methods !   
displayWith: aPen clipRect: aRect

    self lookPolicy
        drawCheckBox: self
        with: aPen
        clipRect: aRect! !

!WBEventMessage methods ! 
arguments
	"Answer the arguments for the receiver."

	^super arguments ifNil: [self defaultArguments]! !

!WBAbstractCodeModule methods !
createMethod
		"Private - Create the method."
	^self policy createMethodFor: self! !

!WBScrollingPane methods !  
amountToScrollUp

    ^10! !

!WBInterfaceObject methods !
winUserStyle

    ^0! !

!WBNLSDictionaryReader class methods !   
fileOutToken: aToken value: aString inCommentOn: aStream
	"File out a token/value pair inside a comment."

	aStream
		cr;
		nextPutAll: self commentStartString;
		nextPutAll: aToken;
		nextPutAll: ' "'.
	aString do: [:ch |
		aStream nextPut: ch.
		ch = $" ifTrue: [aStream nextPut: $"]].
	aStream
		nextPut: $";
		nextPutAll: self commentEndString.! !

!WBGraphicObject methods !
minSize

    ^1@1! !

!PMultipleSelectListBox methods !   
winClassStyle

    ^super pmClassStyle | LbsMultiplesel! !

!WBLayoutWizard methods ! 
otherType

    | newType widgetMap valueClass |
    (newType := (WBChoosePaneDialog new
        classList: (SubPane allSubclasses reject: [:class |
            (class symbol beginsWith: ' ') | class isWBInternalClass])) result) isNil
        ifTrue: [^self].
    widgetMap := self class widgetMap.
    valueClass := attributesList selectedItem object valueClass.
    (widgetMap includesKey: valueClass)
        ifTrue: [(widgetMap at: valueClass) addFirst: newType symbol]
        ifFalse: [widgetMap at: valueClass put: (OrderedCollection with: newType symbol)].
    self setWidgetType: newType symbol.
    widgetType
        contents: (self widgetTypesFor: attributesList selectedItem object);
        value: newType symbol
    ! !

!WBEventManagerWindow methods !  
eventListDoubleClick: selectedItem
	"Callback for the #doubleClicked: event in eventListBox [MultipleSelectListBox]
	(Generated by WindowBuilder Pro)"

	self menuHandlerAdd.! !

!PButton methods !
styles

    ^self wbEditorClass runtimeLessCode
        ifTrue: [#(#pushButton #defaultPushButton)]
        ifFalse: [#(#pushButton #defaultPushButton #cancelPushButton)]! !

!WBENVYCodePolicy methods !  
basicCompileMethodFor: aCodeModule
        "Private - Compile and store the method.
			Answer an association with key = selector and value = compiled method
			if sucessful, else answer nil."

	#osiHack.
	"Needs to answer an association with key = selector and value = compiled method"

    aCodeModule shouldLogMethodSource
			ifFalse: [^self createMethod: aCodeModule sourceString in: aCodeModule targetClass].
    ^aCodeModule targetClass
			compileAsPrivate: aCodeModule sourceString
			notifying: nil
			ifNewAddTo: aCodeModule targetClass controller.! !

!WBFontSelectionWindow methods !  
openFontManager

	"Callback for the #clicked event in managerButton [Button].
		(Generated by WindowBuilder Pro)"

	self owner class openFontManager.! !

!WBSubPool methods ! 
fileOutKeys: aCollection on: aStream
	"File out the receiver's contents."

	| assoc |
	self fileOutHeaderOn: aStream.
	aCollection asSortedCollection do: [:each |
		assoc := self associationAt: each ifAbsent: [nil].
		assoc notNil ifTrue: [self fileOut: assoc on: aStream]].
	self fileOutFooterOn: aStream.! !

!WindowBuilder class methods !   
userName: aString
	"Answer the window builder user's name."

	self editorClass
		propertyValueAt: #UserName
		category: self userPropertyString
		put: aString.! !

!WBPoolManagerWindow methods !
listDraw: aString value: aValueString pane: aPane
	"Display the particular key or category and its associated
		value if that value is a string."

	| box aWBDisplayContext |
	aWBDisplayContext := aPane wbDisplayContext.
	aValueString isNil
		ifTrue: [
			aString wbDisplayWith: aWBDisplayContext]
		ifFalse: [
			box := aWBDisplayContext splitCellLeftRatio: self keyValueRatio.
			aString wbDisplayWith: aWBDisplayContext.
			aWBDisplayContext cellBox: box.
			aValueString wbDisplayWith: aWBDisplayContext].! !

!WBLookPolicy class methods ! 
isWin32

    ^OperatingSystem isWin32! !

!WBLayoutFrameEditor methods !  
currentWidgets: aCollection
	"Update the receiver's contents to reflect
		the new widget."

	super currentWidgets: (
		aCollection reject: [:each |
			each framingBlock isFramingParameters
				or: [each usesFraming not]]).
	currentFramingBlocks := nil.! !

!Fraction methods !
wbStoreOn: aStream
	"Store a representation of the receiver in aStream."

	aStream
		openParenthesis;
		nextPutAll: self printString;
		closeParenthesis.! !

!PThreeStateButton class methods !  
styleFrom: style

	^(style bitIsOn: BsAuto3state)
		ifFalse: [#threeState]
		ifTrue: [#autoThreeState].! !

!WBPoolManagerWindow methods !  
updateOptionMenu

	self poolManager allowDuplicateKeys
		ifTrue: [
			self optionMenu
				checkItem: #menuOptionAllowDuplicateKeys]
		ifFalse: [
			self optionMenu
				uncheckItem: #menuOptionAllowDuplicateKeys].! !

!WBPoolManagerWindow methods ! 
menuCategoryDelete

    "Callback for the menu item titled 'Delete'.
     (Generated by WindowBuilder)"

	| msg |
	self selectedCategories isEmpty ifTrue: [^self].
	msg := self selectedCategories size = 1
		ifTrue: [ 'Delete the category named ', self selectedCategories first, '?' ]
		ifFalse: [ 'Delete ', self selectedCategories size printString, ' categories?' ].
	(MessageBox confirm: msg) ifFalse: [^self].
	[self menuCategoryDelete: self selectedCategories]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].! !

!WBLocator class methods !  
copyAt: aFigure ifAbsent: aBlock
        "^CopiedFigures at: aFigure ifAbsent:
                [CopiedFigures at: aFigure put: aBlock value]"

^CopiedFigures == nil
                ifTrue:
                        [aBlock value]
                ifFalse:
                        [CopiedFigures at: aFigure ifAbsent:
                                [CopiedFigures at: aFigure put: aBlock value]]! !

!Object methods ! 
realClass
		"Private - Answer the reciever's real class
			(for WindowBuilder Pro Development)."
	#addedByOSI.
	^self class! !

!WBFramingEditor methods !  
setExampleRects

    | pRect framer |
    hasFramed
        ifFalse: [^self].
    framer := self newFramerForRect: currentRectList first parentRect: parentRect.
    pRect := framer value: parentRect.
    pRect := ((parentRect offsetFromLeftTop: pRect) * beforeScaleFactor) rounded * 2 + (1 @ 1) extentFromLeftTop: (pRect extent * beforeScaleFactor) rounded * 2.
    beforeRect paneRect: pRect.
    pRect := framer value: largeParentRect.
    pRect := ((largeParentRect offsetFromLeftTop: pRect) * beforeScaleFactor) rounded * 2 + (1 @ 1) extentFromLeftTop: (pRect extent * beforeScaleFactor) rounded * 2.
    afterRect paneRect: pRect.
    ! !

!WBAbstractCodeModule methods !
targetObject
		"Answer the receiver's target object."
	^targetObject ifNil: [self defaultTargetObject]! !

!WBTabOrderEditor methods !
setByZOrder

	layoutForm setByZOrder.
	self setFirstStatus.! !

!PFormattedEntryField class methods !
styleFrom: ignore! !

!WBMenuEditor methods !   
selectedItem: ignore

    self fillInCurrentItem.! !

!WBUndoManager methods !
setCantRedo

    self
        setRedoState: false;
        setRedoLabel: 'Can''t Redo'! !

!WindowBuilder class methods !   
propertyNamed: aCommonName category: aSymbol

    | category |
    (category := self propertiesAtCategory: aSymbol asSymbol) ifNil: [^nil].
    ^category
        detect: [:property | property commonName = aCommonName]
        ifNone: [nil]! !

!WBCodeStream methods !   
nextPutOldEventTable: anEventTable for: anObject
	"Store the event table on aCodeStream."

	| sorted |
	anEventTable isNil ifTrue: [^self].
	sorted := SortedCollection new: anEventTable size.
	anEventTable associationsDo: [:each | sorted add: each].
	sorted do: [:each |
		self cr;
			nextPutAll: #when: ;
			space;
			nextPutAll: each key storeString;
			space;
			nextPutAll: #perform: ;
			space;
			nextPutAll: each value asString storeString;
			endMessage].! !

!WBPrimaryModelModule methods ! 
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self stream
            cr;
            nextPut: $^;
            nextPutAll: self object primaryModel class name].! !

!PDrawnButton methods !   
mutationTypes

    ^#(#Button #CPBitmapButton #CPBitmapPane)! !

!Object methods !
wbManagedValueFor: anOwner
	"Answer a new value manager for the receiver."

	^self! !

!WBDialogScratchWindow methods !  
when: anEvent perform: aSelector
    "Scratch windows should not perform any events"! !

!WBCreateClassDialog methods !
forWindowType: aType

    limitTo := aType.
    self open.! !

!WindowBuilder methods !  
prototype: aWindowClass

    prototype := aWindowClass! !

!WBLookPolicy methods !
drawEntryField: anEntryField with: aPen clipRect: clipRect

    self
        displayWithBorder: aPen
        rect: anEntryField rect
        backColor: anEntryField backColor! !

!WBModelDefinitionEditor methods !  
modelClasses

	^(((self modelType ifNil: [^#()]) wbCreatedClasses
		reject: [:aClass | aClass isWBInternalClass])
		asSortedCollection: [:a :b | a name <= b name]) asArray! !

!WBLookPolicyOS2 methods !  
drawMaximizeButtonWith: aPen at: aRect

    | innerRect |
    innerRect := self draw3DBoxWith: aPen at: aRect.
    aPen
        foreColor: Color black;
        drawRectangle: (innerRect insetBy: 4)! !

!PRadioButtonGroup methods !
styles

	^(1 to: 9) collect: [:int | (int asString,' Column') asSymbol].! !

!LayoutFrame methods !   
indent: aPoint
	"Ignore... for compatibility with FramingParameters."! !

!WBTabPosition methods ! 
nextBasicTabPosition

    ^WBTabPosition new
            basicTabPosition: basicTabPosition + 1! !

!WBLayoutForm methods !  
useDirectSelect: aBoolean
    "Set the value of useDirectSelect."

    useDirectSelect := aBoolean! !

!WBAboutDialog methods !  
shouldInitTranscript
		"Answer true if the transcript should be initialized."
	^InitTranscript = true! !

!PRadioButtonGroup methods !
contents: aCollection

	super contents: aCollection.
	numColumns isNil ifTrue: [^nil].
	self addSubpanes.! !

!WBTabOrderLayoutForm methods !   
button2Down: aPoint
	"Do Nothing"! !

!WBTabOrderLayoutForm methods !  
nextTabPositionFromCollection: aCollectionOfWidgets

	| tabPosition |
	tabPosition := WBTabPosition fromTabPosition: 0.
	aCollectionOfWidgets do: [:widget |
		(widget usesFocus 
		and: [widget tabPosition notNil 
		and: [widget tabPosition >= tabPosition]])
			ifTrue: [tabPosition := widget tabPosition]].
	^tabPosition nextTabPosition.! !

!PTextPane methods ! 
mutationExceptions

    ^#(#CPChildEntryField #Toggle #CPSpinEditor)! !

!SystemDictionary methods !  
allNLSDictionaries
    "Added by OSI to answer all NLS dictionaries"
    #addedByOSI.
    ^self select: [:val |
        val isDictionary and: [
		val isEmpty not and: [
		val isValidNLSDictionary]]].! !

!WBInterfaceObject class methods !
example

	| example defaultRealClassName |
	example := super example.
	defaultRealClassName := self defaultRealClassName.
	example 
		style: example defaultStyle;
		contents: defaultRealClassName;
		font: example defaultFont;
		extent: example defaultSize;
		realClass: (Smalltalk at: defaultRealClassName asSymbol ifAbsent: [SubPane]).
	^example! !

!WBGeometryManager methods !  
hideHandles

    self layoutForm hideHandles! !

!WBLayoutFrameEditor methods !   
setRightAttach: aString

    | ratio |
    aString = self proportional ifTrue: [
        ^self currentFramingBlocks do: [:each |
            each wbRightProportional: true.
            each wbRightAttachedToLeft: false]].
    aString = self paneLeft ifTrue: [
        ^self currentFramingBlocks do: [:each |
            each wbRightProportional: false.
            each wbRightAttachedToLeft: true]].
    ratio := self class horizontalRatioStrings keyAtValue: aString ifAbsent: [
        aString isNumber
            ifTrue: [ratio := aString asRational]
            ifFalse: [ratio := ((self compilerEvaluate: aString) ifNil: [^self]) asRational]].
    self currentFramingBlocks do: [:each |
        each wbRightProportional: false.
        each wbRightAttachedToLeft: false.
        each rightRatio: ratio].! !

!WindowBuilder class methods !  
miniHelpEnabled

    ^self editorClass
        propertyValueAt: #MiniHelpEnabled
        category: self editorPropertyString! !

!WBModelGetModule methods !
defaultCategory
        "Answer the default category for the receiver."
    ^'accessing'! !

!WBAbstractCodeModule methods !  
stream
		"Answer the receiver's code stream."
	^stream! !

!WBTreeNode methods !  
depth

    (self isRoot or: [ parent isRoot ])  ifTrue: [
        ^0
    ] ifFalse: [
        ^parent depth + 1
    ].! !

!WBInterfaceObject methods !   
realClass: aClass

    realClass := aClass.! !

!WBDescriptor class methods ! 
name: aString commonName: aString2 comment: aString3

    ^self new
            name: aString;
            commonName: aString2;
            comment: aString3;
            yourself! !

!WBPoolManagerWindow methods !   
menuPoolFileOut

    "Callback for the menu item titled 'File out...'.
     (Generated by WindowBuilder)"

	| path |
	self selectedPools isEmpty ifTrue: [^self].
	path := self promptForNewFileName: 'File out pools...'.
	path isNil ifTrue: [^self].
	[self menuPoolFileOut: path]
		on: Error
		do: [:exception | ^self menuErrorHandler: exception].! !

!WBPropertyManager class methods ! 
managers
	"Answer a dictionary of managers mapping
		class name to attribute manager."

	"
	WBPropertyManager managers
	"

	^self cacheManagers
		ifTrue: [
			managers ifNil: [
				managers := IdentityDictionary new
					at: #UndefinedObject put: self new;
					yourself]]
		ifFalse: [nil]! !

!WBModelDefinitionEditor methods !  
setClass: aClass

    | valueClass |
    (attributes selectedItem ifNil: [^nil]) valueClass:
        (valueClass := Smalltalk at: (aClass ifNil: [^nil]) asSymbol ifAbsent: [^nil]).
    (valueClass inheritsFrom: Symbol)
        ifTrue: [attributes selectedItem initializeValue: #nil]
        ifFalse: [
            (valueClass inheritsFrom: String)
                ifTrue: [attributes selectedItem initializeValue: self emptyString]
                ifFalse: [
                    (valueClass inheritsFrom: Integer)
                        ifTrue: [attributes selectedItem initializeValue: 0]
                        ifFalse: [
                            (valueClass inheritsFrom: Float)
                                ifTrue: [attributes selectedItem initializeValue: 0.0]
                                ifFalse: [
                                    (valueClass inheritsFrom: Boolean)
                                        ifTrue: [attributes selectedItem initializeValue: true]
                                        ifFalse: [initializeValue contents: self emptyString]]]]].
    self updateInitializeValue: attributes selectedItem! !

!WBTreeNode methods !
setListString: aString

    listString := aString wbManagedValueFor: self.! !

!WBUndoManager methods !   
redo

    self redo: 1! !

!WBCreateMenuModule methods !  
defaultTargetName
		"Answer the default target name."
	^'self'! !

!WBGeometryManager methods !   
alignTop
    "Align the selected widgets along their top sides"

    | target selections origins aWidget redoBlock |
    (selections := self selections copy) size > 1 ifFalse: [^self].
    target := selections first.
    origins := selections collect: [:widget | widget origin].
    self undoManager
        add: 'Align Top'
        undo:
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (origins at: i) x
                    y: (origins at: i) y;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: aWidget x
                    y: target y;
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!WBOutboardWindow methods ! 
closed
    "The receiver has been closed."

    self owner notNil
        ifTrue: [
            self owner outboards remove: self ifAbsent: [].
            self owner removeAllActionsWithReceiver: self.
            owner := nil].
    self sendInputEvent: #stopReceivingMessages.! !

!WBEditClassDialog class methods !   
cleanClassLists

	FrequentClasses := self frequentClasses reject: [:class |
		[class isDeletedClass] on: MessageNotUnderstood do: [false]].
	RecentClasses := self recentClasses reject: [:class | 
		[class isDeletedClass] on: MessageNotUnderstood do: [false]].! !

!PagedRangeControl class methods ! 
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        add: (SelectorPropertyAccessor new name: 'Page Increment'; get: #pageIncrement; set: #pageIncrement: ; format: 'Integer');
        addNames: #('Page Increment') toPage: 'Range';
        wbAddEvent: (
            WBEventDescription new
                event: #nextPage;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #previousPage ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #home;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #changing: ;
                argumentNames: #('position'));
        wbAddEvent: (
            WBEventDescription new
                event: #end;
                argumentNames: #( ));
        yourself! !

!PTextEdit methods !   
styles

    ^#(#defaultStyle #scrollBars #noScrollBars #noBorders #wordWrap)! !

!WBCodePolicy class methods !
current
	"Answer the default code policy."

	^self currentClass new! !

!WBTemplateEditor methods !  
updateFields
	"Update all the fields based on the new template"

	self
		updateAttributePalette: self attributePalette for: template;
		updateText: template;
		updateStyle: template;
		updateSize: (template isNil
			ifTrue: [0@0 extent: 0@0]
			ifFalse: [template rect]);
		updateSizeButton: template;
		redraw.! !

!WBScrapbookRetrieve methods !   
ok: ignore

    self ok! !

!WBMenuEditor methods !   
cancel
    Notifier isAltKeyDown ifTrue: [^editedMenu inspect].
    self close! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBStandardCodePolicy methods !   
basicLogMethodFor: aCodeModule
		"Private - Log the specified method source."
	SourceManager current
		logSource: aCodeModule sourceString
		forSelector: aCodeModule messageSelector
		inClass: aCodeModule targetClass.! !

!WBAbstractCodeModule methods !  
generateMessagePattern: aSymbol arguments: aCollection
        "Private - Generate the message pattern."
	| selectorStream |
	aCollection isEmpty ifTrue: [
		self stream nextPutAll: aSymbol.
		^self ].
	selectorStream := ReadStream on: aSymbol.
	aCollection
		do: [ :eachArgName |
			self stream
				nextPutAll: (selectorStream upTo: $:), ':';
				space;
				nextPutAllNoWrap: eachArgName ]
		andBetweenDo: [
			self stream
				space ].! !

!WBScratchWindow class methods !
createMethod: methodString

    | fileInStream |

    fileInStream := ReadWriteStream on: (String new: methodString size).
    fileInStream
        nextPutAll: '!! WBScratchWindow methods !!';
        nextChunkPut: methodString;
        nextChunkPut: String new.

    fileInStream reset; fileIn.! !

!WindowBuilder methods !  
setCallOuts

	WBCallOutEditor new openOn: self! !

!WBLinkEditor methods !
ok: ignore

    self ok! !

!WBStatusPaneEditor methods ! 
paste

    | index |
    index := list selection.
    index isNil ifTrue: [
        boxes add: clipboard deepCopy.
        index := boxes size.
    ] ifFalse: [
        boxes add: clipboard deepCopy beforeIndex: index
    ].
    list
        contents: (boxes collect: [ :box | box name asString ]);
        selection: index.

    self updateBoxes.! !

!PDrawnButton methods !   
mutationExceptions

    ^#(#Toggle #CPHorizontalPictureButton)! !

!WBBitmapPool methods !
convertBitmapsFromModuleToImage
		"Convert all bitmaps that are loaded from a module (resource DLL)
			to bitmaps that are stored in the image."
		"
		To convert ALL window builder bitmaps, evaluate
			WBBitmapManager convertBitmapsFromModuleToImage.

		To convert the window builder SYSTEM bitmaps, evaluate
			WBBitmapManager system convertBitmapsFromModuleToImage.

		To convert the window builder USER bitmaps, evaluate
			WBBitmapManager current convertBitmapsFromModuleToImage.
		"

	| newBitmap |
	self pool do: [:eachBitmap |
		eachBitmap archive isArray ifTrue: [
			newBitmap := eachBitmap cpCopy.
			eachBitmap release.
			eachBitmap wbBecome: newBitmap]].
	self subPools do: [:eachSubPool |
		eachSubPool convertBitmapsFromModuleToImage].! !

!WBMenuEditor methods ! 
deleteItem

    menuItemsEditor deleteSelection.
    self fillInCurrentItem.! !

!WBAbstractCodeModule methods ! 
generatePreCopyright

	(self wbEditorClass generateCopyright
		and: [self wbEditorClass copyrightAfterBody not])
		ifTrue: [
			self generateCopyright.
			self stream cr].! !

!WindowBuilder class methods !
buyACopy
	"Display a buy-a-copy message."

	MessageBox message: self buyACopyMessage.! !

!WBCodeGenerator class methods !   
generateDirectBitmapRefs: aBoolean
		"Set true if the receiver is to generate direct bitmap references (pool vars)."
		"WBCodeGenerator generateDirectBitmapRefs: true."
		"WBCodeGenerator generateDirectBitmapRefs: false."
	GenerateDirectBitmapRefs := aBoolean.! !

!WBInterfaceObject methods !   
changesTitle

    ^false! !

!PEnhancedEntryField methods !   
readSpecificsFrom: aWidget

    super readSpecificsFrom: aWidget.
    self
        autoTab: aWidget isAutoTab;
        maximumSize: aWidget textLimit;
        getFocus: aWidget getFocus;
        case: aWidget case;
        justification: aWidget justification;
        character: aWidget character;
        field: aWidget field.! !

!WBTabPosition methods ! 
<= aTabPosition

    (aTabPosition basicTabPosition > basicTabPosition) ifTrue: [
        ^true
    ].

    (aTabPosition basicTabPosition = basicTabPosition) &
    (aTabPosition groupPosition notNil & groupPosition notNil and: [
        (aTabPosition groupPosition > groupPosition)
    ]) ifTrue: [
        ^true
    ].

    ^false! !

!WBScrapbookStore methods !   
name

    ^(self paneNamed: 'name') contents.! !

!String methods !   
asSuggestedTempVarToken
		"Answer the receiver as a suggested inst var token."
	#addedByOSI.
	^self asLowerCaseFirstCaps asTempVarToken! !

!WBInterfaceObject methods ! 
reframe: parentRect

    self rect: (parentRect unLocalizeRect: (framingBlock value: (0@0 extent: parentRect extent)))! !

!FrameObject methods ! 
lookPolicy: aWBLookPolicy

    lookPolicy := aWBLookPolicy! !

!WBPoolManagerWindow methods ! 
menuKeyRename: aCollection
	"Rename the keys in aCollection where aCollection
		contains objects of the format (<oldKey> => <pool>) => <newKey>
		where '=>' denotes an association <key> => <value>."

	aCollection do: [:each |
		each key value
			renameKey: each key key
			to: each value].! !

!WBInterfaceObject methods !  
font

    ^font wbManagedValue! !

!WBAbstractAddInModule class methods ! 
modulesModifyingMenus
    "Answer a collection of all of the Add-In Module classes
     that modify the menus"

    ^self loadedModules select: [:module |
        module modifiesMenus]! !

!WBCompositePaneModule methods !  
generateAddPane: aPane to: aParent using: aSymbol
		"Private - Generate the addSubpane: code."
	| isTabStop |
	aPane isWBInterfaceObject ifFalse: [^self].
	"There should be no #subPaneWithFocus: message in CompositePane>>addSubpanes"
	isTabStop := false.
	self stream 
		cr;
		nextPutAll: (self varNameFor: aParent).
	isTabStop
		ifTrue: [self stream indentBy: 1; cr]
		ifFalse: [self stream space].
	self stream
		nextPutAll: aSymbol ;
		space.
	(self isInstVar: (self varNameFor: aPane)) & self useInstVars not
		ifTrue: [self stream nextPutAll: (self varNameFor: #owner); space].
	self stream
		nextPutAll: (self varNameFor: aPane);
		endMessage.
	isTabStop ifTrue: [
		self stream cr;
			nextPutAll: #subPaneWithFocus: ;
			space;
			nextPutAll: (self varNameFor: aPane);
			endMessage;
			indentBy: -1].
	self stream
		endExpression.! !

!WBUndoManager methods ! 
geometryManager

    ^self owner geometryManager! !

!PButtonListBox methods !
style: newStyle

    style == newStyle ifTrue: [^self].
    style := newStyle.
    newStyle == #threeState
        ifTrue: [self wbRealWidget threeState: true; useImages: true]
        ifFalse: [
            newStyle == #noImages
                ifTrue: [self wbRealWidget threeState: false; useImages: false]
                ifFalse: [
                    newStyle == #threeStateNoImages
                        ifTrue: [self wbRealWidget threeState: true; useImages: false]
                        ifFalse: [self wbRealWidget threeState: false; useImages: true]]].
! !

!WBPrototype methods ! 
convertWindow: realWindow inClass: aWindowClass

	| stayingToBack theWidgets realWindowExtent frameObject newWidgets
	  newWidget lastNonGroupTabPos lastGroupTabPos wbVer convertedFramingBlock oldPStyle |

	wbVer := (realWindow owner ifNil: [realWindow]) class wbVersion.
	(frameObject := WindowFrameObject newForClass: aWindowClass)
		realClass: aWindowClass;
		wbRealWidget: realWindow;
		editor: self owner.

	(oldPStyle := realWindow propertyAt: #pStyle) notNil ifTrue: [
		(oldPStyle includes: #modal) ifTrue: [realWindow addModalBorderStyle].
		(oldPStyle includes: #sysmodal) ifTrue: [realWindow addSystemModalStyle]].

	realWindow framingBlock notNil
		ifTrue: [
			convertedFramingBlock :=
				(realWindow isKindOf: DialogTopPane)
					ifTrue: [realWindow framingBlock asFramingBlockForWindowFromDialogTopPane]
					ifFalse: [realWindow framingBlock].
			realWindowExtent := (convertedFramingBlock value: Display boundingBox) extent]
		ifFalse: [
			(realWindow respondsTo: #initWindowSize)
				ifTrue: [realWindowExtent := realWindow initWindowSize]
				ifFalse: [realWindowExtent := realWindow topPaneClass basicNew initWindowSize].
			(realWindow isKindOf: WindowDialog)
				ifTrue: [realWindowExtent := realWindowExtent // WindowDialog dialogUnit]].

	frameObject
		framingBlock: convertedFramingBlock;
		extent: realWindowExtent;
		contents: realWindow label.
	[frameObject createdBy: realWindow createdBy] on: Error do: [ ].
	[frameObject modifiedBy: realWindow modifiedBy] on: Error do: [ ].
	[frameObject iconFile: realWindow iconFile] on: Error do: [ ].

	realWindow backColor notNil
		ifTrue: [frameObject backColor: realWindow backColor].
	frameObject paneName:
		(realWindow paneName notNil
			ifTrue: [realWindow paneName]
			ifFalse: ['mainView']).
	frameObject style isNil
		ifTrue: [frameObject style: frameObject defaultStyle].

	frameObject menu:
		(realWindow menuWindow menus notEmpty
			ifTrue: [realWindow menuWindow asWBPMenuBar]
			ifFalse: [nil]).

	"Needed to have widgets represented as OrderedCollection,
	  since ordering relevant.  Digitalk stores them as an identity dictionary,
	  which loses ordering."
	newWidgets := OrderedCollection new.
	theWidgets := realWindow childrenInBuildOrder reject: [:widget | widget isMDIClient].
	stayingToBack := OrderedCollection new.
	lastNonGroupTabPos := WBTabPosition new.
	lastGroupTabPos := lastNonGroupTabPos.

	theWidgets do: [:widget |
		newWidget :=  self convertWidget: widget inWindow: frameObject.
		(self widget: widget isInstVarIn: (realWindow owner ifNil: [realWindow]))
			ifTrue: [newWidget isInstVar: true].
		widget isAGroupLeader
			ifTrue: [
				widget isATabStopPrim
					ifTrue: [
						newWidget tabPosition: lastNonGroupTabPos nextBasicTabPosition.
						lastNonGroupTabPos := newWidget tabPosition.
						lastGroupTabPos := lastNonGroupTabPos]]
			ifFalse: [
				lastGroupTabPos notNil
					ifTrue: [
						lastGroupTabPos withinGroup
							ifFalse: [lastGroupTabPos makeFirstInGroup].
						newWidget tabPosition: lastGroupTabPos nextTabPosition.
						lastGroupTabPos := newWidget tabPosition]].
		#osiHack.
		"Keep this for old version support
			but disable it for new version windows?"
		(newWidget staysToBack and: [wbVer = 1.0])
			ifTrue: [stayingToBack addLast: newWidget]
			ifFalse: [newWidgets addLast: newWidget]].
	frameObject children: (newWidgets addAllLast: stayingToBack; yourself).
	frameObject convertFramingBlocks.

	^frameObject! !

!WBScrollingPane methods !
initialize

    super initialize.
    topCorner := 0@0.! !

!PStatusPane methods !   
suggestedSize

	^self width @ self height! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventHandlerStubModule methods !
message: aMessage

	self messageSelector: aMessage selector.! !

!WBPrimaryModelOpenOnModule methods !
defaultComment
    "Answer the default comment string."

    ^'Set the model to <', self messageArguments first, '> and open the receiver.
        Remove the #generated tag before modifying this method.
        (Generated by WindowBuilder Pro)'! !

!WBStatusPaneEditor methods ! 
setSpace: aString

    | box |
    list selection isNil ifTrue: [ ^nil ].
    box := boxes at: list selection.
    box space: aString asInteger.! !

!WindowBuilder class methods !
installExtras

	self extras do: [:slot |
		slot do: [:extra |
			extra perform]].! !

!WBMenuTester class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBBitmapManagerWindow methods ! 
updateOptionMenu

	super updateOptionMenu.
	self sameValueForAllCategories
		ifTrue: [
			self optionMenu
				checkItem: #menuOptionSameValueForAllCategories]
		ifFalse: [
			self optionMenu
				uncheckItem: #menuOptionSameValueForAllCategories].
	self showDimensions
		ifTrue: [
			self optionMenu
				checkItem: #menuOptionShowDimensions]
		ifFalse: [
			self optionMenu
				uncheckItem: #menuOptionShowDimensions].
	self poolManager updateSource
		ifTrue: [
			self optionMenu
				checkItem: #menuOptionUpdateSource]
		ifFalse: [
			self optionMenu
				uncheckItem: #menuOptionUpdateSource].
! !

!WBStatusPaneEditor class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBCreatePowerViewModule methods !   
menuModuleClass
		"Answer the menu code module class."
	^WBCreatePowerMenuModule! !

!WBTreeListBox methods ! 
owningEditBox: aBox

    owningEditBox := aBox.! !

!WBLayoutFrameEditor methods !
attachPercent

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: (
		Array
			with: self proportional
			with: self proportional
			with: self proportional
			with: self proportional).! !

!WBTemplateEditor methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| addButton mainView sampleLabel sizeFrame templatesLabel 
	xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	attributePalette := WBToolBar new.
	removeButton := Button new.
	sample := GraphPane new.
	sizeButton := DrawnButton new.
	sizeLabel := StaticText new.
	styleEditor := WBComboBox new.
	styleLabel := StaticText new.
	templateGroup := GroupBox new.
	templateList := ListBox new.
	textEditor := WBEntryField new.
	textLabel := StaticText new.
	
		"Temporary Variables"
	addButton := Button new.
	sampleLabel := StaticText new.
	sizeFrame := StaticBox new.
	templatesLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		when: #activated send: #redraw to: self;
		when: #resized send: #redraw to: self;
		labelWithoutPrefix: 'Template Editor';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -125 * xDU;
				topRatio: 1/2; topInset: -189/2 * yDU;
				rightRatio: 1/2; rightInset: -125 * xDU;
				bottomRatio: 1/2; bottomInset: -171/2 * yDU).
	self addView: mainView.
	
	templateList "ListBox"
		owner: self;
		setName: 'templateList';
		when: #clicked: send: #templateSelected: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -116 * xDU;
				bottomRatio: 1; bottomInset: 49/2 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: templateList;
		subPaneWithFocus: templateList.
	
	addButton "Button"
		owner: self;
		setName: 'addButton';
		when: #clicked send: #add to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 1; topInset: -41/2 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 1; bottomInset: 9/2 * yDU);
		contents: 'Add';
		startGroup;
		font: SysFont.
	mainView addSubpane: addButton.
	
	removeButton "Button"
		owner: self;
		setName: 'removeButton';
		when: #clicked send: #remove to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 62 * xDU;
				topRatio: 1; topInset: -41/2 * yDU;
				rightRatio: 0; rightInset: -116 * xDU;
				bottomRatio: 1; bottomInset: 9/2 * yDU);
		contents: 'Remove';
		startGroup;
		font: SysFont.
	mainView addSubpane: removeButton.
	
	textEditor "WBEntryField"
		owner: self;
		setName: 'textEditor';
		when: #textChanged: send: #setText: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 148 * xDU;
				topRatio: 0; topInset: 36 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 0; bottomInset: -48 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: textEditor.
	
	styleEditor "WBComboBox"
		owner: self;
		setName: 'styleEditor';
		when: #clicked: send: #setStyle: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 148 * xDU;
				topRatio: 0; topInset: 50 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 0; bottomInset: -116 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: styleEditor.
	
	sizeButton "DrawnButton"
		owner: self;
		setName: 'sizeButton';
		when: #clicked send: #setSize to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 189 * xDU;
				topRatio: 0; topInset: 23 * yDU;
				rightRatio: 0; rightInset: -197 * xDU;
				bottomRatio: 0; bottomInset: -31 * yDU);
		stretchToFit;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sizeButton.
	
	sizeLabel "StaticText"
		owner: self;
		setName: 'sizeLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 24 * yDU;
				rightRatio: 1; rightInset: 10 * xDU;
				bottomRatio: 0; bottomInset: -32 * yDU);
		contents: '0 x 0';
		backColor: Color gray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sizeLabel.
	
	attributePalette "WBToolBar"
		owner: self;
		setName: 'attributePalette';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 124 * xDU;
				topRatio: 0; topInset: 22 * yDU;
				rightRatio: 0; rightInset: -186 * xDU;
				bottomRatio: 0; bottomInset: -33 * yDU);
		postAutomatic;
		startGroup;
		noTabStop;
		font: SysFont;
		useSystem: true;
		fontExtent: (7/16) @ (1/2);
		add: WBSetFontSysBitmap selector: #setFont;
		add: WBSetColorSysBitmap selector: #setColor;
		add: WBSetFramingSysBitmap selector: #setFraming;
		add: WBSetMenuSysBitmap selector: #setMenu;
		add: WBOtherSysBitmap selector: #setOther.
	mainView addSubpane: attributePalette.
	
	styleLabel "StaticText"
		owner: self;
		setName: 'styleLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 122 * xDU;
				topRatio: 0; topInset: 52 * yDU;
				rightRatio: 0; rightInset: -146 * xDU;
				bottomRatio: 0; bottomInset: -60 * yDU);
		rightJustified;
		contents: 'Style:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: styleLabel.
	
	textLabel "StaticText"
		owner: self;
		setName: 'textLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 122 * xDU;
				topRatio: 0; topInset: 38 * yDU;
				rightRatio: 0; rightInset: -146 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		rightJustified;
		contents: ' Text:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: textLabel.
	
	sampleLabel "StaticText"
		owner: self;
		setName: 'sampleLabel';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 126 * xDU;
				topRatio: 0; topInset: 66 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 0; bottomInset: -74 * yDU);
		contents: 'Sample';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sampleLabel.
	
	sample "GraphPane"
		owner: self;
		setName: 'sample';
		when: #display send: #yourself to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 126 * xDU;
				topRatio: 0; topInset: 76 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 1; bottomInset: 21/2 * yDU);
		removeHorizontalScrollbarStyle;
		removeVerticalScrollbarStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sample.
	
	templatesLabel "StaticText"
		owner: self;
		setName: 'templatesLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -116 * xDU;
				bottomRatio: 0; bottomInset: -12 * yDU);
		contents: 'Templates';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: templatesLabel.
	
	sizeFrame "StaticBox"
		owner: self;
		setName: 'sizeFrame';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 188 * xDU;
				topRatio: 0; topInset: 22 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 0; bottomInset: -33 * yDU);
		blackFrame;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sizeFrame.
	
	templateGroup "GroupBox"
		owner: self;
		setName: 'templateGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 120 * xDU;
				topRatio: 0; topInset: 10 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 9/2 * yDU);
		contents: 'Template';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: templateGroup! !

!WBListChooser class methods !  
isWBInternalClass

    ^true! !

!ButtonEditor methods !  
save
    | dialog file |
    super save.
    fileName isNil ifTrue: [ ^self ].
    dialog := FileDialog new
                        saveTitle: 'Save Bitmap'
                        fileName: fileName.
    file := dialog file.
    file isNil ifTrue: [^self].
    imageForm wbOutputToFile: file.! !

!WBTabOrderLayoutForm methods !  
notifyModelOfSizeOrPositionChange: aRectangle
	"Do Nothing"! !

!WBActionEditor methods !  
fileOut

    | file classReader |

    file := (FileDialog new
        saveTitle: 'File out Actions'
        fileName: (
            File
                fileName: 'ACTIONS'
                extension: 'ACT')) file.
    file isNil ifTrue: [^self].
    file := File newFile: file.
    classReader := ClassReader forClass: (Smalltalk at: #WBAction).
    WBAction listActions do: [ :act |
        classReader fileOutMethod: ('action',act) asSymbol on: file].
    file close.! !

!PListBox methods !   
copySpecificsTo: aPane

    aPane contents: self contents.! !

!WBTeamVCodePolicy methods !   
inBaseImage: aClass
	"Answer true if aClass is part of the base image."

	"
	| pkgName |
	pkgName := (self currentSubsystem definitionOfClassNamed: aClass name) package name.
	^(pkgName = 'Visual Smalltalk Enterprise') | (pkgName beginsWith: 'From library')
	"
	^super inBaseImage: aClass! !

!BitEditor methods !   
initWindowSize
        "Private - Answer the initial window extent."
    | size |
    size := 10 @ 10 min: (Display extent - windowSize).
    size :=  size extent: windowSize.
    ^size! !

!WBModelInstVar methods !
propertyAt: key
        "Answer the value associated with key
        in the properties dictionary."
    properties isNil ifTrue: [^nil].
    ^properties at: key ifAbsent: [nil]! !

!WBMethodStubModule methods ! 
targetClass
		"Answer the receiver's target class."
	^super targetClass isNil
		ifTrue: [nil]
		ifFalse: [super targetClass instanceClass]! !

!WBDevelopmentWindow methods !   
editorFont

	^self class editorFont! !

!WBResizeBitmap methods ! 
newHeight

    ^newHeightField contents asInteger! !

!CheckBox class methods !   
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #checked ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #unchecked ;
                argumentNames: #( ));
        yourself! !

!WindowBuilder methods !   
menuToolsInspectScrollingForm

    self scrollingForm inspect! !

!WBEventHandlerStubModule methods ! 
defaultMessageArguments
    "Private - Answer the default message selector arguments."

    | answer argCount |
    answer := self eventDescription argumentNames.
    argCount := Message numberOfArgumentsFor: self messageSelector.
    argCount < answer size ifTrue: [^answer copyFrom: 1 to: argCount].
    argCount > answer size ifTrue: [
        answer := answer asOrderedCollection.
        [argCount - 1 > answer size] whileTrue: [answer add: 'arg', (answer size + 1) printString].
        self wbEditorClass runtimeLessCode
            ifTrue: [answer add: 'arg', (answer size + 1) printString]
            ifFalse: [answer add: 'aPane']].
    ^answer! !

!WBToolBarEditor methods ! 
setRBSelector: aString

	list selection isNil ifTrue: [ ^self ].
    (elements at: list selection) rbSelector: aString.! !

!WindowBuilder class methods !   
propertyValueAt: aSymbol category: categorySymbol

    | property |
    (property := self propertyAt: aSymbol category: categorySymbol asSymbol) ifNil: [^nil].
    ^property value! !

!WBInterfaceObject methods !
resID: id

    resID := id! !

!WBLayoutForm methods !
fontFor: widget

	^SysFont! !

!WBGraphicObject methods ! 
topRight

	^rect topRight! !

!WBLayoutForm methods ! 
display

	| region aRect |
	region := self pen setClipRect: (aRect := self currentClipRect).
	self shell drawFrameWith: self pen at: self shell frameLeftTop.
	self updateRect: aRect.
	self pen destroyRegion: region.
	(self checkHideHandles or: [self drawToBitmap]) 
		ifFalse: [self showHandles].
	self drawToBitmap ifFalse: [self showShellHandles].! !

!WBPMenuItem methods !   
title

    ^listString wbManagedValue! !

!WBTargetObject methods !   
primaryModel

    ^self modelObjects
        detect: [:modelObject | modelObject isWBPrimaryModel]
        ifNone: [nil].! !

!WBFontSelectionWindow methods !  
updateContents
	"Update the receiver's contents."

	self
		currentWidgets: self owner selections;
		selectedFont: (
			self currentWidgets notEmpty
				ifTrue: [self currentWidgets first font]
				ifFalse: [nil]);
		selectedPool: nil;
		dirty: false.! !

!WBMenuEditor methods !
nlsStringFor: aString
	| nlsString nlsKey nlsPool |
    nlsString := aString.
    (aString notEmpty and: [aString first == $#])
        ifTrue: [
            nlsKey := aString copyFrom: 2 to: aString size.
            self nlsPools detect: [:sym |
                (nlsString := (nlsPool := Smalltalk at: sym) at: nlsKey
                    ifAbsent: [nlsString := nlsPool at: nlsKey asSymbol
                    ifAbsent: [aString]]) ~= aString]
                    ifNone: []].
	^nlsString! !

!WBEventManagerWindow methods !   
widgetFilters
	"Answer a dictionary mapping strings to filter selectors."

	^self class widgetFilters! !

!WBNLSDictionaryReader class methods ! 
fileOutCategoryFileName: aString on: aStream
	"File out a token/value pair inside a comment."

	^self
		fileOutToken: WBNLSManager tagFileName
		value: aString
		inCommentOn: aStream! !

!WBLayoutForm methods !
destroySelectedWidgets
    "Destroy all of the selected widgets."

    | sel |
    (self
        createUndoRedoForNewWidgets: self emptyCollection
        oldWidgets: (sel := self selections)
        named: (sel size == 1
            ifTrue: ['Delete Widget']
            ifFalse: ['Delete Widgets']))
            redoAction value.! !

!FrameObject methods !
frameContentRect

	^self contentLeftTop extentFromLeftTop: self contentRect extent! !

!WBAbstractCodeModule methods !
shouldLogMethodSource
		"Answer true if the receiver's source should be logged."
	^self defaultShouldLogMethodSource! !

!WBOutboardWindow methods !  
stopReceivingMessages
	"Remove the receiver's mainView (and children) from the Notifier."

	Notifier cleanUpWindows.! !

!WBTimerEditor class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowBuilder methods ! 
menuOptionsTemplates

	WBTemplateEditor new open! !

!Object methods !
wbFullCopyObject: aDictionary
	"Answer a full copy of the receiver."

	| answer aClass size |
	#addedByOSI.
	aClass := self class.
	aClass isVariable
		ifTrue: [
			size := self basicSize.
			answer := aClass basicNew: size]
		ifFalse: [
			size := 0.
			answer := aClass basicNew].
	aDictionary at: self put: answer.
	aClass isPointers
		ifTrue: [
			1 to: size + aClass instSize do: [:index |
				answer instVarAt: index
					put: ((self instVarAt: index) wbFullCopy: aDictionary)]]
		ifFalse: [
			1 to: size do: [:index |
				answer basicAt: index
					put: (self basicAt: index)]].
	^answer! !

!WBGeometryManager methods ! 
cutSelections

    self hasSelections
        ifTrue: [
            self copySelections.
            self clearSelections]! !

!WindowBuilder methods !
drawGrid

    ^self class drawGrid! !

!PScrollBar methods !  
backColor

    ^backColor.! !

!WBWindowEditor methods !  
setIcon

    "Support for setting window icons"

    ((Smalltalk includesKey: #WBIconEditor) and: [Notifier isAltKeyDown]) ifFalse: [
        ^self setIconFromDialog
    ].
    iconEditor notNil ifTrue: [
        iconEditor fileName notNil ifTrue: [
            iconFile := iconEditor fileName.
        ].
    ].
    iconEditor := iconFile isNil ifTrue: [
        (Smalltalk at: #WBIconEditor) new open.
    ] ifFalse: [
        (File exists: iconFile) ifFalse: [
            MessageBox message: 'The icon file: ''',iconFile,''' cannot be found.'.
            (Smalltalk at: #WBIconEditor) new open.
        ] ifTrue: [
            (Smalltalk at: #WBIconEditor) new openOnFile: iconFile.
        ].
    ].! !

!WBBitmapManagerWindow methods ! 
windowTitle

	^'Bitmap Manager'! !

!PButton methods !
autoSizeFrom

    ^(framingBlock isFramingParameters
        or: [framingBlock bottomRatio < 1])
        ifTrue: [#leftJustified]
        ifFalse: [#rightJustified]! !

!WBLookPolicyOS2 methods !
drawHScrollBarWith: aPen at: aRect

    | nonThumbRect |
    nonThumbRect := super drawHScrollBarWith: aPen at: aRect.
    aPen
        foreColor: Color darkGray;
        wbLineFrom: aRect leftTop to: aRect rightTop;
        wbLineFrom: (aRect leftBottom up: 1) to: (aRect rightBottom up: 1).
    ^nonThumbRect! !

!WBTreeNode methods !
positionOf: anEntry

    | position |

    position := 1.

    children do: [ :c |
        c == anEntry ifTrue: [
            ^position
        ].
        position := position + c descendantsCount.
    ].

    self error:  'Child missing'! !

!PLinkButton methods !  
storeContentsOn: aStream indentString: spaceString

	super storeContentsOn: aStream indentString: spaceString.
	(self link notNil and: [self link notEmpty])
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'link: #',self link].
	(self type notNil and: [self type notEmpty])
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'type: #',self type].! !

!WBSubPool methods ! 
fileOut: anAssociation on: aStream
	"File out the specified key/value pair."! !

!WindowBuilder class methods !
openNew

    self new menuFileOpen! !

!WBBitmapEditorCompositePane methods ! 
editBitmap

	"Callback for the #clicked event in editButton [Button].
		(Generated by WindowBuilder Pro)"

	self selectedValue isBitmap ifTrue: [BitEditor new openOn: self selectedValue].! !

!WBTemplateEditor methods !
redraw

	self displayImage! !

!WindowBuilder class methods ! 
labelName

	^'WindowBuilder Pro'! !

!WBToolBarEditor methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| bitmapLabel bitmaps buttonGroup buttons buttonsGroup 
	cancel cellSize cellSizeLabel copy default down editBitmaps 
	help insert leftButtonLabel mainView numSpaces 
	numSpacesLabel ok paste rbSelector remove rightButtonLabel 
	selector selectorGroup system up vertical xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	bitmapLabel := StaticText new.
	bitmaps := WBComboBox new.
	buttonGroup := GroupBox new.
	buttons := WBListBox new.
	buttonsGroup := GroupBox new.
	cancel := Button new.
	cellSize := WBEntryField new.
	cellSizeLabel := StaticText new.
	copy := Button new.
	default := CheckBox new.
	down := Button new.
	editBitmaps := Button new.
	help := Button new.
	insert := Button new.
	leftButtonLabel := StaticText new.
	numSpaces := WBEntryField new.
	numSpacesLabel := StaticText new.
	ok := Button new.
	paste := Button new.
	rbSelector := WBEntryField new.
	remove := Button new.
	rightButtonLabel := StaticText new.
	selector := WBEntryField new.
	selectorGroup := GroupBox new.
	system := CheckBox new.
	up := Button new.
	vertical := CheckBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		when: #activated send: #activated to: self;
		addModalBorderStyle;
		labelWithoutPrefix: 'WBToolBar Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -140 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -62 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -140 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -62 * yDU).
	self addView: mainView.
	
	cellSizeLabel "StaticText"
		owner: self;
		setName: 'cellSizeLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 106 * yDU;
				rightRatio: 0; rightInset: -38 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		rightJustified;
		contents: 'Cell Size:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: cellSizeLabel.
	
	bitmapLabel "StaticText"
		owner: self;
		setName: 'bitmapLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 160 * xDU;
				topRatio: 0; topInset: 16 * yDU;
				rightRatio: 0; rightInset: -188 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		rightJustified;
		contents: 'Bitmap:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: bitmapLabel.
	
	leftButtonLabel "StaticText"
		owner: self;
		setName: 'leftButtonLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 166 * xDU;
				topRatio: 0; topInset: 38 * yDU;
				rightRatio: 0; rightInset: -206 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		contents: 'Left Button:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: leftButtonLabel.
	
	rightButtonLabel "StaticText"
		owner: self;
		setName: 'rightButtonLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 166 * xDU;
				topRatio: 0; topInset: 60 * yDU;
				rightRatio: 0; rightInset: -210 * xDU;
				bottomRatio: 0; bottomInset: -68 * yDU);
		contents: 'Right Button:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: rightButtonLabel.
	
	numSpacesLabel "StaticText"
		owner: self;
		setName: 'numSpacesLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 160 * xDU;
				topRatio: 0; topInset: 90 * yDU;
				rightRatio: 0; rightInset: -206 * xDU;
				bottomRatio: 0; bottomInset: -98 * yDU);
		rightJustified;
		contents: 'Num Spaces:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: numSpacesLabel.
	
	vertical "CheckBox"
		owner: self;
		setName: 'vertical';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 238 * xDU;
				topRatio: 0; topInset: 90 * yDU;
				rightRatio: 0; rightInset: -272 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		contents: 'Vertical';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: vertical.
	
	system "CheckBox"
		owner: self;
		setName: 'system';
		addClipsiblingsStyle;
		when: #clicked: send: #toggleSystem: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 238 * xDU;
				topRatio: 0; topInset: 90 * yDU;
				rightRatio: 0; rightInset: -272 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		contents: 'System';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: system.
	
	editBitmaps "Button"
		owner: self;
		setName: 'editBitmaps';
		when: #clicked send: #editBitmaps to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 158 * xDU;
				topRatio: 0; topInset: 106 * yDU;
				rightRatio: 0; rightInset: -210 * xDU;
				bottomRatio: 0; bottomInset: -122 * yDU);
		contents: 'Edit Bitmaps';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: editBitmaps.
	
	help "Button"
		owner: self;
		setName: 'help';
		when: #clicked send: #help to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 262 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -272 * xDU;
				bottomRatio: 0; bottomInset: -26 * yDU);
		contents: '?';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: help.
	
	buttons "WBListBox"
		owner: self;
		setName: 'buttons';
		when: #changedIndex: send: #selectButton: to: self;
		when: #drawItem: send: #drawItem:pane: to: self withArgument: buttons;
		when: #drawSelection: send: #highlightItem:pane: to: self withArgument: buttons;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -108 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		ownerDrawFixed;
		startGroup;
		font: SysFont.
	mainView
		addSubpane: buttons;
		subPaneWithFocus: buttons.
	
	cellSize "WBEntryField"
		owner: self;
		setName: 'cellSize';
		when: #textChanged: send: #setCellSize: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 40 * xDU;
				topRatio: 0; topInset: 104 * yDU;
				rightRatio: 0; rightInset: -74 * xDU;
				bottomRatio: 0; bottomInset: -116 * yDU);
		contents: '25 @ 22';
		startGroup;
		font: SysFont.
	mainView addSubpane: cellSize.
	
	default "CheckBox"
		owner: self;
		setName: 'default';
		when: #clicked: send: #toggleDefault: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 77 * xDU;
				topRatio: 0; topInset: 105 * yDU;
				rightRatio: 0; rightInset: -111 * xDU;
				bottomRatio: 0; bottomInset: -115 * yDU);
		contents: 'Default';
		startGroup;
		font: SysFont.
	mainView addSubpane: default.
	
	insert "Button"
		owner: self;
		setName: 'insert';
		when: #clicked send: #insert to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 112 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -150 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		contents: '&Insert';
		startGroup;
		font: SysFont.
	mainView addSubpane: insert.
	
	copy "Button"
		owner: self;
		setName: 'copy';
		when: #clicked send: #copy to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 112 * xDU;
				topRatio: 0; topInset: 30 * yDU;
				rightRatio: 0; rightInset: -150 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		contents: '&Copy';
		startGroup;
		font: SysFont.
	mainView addSubpane: copy.
	
	paste "Button"
		owner: self;
		setName: 'paste';
		when: #clicked send: #paste to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 112 * xDU;
				topRatio: 0; topInset: 48 * yDU;
				rightRatio: 0; rightInset: -150 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		contents: '&Paste';
		startGroup;
		font: SysFont.
	mainView addSubpane: paste.
	
	up "Button"
		owner: self;
		setName: 'up';
		when: #clicked send: #up to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 112 * xDU;
				topRatio: 0; topInset: 66 * yDU;
				rightRatio: 0; rightInset: -150 * xDU;
				bottomRatio: 0; bottomInset: -82 * yDU);
		contents: '&Up';
		startGroup;
		font: SysFont.
	mainView addSubpane: up.
	
	down "Button"
		owner: self;
		setName: 'down';
		when: #clicked send: #down to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 112 * xDU;
				topRatio: 0; topInset: 84 * yDU;
				rightRatio: 0; rightInset: -150 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		contents: '&Down';
		startGroup;
		font: SysFont.
	mainView addSubpane: down.
	
	remove "Button"
		owner: self;
		setName: 'remove';
		when: #clicked send: #remove to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 112 * xDU;
				topRatio: 0; topInset: 102 * yDU;
				rightRatio: 0; rightInset: -150 * xDU;
				bottomRatio: 0; bottomInset: -118 * yDU);
		contents: '&Remove';
		startGroup;
		font: SysFont.
	mainView addSubpane: remove.
	
	bitmaps "WBComboBox"
		owner: self;
		setName: 'bitmaps';
		addClipsiblingsStyle;
		when: #changed: send: #selectBitmap: to: self;
		when: #textChanged: send: #selectBitmap: to: self;
		when: #needsContents send: #getBitmaps: to: self withArgument: bitmaps;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 190 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -260 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		dropDownList;
		startGroup;
		font: SysFont.
	mainView addSubpane: bitmaps.
	
	selector "WBEntryField"
		owner: self;
		setName: 'selector';
		addClipsiblingsStyle;
		when: #textChanged: send: #setSelector: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 166 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -268 * xDU;
				bottomRatio: 0; bottomInset: -58 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: selector.
	
	rbSelector "WBEntryField"
		owner: self;
		setName: 'rbSelector';
		addClipsiblingsStyle;
		when: #textChanged: send: #setRBSelector: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 166 * xDU;
				topRatio: 0; topInset: 68 * yDU;
				rightRatio: 0; rightInset: -268 * xDU;
				bottomRatio: 0; bottomInset: -80 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: rbSelector.
	
	numSpaces "WBEntryField"
		owner: self;
		setName: 'numSpaces';
		addClipsiblingsStyle;
		when: #textChanged: send: #setNumSpaces: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 208 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 0; rightInset: -234 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: numSpaces.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 214 * xDU;
				topRatio: 0; topInset: 106 * yDU;
				rightRatio: 0; rightInset: -242 * xDU;
				bottomRatio: 0; bottomInset: -122 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 244 * xDU;
				topRatio: 0; topInset: 106 * yDU;
				rightRatio: 0; rightInset: -276 * xDU;
				bottomRatio: 0; bottomInset: -122 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	selectorGroup "GroupBox"
		owner: self;
		setName: 'selectorGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 162 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 0; rightInset: -272 * xDU;
				bottomRatio: 0; bottomInset: -84 * yDU);
		contents: 'Selectors';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: selectorGroup.
	
	buttonGroup "GroupBox"
		owner: self;
		setName: 'buttonGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 158 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -276 * xDU;
				bottomRatio: 0; bottomInset: -104 * yDU);
		contents: 'Button';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: buttonGroup.
	
	buttonsGroup "GroupBox"
		owner: self;
		setName: 'buttonsGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -154 * xDU;
				bottomRatio: 0; bottomInset: -122 * yDU);
		contents: 'Buttons';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: buttonsGroup! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutForm methods !
button2Up: aPoint
    "Process a release button event."

    self propertyAt: #hideHandles put: false.
    super button2Up: aPoint.
    self loadedWidgets isNil ifTrue: [^self].
    self button1Up: aPoint! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBMenuEditor methods ! 
checkMnemonics

    | currentItem  mnemonic |

    currentItem := menuItemsEditor selectedItem.
    mnemonic := currentItem listString mnemonicChar.

    currentItem parent children do: [ :p |
        p ~= currentItem ifTrue: [
            mnemonic notNil & (p listString mnemonicChar = mnemonic) ifTrue: [
                ^MessageBox messageNote:  'Another menu item (', p listString stripMnemonic trimBlanks asQuotedString, ') already uses the mnemonic ~', mnemonic asUpperCase asString, '.  Please choose another.'
            ].
        ].
    ].! !

!WBInterfaceObject class methods !  
templates

	^Templates ifNil: [self clearTemplates].! !

!WBPropertyEditor methods !  
preInitWindow

	self mainView children do: [:each |
		each font: SysFont].! !

!WBModelInstVar methods ! 
okToGenerateEventsTriggered

    ^(self myClass class methodDictionary
        at: #constructEventsTriggered
        ifAbsent: [^true]) references: self generatedSymbol.! !

!WBBitmapManagerWindow methods !  
listDraw: aString value: aBitmap pane: aPane
	"Display the particular key or category and its associated
		value if that value is a string."

	| aWBDisplayContext bitmapBox dimensionBox |
	aWBDisplayContext := aPane wbDisplayContext.
	aBitmap isNil
		ifTrue: [
			aString wbDisplayWith: aWBDisplayContext]
		ifFalse: [
			bitmapBox := aWBDisplayContext splitCellLeftRatio: self keyValueRatio.
			self showDimensions ifTrue: [
				dimensionBox := aWBDisplayContext splitCellRightInset: (
					keyDimensionInset ifNil: [
						keyDimensionInset := (aPane font stringWidth: '000x000x0') + 4])].
			aString wbDisplayWith: aWBDisplayContext.
			dimensionBox notNil ifTrue: [
				aWBDisplayContext cellBox: dimensionBox.
				(aBitmap isBitmap
					ifTrue: [aBitmap width asString, 'x', aBitmap height asString, 'x', aBitmap bitCount asString]
					ifFalse: ['']) wbDisplayWith: aWBDisplayContext].
			aWBDisplayContext cellBox: bitmapBox.
			aBitmap wbDisplayWith: aWBDisplayContext].! !

!WBCodeStream methods !
space
		"Append a space to the code stream.
			Spaces never begin a new line or end a message or expression."
	stream nextPut: Space.! !

!WBTreeListBox methods !   
gettingFocus

    self handle isValid ifFalse: [ ^self ].

    owningEditBox notNil ifTrue: [
        owningEditBox  sendInputEvent: #setFocus.
    ].! !

!PWBToolBar methods !  
cellSize: aPoint

    cellSize := aPoint! !

!WindowBuilder methods ! 
updateOutboardPrototypes: newPrototype
	"Update all of the outboard windows with the new prototype"

	self outboards do: [:window |
		window prototypeChanged: newPrototype].! !

!WinDialogInfo methods !  
readFrom: fileName
        "Private - WBPro Development."
    | s f |
    #addedByOSI.
    f := File pathName: fileName.

    f nextByte; nextByte; nextByte; nextByte.
    [ f nextByte = 0 ] whileFalse: [ ].
    f nextByte; nextByte.

    s := f nextUShort.
    f nextByte; nextByte.
    contents := ByteArray new: s.
    1 to: s do: [:i |
        contents at: i put: f nextByte.
    ].

    f close.! !

!WBListChooser methods !  
fromList: aList prompt: questionString
        "Private - Initialize a Prompter window
         and give it control."

    | lineHeight charSize |
    self labelWithoutPrefix: ''.
    self mainView when: #opened send: #opened to: self.
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.
    self addSubpane:
        (StaticText new
            centered;
            contents: questionString;
            framingBlock: [:box |
                (box leftTop rightAndDown: lineHeight@5)
                    extentFromLeftTop: (box width - 10) @ lineHeight ] ).
    self addSubpane:
        (self listClass new
            paneName: 'list';
            contents: aList;
            when: #doubleClicked: send: #ok: to: self;
            framingBlock: [:box |  ((box leftTop
                     rightAndDown: (1 @ 2) * charSize))
                     rightBottom:  (box rightBottom leftAndUp: (1@3) * charSize) ] ).
    self addSubpane:
        (Button new
            defaultPushButton;
            contents: 'OK';
            when: #clicked send: #ok to: self;
            framingBlock: [:box | ((box leftBottom
                        rightAndUp: (1 @ (5/2)) * charSize))
                    extentFromLeftTop: (10 @ 2) * charSize ] ).
    self addSubpane:
        (Button new
            contents: 'Cancel';
            when: #clicked send: #cancel to: self;
            framingBlock: [:box | ((box leftBottom
                        rightAndUp: (12 @ (5/2)) * charSize))
                    extentFromLeftTop: (10 @ 2) * charSize ] ).
    self openWindow.
    ^reply! !

!WBEnhancedEntryFieldEditor methods !
getFocus: aPane

    aPane contents: self getFocusDict keys asSortedCollection asArray! !

!WBTreeNode methods !  
printOn: aStream

    self isRoot ifTrue: [
        aStream nextPutAll: '(ROOT)'.
    ] ifFalse: [
        aStream nextPutAll: '(', parent listString, '>>', currentString, ')'.
    ].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEditClassDialog methods ! 
filterSelect: selectedItem

    "Callback for the #clicked: event triggered in the WBComboBox named 'filter'.
     (Generated by WindowBuilder)"

    self class filter: self filterChoice.
    self updateListContents.! !

!WBNLSDictionaryReader class methods !   
fileOutPoolTableEndOn: aStream
	"File out a token/value pair inside a comment."

	aStream cr.
	self fileOutToken: WBNLSManager tagPoolEnd inCommentOn: aStream.
	aStream
		cr;
		nextPutAll: self commentStartString;
		next: 40 put: $=;
		nextPutAll: self commentEndString;
		cr.! !

!WBInterfaceObject methods ! 
wbDestroyWidget

	self propertyAt: #oldParent put: self parent.
	self parent children remove: self ifAbsent: [nil].
	self parent: nil.! !

!WindowBuilder methods ! 
children

    ^self prototype children! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBNLSManagerWindow methods ! 
suggestedCategoriesPrim
	"Answer a collection of suggested categories."

	^#( 'English' 'German' 'French' 'Spanish' )! !

!PEntryField methods ! 
mutationTypes

    ^#(#EntryField #StaticText #Toggle #CPSpinEditor)! !

!WBLayoutForm methods !  
boundingBoxWithLastFor: aCollection
    "Answer the rectangle encompassing all the widgets in <aCollection>."

    ^aCollection
        inject: aCollection first boundingBox
        into: [:aRect :widget | aRect merge: widget boundingBoxWithLast].! !

!Symbol methods !  
wbEvaluateWithReceiver: anObject
    "Private - this method is part of the development environment and cannot be relied on in a run-time image.
    Answer the result of evaluating the receiver using <anObject> as the message receiver. "

	#addedByOSI.
    ^anObject perform: self! !

!WBTabOrderLayoutForm methods !
button1Down: aPoint

    self 
        useLeftButton;
        buttonDown: aPoint.! !

!WBLayoutForm methods !   
clearSelections

    self selections: self emptyCollection! !

!PWBToolBar methods !  
defaultCellSize

    ^25 @ 22! !

!WindowBuilder class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowBuilder methods ! 
menuFileNewComposite

    self confirmSaveChanges
        ifTrue: [
            self inENVY ifFalse: [WBCompositePaneScratchWindow resetToDefault].
            self editClass: WBCompositePaneScratchWindow].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WinDialogInfo methods !   
extent
        "Private - WBPro Development."
    #addedByOSI.
    ^(self uShortAtOffset: 9) @ (self uShortAtOffset: 11)! !

!WindowFrameObject methods !
isNonWindowParent

    ^self isDialog! !

!WBGeometryManager methods !
sizeByPixelRight
    "Size the selected widgets right one pixel"

    | selections |
    (selections := self selections copy) isEmpty
        ifTrue: [^self owner setWindowSize: (self shell width + 1 @ self shell height)].
    (self undoManager
        add: 'Size Pixel Right'
        undo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    configureWidget: aWidget x
                    y: aWidget y
                    width: (aWidget width - 1 max: 0)
                    height: aWidget height
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections]
        redo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    configureWidget: aWidget x
                    y: aWidget y
                    width: aWidget width + 1
                    height: aWidget height
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections])
        redoAction value.
    self updateWidget.! !

!WBBitmapManagerWindow methods !   
menuBitmapCopy

	| aBitmap |
	(aBitmap := self selectedValue) isBitmap ifTrue: [
		Clipboard setBitmap: aBitmap].! !

!WBTabOrderLayoutForm methods !   
removeGroupingPanes

	self children copy do: [:widget |
		widget isGrouper
			ifTrue: [self children remove: widget]].! !

!WBAbstractCodeModule methods !  
category: aString
		"Set the category for the receiver."
	category := aString.! !

!WBModelInstVar methods !  
hasAccessors

    ^hasAccessors! !

!WBEventManagerWindow methods !   
widgetFilter

	^widgetFilterBox selectedItem! !

!WBInterfaceObject methods ! 
listEditorValidation

    ^nil! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBTreeNode methods ! 
owner: anObject
	"Set the receiver's owner."

	owner := anObject.
	self update.! !

!WBLookPolicyWin31 methods !
scrollBarThumbWidth

    ^scrollBarThumbWidth ifNil: [
        scrollBarThumbWidth := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxhthumb" 10]
            ifFalse: [super scrollBarThumbWidth]]! !

!WindowBuilder methods !  
prototype

    ^prototype ifNil: [prototype := WBPrototype new realClass: WBScratchWindow].! !

!WindowBuilder class methods !
propertiesAtCategory: aSymbol

    ^self properties
        at: aSymbol asSymbol
        ifAbsent: [nil]! !

!WBCodeStream methods !
cr
		"Write the line terminating character (carriage-line-feed)
			to the receiver stream, then indent."
	self checkEnd.
	stream cr.
	lineStartPos := stream position.
	stream next: indent put: Tab.! !

!WindowBuilder methods !
statusPane

	^status! !

!WBLayoutForm methods !  
duplicateWidgets: aCollection
    "Set the value of duplicateWidgets."

    duplicateWidgets := aCollection.! !

!BitEditor methods !
changeBits: aPane
    | aPoint  changePoint imagePoint |
    aPoint := aPane mouseLocation.
    (self isInGrid: aPoint)
        ifFalse: [^self].
    imagePoint := aPoint // scale.
    changePoint := imagePoint * scale.
    changePoint printString.
    bitPen fill: ((changePoint + 2) extent: (scale @ scale) - 3)
        color: bitColor.
    imagePen fill: (imagePoint extent: 1 @ 1)
        color: bitColor.
    copy pen fill: (imagePoint extent: 1 @ 1)
        color: bitColor! !

!PStatusPane methods ! 
maxSize

	^32000 @ self height! !

!WBTabOrderEditor methods !
tabPlaced

	(layoutForm totalTabCount >= layoutForm tabCount) 
		ifTrue: [
			self setStatus:
				'Placed ',
				layoutForm tabCount asString,
				' of ',
				layoutForm totalTabCount asString].! !

!WBPropertyEditor methods !  
updateItems

    | items selectedItem selectedIndex propertyName |
    selectedItem := propertyList selectedItem.
    items := propertyList contents.
    propertyName := selectedItem copyFrom: 1 to: (selectedItem indexOf: $:) - 2.
    selectedIndex := items indexOf: (items detect: [:item | item beginsWith: propertyName] ifNone: [^nil]).
    propertyList
        contents:
            ((WindowBuilder propertiesAtCategory: self selectedCategory) values
                collect: [:property | self labelForProperty: property]) asSortedCollection asArray;
        selectIndex: selectedIndex.! !

!WBModelObjectEditor methods ! 
edit

    | selectedObject |
    (selectedObject := self selectedObject) ifNil: [^self].
    ((selectedObject attributeEditor) ifNil: [^self]) new openOn: selectedObject.
    self owner setDirty.! !

!WBPoolManagerWindow methods ! 
keyListNeedsContents: aPane

    "Callback for the #needsContents event triggered in the MultipleSelectListBox named 'keyListBox'.
     (Generated by WindowBuilder)"

	| oldSelection newContents newSelection |
	oldSelection := self selectedKeysAndPools.
	newContents := SortedCollection new.
	self selectedPools do: [:eachPool |
		eachPool keys do: [:eachKey | newContents add: eachKey => eachPool]].
	newSelection := oldSelection select: [:each | newContents includes: each].
	aPane contents: newContents.
	self selectedKeysAndPools: newSelection.! !

!WBLayoutFrameEditor methods ! 
labels

	^labels ifNil: [
		labels := (Array new: 6)
			at: 1 put: (self paneNamed: 'leftAttachLabel');
			at: 2 put: (self paneNamed: 'topAttachLabel');
			at: 3 put: (self paneNamed: 'rightAttachLabel');
			at: 4 put: (self paneNamed: 'bottomAttachLabel');
			at: 5 put: (self paneNamed: 'beforeLabel');
			at: 6 put: (self paneNamed: 'afterLabel');
			yourself]! !

!CompositeFrameObject methods !  
storeOn: aStream indentString: indentString

	self storeRectOn: aStream indentString: indentString.
	self storeColorOn: aStream indentString: indentString.! !

!WindowBuilder class methods !   
isWBInternalClass

	^true! !

!Font methods ! 
wbManagedValueFor: anOwner
	"Answer a new value manager for the receiver."

	^WBManagedPFont for: anOwner value: self! !

!WBMultiListChooser methods !  
preInitWindow

    | charSize |
    charSize := WindowDialog unitMultiplier.
    self addSubpane:
        (Button new
            contents: 'Select All';
            when: #clicked send: #selectAll to: self;
            framingBlock: [:box | ((box leftBottom
                        rightAndUp: (23 @ (5/2)) * charSize))
                    extentFromLeftTop: (10 @ 2) * charSize ] ).! !

!PGenericSubpane methods !   
usesFocus

   ^false! !

!WBUndoManager methods ! 
deferRedraw: aBlock

    ^self owner topLayoutForm deferRedraw: aBlock! !

!WindowBuilder methods !   
saveWhenPerform

	| methodName savedSelection isTriggered current |
	isTriggered := self currentEventIsTriggered.
	current := self currentEvent.
	perform contents hasContent
		ifTrue: [
			methodName := isTriggered
				ifTrue: [perform contents wbValidTriggeredSelectorFor: current]
				ifFalse: [self getValidMethodName: perform contents].
			(perform contents = methodName)
				ifFalse: [
					savedSelection := perform selection.
					perform contents: methodName.
					perform selectFrom: savedSelection x to: savedSelection y].
			methodName isNil
				ifFalse: [
					isTriggered
						ifTrue: [
							thePane
								eventHandlerSelectorAt: current
								put: methodName
								prototype: self prototype]
						ifFalse: [
							thePane
								oldEventHandlerSelectorAt: current
								put: methodName , ':']]]
		ifFalse: [
			isTriggered
				ifTrue: [
					thePane
						eventHandlerSelectorAt: current
						put: ''
						prototype: self prototype]
				ifFalse: [
					thePane
						oldEventHandlerSelectorAt: current
						put: '']].
	self updateEvents: true.! !

!Window methods !  
wbMutateTo: anObject
	"Mutate the receiver's properties into anObject."

	#addedByOSI.
	^self wbPropertyManager wbMutateFrom: self to: anObject! !

!WBCreateViewModule methods !   
constructVarNameForFont: aFont
	"Answer a new variable name for the specified object."

	| answer |
	answer := aFont wbSuggestedName asSuggestedTempVarToken.
	(self isVarName: answer) | (self isInstVar: answer) ifFalse: [^answer].
	^self constructTempNameFrom: answer! !

!WBHandle methods !   
selector
        ^locator selector! !

!WBCodeStream methods ! 
nextPutComment: aString
		"Append a comment with quotes to the receiver's stream."
	| commentStream first |
	commentStream := ReadStream on: aString.
	self wrapDuring: [
		self nextPut: $".
		first := true.
		[ commentStream skipWhitespace; atEnd ] whileFalse: [
			first ifTrue: [ first := false ] ifFalse: [ self space ].
			self nextPutAll: commentStream upToWhitespace ].
		self nextPut: $" ].! !

!WindowFrameObject methods !
nlsPools

    ^self propertyAt: #nlsPools ifAbsent: [self propertyAt: #nlsPools put: Set new].! !

!FrameObject methods ! 
frameExtent

    ^rect extent! !

!WBModelObjectEditor methods !  
saveWhenSend

    | methodName savedSelection current selectedObject |
    current := self currentEvent.
    selectedObject := self selectedObject.
    send contents hasContent
        ifTrue: [
            methodName := send contents wbValidTriggeredSelectorFor: current.
            (send contents = methodName)
                ifFalse: [
                    savedSelection := send selection.
                    send contents: methodName.
                    send selectFrom: savedSelection x to: savedSelection y].
            methodName isNil
                ifFalse: [
                    selectedObject
                        eventHandlerSelectorAt: current
                        put: methodName
                        prototype: self prototype]]
        ifFalse: [
            selectedObject
                eventHandlerSelectorAt: current
                put: ''
                prototype: self prototype].
    self updateEvents: selectedObject refresh: true.! !

!WBToolBarEditor methods ! 
cellSize

    | cellSize |
    cellSize := (self paneNamed: 'cellSize') contents.
    ^((cellSize upTo: $@) trimBlanks asInteger) @
        ((cellSize reversed upTo: $@) reversed trimBlanks asInteger).! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder class methods !  
resetTranscript
	"Reset the Transcript "
	" WindowBuilder resetTranscript "

	| contents |
	contents := Transcript contents.
	Transcript mainView clearTextModified.
	Transcript mainView closeView.
	Transcript class initializeTranscript.
	Transcript contents: contents! !

!WBDefaultDialogScratchWindow methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| button1 mainView xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	button1 := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'New Dialog';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -75 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -50 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -75 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -50 * yDU).
	self addView: mainView.! !

!ButtonEditor methods !   
changeBits: aPane
    | aPoint  changePoint imagePoint |
    aPoint := aPane mouseLocation.
    (self isInGrid: aPoint)
        ifFalse: [^self].
    imagePoint := aPoint // scale.
    changePoint := imagePoint * scale.
    changePoint printString.
    bitPen fill: ((changePoint + 2) extent: (scale @ scale) - 3)
        color: bitColor.
    imagePen fill: (imagePoint extent: 1 @ 1)
        color: bitColor.
    copy pen fill: (imagePoint extent: 1 @ 1)
        color: bitColor.
    (imagePoint x > (imageForm extent x / 2)) ifTrue: [ ^nil ].
    imagePoint := imagePoint + self offset.
    changePoint := imagePoint * scale.
    (self isInGrid: changePoint) ifFalse: [ ^self ].
    changePoint printString.
    bitPen fill: ((changePoint + 2) extent: (scale @ scale) - 3)
        color: bitColor.
    imagePen fill: (imagePoint extent: 1 @ 1)
        color: bitColor.
    copy pen fill: (imagePoint extent: 1 @ 1)
        color: bitColor! !

!WBResizeBitmap methods !  
isButtonBitmap: aBoolean

	isButtonBitmap := aBoolean.! !

!PEntryField methods ! 
genReceiveWindowMessagesOn: aStream indentString: spaceString
    "Don't generate method for EntryField or ListBox - they already have it"! !

!PEntryFieldGroup methods ! 
addSubpanes

	| numRows labelWidth fieldHeight scrollWidth vertOffset lowest xDU yDU |
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	self children: nil.
	self font isNil ifTrue: [self font: self defaultFont].
	labelWidth := (self contents inject: 0 into: [:max :item | max max: (self font wbStringWidth: item)]) + 8.
	fieldHeight := self font height + 8.
	scrollWidth := self style == #verticalScrollBar
		ifTrue: [self lookPolicy scrollBarWidth]
		ifFalse: [0].
	self style == #defaultStyle
		ifTrue: [
			vertOffset := self font height + 2.
			self children add:
				(PGroupBox new
					parent: self;
					realClass: GroupBox;
					framingBlock: (
						LayoutFrame new
							leftRatio: 0; leftInset: 0 * xDU;
							topRatio: 0; topInset: 0 * yDU;
							rightRatio: 1; rightInset: 0 * xDU;
							bottomRatio: 1; bottomInset: 0 * yDU);
					paneName: 'group';
					contents: self label;
					yourself)]
		ifFalse: [vertOffset := 0].
	lowest := 0.
	numRows := self contents size max: 1.
	1 to: numRows do: [:row |
			row > self contents size 
				ifFalse: [
					self children add:
					   (PStaticText new
							parent: self;
							realClass: StaticText;
							framingBlock: (
								LayoutFrame new
									leftRatio: 0; leftInset: 2;
									topRatio: 0; topInset: 10 + vertOffset + ((fieldHeight + 4) * (row - 1));
									rightRatio: 0; rightInset: (2 + labelWidth) negated;
									bottomRatio: 0; bottomInset: (2 + vertOffset + ((fieldHeight + 4) * row)) negated);
							style: #rightJustified;
							contents: (self contents at: row),':';
							yourself).
					self children add:
					   (self fieldPClass new
							parent: self;
							realClass: self fieldClass;
							framingBlock: (
								LayoutFrame new
									leftRatio: 0; leftInset: 6 + labelWidth;
									topRatio: 0; topInset: 6 + vertOffset + ((fieldHeight + 4) * (row - 1));
									rightRatio: 1; rightInset: 4 + scrollWidth;
									bottomRatio: 0; bottomInset: (lowest := 2 + vertOffset + ((fieldHeight + 4) * row)) negated);
							paneName: (self contents at: row);
							yourself)]].
	self contents size > 0
		ifTrue: [self bestSize y: lowest + 4].
	self foreColor: self foreColor.
	self backColor: self realBackColor.! !

!WindowBuilder class methods !
defaultWBIcon
	"Answer a new wb icon."

	^Icon fromFile: 
		((File findFileName: self defaultWBIconFileName) 
			ifNil: [^nil])! !

!WBCreateViewsModule methods ! 
createMultipleViewsSelector
		"Answer the create mulitple views selector."
	^super defaultMessageSelector! !

!DropDownList class methods !   
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #listVisible ;
                argumentNames: #( ));
        yourself! !

!WBTabOrderEditor methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| addGroupButton cancelButton clearAllButton mainView 
	okButton resetButton scrollingForm xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	removeGroupButton := Button new.
	status := StatusPane new.
	
		"Temporary Variables"
	addGroupButton := Button new.
	cancelButton := Button new.
	clearAllButton := Button new.
	okButton := Button new.
	resetButton := Button new.
	scrollingForm := WBScrollingPane new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Tab Order Editor';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1/2; leftInset: -150 * xDU;
				topRatio: 1/2; topInset: -109 * yDU;
				rightRatio: 1/2; rightInset: -150 * xDU;
				bottomRatio: 1/2; bottomInset: -91 * yDU).
	self addView: mainView.
	
	scrollingForm "WBScrollingPane"
		owner: self;
		setName: 'scrollingForm';
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 0 * yDU;
				rightRatio: 1; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 61/2 * yDU);
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: scrollingForm.
	
	status "StatusPane"
		owner: self;
		setName: 'status';
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 1; topInset: -21/2 * yDU;
				rightRatio: 1; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 0 * yDU);
		contents: (
		    OrderedCollection new
		        addLast: (
		            StatusBox new
		                space: 7;
		                width: 10;
		                name: #status
		        );
		        yourself
		);
		startGroup;
		noTabStop.
	mainView addSubpane: status.
	
	addGroupButton "Button"
		owner: self;
		setName: 'addGroupButton';
		when: #clicked send: #addGroup to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 40 * xDU;
				topRatio: 1; topInset: -57/2 * yDU;
				rightRatio: 0; rightInset: -88 * xDU;
				bottomRatio: 1; bottomInset: 29/2 * yDU);
		contents: '&Add Group';
		startGroup;
		font: SysFont.
	mainView
		addSubpane: addGroupButton;
		subPaneWithFocus: addGroupButton.
	
	removeGroupButton "Button"
		owner: self;
		setName: 'removeGroupButton';
		when: #clicked send: #removeGroup to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 92 * xDU;
				topRatio: 1; topInset: -57/2 * yDU;
				rightRatio: 0; rightInset: -152 * xDU;
				bottomRatio: 1; bottomInset: 29/2 * yDU);
		contents: '&Remove Group';
		startGroup;
		font: SysFont.
	mainView addSubpane: removeGroupButton.
	
	clearAllButton "Button"
		owner: self;
		setName: 'clearAllButton';
		when: #clicked send: #clearAll to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 1; topInset: -57/2 * yDU;
				rightRatio: 0; rightInset: -36 * xDU;
				bottomRatio: 1; bottomInset: 29/2 * yDU);
		contents: '&Clear All';
		startGroup;
		font: SysFont.
	mainView addSubpane: clearAllButton.
	
	resetButton "Button"
		owner: self;
		setName: 'resetButton';
		when: #clicked send: #reset to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 156 * xDU;
				topRatio: 1; topInset: -57/2 * yDU;
				rightRatio: 0; rightInset: -190 * xDU;
				bottomRatio: 1; bottomInset: 29/2 * yDU);
		contents: 'Reset';
		startGroup;
		font: SysFont.
	mainView addSubpane: resetButton.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		when: #clicked send: #ok to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -70 * xDU;
				topRatio: 1; topInset: -57/2 * yDU;
				rightRatio: 1; rightInset: 36 * xDU;
				bottomRatio: 1; bottomInset: 29/2 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: okButton.
	
	cancelButton "Button"
		owner: self;
		setName: 'cancelButton';
		when: #clicked send: #cancel to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -32 * xDU;
				topRatio: 1; topInset: -57/2 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1; bottomInset: 29/2 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancelButton.
	
	self createMenus: mainView! !

!PComboBox methods !   
attributeEditor

    ^WBListEditor! !

!WBInterfaceObject methods !   
autoSizeRatio

    ^1.1! !

!WBCreateBitmap methods ! 
openOn: anInitialKey

	initialKey := anInitialKey.
	self open.! !

!WBTeamVCodePolicy class methods !
toolInterface
		"Answer the Team/V tool interface."
	^WBTeamVToolInterface ifNil: [
		WBTeamVToolInterface := self defaultToolInterface ]! !

!WindowFrameObject methods !   
createdBy

    ^createdBy! !

!ButtonListBox class methods !  
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        add: (SelectorPropertyAccessor new name: 'Three State'; get: #isThreeState; set: #threeState: ; format: 'Boolean');
        add: (SelectorPropertyAccessor new name: 'Use Images'; get: #useImages; set: #useImages: ; format: 'Boolean');
        addNames: #('Three State' 'Use Images') toPage: 'Style';
        wbRemoveEventNamed: #drawItem:;
        wbRemoveEventNamed: #drawFocus:;
        wbRemoveEventNamed: #drawSelection:;
        wbRemoveEventNamed: #measureItem:;
        wbAddEvent: (
            WBEventDescription new
                event: #needsImageFor:;
                argumentNames: #('anItem'));
        wbAddEvent: (
            WBEventDescription new
                event: #needsStringFor: ;
                argumentNames: #('anItem'));
        wbAddEvent: (
            WBEventDescription new
                event: #needsStateFor:;
                argumentNames: #('anItem'));
        wbAddEvent: (
            WBEventDescription new
                event: #checkedIndex:;
                argumentNames: #('anIndex'));
        wbAddEvent: (
            WBEventDescription new
                event: #checked:;
                argumentNames: #('aString'));
        wbAddEvent: (
            WBEventDescription new
                event: #indeterminate:;
                argumentNames: #('aString'));
        wbAddEvent: (
            WBEventDescription new
                event: #unchecked:;
                argumentNames: #('aString'));
        wbAddEvent: (
            WBEventDescription new
                event: #indeterminateIndex:;
                argumentNames: #('anIndex'));
        wbAddEvent: (
            WBEventDescription new
                event: #uncheckedIndex:;
                argumentNames: #('anIndex'));
        yourself! !

!WBInterfaceObject methods !  
setPopupMenu: aRealMenu

	self menu: aRealMenu asWBPMenu.! !

!WBDevelopmentWindow methods !  
updateFontButton: palette for: currentWidget
	"Update the Font button"

	(currentWidget notNil and: [currentWidget usesFont])
		ifTrue: [palette enableItem: #setFont]
		ifFalse: [palette disableItem: #setFont].! !

!WBKeyEntryField methods !  
keyboardInput: aKeyboardInputEvent
		"Private - Process the character input message."
	| virtualKey |
	virtualKey := aKeyboardInputEvent virtualKey.
	(virtualKey = AltKey) | (virtualKey = ControlKey) | (virtualKey = ShiftKey) ifFalse: [
		accelerator keyCode: virtualKey.
		self contents: accelerator keyName.
		self setAugmentKeys.
		self selectAll.
		self event: #keyEntered.
	].! !

!WBMenubarEditor methods !  
newMenuClass

    ^WBPMenubar! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder methods !   
clearDirty

    self dirty: false! !

!WBLookPolicyWin95 methods !
scrollBarThumbWidth

    ^scrollBarThumbWidth ifNil: [
        scrollBarThumbWidth := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxhthumb" 10]
            ifFalse: [super scrollBarThumbWidth]]! !

!PGraphPane methods ! 
mutationTypes

    ^#(#GraphPane)! !

!WBPropertyEditor class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventManagerWindow methods ! 
showButtons: aBoolean

    | panes |
    (panes := OrderedCollection new)
        add: (self paneNamed: 'addButton');
        add: (self paneNamed: 'removeButton');
        add: (self paneNamed: 'saveButton').
    aBoolean
        ifTrue: [
            methodTextEdit framingBlock
                rightInset: methodTextEditFramingBlock rightInset.
            methodTextEdit resize: self mainView rectangle.
            panes do: [:each | each showWindow].
            self optionMenu checkItem: #menuOptionShowButtons]
        ifFalse: [
            panes do: [:each | each hideWindow].
            methodTextEdit framingBlock
                rightInset: panes first framingBlock rightInset.
            methodTextEdit resize: self mainView rectangle.
            self optionMenu uncheckItem: #menuOptionShowButtons].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutForm methods !  
buttonReleaseResizing: aPoint
    "Process a button release event after resizing a widget."

    | aWidget x y width height gridSize oldBox newBox contentRect |
    self drawBand.
    x := bandRect leftTop x.
    y := bandRect leftTop y.
    width := bandRect width.
    height := bandRect height.
    self useGrid
        ifTrue: [
            gridSize := self gridSize.
            contentRect := self shell frameContentRect.
            x := contentRect left distanceRight: x.
            y := contentRect top distanceDown: y.
            x := contentRect left right: (x roundTo: (self gridSize x max: 1)).
            y := contentRect top down: (y roundTo: (self gridSize y max: 1)).
            width := (width roundTo: gridSize x) max: gridSize x.
            height := (height roundTo: gridSize y) max: gridSize y].
    aWidget := self selections first.
    oldBox := aWidget boundingBox.
    newBox := x @ y extentFromLeftTop: width @ height.
    (self
        createUndoRedoForChangeSize: aWidget
        newBox: newBox
        oldBox: oldBox)
            redoAction value.
    self model isNil
        ifFalse: [self model setDirty].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PEntryFieldGroup methods !
bestSize

	^bestSize ifNil: [bestSize := 250@100]! !

!WBStatusPaneEditor methods !   
selectBox: index

    | box |
    box := boxes at: index.
    (self paneNamed: 'name') contents: box name asString.
    (self paneNamed: 'width') contents: box width asString.
    (self paneNamed: 'space') contents: box space asString.
    (self paneNamed: 'contents') setContents: box contents.

    self updateBoxes.! !

!WBListEditor methods ! 
ok

	item contents = listBox selectedItem
		ifFalse: [self add].
	thePane isCollection
		ifTrue: [thePane := list asArray]
		ifFalse: [thePane contents: list asArray].
	self close! !

!WBGraphicObject methods !   
lastRect

    ^lastRect! !

!WBModelCodeModule methods !  
wrapComment
    "Answer true if the comment should be wrapped."

    ^false! !

!WindowBuilder class methods !   
osiMessage
	"Answer the OSI information message string."

	^'Objectshare Systems, Inc.
3160 De La Cruz Blvd, Suite 205
Santa Clara, California 95054

Phone:   (408) 970-7280
Fax:        (408) 970-7282

Compuserve:   76436,1063
Support:           74012,2123'! !

!WBHandle methods !
invokeStep: deltaPoint! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCodeGenerator methods !  
cleanup
        "Private - do any module specific cleanup."
    modules do: [:eachClassModules |
        eachClassModules do: [:eachModule |
            eachModule cleanup]].! !

!PWBToolBar methods !
backColor

    ^backColor.! !

!WBLayoutWizard class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBInterfaceObject methods ! 
editor

	^(self parent ifNil: [^nil]) editor! !

!WBCreateViewModule methods !
children
        "Answer the child panes."
    ^self modelObjects, self view childrenInBuildOrder! !

!WBInterfaceObject methods !
modelObjects
        "Answer the modelObjects."
    ^self prototype modelObjects! !

!WBTeamVCodePolicy class methods !   
defaultTeamInterface
		"Answer the Team/V tool interface."
	^Smalltalk at: #TeamVInterface! !

!WBHandle class methods !  
handleSize: aPoint

    HandleSize := aPoint! !

!WBPoolManagerWindow methods !   
updatePools

	poolListBox update.! !

!WBMultiToolPalette class methods ! 
isWBInternalClass

    ^true! !

!PStatusPane methods !   
updateBoxes

	self style == #leftJustified
		ifTrue:[self updateBoxesLeftJustified]
		ifFalse: [
			self style == #leftJustifiedFixed
				ifTrue:[self updateBoxesLeftJustifiedFixed]
				ifFalse: [
					self style == #rightJustifiedFixed
						ifTrue:[self updateBoxesRightJustifiedFixed]
						ifFalse:[self updateBoxesRightJustified]]].! !

!WBLayoutFrameEditor methods !  
bottomAttachSelected: selectedItem

	"Callback for the #clicked: event in bottomAttachField [WBComboBox].
		(Generated by WindowBuilder Pro)"

	self
		setBottomAttach: selectedItem;
		updateFramingBlocks;
		updateExample;
		dirty: true.! !

!WBGeometryManager methods !  
addWidgetOfClass: aClass

    self layoutForm notNil
        ifTrue: [self layoutForm addWidgetOfClass: aClass].! !

!WBLookPolicyWin95 methods !
scrollBarHeight

    ^scrollBarHeight ifNil: [
        scrollBarHeight := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCyhscroll" 3]
            ifFalse: [super scrollBarHeight]]! !

!LayoutFrame methods !
wbBottomAttachedToTop
	"Answer true if the receiver's bottom is attached to the receiver's top."

	^(self propertyAt: #wbBottomAttachedToTop) ifNil: [
		self wbBottomAttachedToTop: (
			self wbTopProportional and: [
				(self bottomRatio = self topRatio) & (self bottomInset ~= 0)])]! !

!WBFontManager methods !  
editorClass
    "Answer a pool manager window class for the receiver."

    ^WBFontManagerWindow! !

!WBInterfaceObject methods !
initializeForDataType: aClass
    "Do Nothing"! !

!WBLayoutForm methods ! 
notifyModelOfLayoutChange

    self triggerEvent: #changed.
    self model isNil
        ifFalse: [
            self model currentLayoutForm showOrder: false.
            self model currentLayoutForm: self.
            self model currentLayoutForm
                dragOutline: self model dragOutline;
                showOrder: self model showZOrder;
                targetIsFirst: self model targetIsFirst;
                useFence: self model useFence";
                useDirectSelect: self model useDirectSelect"].! !

!WindowBuilder methods ! 
supportsStyleDialog

	^true! !

!WBStatusPaneEditor methods ! 
updateBoxes

    boxes isEmpty ifTrue: [
        (self paneNamed: 'remove') disable.
        (self paneNamed: 'copy') disable.
        (self paneNamed: 'up') disable.
        (self paneNamed: 'down') disable.
        ^nil
    ] ifFalse: [
        (self paneNamed: 'remove') enable.
        (self paneNamed: 'copy') enable.
    ].
    list selection == boxes size ifTrue: [
        (self paneNamed: 'down') disable
    ] ifFalse: [
        (self paneNamed: 'down') enable
    ].
    list selection == 1 ifTrue: [
        (self paneNamed: 'up') disable
    ] ifFalse: [
        (self paneNamed: 'up') enable
    ].! !

!WBCreateBitmap methods ! 
updateOk

	"Callback for the #textChanged: event in keyField [EnhancedEntryField].
		(Generated by WindowBuilder Pro)"

	| aString |
	((aString := self bitmapKey) notEmpty
		and: [aString first isUppercase
		and: [self bitmapWidth > 0
		and: [self bitmapHeight > 0]]])
			ifTrue: [okButton enable]
			ifFalse: [okButton disable].! !

!WBKeyAccel methods !  
pmKeyCodeFor: winCode

    ^WinToPMKeyMap at: winCode ifAbsent: [ nil ]! !

!WBTreeNode methods ! 
indent

    | newParent |

    self canIndent ifTrue: [
        newParent := self previousSibling.
        self parent: newParent.
        self shiftRight.
    ].! !

!WBScrapbookStore methods !  
ok

	| name chapter clipboard |
	layoutPane clipboard isNil
		ifFalse: [
			name := (self paneNamed: 'name') contents.
			name isEmpty
				ifFalse: [
					clipboard := layoutPane clipboard.
					(self paneNamed: 'chapters') selectedItems do: [:chap |
						chapter := (self wbEditorClass scrapbook at: chap).
						(chapter includesKey: name)
							ifTrue: [
								(MessageBox confirm: '''' , name , ''' already exists. Do you want to replace it?')
									ifFalse: [^nil]].
						chapter at: name put: clipboard.
						chap = 'Quick Reference'
							ifTrue: [isQuick := true]].
					self close]]! !

!WBLayoutForm methods ! 
button1MotionSelecting: aPoint
    "Process a motion event that occurred while we are drag selecting."

    | x y |
    x := self cursorSelectPoint x.
    y := self cursorSelectPoint y.
    ((aPoint x isLeftOf: x) and: [aPoint y isAbove: y])
        ifTrue: [self currentNib: #topLeft]
        ifFalse: [
            ((aPoint x isRightOf: x) and: [aPoint y isAbove: y])
                ifTrue: [self currentNib: #topRight]
                ifFalse: [
                    ((aPoint x isLeftOf: x) and: [aPoint y isBelow: y])
                        ifTrue: [self currentNib: #bottomLeft]
                        ifFalse: [
                            ((aPoint x isRightOf: x) and: [aPoint y isBelow: y])
                                ifTrue: [self currentNib: #bottomRight]]]].
    self
        drawBand;
        bandRect: (self cursorSelectPoint extentFromLeftTop: 0@0);
        resizeBand: aPoint;
        drawBand
! !

!WBPMenuItem methods !   
accelerator

    ^keyAccel! !

!Bitmap methods !  
wbInitButton
	"Private - WBPro Development.
		Create a new tool bar button bitmap template"

	| w h |
	#addedByOSI.
	w := self width // 2.
	h := self height.
	self pen
		fill: Color gray;
		foreColor: Color black;
		lineFrom: 1@0 to: (w - 1)@0;
		lineFrom: (w + 1)@0 to: (2 * w - 1)@0;
		lineFrom: (2 * w - 1)@1 to: (2 * w - 1)@(h - 1);
		lineFrom: 1@(h - 1) to: (w - 1)@(h - 1);
		lineFrom: (w + 1)@(h - 1) to: (2 * w - 1)@(h - 1);
		lineFrom: 0@1 to: 0@(h - 1);
		lineFrom: (w - 1)@1 to: (w - 1)@(h - 1);
		lineFrom: w@1 to: w@(h - 1);
		foreColor: Color white;
		lineFrom: 1@1 to: 1@(h - 2);
		lineFrom: 2@1 to: (w - 2)@1;
		foreColor: Color darkGray;
		lineFrom: 1@(h - 2) to: (w - 1)@(h - 2);
		lineFrom: 2@(h - 3) to: (w - 1)@(h - 3);
		lineFrom: (w - 2)@1 to: (w - 2)@(h - 2);
		lineFrom: (w - 3)@2 to: (w - 3)@(h - 2);
		lineFrom: (w + 1)@1 to: (w + 1)@(h - 1);
		lineFrom: (w + 2)@1 to: (2 * w - 1)@1;
		lineFrom: (w + 2)@2 to: (w + 2)@(h - 1);
		lineFrom: (w + 3)@2 to: (2 * w - 1)@2.! !

!WindowBuilder class methods ! 
privateString

    ^#Private! !

!WBFramerExample methods !   
paneRect: aRect

    paneRect := aRect.
    self display.! !

!WindowBuilder methods !   
autoSize

    ^self class autoSize! !

!WBTemplateEditor methods !
styleLabel

	^styleLabel! !

!WBPoolManagerWindow methods !   
selectedKeyAndPool: aKeyAndPool
	"Set the selected key/pool."

	self selectedKeysAndPools: (OrderedCollection with: aKeyAndPool).! !

!WindowBuilder methods !   
menuFileAbout

    self class aboutWB! !

!PCompositePane methods !   
children

	^children ifNil: [children := #()].! !

!WBGraphicObject methods ! 
topLeft

	^rect topLeft! !

!Object methods ! 
wbFullCopy: aDictionary
	"Answer a full copy of the receiver."

	#addedByOSI.
	^aDictionary at: self ifAbsent: [self wbFullCopyReal: aDictionary]! !

!PButtonListBox class methods !   
styleFrom: style

    ^nil! !

!WBDialogScratchWindow class methods ! 
createMethod: methodString

    | fileInStream |

    fileInStream := ReadWriteStream on: (String new: methodString size).
    fileInStream
        nextPutAll: '!! WBDialogScratchWindow methods !!';
        nextChunkPut: methodString;
        nextChunkPut: String new.

    fileInStream reset; fileIn.! !

!WBLayoutForm methods ! 
clipboard: aCollection

    self model clipboard: (aCollection collect: [:aWidget |
        aWidget wbDuplicate]).! !

!WBLayoutForm methods !   
scrollingForm

    ^self superWindow! !

!WindowBuilder class methods !   
instVarNameCheck

    ^self editorClass
        propertyValueAt: #InstVarNameCheck
        category: self editorPropertyString! !

!WBGeometryManager methods ! 
sendBackward
    "Send the selected widgets backward in the z-order"

    self sendBackward:
        (self children select: [:child |
            self selections includes: child]).! !

!WindowFrameObject methods !  
style: aCollection

	| propertyManager |
	propertyManager := self wbRealWidget wbPropertyManager.
	self realStyleNames associationsDo: [:each |
		(propertyManager includesKey: each value) ifTrue: [
			propertyManager
				setProperty: each value
				to: (aCollection includes: each key)
				for: self wbRealWidget]].
	style := aCollection.! !

!WBBitmapManagerWindow methods !   
menuKeyResize: isButtonBitmap

    | prompter newExtent oldExtent operation |
    oldExtent := (self anySelectedBitmap ifNil: [^self]) extent.
    (prompter := WBResizeBitmap new)
        oldExtent: oldExtent;
        isButtonBitmap: isButtonBitmap;
        open.
    newExtent := prompter newExtent ifNil: [^self].
    operation :=
        prompter isButtonBitmap
            ifTrue: [
                prompter isScaled
                    ifTrue: [#wbScaleButton:]
                    ifFalse: [#wbResizeButton:]]
            ifFalse: [
                prompter isScaled
                    ifTrue: [#wbScale:]
                    ifFalse: [#wbResize:]].
    [self
        menuKeyResizeBitmap: self selectedKeysAndPools
        categories: self selectedCategories
        all: prompter isResizeAll
        from: oldExtent
        to: newExtent
        operation: operation.
    ] on: WBPoolError do: [:exception | ^self menuErrorHandler: exception].! !

!WindowBuilder methods !  
dirty

    ^dirty! !

!WBPoolManagerWindow methods !  
menuKeyBrowseReferences

    "Callback for the menu item titled 'Browse references...'.
     (Generated by WindowBuilder)"

	| keysAndPools |
	(keysAndPools := self selectedKeysAndPools) isEmpty ifTrue: [^self].
	self menuKeyBrowseReferences: keysAndPools.! !

!WBEditClassDialog methods !
packageChoice

    package selectedItem isNil ifTrue: [^self class defaultChoice].
    ^package selectedItem.! !

!StylePropertyAccessor methods !   
wbDefaultPoolName

	| match |
	(match := self pool) notNil ifTrue: [
		Smalltalk associationsDo: [:each |
			each value == match ifTrue: [^each key]]].
	^super wbDefaultPoolName! !

!WindowBuilder class methods !  
wbIcon
	"Answer the wb icon or nil."

	^self 
		propertyAt: #wbIcon 
		ifAbsent: [self defaultWBIcon]! !

!WBGeometryManager methods ! 
moveByPixelUp
    "Move the selected widgets up one pixel"

    | selections |
    (selections := self selections copy) isEmpty
        ifTrue: [^self owner setWindowPosition: (self shell x @ (self shell y - 1))].
    (self undoManager
        add: 'Move Pixel Up'
        undo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    moveWidget: aWidget x
                    y: (aWidget y down: 1);
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections]
        redo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    moveWidget: aWidget x
                    y: (aWidget y up: 1);
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections])
        redoAction value.
    self updateWidget.! !

!WindowBuilder class methods !  
gridSize

    ^self editorClass
        propertyValueAt: #GridSize
        category: self gridPropertyString.! !

!WBLayoutForm methods !   
showHandles: aCollectionOfHandles

    self showHandles: aCollectionOfHandles color: self handleColor.! !

!WBModelDefinitionEditor methods ! 
edit

    | toolInterface browser globalList global |
    self isDirty
        ifTrue: [self updateModel ifFalse: [^self]].
    self wbEditorClass envyIsInstalled
        ifTrue: [^self selectedModel edit].
    (self wbEditorClass teamIsInstalled and: [self wbEditorClass useClassHierarchyBrowser not xor: Notifier isAltKeyDown])
        ifTrue: [
            browser := (toolInterface := Smalltalk at: #ToolInterface) current subsystemBrowserClass openHierarchyOn: toolInterface currentSubsystem.
            globalList := browser globalList.
            global := globalList subsystem definitionOfGlobalNamed: selectedModel symbol.
            globalList selectionHolder value: global.
            globalList container packageList module: global package.
            browser classEditor categoryList category: '** all **']
        ifFalse: [
            (self activateClassBrowserOnClass: selectedModel) isNil
                ifTrue: [
                    (Message
                        receiver: ClassHierarchyBrowser new open
                        selector: #wbFindClass:
                        arguments: (Array with: selectedModel symbol)) performDeferred]].! !

!WBTreeNode methods !
removeChild: aChild

    children remove: aChild.! !

!WBPoolManagerWindow methods !  
menuKeyDelete: aCollection

	aCollection do: [:each | each value removeKey: each key].! !

!WBLayoutFrameEditor methods ! 
leftAttachSelected: selectedItem

	"Callback for the #clicked: event in leftAttachField [WBComboBox].
		(Generated by WindowBuilder Pro)"

	self
		setLeftAttach: selectedItem;
		updateFramingBlocks;
		updateExample;
		dirty: true.! !

!WBCallOutEditor methods !  
shell

	^self owner shell! !

!PStaticText methods !  
winUserStyle

    ^((OrderedCollection new
            add: SsLeft;
            add: SsRight;
            add: SsCenter;
            yourself) asArray
        at: (#(#leftJustified #rightJustified #centered) indexOf: style))! !

!WBTemplateEditor methods ! 
sizeLabel

	^sizeLabel! !

!WindowBuilder methods !   
menuScrapbookStore

    self geometryManager copySelections.
    (self clipboard isNil or: [self clipboard isEmpty])
        ifTrue: [^MessageBox message: 'At least one pane must be selected first.'].
    (WBScrapbookStore new openOn: self layoutForm) isQuick
        ifTrue: [self updateQuickReferenceMenu]! !

!WBKeyAccel methods ! 
accelArray: accelArray

    | bits accel code |

    bits := accelArray at: 2.
    accel := accelArray at: 1.

    bits isNil ifTrue: [ bits := AfVirtualkey ].

    self accelBits:  bits.

    accel isNil ifTrue: [
        ^keyCode := nil
    ].

    code := UserLibrary mapVirtualKey: accel mapType: 2.
    code == 0 ifTrue: [
        self keyCode: accel
    ] ifFalse: [
        self keyCode: code asCharacter.
    ].! !

!WBModelDefinitionEditor methods !  
addAttribute

    | newInstVar target |
    newInstVar := (WBModelInstVar new
        name: '<new instVar>';
        myClass: selectedModel;
        hasAccessors: false;
        initialized: false;
        lazy: false;
        valueClass: Object;
        initializeValue: nil;
        hasEvent: false;
        yourself).
    (target := attributes contents
        detect: [:instVar | instVar myClass ~~ selectedModel]
        ifNone: [nil]) isNil
        ifTrue: [attributes contents addFirst: newInstVar]
        ifFalse: [attributes contents add: newInstVar before: target].
    attributes
        contents: attributes contents;
        selectItem: newInstVar.
    self selectAttribute: newInstVar.
    name
        setFocus;
        selectAll.
    self setDirty.
! !

!WBDevelopmentCompositePane class methods !
isWBInternalClass

    ^true! !

!WBPMenu methods !   
asMenu

    | menu |

    menu := Menu new.
    menu title: ''.
    children do: [ :c |
        c appendTo: menu.
    ].

    ^menu! !

!WBFramingEditor methods !
cornerYAnchorChanged: selectedItem

    selectedItem = 'Pane top'
        ifTrue:
            [originYAnchor disableItem: 'Pane bottom'.
            ]
        ifFalse:
            [originYAnchor enableItem: 'Pane bottom'.
            ].
    self setExampleRects.! !

!WBTabOrderEditor class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBTabOrderEditor methods !  
removeGroup

	layoutForm destroySelectedWidgets.! !

!WBCodeStream methods !  
lineSize
		"Private - Answer the # of characters in the current line."
	^stream position - lineStartPos! !

!WBPoolManagerWindow methods !
menuPoolUpdateDependentClasses: aCollection

	| translator |
	translator := (Smalltalk at: #WBTranslator ifAbsent: [
			^MessageBox message: 'The WindowBuilder Translator must be loaded first'.
		]) new.
	aCollection do: [:eachClass |
		eachClass wbCreated ifTrue: [translator translate: eachClass].
		eachClass compileAll.
		eachClass class compileAll].! !

!WBPoolEditorCompositePane methods !
updateValue! !

!WBEventManagerWindow class methods !   
toFieldExtensions: aDictionary

	"
	WBEventManagerWindow toFieldExtensions: nil.
	"

	toFieldExtensions := aDictionary.! !

!WBLinkEditor methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel linkTypeGroup list listLabel mainView ok 
	typeDescription types xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	linkTypeGroup := GroupBox new.
	list := ListBox new.
	listLabel := StaticText new.
	ok := Button new.
	typeDescription := TextEdit new.
	types := ListBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Link Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -91 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -105/2 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -91 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -105/2 * yDU).
	self addView: mainView.
	
	listLabel "StaticText"
		owner: self;
		setName: 'listLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -95 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Select a Class:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: listLabel.
	
	types "ListBox"
		owner: self;
		setName: 'types';
		when: #clicked: send: #selectType: to: self;
		when: #doubleClicked: send: #ok: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 104 * xDU;
				topRatio: 0; topInset: 17 * yDU;
				rightRatio: 0; rightInset: -174 * xDU;
				bottomRatio: 0; bottomInset: -44 * yDU);
		startGroup;
		noTabStop;
		font: SysFont;
		contents: #( 'Independent' 'Child' 'Sibling' ).
	mainView addSubpane: types.
	
	typeDescription "TextEdit"
		owner: self;
		setName: 'typeDescription';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 104 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -174 * xDU;
				bottomRatio: 0; bottomInset: -83 * yDU);
		removeHorizontalScrollbarStyle;
		addVerticalScrollbarStyle;
		addBorderStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: typeDescription.
	
	list "ListBox"
		owner: self;
		setName: 'list';
		when: #clicked: send: #select: to: self;
		when: #doubleClicked: send: #ok: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 11 * yDU;
				rightRatio: 0; rightInset: -96 * xDU;
				bottomRatio: 0; bottomInset: -102 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: list;
		subPaneWithFocus: list.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 100 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 0; rightInset: -137 * xDU;
				bottomRatio: 0; bottomInset: -102 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 141 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 0; rightInset: -178 * xDU;
				bottomRatio: 0; bottomInset: -102 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	linkTypeGroup "GroupBox"
		owner: self;
		setName: 'linkTypeGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 100 * xDU;
				topRatio: 0; topInset: 7 * yDU;
				rightRatio: 0; rightInset: -178 * xDU;
				bottomRatio: 0; bottomInset: -86 * yDU);
		contents: 'Link Type';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: linkTypeGroup! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventManagerWindow methods !
handlerListBoxDragEnabled

    ^handlerListBoxDragEnabled ifNil: [true]! !

!WBModelEventsTriggeredModule methods !   
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self generateGeneratedSymbol.
        self stream cr; nextPutAll: '^super constructEventsTriggered'; indentBy: 1.
        self object do: [:eventName |
            eventName isNil
                ifFalse: [self stream cr; nextPutAll: 'add: #'; nextPutAll: eventName; nextPut: $;]].
        self stream cr; nextPutAll: #yourself; indentBy: -1]! !

!PColumnListBox methods !   
listEditorAllowsSort

    ^false! !

!WBTabOrderLayoutForm methods !  
buttonDown: aPoint

    | aNib child |

    child := self findChildFor: aPoint.

    self loadedWidgets isNil
        ifFalse: [^self placeWidgets: aPoint].

    "Save the original selection point and clear the allowMove flag.
     This is used to avoid moving the widget in the case of very small mouse jiggles."
    self cursorSelectPoint: aPoint.
    self allowMove: false.

    self handles notEmpty ifTrue: ["See if selected widget's resizers are under the mouse."
        (aNib := self handleAt: aPoint) notNil
            ifTrue: [
                self selection: aNib owner.
                self currentNib: aNib selector.
                self hideHandles.
                ^self setupResizing]].

    child notNil 
        ifTrue: [
            self hideHandles.
            (self selections includes: child)
                ifFalse: [self selection: child].
            ^self]
        ifFalse: [
            "Must have selected white space, deselect current widget."
            self
                hideHandles;
                clearSelections;
                triggerEvent: #clicked: with: nil].! !

!WBDialogScratchWindow class methods !  
isScratchWindow

    ^true! !

!WindowBuilder methods !   
undoManager: aWBUndoManager

    undoManager := aWBUndoManager! !

!PStaticText methods ! 
displayWith: aPen clipRect: clipRect

	| just string aRect region charsDrawn default |
	region := aPen setClipRect: clipRect.
	aPen fill: rect color: self backColor.
	aPen
		foreColor: foreColor;
		backColor: self backColor;
		font: self font.
	default := WBLookPolicy default.
	just :=  (Array
		with: default leftJustification
		with: default leftJustificationWordWrap
		with: default rightJustification
		with: default centerJustification)
		at: (#(#leftJustified #leftJustifiedWordWrap #rightJustified #centered) indexOf: style).
	aPen setTextAlign: TaTop.
	OperatingSystem isOS2
		ifTrue: [
			string := self contents.
			aRect := rect.
			aPen setTextAlign: WBDisplayContext defaultTextAlign.
			[(charsDrawn := aPen winDrawText: string in: aRect justification: just) = 0] whileFalse: [
				 string := string copyFrom: charsDrawn + 1 to: string size.
				aRect := aRect left @ (aRect top down: self font height) rightBottom: aRect rightBottom]]
		ifFalse: [
			aPen 
				winDrawText: self contents 
				in: rect 
				format: just | default wordBreak].
	aPen destroyRegion: region.! !

!WBModelTriggerEventModule methods !   
defaultComment
        "Answer the default comment string."
    ^'Private - trigger the #', self object eventName, ' event.',
        super defaultComment! !

!WindowBuilder methods !  
isDirty

    ^self dirty! !

!WBOutboardWindow methods !  
openOn: aWindowBuilder

	owner := aWindowBuilder.
	self open! !

!WBAttributeWindow methods !
owner
		"Answer the receiver's owner."
	^owner! !

!FrameObject methods ! 
margin

	^8! !

!WindowBuilder methods !  
tagNewEvents
	"Answer the string appended to new events."

	^''! !

!WBDevelopmentWindow methods !   
templateRemove: aSymbol

	^WBInterfaceObject templateRemove: aSymbol! !

!WBTabOrderLayoutForm methods !  
widgetsFrom: aCollection containedIn: grouper testBlock: aBlock

	^aCollection select: [:widget | 
		(aBlock value: widget)
			and: [(grouper rect containsPoint: widget rect leftTop) 
			and: [grouper rect containsPoint: widget rect rightBottom]]].! !

!WBLayoutForm methods !   
directEditor
    "Answer the value of directEditor."

    ^directEditor! !

!WBCodeGenerator methods !   
propertyAt: key ifAbsent: aBlock
        "Answer the value associated with key
        in the properties dictionary; if absent, 
        answer the result of evaluating aBlock."
    properties isNil ifTrue: [ ^aBlock value ].
    ^properties at: key ifAbsent: aBlock! !

!WBPrimaryModelInitializeModule methods !   
wrapComment
    "Answer true if the comment should be wrapped."

    ^false! !

!WBAbstractAddInModule class methods !   
loaded: aBoolean
    "Set the value of loaded to <aBoolean>."

    loaded := aBoolean! !

!WindowBuilder class methods ! 
wbInitializeOldSystemBitmaps
	"Initialize the old system bitmap names."

	(Smalltalk at: #CPBitmapDict ifAbsent: [^self])
		addSystemMap: (Dictionary new 
			at: '3D Button' put: 'WB3DButtonSysBitmap';
			at: 'ActionButton' put: 'ActionButtonSysBitmap';
			at: 'address' put: 'WBAddressSysBitmap';
			at: 'AddressEditorPane' put: 'WBAddressEditorPaneSysBitmap';
			at: 'AddressPane' put: 'WBAddressPaneSysBitmap';
			at: 'alignBottom' put: 'WBAlignBottomSysBitmap';
			at: 'alignCenterHorizontal' put: 'WBAlignCenterHorizontalSysBitmap';
			at: 'alignCenterVertical' put: 'WBAlignCenterVerticalSysBitmap';
			at: 'alignDistributeHorizontal' put: 'WBAlignDistributeHorizontalSysBitmap';
			at: 'alignDistributeVertical' put: 'WBAlignDistributeVerticalSysBitmap';
			at: 'alignLeft' put: 'WBAlignLeftSysBitmap';
			at: 'alignRight' put: 'WBAlignRightSysBitmap';
			at: 'alignTop' put: 'WBAlignTopSysBitmap';
			at: 'AnimationPane' put: 'WBAnimationPaneSysBitmap';
			at: 'ArrowTool' put: 'WBArrowToolSysBitmap';
			at: 'autosize' put: 'WBAutosizeSysBitmap';
			at: 'bitmapManagerToolbarBitmap' put: 'WBBitmapManagerToolbarBitmapSysBitmap';
			at: 'bringToFront' put: 'WBBringToFrontSysBitmap';
			at: 'Button' put: 'ButtonSysBitmap';
			at: 'checkBox' put: 'WBCheckBoxSysBitmap';
			at: 'CheckBox' put: 'CheckBoxSysBitmap';
			at: 'CheckBoxGroup' put: 'CheckBoxGroupSysBitmap';
			at: 'checkBoxOn' put: 'WBCheckBoxOnSysBitmap';
			at: 'clear' put: 'WBClearSysBitmap';
			at: 'ComboBox' put: 'ComboBoxSysBitmap';
			at: 'Composite' put: 'WBCompositeSysBitmap';
			at: 'copy' put: 'WBCopySysBitmap';
			at: 'CP3DCheckBox' put: 'CP3DCheckBoxSysBitmap';
			at: 'CP3DFrame' put: 'CP3DFrameSysBitmap';
			at: 'CP3DRadioButton' put: 'CP3DRadioButtonSysBitmap';
			at: 'CPBitmapButton' put: 'CPBitmapButtonSysBitmap';
			at: 'CPBitmapPane' put: 'CPBitmapPaneSysBitmap';
			at: 'CPBitmapToggle' put: 'CPBitmapToggleSysBitmap';
			at: 'CPCircularGauge' put: 'CPCircularGaugeSysBitmap';
			at: 'CPColumnarListBox' put: 'CPColumnarListBoxSysBitmap';
			at: 'CPDateEditor' put: 'CPDateEditorSysBitmap';
			at: 'CPHierarchicalListBox' put: 'CPHierarchicalListBoxSysBitmap';
			at: 'CPHorizontalBarGauge' put: 'CPHorizontalBarGaugeSysBitmap';
			at: 'CPHorizontalSlider' put: 'CPHorizontalSliderSysBitmap';
			at: 'CPNumericEditor' put: 'CPNumericEditorSysBitmap';
			at: 'CPSpinButton' put: 'CPSpinButtonSysBitmap';
			at: 'CPStaticGraphic' put: 'WBCPStaticGraphicSysBitmap';
			at: 'CPTableEditor' put: 'CPTableEditorSysBitmap';
			at: 'CPTimeEditor' put: 'CPTimeEditorSysBitmap';
			at: 'CPValueSet' put: 'CPValueSetSysBitmap';
			at: 'CPVerticalBarGauge' put: 'CPVerticalBarGaugeSysBitmap';
			at: 'CPVerticalSlider' put: 'CPVerticalSliderSysBitmap';
			at: 'createNew' put: 'WBCreateNewSysBitmap';
			at: 'createNewDialog' put: 'WBCreateNewDialogSysBitmap';
			at: 'cut' put: 'WBCutSysBitmap';
			at: 'DictionaryEditorPane' put: 'WBDictionaryEditorPaneSysBitmap';
			at: 'DrawnButton' put: 'DrawnButtonSysBitmap';
			at: 'duplicate' put: 'WBDuplicateSysBitmap';
			at: 'editAppCode' put: 'WBEditAppCodeSysBitmap';
			at: 'editTabbing' put: 'WBEditTabbingSysBitmap';
			at: 'EnhancedEntryField' put: 'EnhancedEntryFieldSysBitmap';
			at: 'EntryField' put: 'EntryFieldSysBitmap';
			at: 'EntryFieldGroup' put: 'EntryFieldGroupSysBitmap';
			at: 'GraphPane' put: 'GraphPaneSysBitmap';
			at: 'Group' put: 'WBGroupSysBitmap';
			at: 'GroupBox' put: 'GroupBoxSysBitmap';
			at: 'LinkButton' put: 'LinkButtonSysBitmap';
			at: 'List' put: 'WBListSysBitmap';
			at: 'ListBox' put: 'ListBoxSysBitmap';
			at: 'ListEditorPane' put: 'WBListEditorPaneSysBitmap';
			at: 'ListPane' put: 'ListPaneSysBitmap';
			at: 'littleDownArrow' put: 'WBLittleDownArrowSysBitmap';
			at: 'littleUpArrow' put: 'WBLittleUpArrowSysBitmap';
			at: 'Misc' put: 'WBMiscSysBitmap';
			at: 'MultipleSelectListBox' put: 'MultipleSelectListBoxSysBitmap';
			at: 'NamePane' put: 'WBNamePaneSysBitmap';
			at: 'OkCancelPane' put: 'WBOkCancelPaneSysBitmap';
			at: 'openNew' put: 'WBOpenNewSysBitmap';
			at: 'osilogo' put: 'WBOsilogoSysBitmap';
			at: 'other:' put: 'WBOtherSysBitmap';
			at: 'paste' put: 'WBPasteSysBitmap';
			at: 'PersonPane' put: 'WBPersonPaneSysBitmap';
			at: 'position' put: 'WBPositionSysBitmap';
			at: 'RadioButton' put: 'RadioButtonSysBitmap';
			at: 'radioButton' put: 'WBRadioButtonSysBitmap';
			at: 'RadioButtonGroup' put: 'RadioButtonGroupSysBitmap';
			at: 'radioButtonOn' put: 'WBRadioButtonOnSysBitmap';
			at: 'replicateHeight' put: 'WBReplicateHeightSysBitmap';
			at: 'replicateWidth' put: 'WBReplicateWidthSysBitmap';
			at: 'save' put: 'WBSaveSysBitmap';
			at: 'sendToBack' put: 'WBSendToBackSysBitmap';
			at: 'setColor:' put: 'WBSetColorSysBitmap';
			at: 'setDrawGrid' put: 'WBSetDrawGridSysBitmap';
			at: 'setFont:' put: 'WBSetFontSysBitmap';
			at: 'setFraming:' put: 'WBSetFramingSysBitmap';
			at: 'setMenu:' put: 'WBSetMenuSysBitmap';
			at: 'SexPane' put: 'SexPaneSysBitmap';
			at: 'size' put: 'WBSizeSysBitmap';
			at: 'StaticBox' put: 'StaticBoxSysBitmap';
			at: 'StaticGraphic' put: 'StaticGraphicSysBitmap';
			at: 'StaticText' put: 'StaticTextSysBitmap';
			at: 'StatusPane' put: 'StatusPaneSysBitmap';
			at: 'steelPattern' put: 'WBSteelPatternSysBitmap';
			at: 'testWindow' put: 'WBTestWindowSysBitmap';
			at: 'Text' put: 'TextSysBitmap';
			at: 'TextEdit' put: 'TextEditSysBitmap';
			at: 'TextPane' put: 'TextPaneSysBitmap';
			at: 'ThreeStateButton' put: 'ThreeStateButtonSysBitmap';
			at: 'toolPaneExample' put: 'WBToolPaneExampleSysBitmap';
			at: 'Valuator' put: 'WBValuatorSysBitmap';
			at: 'WBHorizontalScrollBar' put: 'WBHorizontalScrollBarSysBitmap';
			at: 'wbpro' put: 'WBWbproSysBitmap';
			at: 'WBToolBar' put: 'WBToolBarSysBitmap';
			at: 'WBVerticalScrollBar' put: 'WBVerticalScrollBarSysBitmap';
			at: 'window' put: 'WBWindowSysBitmap';
			at: 'windowBuilderToolbarBitmap' put: 'WBWindowBuilderToolbarSysBitmap';
			yourself).
	! !

!WBInterfaceObject class methods !  
exampleFrom: aClassName
    "Answer an new instance of the receiver appropriately
     initialized. If a template exists, use it."
    | example |
    (example := self templateAt: aClassName) isNil
        ifTrue: [
            example := super example.
            example
                realClass: (Smalltalk
                    at: aClassName asSymbol
                    ifAbsent: [SubPane]).
            example usesTitle
                ifTrue: [example text: aClassName asString].
            example
                style: example defaultStyle;
                font: example defaultFont;
                extent: example defaultSize]
        ifFalse: [
            example := example wbCopy].
    ^example! !

!WBLookPolicyOS2 methods ! 
scrollBarThumbWidth

	^scrollBarThumbWidth ifNil: [
		scrollBarThumbWidth := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCxhslider" 32]
			ifFalse: [super scrollBarThumbWidth]]! !

!WBLookPolicyWin95 methods ! 
rightJustification

    ^"SsRight" 2! !

!Bitmap methods !
screenWidth4: w height: h
        "Private - Initialize the receiver with width w and height h."
    | planes hOldBitmap |
    planes := GDILibrary getDeviceCaps: Display deviceContext
        index: Planes.
    self
        initPenWidth: w
        height: h
        planes: planes
        bitCount: 4.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap! !

!WBFramingEditor methods !  
yCenteredToggled: isCentered

    isCentered
        ifTrue:
            [originYStyleFixed selection: true.
            originYStyleScaled selection: false.
            cornerYStyleFixed selection: true.
            cornerYStyleScaled selection: false.
            originYAnchor selection: 'Window top'.
            cornerYAnchor selection: 'Window top'.
            originYStyleFixed disable.
            originYStyleScaled disable.
            cornerYStyleFixed disable.
            cornerYStyleScaled disable.
            originYAnchor disable.
            cornerYAnchor disable.
            topRelative disable.
            bottomRelative disable.
            ]
        ifFalse:
            [originYStyleFixed enable.
            originYStyleScaled enable.
            cornerYStyleFixed enable.
            cornerYStyleScaled enable.
            originYAnchor enable.
            cornerYAnchor enable.
            topRelative enable.
            bottomRelative enable.
            ].
    self setExampleRects.! !

!Pattern methods !  
wbTranslate: aString using: stringTemplate
	"Private - Translate aString using stringTemplate and the receiver."

	| stream templateStream pos chunk |
	templateStream := ReadStream on: stringTemplate.
	stream := WriteStream on: (String new: aString size + 10).
	[	pos := templateStream position.
		chunk := templateStream upTo: WildcardChar.
		stream nextPutAll: chunk.
		templateStream position - pos > chunk size
	] whileTrue: [].
	^stream contents! !

!WindowBuilder class methods !
autoSize: aBoolean

    ^self editorClass
        propertyValueAt: #AutoSize
        category: self editorPropertyString
        put: aBoolean! !

!WBDevelopmentWindow class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBLayoutForm methods !  
updateAfterResize
    "Do Nothing"! !

!WindowBuilder class methods !  
createMethod: methodString in: aClass loggingSource: logSource
	"Do all method creation through this method"

	| result hook aSymbol |
	self teamIsInstalled & logSource
		ifTrue: [
			^aClass isMetaClass
				ifTrue: [
					((Smalltalk at: #TeamVInterface) current definitionOfGlobalNamed: (aSymbol := aClass instanceClass name asSymbol)) package
						addMethodInClassNamed: aSymbol
						meta: true
						sourceString: methodString
						notifying: nil]
				ifFalse: [
					((Smalltalk at: #TeamVInterface) current definitionOfGlobalNamed: (aSymbol := aClass name asSymbol)) package
						addMethodInClassNamed: aSymbol
						meta: false
						sourceString: methodString
						notifying: nil]]
		ifFalse: [
			result := aClass compile: methodString.
			result notNil & logSource
				ifTrue: [
					((hook := self codeGenerationHook) notNil 
					and: [self respondsTo: hook asSymbol])
						ifTrue: [
							self
									perform: hook asSymbol
									with: methodString
									with: result key
									with: aClass]
						ifFalse: [
							SourceManager current
									logSource: methodString
									forSelector: result key
									inClass: aClass]]].! !

!WBMenuEditor methods !  
updateItem: itemIndex

    | item accel list |

	itemIndex isNil ifTrue: [ ^self ].
    list := menuItemsEditor contents asFlatList.
    list size < itemIndex ifTrue: [
        ^self
    ].

    item := list at: itemIndex.

    item isSeparator: dividerState selection.

    hasAccelCheckBox selection  ifTrue: [
        accel := WBKeyAccel new keyName: keyShortCutEditor text.
        accel isAlt: isAlt selection.
        accel isShift: isShift selection.
        accel isCtrl: isCtrl selection.
        item accelerator: accel.
     ] ifFalse: [
        item accelerator: nil.
    ].

    selectorEditor contents trimBlanks notEmpty ifTrue: [
        (selectorEditor contents first == $<) ifFalse: [
            item selector: selectorEditor contents trimBlanks asSymbol.
        ].
    ] ifFalse: [
         item selector: nil.
    ].! !

!WBCodeStream methods !
nextPutAll: aString
		"Append aString to the code stream.
			Keep all characters in aString on the same line."
	self checkEnd.
	(self isSpaceOnLine: aString size) ifFalse: [ self cr ].
	stream nextPutAll: aString.! !

!WBPMenu methods !   
storeOn: aStream indentString: indentString

    | mainMenu |

    mainMenu := WBPMenuItem new.
    mainMenu children: children.
    mainMenu storeOn: aStream indentString: indentString.! !

!WBGraphicObject methods ! 
height
        "Answer the receiver's height."
    ^self hitRect height! !

!WBMultiToolPalette methods ! 
at: key on: name put: aBitmapFileName

    ^self at: key on: name put: aBitmapFileName selector: nil! !

!WBCodeGenerator methods !   
classDefinitions
		"Answer the dictionary of class definitions."
	^classDefinitions ifNil: [ classDefinitions := IdentityDictionary new ]! !

!WBLayoutWizard methods !   
targetObject

    ^self prototype targetObject! !

!WBModelInstVar methods !  
lazy

    ^lazy! !

!WBPoolManager methods !  
defaultCodeGenerationStyle
	"Answer the code generation style.
		Answer #key to generate code that references the pool key directly.
		Answer #pool to generate code that is '(<pool> at: <key>)'.
		Answer #manager to generate code that is
			'(<valueClass> named: <key>)'  or  '(<managerClass> system at: <key>)'."

	^self class system == self
		ifTrue: [#key]
		ifFalse: [self defaultIndirectCodeGenerationStyle]! !

!PEntryField methods !
justification

    ^#left! !

!PStaticGraphic methods !   
defaultSize

    ^32@32! !

!WindowBuilder methods !  
attributePalette

	^attributeBar! !

!WBClassDefinition methods ! 
basicInstVarNames
		"Private - Answer a collection of instance variable names."
	^self classField instVarNames! !

!PEnhancedEntryField methods ! 
autoTab

	^autoTab ifNil: [autoTab := false].! !

!WBEnhancedAttributeEditor methods !
saveFields

	self fieldNames do: [:each |
		self
			saveField: (self thePropertyManager getAccessor: each ifAbsent: [nil])
			pane: (self paneNamed: each)].! !

!WBTemplateEditor methods !   
template

	^template! !

!SubPane methods !   
isATabStopPrim
	"Private - WindowBuilder Pro Development.
		Answer true if the receiver is a tabstop"

	#addedByOSI.
	^self isATabStop! !

!WBLookPolicy methods ! 
displayWithNoBorder: aPen rect: aRect backColor: backColor

    ^self
        drawFilledBoxWith: aPen
        at: aRect
        inset: 0
        backColor: backColor! !

!WBScrollBarEditor methods !
ok

    thePane
        lineIncrement: (self paneNamed: 'lineInc') contents asInteger;
        pageIncrement: (self paneNamed: 'pageInc') contents asInteger;
        minimum: (self paneNamed: 'minimum') contents asInteger;
        maximum: (self paneNamed: 'maximum') contents asInteger.

    self close! !

!WindowBuilder methods !
setOther

    | currentWidget before after |
    (thePane isFrameObject not
        and: [thePane isCompositePane
        and: [Notifier isAltKeyDown not]])
        ifTrue: [
            self class new
                openCompositePane: thePane realClass
                from: self.
            ^nil].
    currentWidget := self currentWidget.
    before := currentWidget wbCopy.
    super setOther ifFalse: [^self].
    after := currentWidget wbCopy.
    self undoManager
        add: (currentWidget realClass isScratchWindow
            ifTrue: ['Untitled']
            ifFalse: [currentWidget realClass name]), ' Attributes'
        undo: [before wbCopyTo: currentWidget]
        redo: [after wbCopyTo: currentWidget].! !

!WBEditClassDialog class methods ! 
removeFromFilterList: aClass

    self filterList remove: aClass asString ifAbsent: []! !

!WBCreatePowerViewModule methods ! 
defaultOwnerName
		"Answer the default owner name."
	^'wbOwner'! !

!WBChoosePaneDialog methods ! 
preInitWindow

    self labelWithoutPrefix: 'Choose a Widget Type:'.! !

!WBEventMessage methods !
moveTop
	"Move the receiver's action to the top of the list."

	self moveToIndex: 1.! !

!PGenericSubpane methods !  
realClass: aClass

    realClass := aClass.
    self style: self defaultStyle.! !

!PEntryFieldGroup methods !   
storeSpecificsOn: aStream indentString: indentString
    "Write out the list"
    self label isEmpty
        ifFalse: [
            aStream nextPutAll: ';'; cr;
                nextPutAll: indentString, 'label: ';
                nextPutStringConstant: self label].
    super storeStyleOn: aStream indentString: indentString.
    self contents isNil
        ifFalse: [
            (self contents isArray and: [self contents notEmpty])
                ifTrue: [
                    aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'contents: #( '.
                    self contents do: [:item |
                        aStream nextPutAll: item asQuotedString; space].
                    aStream nextPut: $)]].! !

!WBTabOrderLayoutForm methods !  
clearTabOrder

	self children do: [:widget |
		widget tabPosition: nil].
	self 
		resetGroups;
		updateRect: self shell frameContentRect.! !

!WBFontSelectionWindow methods !
poolManager: aPoolManager

	poolManager := aPoolManager.! !

!WBChooseClassDialog class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowBuilder methods ! 
menuToolsInspectSelf

    self inspect! !

!WBAbstractCodeModule methods !
messageArguments: anArray
		"Private - Set the message selector arguments."
	arguments := anArray.! !

!WBPoolManager methods !   
codeKeySelector
	"Answer the named method class field, so that the
		code generator can generate expressions such as
		'Bitmap named: <aKey>'   or   'Font named: <aKey>'."

	^#named:! !

!WBScrapbookRetrieve methods !  
changeName: newName
    | pageList |
    page isNil | chapter isNil ifTrue: [ ^nil ].
    newName = page ifTrue: [ ^nil ].
    ((scrapbook at: chapter) includesKey: newName) ifTrue: [
        (MessageBox confirm: '''',newName,''' already exists. Do you want to replace it?') ifFalse: [
            (self paneNamed: 'name') contents: page.
            ^nil
        ].
    ].
    (scrapbook at: chapter) at: newName put:
        ((scrapbook at: chapter ifAbsent: [^nil]) at: page ifAbsent: [^nil]).
    (scrapbook at: chapter) removeKey: page.
    self loadPages: (pageList := self paneNamed: 'pages').
    pageList selectItem: newName.
    self getPage: pageList.
    (self paneNamed: 'ok') enable.
    chapter = 'Quick Reference' ifTrue: [ removedQuick := true ].! !

!WBMenuItem methods !  
toggleSelector: aSymbol
        "Private - Set the toggle selector of the menu item."
    toggleSelector := aSymbol! !

!BitEditor methods !  
displayBits: aPane
    bitPen := aPane pen.
    bitPen
        copyBitmap: copy
        from: copy boundingBox
        to: (0 @ 0 extent: copy extent * scale).
    self grid: scale! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPoolManagerWindow methods !  
categoryPath: aString
	"Answer the path of the currently selected category."

	(self selectedPool ifNil: [^nil])
		fileNameFor: (self selectedCategory ifNil: [^nil])
		put: aString.! !

!WindowBuilder methods ! 
menuFileOpenComposite

    self confirmSaveChanges
        ifTrue: [self editClass: (self getEditedCompositeClass ifNil: [^nil])].! !

!WBLayoutForm methods !   
setupShellResizing: aPoint
    "Setup for the resizing state."

    | frameContentRect |
    self releaseState: #buttonReleaseResizingShell:.
    self motionState: #button1MotionResizingShell:.
    self minSize: self wbMinSize.
    self maxSize: self wbMaxSize.
    self bandRect: (frameContentRect := self shell frameContentRect).
    self cursorOffset: (Array with: (frameContentRect rightBottom distanceRightAndDown: aPoint)).
    self updateWidget.
    self drawBand.
    self setCursor: self currentNib.! !

!WBTargetObject methods !  
canTriggerEvent: eventName
        "Answer whether instances of the receiver can trigger
         an event named <eventName>."
    ^self wbEventsTriggered includes: eventName asSymbol! !

!WBPropertyEditor methods !  
revert

    (changes isEmpty or: [
        (MessageBox confirm: 'Undo all property changes?') not]) ifTrue: [^self].
    self revertPrim.! !

!WBTabPosition methods !  
basicTabPosition

    ^basicTabPosition! !

!WBLookPolicyWin95 class methods !
isDefault

    ^self isWindows95
        or: [self ctl3dEnabled]! !

!CompositeFrameObject methods ! 
drawFrameWith: aPen at: aPoint
	| aRect region |
	region := aPen setClipRect: (aRect := aPoint extentFromLeftTop: rect extent).
	aPen
		foreColor: Color windowBorder;
		drawRectangle: aRect.
	aPen destroyRegion: region.! !

!WBFramingEditor methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| afterResizeLabel beforeResizeLabel bottomGroup cancel 
	centeringGroup exampleGroup leftGroup mainView ok 
	rightGroup topGroup xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	afterRect := WBFramerExample new.
	beforeRect := WBFramerExample new.
	bottomRelative := StaticText new.
	cornerXAnchor := WBComboBox new.
	cornerXStyleFixed := RadioButton new.
	cornerXStyleScaled := RadioButton new.
	cornerYAnchor := WBComboBox new.
	cornerYStyleFixed := RadioButton new.
	cornerYStyleScaled := RadioButton new.
	leftRelative := StaticText new.
	originXAnchor := WBComboBox new.
	originXStyleFixed := RadioButton new.
	originXStyleScaled := RadioButton new.
	originYAnchor := WBComboBox new.
	originYStyleFixed := RadioButton new.
	originYStyleScaled := RadioButton new.
	rightRelative := StaticText new.
	topRelative := StaticText new.
	xCenteredCheckBox := CheckBox new.
	yCenteredCheckBox := CheckBox new.
	
		"Temporary Variables"
	afterResizeLabel := StaticText new.
	beforeResizeLabel := StaticText new.
	bottomGroup := GroupBox new.
	cancel := Button new.
	centeringGroup := GroupBox new.
	exampleGroup := GroupBox new.
	leftGroup := GroupBox new.
	ok := Button new.
	rightGroup := GroupBox new.
	topGroup := GroupBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Set Framing Parameters';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -108 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -161/2 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -108 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -161/2 * yDU).
	self addView: mainView.
	
	originXStyleFixed "RadioButton"
		owner: self;
		setName: 'originXStyleFixed';
		when: #turnedOn send: #originXStyleChanged: to: self withArgument: originXStyleFixed;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 10 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -20 * yDU);
		contents: 'Fixed';
		startGroup;
		font: SysFont.
	mainView
		addSubpane: originXStyleFixed;
		subPaneWithFocus: originXStyleFixed.
	
	originXStyleScaled "RadioButton"
		owner: self;
		setName: 'originXStyleScaled';
		when: #turnedOn send: #originXStyleChanged: to: self withArgument: originXStyleScaled;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -30 * yDU);
		contents: 'Scaled';
		noTabStop;
		font: SysFont.
	mainView addSubpane: originXStyleScaled.
	
	originXAnchor "WBComboBox"
		owner: self;
		setName: 'originXAnchor';
		when: #changed: send: #originXAnchorChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 19 * yDU;
				rightRatio: 0; rightInset: -123 * xDU;
				bottomRatio: 0; bottomInset: -133/2 * yDU);
		dropDownList;
		startGroup;
		font: SysFont.
	mainView addSubpane: originXAnchor.
	
	cornerXStyleFixed "RadioButton"
		owner: self;
		setName: 'cornerXStyleFixed';
		when: #turnedOn send: #cornerXStyleChanged: to: self withArgument: cornerXStyleFixed;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 44 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -54 * yDU);
		contents: 'Fixed';
		startGroup;
		font: SysFont.
	mainView addSubpane: cornerXStyleFixed.
	
	cornerXStyleScaled "RadioButton"
		owner: self;
		setName: 'cornerXStyleScaled';
		when: #turnedOn send: #cornerXStyleChanged: to: self withArgument: cornerXStyleScaled;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 54 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		contents: 'Scaled';
		noTabStop;
		font: SysFont.
	mainView addSubpane: cornerXStyleScaled.
	
	cornerXAnchor "WBComboBox"
		owner: self;
		setName: 'cornerXAnchor';
		addClipsiblingsStyle;
		when: #changed: send: #cornerXAnchorChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 53 * yDU;
				rightRatio: 0; rightInset: -123 * xDU;
				bottomRatio: 0; bottomInset: -201/2 * yDU);
		dropDownList;
		startGroup;
		font: SysFont.
	mainView addSubpane: cornerXAnchor.
	
	originYStyleFixed "RadioButton"
		owner: self;
		setName: 'originYStyleFixed';
		when: #turnedOn send: #originYStyleChanged: to: self withArgument: originYStyleFixed;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 78 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -88 * yDU);
		contents: 'Fixed';
		startGroup;
		font: SysFont.
	mainView addSubpane: originYStyleFixed.
	
	originYStyleScaled "RadioButton"
		owner: self;
		setName: 'originYStyleScaled';
		when: #turnedOn send: #originYStyleChanged: to: self withArgument: originYStyleScaled;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -98 * yDU);
		contents: 'Scaled';
		noTabStop;
		font: SysFont.
	mainView addSubpane: originYStyleScaled.
	
	originYAnchor "WBComboBox"
		owner: self;
		setName: 'originYAnchor';
		addClipsiblingsStyle;
		when: #changed: send: #originYAnchorChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 87 * yDU;
				rightRatio: 0; rightInset: -123 * xDU;
				bottomRatio: 0; bottomInset: -269/2 * yDU);
		dropDownList;
		startGroup;
		font: SysFont.
	mainView addSubpane: originYAnchor.
	
	cornerYStyleFixed "RadioButton"
		owner: self;
		setName: 'cornerYStyleFixed';
		when: #turnedOn send: #cornerYStyleChanged: to: self withArgument: cornerYStyleFixed;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 112 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -122 * yDU);
		contents: 'Fixed';
		startGroup;
		font: SysFont.
	mainView addSubpane: cornerYStyleFixed.
	
	cornerYStyleScaled "RadioButton"
		owner: self;
		setName: 'cornerYStyleScaled';
		when: #turnedOn send: #cornerYStyleChanged: to: self withArgument: cornerYStyleScaled;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 122 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -132 * yDU);
		contents: 'Scaled';
		noTabStop;
		font: SysFont.
	mainView addSubpane: cornerYStyleScaled.
	
	cornerYAnchor "WBComboBox"
		owner: self;
		setName: 'cornerYAnchor';
		addClipsiblingsStyle;
		when: #changed: send: #cornerYAnchorChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 121 * yDU;
				rightRatio: 0; rightInset: -123 * xDU;
				bottomRatio: 0; bottomInset: -337/2 * yDU);
		dropDownList;
		startGroup;
		font: SysFont.
	mainView addSubpane: cornerYAnchor.
	
	xCenteredCheckBox "CheckBox"
		owner: self;
		setName: 'xCenteredCheckBox';
		addClipsiblingsStyle;
		when: #clicked: send: #xCenteredToggled: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 146 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 0; bottomInset: -156 * yDU);
		contents: '&Horizontally';
		startGroup;
		font: SysFont.
	mainView addSubpane: xCenteredCheckBox.
	
	yCenteredCheckBox "CheckBox"
		owner: self;
		setName: 'yCenteredCheckBox';
		addClipsiblingsStyle;
		when: #clicked: send: #yCenteredToggled: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 72 * xDU;
				topRatio: 0; topInset: 146 * yDU;
				rightRatio: 0; rightInset: -112 * xDU;
				bottomRatio: 0; bottomInset: -156 * yDU);
		contents: '&Vertically';
		startGroup;
		font: SysFont.
	mainView addSubpane: yCenteredCheckBox.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 130 * xDU;
				topRatio: 0; topInset: 140 * yDU;
				rightRatio: 0; rightInset: -170 * xDU;
				bottomRatio: 0; bottomInset: -158 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 172 * xDU;
				topRatio: 0; topInset: 140 * yDU;
				rightRatio: 0; rightInset: -212 * xDU;
				bottomRatio: 0; bottomInset: -158 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	afterRect "WBFramerExample"
		owner: self;
		setName: 'afterRect';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 80 * yDU;
				rightRatio: 0; rightInset: -208 * xDU;
				bottomRatio: 0; bottomInset: -132 * yDU);
		backColor: Color gray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: afterRect.
	
	beforeRect "WBFramerExample"
		owner: self;
		setName: 'beforeRect';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -190 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		backColor: Color gray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: beforeRect.
	
	afterResizeLabel "StaticText"
		owner: self;
		setName: 'afterResizeLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 72 * yDU;
				rightRatio: 0; rightInset: -208 * xDU;
				bottomRatio: 0; bottomInset: -80 * yDU);
		contents: 'After Resizing:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: afterResizeLabel.
	
	beforeResizeLabel "StaticText"
		owner: self;
		setName: 'beforeResizeLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -190 * xDU;
				bottomRatio: 0; bottomInset: -20 * yDU);
		contents: 'Before Resizing:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: beforeResizeLabel.
	
	topRelative "StaticText"
		owner: self;
		setName: 'topRelative';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 79 * yDU;
				rightRatio: 0; rightInset: -123 * xDU;
				bottomRatio: 0; bottomInset: -87 * yDU);
		contents: 'Relative to:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: topRelative.
	
	rightRelative "StaticText"
		owner: self;
		setName: 'rightRelative';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 45 * yDU;
				rightRatio: 0; rightInset: -123 * xDU;
				bottomRatio: 0; bottomInset: -53 * yDU);
		contents: 'Relative to:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: rightRelative.
	
	leftRelative "StaticText"
		owner: self;
		setName: 'leftRelative';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 11 * yDU;
				rightRatio: 0; rightInset: -123 * xDU;
				bottomRatio: 0; bottomInset: -19 * yDU);
		contents: 'Relative to:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: leftRelative.
	
	bottomRelative "StaticText"
		owner: self;
		setName: 'bottomRelative';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 113 * yDU;
				rightRatio: 0; rightInset: -123 * xDU;
				bottomRatio: 0; bottomInset: -121 * yDU);
		contents: 'Relative to:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: bottomRelative.
	
	centeringGroup "GroupBox"
		owner: self;
		setName: 'centeringGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 136 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 0; bottomInset: -158 * yDU);
		contents: 'Centering';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: centeringGroup.
	
	topGroup "GroupBox"
		owner: self;
		setName: 'topGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 68 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 0; bottomInset: -102 * yDU);
		contents: 'Top';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: topGroup.
	
	bottomGroup "GroupBox"
		owner: self;
		setName: 'bottomGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 102 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 0; bottomInset: -136 * yDU);
		contents: 'Bottom';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: bottomGroup.
	
	leftGroup "GroupBox"
		owner: self;
		setName: 'leftGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 0 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 0; bottomInset: -34 * yDU);
		contents: 'Left';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: leftGroup.
	
	rightGroup "GroupBox"
		owner: self;
		setName: 'rightGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 34 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 0; bottomInset: -68 * yDU);
		contents: 'Right';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: rightGroup.
	
	exampleGroup "GroupBox"
		owner: self;
		setName: 'exampleGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 130 * xDU;
				topRatio: 0; topInset: 0 * yDU;
				rightRatio: 0; rightInset: -212 * xDU;
				bottomRatio: 0; bottomInset: -136 * yDU);
		contents: 'Example';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: exampleGroup! !

!WBMultiToolPalette methods !  
enable: key on: name
    | element |
    (element := self elementAt: key on: name) isNil
            ifFalse: [
                element up.
                (self handle isValid and: [ elements == (self pageNamed: name)])
                    ifTrue: [ self display: key ]]! !

!WBAbstractCreateViewsModule methods !
defaultOwnerName
		"Answer the default owner name."
	^'self'! !

!WBPrototype methods !   
convertWidget: realWidget inWindow: aWindow

	| widget widgetClass |
	widgetClass := realWidget class wbPseudoClass.
	widgetClass == PScrollBar
		ifTrue: [
			widgetClass := (realWidget style bitIsOn: SbsVert)
				ifTrue: [PWBVerticalScrollBar]
				ifFalse: [PWBHorizontalScrollBar]].

	widget := widgetClass new.
	realWidget wbFramingBlock isContext
		ifTrue: [widget framingBlock: (self framingParametersFor: realWidget wbFramingBlock inWindow: aWindow)]
		ifFalse: [widget framingBlock: realWidget wbFramingBlock].
	aWindow isDialog ifTrue: [
		widget framingBlock:
			widget wbFramingBlock asFramingBlockForWindowFromDialogSubPane].

	widget
		realClass: realWidget class;
		wbRealWidget: realWidget;
		contents: realWidget contents;
		menu: realWidget getPopupMenu;
		paneName: realWidget paneName;
		setStyleFrom:  realWidget style;
		readSpecificsFrom: realWidget;
		parent: aWindow;
		creationMethodSelector: realWidget definedIn.

	realWidget foreColor notNil ifTrue: [widget foreColor: realWidget foreColor].
	realWidget backColor notNil ifTrue: [widget backColor: realWidget backColor].
	widget menu notNil ifTrue: [widget menu: widget menu asWBPMenu].
	realWidget font isNil ifFalse: [widget font: realWidget font].

	^widget! !

!Window methods !   
hasClipsiblingsStyle
        "Answer true if the receiver has
			the clip siblings style to the receiver."
	#addedByOSI.
    ^self hasStyle: WsClipsiblings! !

!WBTabOrderLayoutForm methods ! 
saveOldTabPositions

	self children do: [:widget | 
		widget 
			propertyAt: #oldTabPosition 
			put: widget tabPosition].! !

!SmalltalkWindowPolicy methods !
addStandardLeftMenus
        "Private - add the menus that are to be located
         on the menu bar before any application-specific
         menus (File & Edit)."
    super addStandardLeftMenus.
    self addSmalltalkMenu.

    #modifiedByOSI.
    "Modified by WBPro Development."
    (window owner class inheritsFrom: TranscriptWindow) ifTrue: [
        self addWindowBuilderMenu ].! !

!WBScrollBarEditor methods ! 
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel lineInc lineIncLabel mainView maximum maximumLabel 
	minimum minimumLabel ok pageInc pageIncLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	lineInc := EntryField new.
	lineIncLabel := StaticText new.
	maximum := EntryField new.
	maximumLabel := StaticText new.
	minimum := EntryField new.
	minimumLabel := StaticText new.
	ok := Button new.
	pageInc := EntryField new.
	pageIncLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Scroll Bar Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -53 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -39 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -53 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -39 * yDU).
	self addView: mainView.
	
	minimumLabel "StaticText"
		owner: self;
		setName: 'minimumLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 34 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 0; bottomInset: -42 * yDU);
		rightJustified;
		contents: 'Minimum:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: minimumLabel.
	
	maximumLabel "StaticText"
		owner: self;
		setName: 'maximumLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 48 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 0; bottomInset: -56 * yDU);
		rightJustified;
		contents: 'Maximum:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: maximumLabel.
	
	pageIncLabel "StaticText"
		owner: self;
		setName: 'pageIncLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -56 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		rightJustified;
		contents: 'Page increment:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: pageIncLabel.
	
	lineIncLabel "StaticText"
		owner: self;
		setName: 'lineIncLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 6 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 0; bottomInset: -14 * yDU);
		rightJustified;
		contents: 'Line increment:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: lineIncLabel.
	
	lineInc "EntryField"
		owner: self;
		setName: 'lineInc';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 60 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -102 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: lineInc;
		subPaneWithFocus: lineInc.
	
	pageInc "EntryField"
		owner: self;
		setName: 'pageInc';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 60 * xDU;
				topRatio: 0; topInset: 18 * yDU;
				rightRatio: 0; rightInset: -102 * xDU;
				bottomRatio: 0; bottomInset: -30 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: pageInc.
	
	minimum "EntryField"
		owner: self;
		setName: 'minimum';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 60 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -102 * xDU;
				bottomRatio: 0; bottomInset: -44 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: minimum.
	
	maximum "EntryField"
		owner: self;
		setName: 'maximum';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 60 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -102 * xDU;
				bottomRatio: 0; bottomInset: -58 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: maximum.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 62 * yDU;
				rightRatio: 0; rightInset: -52 * xDU;
				bottomRatio: 0; bottomInset: -76 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 54 * xDU;
				topRatio: 0; topInset: 62 * yDU;
				rightRatio: 0; rightInset: -102 * xDU;
				bottomRatio: 0; bottomInset: -76 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel! !

!WindowBuilder methods !  
viewList

	^(self prototype windows select: [:window |
			window paneName notNil]) collect: [:window | 
             window paneName].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PComboBox methods !
winUserStyle

    ^((Array with: CbsDropdown with: CbsDropdownlist with: CbsSimple)
        at: (#(#dropDown #dropDownList #simpleList) indexOf: style))! !

!WindowBuilder class methods !  
allProperties

    | collection |
    collection := OrderedCollection new.
    self properties keysDo: [:category |
        category == self privateString
            ifFalse: [
                (self properties at: category) do: [:property |
                    collection add: property]]].
    ^collection! !

!WBChooseClassDialog methods !  
initialize

    allowOthers := true.
    super initialize.! !

!WBEditClassDialog methods !  
mostFrequentList

    | bag |
    ^((bag := self class frequentClasses) elements keys asSortedCollection: [:a :b |
        (bag occurrencesOf: b) <= (bag occurrencesOf: a)]) asArray collect: [:class | class name].! !

!WBSubPool methods !  
fileOutHeaderOn: aStream
	"File out the receiver's header."! !

!WBLookPolicyWin95 methods !   
menuFont

    ^menuFont ifNil: [
        menuFont :=    Font
            face: 'MS Sans Serif'
            size: 8
            fixedWidth: false
            attributes: 0]! !

!WBLayoutForm methods !  
targetIsFirst
    "Answer the value of targetIsFirst."

    ^targetIsFirst! !

!WBEventManagerWindow methods !   
optionMenu

    ^self menuTitled: 'Option'! !

!WBCodeStream methods !
defaultMaxLineSize
        "Answer the maximum number of characters per line.
            Nil indicates no maximum."
    ^60! !

!WBInterfaceObject methods !
isInstVar
		"Answer true if the receiver is referenced by an instance variable."
	^isInstVar = true! !

!WindowBuilder methods !  
menuToolsGenerateTestCode

    | codeModule |
    codeModule  := WBCreateViewModule new
            owner: self codeGenerator;
            targetClass: self prototype realClass;
            targetObject: self prototype targetObject;
            view: self shell;
            initCodeGeneration.
    (self selections isEmpty
        ifTrue: [Array with: self shell]
        ifFalse: [self selections]) do: [:widget |
            codeModule generatePane: widget.
            codeModule stream cr].
    WBTextEditWindow new
        labelWithoutPrefix: 'Test Code Generation';
        openOn: (
			codeModule stream contents
				replaceAll: (String with: Tab) with: '    ').! !

!WBCreateViewsStubModule methods ! 
generateBody
		"Private - Generate the method body."
	self stream indentBy: 1 during: [
		self generateGeneratedSymbol.
		self stream cr;
			nextPutAll: #self ; space;
			nextPutAll: #createViewsFor: ; space;
			nextPutAll: #self ; space;
			nextPutAll: #owner: ; space;
			nextPutAll: #self;
			endExpression ].! !

!WBVersionCodeModule methods !   
generateComment
        "Private - Generate the comment."

    super generateComment.
    self stream cr.! !

!LayoutFrame methods !
wbRightProportional: aBoolean
	"Set true if the receiver is right proportional (inset = 0)."

	self propertyAt: #wbRightProportional put: aBoolean.
	^aBoolean! !

!WBPoolManagerWindow methods !   
menuPoolFileOut: aPath
	"File out the selected pools."

	| stream |
	CursorManager execute changeFor: [
		stream := File newFile: aPath.
		[self selectedPools
			do: [:each | each fileOutOn: stream].
		] ensure: [stream close]].! !

!WBInterfaceObject methods !   
isComposite

    ^self isCompositePane! !

!WBTargetObject methods !  
initializeFrom: anObject

	invalidInstVars := Dictionary new.
	handlers := anObject eventTable.
	anObject isWindow ifTrue: [
		oldHandlers := anObject handlersOrNil].
	realClass := anObject class.
	self
		modelObjects: anObject modelObjects;
		wbEventsTriggered: anObject class eventsTriggered;
		wbInstVarMap: anObject wbInstVarMap.! !

!WBLookPolicyOS2 methods !  
drawLeftArrowWith: aPen at: aRect

    | innerRect side point |
    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class leftArrow
                from: self class leftArrow boundingBox
                to: aRect]
        ifFalse: [
            innerRect := self draw3DBoxWith: aPen at: aRect.
            side := (innerRect width min: innerRect height) // 7.
            point := innerRect center left: side.
            aPen
                foreColor: Color black;
                wbLineFrom: (point up: 1) to: ((point up: 1) rightAndUp: side * 2 + 1);
                wbLineFrom: point to: (point rightAndUp: side * 2 + 1);
                wbLineFrom: (point down: 1) to: ((point down: 1) rightAndUp: side * 2 + 1);
                wbLineFrom: point to: (point rightAndDown: side * 2 + 1);
                wbLineFrom: (point down: 1) to: ((point down: 1) rightAndDown: side * 2 + 1);
                wbLineFrom: (point up: 1) to: ((point up: 1) rightAndDown: side * 2 + 1)]! !

!WBLayoutFrameEditor methods !
bottomAttachmentFor: aCollection
	"Answer the bottom attachment for the specified framing blocks."

	| ratio |
	aCollection do: [:each |
		ratio notNil
			ifTrue: [
				each wbBottomProportional
					ifTrue: [ratio = self proportional ifFalse: [^'']]
					ifFalse: [
						each wbBottomAttachedToTop
							ifTrue: [ratio = self paneTop ifFalse: [^'']]
							ifFalse: [ratio = each bottomRatio asRational ifFalse: [^'']]]]
			ifFalse: [
				each wbBottomProportional
					ifTrue: [ratio := self proportional]
					ifFalse: [
						each wbBottomAttachedToTop
							ifTrue: [ratio := self paneTop]
							ifFalse: [ratio := each bottomRatio asRational]]]].
	ratio ifNil: [^''].
	ratio isString ifTrue: [^ratio].
	^self class verticalRatioStrings at: ratio ifAbsent: [ratio printString]! !

!WBTeamVCodePolicy methods !
addKey: aKey inPoolNamed: aSymbol
	"Add the specified key to a pool in the system."

	(self currentSubsystem unpackagedPackage subsystem 
		definitionOfPoolNamed: aSymbol asSymbol) isNil
		ifTrue: [super addKey: aKey inPoolNamed: aSymbol]
		ifFalse: [
			self currentSubsystem unpackagedPackage
				addPoolVariableNamed: aKey
				inPoolNamed: aSymbol].! !

!WBModelInstVar methods ! 
myClass

    ^myClass! !

!WBAttributeWindow methods !
hasChanged
		"Answer true if the receiver's contents has changed."
	^hasChanged = true! !

!WBTabOrderEditor methods !
ok

	self cleanUpOk.
	self close! !

!WBEnhancedAttributeEditor methods !
ok
	"Callback for the #clicked event in ok [Button]
	(Generated by WindowBuilder Pro)"

	self
		saveFields;
		close.! !

!PStaticBox methods !
defaultForeColor

    ^nil! !

!WBBitmapEditorCompositePane methods ! 
addSubpanes

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| xDU yDU |
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	
		"Instance Variables"
	bitmapPane := GraphPane new.
	editBitmapButton := Button new.
	editButtonButton := Button new.
	sameBitmapButton := CheckBox new.
	sizeButton := DrawnButton new.
	sizePane := StaticText new.
	
	self
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -68 * xDU;
				topRatio: 1/2; topInset: -52 * yDU;
				rightRatio: 1/2; rightInset: -68 * xDU;
				bottomRatio: 1/2; bottomInset: -52 * yDU);
		backColor: Color gray.
	
	editBitmapButton "Button"
		owner: self;
		setName: 'editBitmapButton';
		when: #clicked send: #editBitmap to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 1; topInset: -25/2 * yDU;
				rightRatio: 1/2; rightInset: 7/2 * xDU;
				bottomRatio: 1; bottomInset: 0 * yDU);
		contents: 'Edit Bitmap...';
		startGroup;
		font: SysFont.
	self addSubpane: editBitmapButton.
	
	editButtonButton "Button"
		owner: self;
		setName: 'editButtonButton';
		when: #clicked send: #editButton to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 5/2 * xDU;
				topRatio: 1; topInset: -25/2 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 1; bottomInset: 0 * yDU);
		contents: 'Edit Button...';
		startGroup;
		font: SysFont.
	self addSubpane: editButtonButton.
	
	bitmapPane "GraphPane"
		owner: self;
		setName: 'bitmapPane';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 10 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 1; bottomInset: 27 * yDU);
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: bitmapPane.
	
	sizeButton "DrawnButton"
		owner: self;
		setName: 'sizeButton';
		when: #clicked send: #setBitmapSize to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 0 * yDU;
				rightRatio: 0; rightInset: -10 * xDU;
				bottomRatio: 0; bottomInset: -8 * yDU);
		stretchToFit;
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: sizeButton.
	
	sameBitmapButton "CheckBox"
		owner: self;
		setName: 'sameBitmapButton';
		when: #clicked: send: #setSameBitmapForAllCategories:pane: to: self withArgument: sameBitmapButton;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 1; topInset: -25 * yDU;
				rightRatio: 0; rightInset: -108 * xDU;
				bottomRatio: 1; bottomInset: 15 * yDU);
		contents: 'Same bitmap for all categories';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: sameBitmapButton.
	
	sizePane "StaticText"
		owner: self;
		setName: 'sizePane';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 12 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'width x height x bit count';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: sizePane! !

!WBEventManagerWindow methods !
handlerListBoxDragEnabled: aBoolean

    handlerListBoxDragEnabled := aBoolean.
    handlerListBox
        dragSource: self handlerListBoxDragTargetEnabled;
        dragTarget: self handlerListBoxDragTargetEnabled.
    handlerListBoxDragEnabled
        ifTrue: [
            self optionMenu
                checkItem: #menuOptionDragDropHandlers]
        ifFalse: [
            self optionMenu
                uncheckItem: #menuOptionDragDropHandlers].! !

!PWBHorizontalScrollBar methods !  
defaultSize

    ^100 @ self suggestedSize y! !

!Object methods !
wbFullCopyProperties: aDictionary
	"Answer a full copy of the receiver."

	| answer |
	#addedByOSI.
	answer := self species new.
	aDictionary at: self put: answer.
	self wbPropertyManager wbFullCopy: aDictionary from: self to: answer.
	^answer! !

!PRadioButtonGroup methods !
setStyleFrom: aRealStyle! !

!WindowBuilder methods !   
partsSupportEnabled

	^self class partsSupportEnabled! !

!WBInterfaceObject methods !
when: eventName send: selector to: anObject
		"Form an action with <anObject> as the receiver and
		a <selector> as the message selector and append
		it to the actions list for the event named <eventName>."

	self wbRealWidget
		when: eventName 
		send: selector 
		to: anObject.! !

!PStatusPane methods !  
changesSize

	^true! !

!WindowBuilder methods !  
usesLookPolicyOS2

    ^self class lookPolicy == WBLookPolicyOS2! !

!WBLookPolicyWin95 methods ! 
drawHorizontalScrollBar: aScrollBar with: aPen clipRect: clipRect

    | nonThumbRect |
    nonThumbRect := self drawHScrollBarWith: aPen at: aScrollBar rect.
    aPen
        fill: nonThumbRect color: aScrollBar backColor;
        foreColor: Color darkGray;
        wbLineFrom: nonThumbRect leftTop to: nonThumbRect rightTop;
        wbLineFrom: (nonThumbRect leftBottom up: 1) to: (nonThumbRect rightBottom up: 1);
        foreColor: Color gray;
        wbLineFrom: (nonThumbRect leftTop down: 1) to: (nonThumbRect rightTop down: 1);
        wbLineFrom: (nonThumbRect leftBottom up: 2) to: (nonThumbRect rightBottom up: 2).
    ^nonThumbRect! !

!WBFontEditorCompositePane methods !
enableFields: aFont

	aFont notNil
		ifTrue: [
			selectButton enable.
			nameLabel wbGrayEnable.
			sizeLabel wbGrayEnable.
			nameField enable.
			sizeField enable.
			boldCheckBox enable.
			italicCheckBox enable.
			strikeOutCheckBox enable.
			underscoreCheckBox enable.
			fixedWidthCheckBox enable.
			sampleGroupBox enable.
			sampleTextEdit enable]
		ifFalse: [
			self atleastOneKeyAndCategorySelected
				ifTrue: [
					selectButton enable.
					nameLabel wbGrayEnable]
				ifFalse: [
					selectButton disable.
					nameLabel wbGrayDisable].
			sizeLabel wbGrayDisable.
			nameField disable.
			sizeField disable.
			boldCheckBox disable.
			italicCheckBox disable.
			strikeOutCheckBox disable.
			underscoreCheckBox disable.
			fixedWidthCheckBox disable.
			sampleGroupBox disable.
			sampleTextEdit disable].! !

!WBLookPolicyOS2 methods !
rightJustification

    ^"DtRight" 512! !

!WBPoolManagerWindow methods ! 
menuCategoryNew: aCollection

	aCollection do: [:eachCategory |
		self poolManager addCategory: eachCategory.
		self poolManager pools do: [:eachPool |
			eachPool keys do: [:eachKey |
				eachPool at: eachKey in: eachCategory ifAbsentPut: [
					eachPool at: eachKey]]]].! !

!Object methods !   
isWBClassBrowser
        "Private - WBPro Development."
    #addedByOSI.
    ^false! !

!WBOutboardWindow methods !  
ownerChanged

	ownerChanged := true.! !

!WBLookPolicyWin31 methods ! 
drawUpArrowWith: aPen at: aRect

    | innerRect side |
    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class upArrow
                from: self class upArrow boundingBox
                to: aRect]
        ifFalse: [
            innerRect := self draw3DBoxWith: aPen at: aRect.
            side := (innerRect width min: innerRect height) // 7.
            aPen
                polygonFilled: (Array
                    with: (innerRect center up: side + 2)
                    with: (innerRect center rightAndDown: (side * 2 + 1) @ (side - 1))
                    with: (innerRect center leftAndDown: (side * 2 + 1) @ (side - 1)));
                fill: ((innerRect center leftAndDown: side @ (side*2 - 1 - Rectangle leftTopUnit y))
                    extentFromLeftTop: (side*2+1) @ (side*2+1)) color: Color black].! !

!WindowBuilder methods !   
usesLookPolicyDefault

    ^self class lookPolicy isNil! !

!WBCodeModule methods !   
generateComment
		"Private - Generate the comment."

	super generateComment.
	self stream cr.! !

!PStatusPane methods !
colorButtonHighlight

    ^Color buttonHighlight! !

!WBBitmapManagerWindow methods ! 
keyListDrawItem: drawIndex pane: aPane

	"Callback for the #drawItem: event triggered in the MultipleSelectListBox named 'keyListBox'.
	 (Generated by WindowBuilder)"

	| aKeyAndPool aBitmap |
	aKeyAndPool := self keysAndPools at: drawIndex.
	aBitmap := self
		valueAt: aKeyAndPool key
		in: self selectedCategory
		pool: aKeyAndPool value.
	self
		keyListDraw: aKeyAndPool key
		value: aBitmap
		pane: aPane.! !

!WindowBuilder class methods !  
userBitmapFileNames
	"Answer the possible names of the user bitmap DLL."

	^#('WB31USRW.BPL')! !

!WBPropertyManager class methods ! 
for: aClass
	"Answer the attribute manager for aClass."

	^self cacheManagers
		ifTrue: [
			self managers
				at: aClass symbol
				ifAbsentPut: [self newFor: aClass]]
		ifFalse: [
			self newFor: aClass]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder class methods !  
defineEditorProperties: collection
    "Define the editor properties used in WindowBuilder Pro"

    collection

        add: (WBPropertyDescriptor new
            name: #AutoSize;
            commonName: 'Auto Size';
            comment: 'Specifies whether widgets should automatically auto size when their contents are changed within the editor.';
            category: self editorPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #AutoSave;
            commonName: 'Auto Save';
            comment: 'Specifies whether the window definition should automatically be saved before testing a window.';
            category: self editorPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #DragOutlines;
            commonName: 'Drag Outlines';
            comment: 'Specifies whether widgets should be dragged as outlines or not.';
            category: self editorPropertyString;
            default: false;
            yourself);

        add: (WBPropertyDescriptor new
            name: #HandleSize;
            commonName: 'Handle Size';
            comment: 'Specifies the handle size used in the WindowBuilder Pro editor.';
            category: self editorPropertyString;
            default: 8@8;
            changeBlock: [:handleSize | WBHandle handleSize: handleSize];
            yourself);

        add: (WBPropertyDescriptor new
            name: #MaxUndoLevels;
            commonName: 'Max Undo Levels';
            comment: 'Specifies the maximum number of undo levels maintained by the WindowBuilder Pro editor.';
            category: self editorPropertyString;
            default: 20;
            changeBlock: [:maxUndoLevels | WBUndoManager maxUndoLevels: maxUndoLevels];
            yourself);

        add: (WBPropertyDescriptor new
            name: #AutoUpdateOutboards;
            commonName: 'Auto Update Outboards';
            comment: 'Specifies whether the outboard windows should be updated when new widgets are selected in the main editing window.';
            category: self editorPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #ShowZOrder;
            commonName: 'Show Z Order';
            comment: 'Specifies whether the z-order of the widgets should be shown in the editor.';
            category: self editorPropertyString;
            default: false;
            yourself);

        add: (WBPropertyDescriptor new
            name: #MaxWindowSize;
            commonName: 'Max Window Size';
            comment: 'Specifies the maximum window size that can be built using WindowBuilder Pro.';
            category: self editorPropertyString;
            default: 1280@1024;
            yourself);

        add: (WBPropertyDescriptor new
            name: #NlsAutosize;
            commonName: 'NLS Autosize';
            comment: 'Specifies whether the target widget is auto-sized based on the widest NLS string.';
            category: self editorPropertyString;
            default: false;
            yourself);

        add: (WBPropertyDescriptor new
            name: #TargetIsFirst;
            commonName: 'Target Is First';
            comment: 'Specifies whether the target widget is the first widget selected in a sequence. Setting this to false, will emulate the VisualAge target-is-last-selected model.';
            category: self editorPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #UseFence;
            commonName: 'Use Fence';
            comment: 'Specifies whether widgets should be constrained to the bounding box of their parent widget. Setting this to false will allow a widget to be positioned anywhere within its parent (even off screen out of view).';
            category: self editorPropertyString;
            default: true;
            yourself);

        "add: (WBPropertyDescriptor new
            name: #MiniHelpEnabled;
            commonName: 'Mini Help Enabled';
            comment: 'Specifies whether Mini Help should be enabled or not. If true, WindowBuilder will popup help descriptions of attributed editor items when the cursor is passed over them.';
            category: self editorPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #MiniHelpDelay;
            commonName: 'Mini Help Delay';
            comment: 'Specifies the Mini Help delay in milliseconds. This delay is the time between the pointer passing over a widget and its Mini Help description appearing.';
            category: self editorPropertyString;
            default: 500;
            yourself);"

        add: (WBPropertyDescriptor new
            name: #PartsSupport;
            commonName: 'Parts Support';
            comment: 'Specifies whether PARTS Support should be enabled or not.';
            category: self editorPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #UseWBComboBox;
            commonName: 'Use WBComboBox';
            comment: 'Specifies whether WBComboBox should be used by default rather than ComboBox.';
            category: self editorPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #UseClassHierarchyBrowser;
            commonName: 'Use ClassHierarchyBrowser';
            comment: 'Specifies whether the ''Browse Class...'' menu item should open the ClassHierarchyBrowser or the platform specific class browser (PackageBrowser for Team/V).';
            category: self editorPropertyString;
            default: false;
            yourself);

        yourself.! !

!WindowBuilder methods !   
performTextChanged: aString pane: aPane

	thePane isNil
		ifTrue: [^nil].
	(self currentEventIsTriggered
		ifTrue: [
			(aPane contents wbValidTriggeredSelectorFor: self currentEvent)
			= (thePane eventHandlerSelectorAt: self currentEvent)]
		ifFalse: [
			(self getValidMethodName: aPane contents) 
			= (thePane oldEventHandlerSelectorAt: self currentEvent)])
		ifTrue: [^self].
	self saveWhenPerform.
	self layoutFormChanged.! !

!WBInterfaceObject methods ! 
nlsPools

    ^(self parent ifNil: [^Set new]) nlsPools! !

!WBHandle methods !   
canBeConnected
    ^false! !

!WBTabOrderLayoutForm methods !  
notifyModelOfSelectionChange
	"Do Nothing"! !

!WBCreateBitmap methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancelButton color4BitButton color8BitButton colorButton 
	defaultSizeButton groupBox1 heightLabel mainView monoButton 
	sizeGroup typeGroup widthLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	heightField := EnhancedEntryField new.
	keyField := EnhancedEntryField new.
	okButton := Button new.
	widthField := EnhancedEntryField new.
	
		"Temporary Variables"
	cancelButton := Button new.
	color4BitButton := RadioButton new.
	color8BitButton := RadioButton new.
	colorButton := RadioButton new.
	defaultSizeButton := Button new.
	groupBox1 := GroupBox new.
	heightLabel := StaticText new.
	monoButton := RadioButton new.
	sizeGroup := GroupBox new.
	typeGroup := GroupBox new.
	widthLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Create Bitmap';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -71 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -54 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -71 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -54 * yDU).
	self addView: mainView.
	
	keyField "EnhancedEntryField"
		owner: self;
		setName: 'keyField';
		when: #textChanged: send: #updateOk to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 8 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -134 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		startGroup;
		font: SysFont;
		character: #okAlphaNumericNoSpace:.
	mainView
		addSubpane: keyField;
		subPaneWithFocus: keyField.
	
	monoButton "RadioButton"
		owner: self;
		setName: 'monoButton';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 10 * xDU;
				topRatio: 0; topInset: 45 * yDU;
				rightRatio: 0; rightInset: -62 * xDU;
				bottomRatio: 0; bottomInset: -55 * yDU);
		contents: 'Monochrome';
		startGroup;
		font: SysFont.
	mainView addSubpane: monoButton.
	
	colorButton "RadioButton"
		owner: self;
		setName: 'colorButton';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 10 * xDU;
				topRatio: 0; topInset: 59 * yDU;
				rightRatio: 0; rightInset: -62 * xDU;
				bottomRatio: 0; bottomInset: -69 * yDU);
		contents: 'Color';
		noTabStop;
		font: SysFont.
	mainView addSubpane: colorButton.
	
	color4BitButton "RadioButton"
		owner: self;
		setName: 'color4BitButton';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 10 * xDU;
				topRatio: 0; topInset: 73 * yDU;
				rightRatio: 0; rightInset: -62 * xDU;
				bottomRatio: 0; bottomInset: -83 * yDU);
		contents: '4 Bit Color';
		noTabStop;
		font: SysFont.
	mainView addSubpane: color4BitButton.
	
	color8BitButton "RadioButton"
		owner: self;
		setName: 'color8BitButton';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 10 * xDU;
				topRatio: 0; topInset: 87 * yDU;
				rightRatio: 0; rightInset: -62 * xDU;
				bottomRatio: 0; bottomInset: -97 * yDU);
		contents: '8 Bit Color';
		noTabStop;
		font: SysFont.
	mainView addSubpane: color8BitButton.
	
	widthField "EnhancedEntryField"
		owner: self;
		setName: 'widthField';
		when: #textChanged: send: #updateOk to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 104 * xDU;
				topRatio: 0; topInset: 42 * yDU;
				rightRatio: 0; rightInset: -134 * xDU;
				bottomRatio: 0; bottomInset: -54 * yDU);
		contents: '32';
		startGroup;
		font: SysFont;
		character: #okPositiveInteger:;
		field: #okInteger;
		right.
	mainView addSubpane: widthField.
	
	heightField "EnhancedEntryField"
		owner: self;
		setName: 'heightField';
		when: #textChanged: send: #updateOk to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 104 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 0; rightInset: -134 * xDU;
				bottomRatio: 0; bottomInset: -68 * yDU);
		contents: '32';
		startGroup;
		font: SysFont;
		character: #okPositiveInteger:;
		field: #okInteger;
		right.
	mainView addSubpane: heightField.
	
	defaultSizeButton "Button"
		owner: self;
		setName: 'defaultSizeButton';
		when: #clicked send: #setDefaultSize to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 74 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 0; rightInset: -134 * xDU;
				bottomRatio: 0; bottomInset: -80 * yDU);
		contents: 'Default';
		startGroup;
		font: SysFont.
	mainView addSubpane: defaultSizeButton.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 70 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 0; rightInset: -102 * xDU;
				bottomRatio: 0; bottomInset: -104 * yDU);
		defaultPushButton;
		contents: 'OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: okButton.
	
	cancelButton "Button"
		owner: self;
		setName: 'cancelButton';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 106 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 0; rightInset: -138 * xDU;
				bottomRatio: 0; bottomInset: -104 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancelButton.
	
	heightLabel "StaticText"
		owner: self;
		setName: 'heightLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 74 * xDU;
				topRatio: 0; topInset: 58 * yDU;
				rightRatio: 0; rightInset: -100 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		rightJustified;
		contents: 'Height:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: heightLabel.
	
	widthLabel "StaticText"
		owner: self;
		setName: 'widthLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 76 * xDU;
				topRatio: 0; topInset: 44 * yDU;
				rightRatio: 0; rightInset: -100 * xDU;
				bottomRatio: 0; bottomInset: -52 * yDU);
		rightJustified;
		contents: 'Width:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: widthLabel.
	
	typeGroup "GroupBox"
		owner: self;
		setName: 'typeGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -66 * xDU;
				bottomRatio: 0; bottomInset: -104 * yDU);
		contents: 'Type';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: typeGroup.
	
	sizeGroup "GroupBox"
		owner: self;
		setName: 'sizeGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 70 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -138 * xDU;
				bottomRatio: 0; bottomInset: -84 * yDU);
		contents: 'Size';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sizeGroup.
	
	groupBox1
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -138 * xDU;
				bottomRatio: 0; bottomInset: -30 * yDU);
		contents: 'Key';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: groupBox1! !

!WBCreateViewModule methods !   
modelObjects
        "Answer the modelObjects."
    ^self view modelObjects! !

!WBNLSEditorCompositePane class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WildPattern methods !   
wbTranslate: aString using: stringTemplate
	"Private - Translate aString using stringTemplate and the receiver."

	| stream templateStream patternStream chunk pos index pt |
	patternStream := ReadStream on: patternCollection.
	pt := patternStream next match: aString index: 1.
	index := pt notNil ifTrue: [pt y] ifFalse: [0].
	templateStream := ReadStream on: stringTemplate.
	stream := WriteStream on: (String new: aString size + 10).
	[	pos := templateStream position.
		chunk := templateStream upTo: WildcardChar.
		stream nextPutAll: chunk.
		templateStream position - pos > chunk size
	] whileTrue: [
		patternStream atEnd ifFalse: [
			(pt := patternStream next match: aString index: index + 1) notNil
				ifTrue: [
					stream nextPutAll: (aString copyFrom: index + 1 to: pt x - 1).
					index := pt y].
			patternStream atEnd ifTrue: [
				patternCollection last input isEmpty ifTrue: [
					stream nextPutAll: (aString copyFrom: index + 1 to: aString size)]]]].
	^stream contents! !

!WindowBuilder class methods !   
wbInitializeDevelopment
	"Perform initialization."

	[WBBitmapManager loadStandardWBBitmaps]
		on: Error do: [ ].
	self
		initializeProperties;
		initTranscriptMenu;
		wbInitializeSystemBitmaps;
		wbInitializeOldBitmapNames;
		wbInitializeOldSystemBitmaps;
		wbInitializeRegistry;
		wbInitializeSessionEvents.
	[self scrapbookFindAndLoadFile: self wbScrapbookFileName]
		on: Error do: [ ].! !

!WBLayoutForm methods ! 
initialize
    "Private - Initialize the reciever"

    super initialize.
    self
        clearSelections;
        cursorOffset: self initialCursorOffset;
        redrawMovingWidget: false.
    showOrder := false.
    targetIsFirst := true.
    useDirectSelect := false.! !

!PWBToolBar methods ! 
framingBlock: framer
	| width height |
	self style == #mdiToolBar
		ifFalse: [^super framingBlock: framer].
	parentWindow isNil
		ifTrue: [width := height := 300]
		ifFalse: [
			width := parentWindow rect width.
			height := parentWindow rect height].
	self vertical
		ifTrue: [
			framingBlock := LayoutFrame new
				leftRatio: 0; leftInset: 0;
				topRatio: 0; topInset: 0;
				rightRatio: 0; rightInset: self cellSize x;
				bottomRatio: 1; bottomInset: 0]
		ifFalse: [
			framingBlock := LayoutFrame new
				leftRatio: 0; leftInset: 0;
				topRatio: 0; topInset: 0;
				rightRatio: 1; rightInset: 0;
				bottomRatio: 0; bottomInset: self cellSize y].
! !

!WindowBuilder methods ! 
hasMultipleViews

	^self prototype windows size > 1! !

!WindowBuilder methods !  
menuToolsInspectSelection

    self hasSelections
        ifFalse: [self shell inspect]
        ifTrue: [
            self selections size == 1
                ifTrue: [self selections first inspect]
                ifFalse: [self selections inspect]].! !

!WindowBuilder class methods !  
copyright

    ^self editorClass
        propertyValueAt: #Copyright
        category: self codeGenerationPropertyString.! !

!WBLayoutFrameEditor methods !
updateContents
	"Update the contents based on the currently selected widgets."

	self currentFramingBlocks notEmpty
		ifTrue: [
			self labels do: [:each | each wbGrayEnable].
			self groups do: [:each | each enable].
			leftAttachField
				enable;
				text: (self leftAttachmentFor: self currentFramingBlocks).
			topAttachField
				enable;
				text: (self topAttachmentFor: self currentFramingBlocks).
			rightAttachField
				enable;
				text: (self rightAttachmentFor: self currentFramingBlocks).
			bottomAttachField
				enable;
				text: (self bottomAttachmentFor: self currentFramingBlocks)]
		ifFalse: [
			self labels do: [:each | each wbGrayDisable].
			self groups do: [:each | each disable].
			self fields do: [:each | each selection: nil; disable]].! !

!WBScratchWindow methods ! 
perform: selector
    "Scratch windows should not perform any events"
    ^MessageBox messageNote: 'Scratch windows cannot do anything. You must first create a new view manager class with the "Save As..." command in order to add behavior.'! !

!WBLookPolicy methods !   
drawHScrollBarWith: aPen at: aRect

    | thumbRect nonThumbRect leftArrowRect rightArrowRect arrowWidth |
    arrowWidth := self scrollBarArrowWidth.
    leftArrowRect := (aRect leftTop rightBottom: (aRect left right: arrowWidth) @ aRect bottom).
    rightArrowRect := ((aRect right left: arrowWidth) @ aRect top rightBottom: aRect rightBottom).
    thumbRect := (aRect left right: arrowWidth) @ aRect top rightBottom: (aRect left right: self scrollBarThumbWidth + arrowWidth) @ aRect bottom.
    nonThumbRect := ((aRect left right: arrowWidth + self scrollBarThumbWidth) @ aRect top) rightBottom: (aRect right left: arrowWidth)@ aRect bottom.
    self
        drawLeftArrowWith: aPen at: leftArrowRect;
        draw3DBoxWith: aPen at: thumbRect;
        drawRightArrowWith: aPen at: rightArrowRect.
    aPen fill: nonThumbRect color: self scrollBarColor.
    ^nonThumbRect! !

!WBBitmapManagerWindow methods !
menuBitmapPaste

	| aBitmap aKeyAndPool aCategory |
	aKeyAndPool := self selectedKeyAndPool ifNil: [^self].
	aCategory := self selectedCategory ifNil: [^self].
	(aBitmap := Clipboard getBitmap) isBitmap
		ifTrue: [
			aKeyAndPool value
				at: aKeyAndPool key
				in: aCategory
				put: aBitmap]
		ifFalse: [
			MessageBox message:
				'The clipboard does not contain a bitmap'].! !

!WBModelObjectEditor methods ! 
setEvents

    WBEventManagerWindow new openOn: self.! !

!WBCreateClassDialog methods !  
initWindow

    | superClassSymbol packageList |
    self defaultType == #ViewManager
        ifTrue: [(self paneNamed: 'setViewManager') selection: true]
        ifFalse: [(self paneNamed: 'setApplicationCoordinator') selection: true].
    self inTeamV
        ifTrue: [
            (self paneNamed: 'packageName')
                contents: (packageList := self teamPackageChoices);
                selectItem: (self defaultPackage ifNil: [packageList first]);
                getSelection]
        ifFalse: [
            self inENVY
                ifTrue: [
                    (self paneNamed: 'packageLabel') contents: 'Application:'.
                    (packageList := self envyApplicationChoices) isEmpty
                        ifTrue: [
                            ^self sendInputEvent: #informUserOfNoApplicationChoices].
                    (self paneNamed: 'packageName')
                        contents: (packageList := self envyApplicationChoices);
                        selectItem: (self defaultPackage ifNil: [packageList first]);
                        getSelection]
                ifFalse: [
                    self inXoteryX
                        ifTrue: [
                            (self paneNamed: 'packageLabel') contents: 'Xo Package:'.
                            (self paneNamed: 'packageName')
                                contents: (packageList := self xoteryxPackageChoices);
                                selectItem: (self defaultPackage ifNil: [packageList first]);
                                getSelection]
                        ifFalse: [
                            (self paneNamed: 'packageName') disable.
                            (self paneNamed: 'packageLabel') disable]]].
    superClassSymbol := (limitTo = 'CompositePane'
        ifTrue: [
            self labelWithoutPrefix: 'New CompositePane'.
            (self paneNamed: 'setViewManager') hideWindow.
            (self paneNamed: 'setApplicationCoordinator') hideWindow.
            #CompositePane]
        ifFalse: [
            limitTo = 'EventManager'
                ifTrue: [
                    self labelWithoutPrefix: 'New Model'.
                    (self paneNamed: 'setViewManager') hideWindow.
                    (self paneNamed: 'setApplicationCoordinator') hideWindow.
                    #EventManager]
                ifFalse: [
                    limitTo = 'Window'
                        ifTrue: [
                            self labelWithoutPrefix: 'New Window'.
                            self defaultType == #ViewManager
                                ifTrue: [#ViewManager]
                                ifFalse: [#ApplicationCoordinator]]
                        ifFalse: [
                            self labelWithoutPrefix: 'New Dialog'.
                            self defaultType == #ViewManager
                                ifTrue: [#WindowDialog]
                                ifFalse: [#DialogCoordinator]]]]).
    (self paneNamed: 'superclassName')
        contents: (self superclassListFor: superClassSymbol);
        selectItem: (self defaultSuperClassFor: superClassSymbol) asString;
        getSelection.
    (self paneNamed: 'className') contents: (self superclassListFor: superClassSymbol).! !

!WBTemplateEditor methods !   
shell

	^self template! !

!String methods !  
asColor
        "Answer the color definition."
        
    #addedByOSI.
    ^Color
        red:    (self at: 1) asciiValue
        green:  (self at: 2) asciiValue
        blue:   (self at: 3) asciiValue! !

!Object methods !
creationMethodSelector

    ^self propertyAt: #creationMethodSelector! !

!WBCreateBitmap methods !   
bitmapType
	"Answer the currently selected bitmap type."

	self class bitmapTypes associationsDo: [:each |
		(self paneNamed: each key) selection ifTrue: [^each value]].
	^#width:height:! !

!WBNLSDictionaryReader class methods !  
fileOutCategoryName: aString on: aStream
	"File out a token/value pair inside a comment."

	^self
		fileOutToken: WBNLSManager tagCategory
		value: aString
		inCommentOn: aStream! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventManagerWindow methods !   
eventSelected: anEvent
    "Answer the currently selected event if exactly one is selected,
        else answer nil."

    self eventSelections: (OrderedCollection with: anEvent).! !

!WindowBuilder methods !
getValidMethodName: string

	| result |
	result := (string 	select: [:char |
		char isAlphaNumeric]).
	(result notEmpty and: [result first isDigit])
		ifTrue: [^nil].
	^result! !

!WBLookPolicyWin31 methods ! 
displayWithBorder: aPen rect: aRect backColor: backColor

    | innerRect |
    aPen
        foreColor: Color windowBorder;
        wbLineFrom: aRect topLeft to: (aRect topRight left: 1);
        wbLineFrom: aRect topLeft to: (aRect bottomLeft up: 1);
        wbLineFrom: (aRect topRight left: 1) to: (aRect bottomRight leftAndUp: 1);
        wbLineFrom: (aRect bottomLeft up: 1) to: (aRect bottomRight leftAndUp: 1);
        fill: (innerRect := aRect insetBy: 1)
        color: backColor.
    ^innerRect! !

!WBTeamVCodePolicy methods !
updateSourceFor: aKey inPoolNamed: aSymbol sourceString: aString
	"Update the source for the specified pool key."

	| poolVarDef |
	(self currentSubsystem unpackagedPackage subsystem 
		definitionOfPoolNamed: aSymbol asSymbol) isNil ifTrue: [^self].
	poolVarDef :=
		(((self currentSubsystem
			definitionOfPoolNamed: aSymbol) ifNil: [^self])
				definitionOfPoolVariableNamed: aKey) ifNil: [^self].
	poolVarDef sourceString = aString ifFalse: [
		poolVarDef sourceString: aString].! !

!WBUndoRedoDialog methods !   
undo

    undoList selectedItems isEmpty ifTrue: [^self].
    self undoManager undo: (undoList contents indexOf: undoList selectedItems last ifAbsent: [1]).
    self preInitWindow.! !

!WBMultiListChooser methods !  
opened
        "Private - Dialog is opened, select the text
         and set the initial focus."

    | list |
    list := self paneNamed: 'list'.
    sel notNil ifTrue: [
        list selection: sel.
    ].
    list setFocus.! !

!WBLookPolicyWin95 methods !
initialize

	super initialize.
	self class isDefault
		ifTrue: [userLibrary := Smalltalk at: #UserLibrary ifAbsent: [nil]]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutFrameEditor methods !  
attach: attachments
	"Set the attachments for all four sides.
		attachments is an array specifying the attachments
		for the left, top, right, and bottom in that order."

	self
		setLeftAttach: (attachments at: 1);
		setTopAttach: (attachments at: 2);
		setRightAttach: (attachments at: 3);
		setBottomAttach: (attachments at: 4);
		updateFramingBlocks;
		updateContents;
		updateExample;
		dirty: true.! !

!WBCallOutEditor methods ! 
updateCallOutList

    callOutList contents: ((callOutMap select: [:sym |
        sym notNil]) keys asSortedCollection: [:a :b | a printString <= b printString])! !

!WBBitmapSubPool methods ! 
fileOut: anAssociation on: aStream
	"File out the specified key/value pair."

	aStream
		nextPutAll: anAssociation key;
		cr.
	anAssociation value
		wbOutputToFileStream: aStream.! !

!WBAttributeWindow methods ! 
ownerAboutToChange
		"The receiver's owner is about to change."
! !

!WBFontEditorCompositePane methods ! 
selectFont

	"Callback for the #clicked event in selectButton [Button].
		(Generated by WindowBuilder Pro)"

	| font |
	self atleastOneKeyAndCategorySelected ifFalse: [^self].
	font := FontDialog new
		sampleFont: (self selectedValueForAll ifNil: [SysFont]);
		open;
		chosen.
	font isNil ifTrue: [^self].
	nameField selection: font faceName.
	sizeField text: font pointSize printString.
	boldCheckBox selection: font bold.
	italicCheckBox selection: font italic.
	strikeOutCheckBox selection: font strikeOut.
	underscoreCheckBox selection: font underscore.
	self setFont.! !

!WBMultiViewAddInModule class methods !  
modifiesMenus
    "Does this add-in modify the menus?"

    ^true! !

!WBClassDefinition methods !   
allInstVarNames
		"Answer a collection of all instance variable names."
	^allInstVarNames ifNil: [ allInstVarNames := self basicAllInstVarNames ]! !

!WBFileSelectorEditor methods ! 
filters: aCollection

    filters := aCollection! !

!WBAbstractCodeModule methods !  
generateBody
		"Private - Generate the method body."
! !

!WBPoolManagerWindow methods !  
allCategories
	"Answer a collection of all categories in the selected pools."

	| answer |
	answer := Set new.
	self pools do: [:each | answer addAll: each categories].
	^answer asSortedCollection! !

!Timer methods ! 
attributeEditor

    ^WBTimerEditor! !

!WindowBuilder class methods !
miniHelpDelay

    ^self editorClass
        propertyValueAt: #MiniHelpDelay
        category: self editorPropertyString! !

!WindowBuilder methods !   
preEditCheck

	^self currentWidget preEdit: self.! !

!WBEditClassDialog methods !
packageList

    ^OrderedCollection new
        add: self class defaultChoice;
        addAll: (self packageChoices collect: [:pack | pack name]) asSortedCollection;
        yourself.! !

!WBInterfaceObject methods !   
wbUpdateConstraints

	| windowRect |
	windowRect := (self parent ifNil: [^nil]) frameContentRect.
	self framingBlock isNil
		ifFalse: [
			self framingBlock: 
				(self framingBlock 
					newFramerFromNewRect: (windowRect localizeRect: self rect) 
					parentRect: (0 @ 0 extent: windowRect extent)).
			self reframe: windowRect].! !

!PRealWidgetControl methods !  
realBackColor

	#osiHack.
	"This should probably be moved up..."
	^self backColor! !

!WBLayoutWizard class methods !   
initializeStandardButtons

    ^#(
            'OK'
            'Cancel'
            'Close'
            'Apply'
            'Help'
        ) asOrderedCollection! !

!WindowBuilder class methods !
autoUpdateOutboards

    ^self editorClass
        propertyValueAt: #AutoUpdateOutboards
        category: self editorPropertyString! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder class methods !
openBitmapManager

    self runtimeLessPoolManagerWarning.
    (Notifier isControlKeyDown
        ifTrue: [WBBitmapManager system]
        ifFalse: [WBBitmapManager current]) edit.! !

!WBEditClassDialog methods !  
packageSelect: selectedItem

    "Callback for the #clicked: event triggered in the WBComboBox named 'package'.
     (Generated by WindowBuilder)"

    | packageChoice |
    packageChoice := self packageChoice.
    self class packageChoice: packageChoice.
    self updateListContents.! !

!WBModelObjectEditor methods ! 
preInitWindow

	super preInitWindow.
	objectList printSelector: #wbNameAndClass.
	self
		updateObjectList;
		disableFields.
	editButton disable.
	removeButton disable.! !

!WBAbstractCodeModule methods ! 
defaultCategory
		"Answer the default category for the receiver."
	^'window definition'! !

!WBAbstractCodeModule methods !   
generateMessagePattern
        "Private - Generate the message pattern."
	self stream wrapDuring: [
		self stream indentBy: 1 during: [
			self
				generateMessagePattern: self messageSelector
				arguments: self messageArguments ] ].! !

!WBTabOrderEditor methods !
update

	super update.
	layoutForm 
		clearSelections;
		setWidgets: self children copy;
		invalidateRect: nil erase: false.! !

!WBInstVarSetModule methods !
defaultCategory
		"Answer the default category for the receiver."
	^'accessing'! !

!WBBitmapManagerWindow methods !  
menuKeyResizeButton

	self menuKeyResize: true.! !

!WBAbstractAddInModule class methods !
modifyCodeGeneration: codeModules
    "Modify the code generation"! !

!WBMenu methods !   
appendItem: anObject
    selector: aSelector
    accelKey: aCharacter
    accelBits: afBits
        "Append an item with label aLabelString and
         selector aSelector and accelerator described
         by aCharacter and afBits to the receiver menu.
         aCharacter is the asciiValue of the accelerator key.
         afBits is one or more of the following from the
         VirtualKeyConstants pool dictionary:
            AfAlt, AfChar, AfControl, AfHelp, AfLonekey, AfShift
            AfSyscommand, AfVirtualkey."
    ^self
        insertItem: (self fixUnderScoreChar: anObject)
        selector: aSelector
        accelKey: aCharacter
        accelBits: afBits
        after: nil! !

!String methods !  
storeColorOn: aStream
		"Store the color definition."
	#addedByOSI.
	self asColor storeColorOn: aStream! !

!WBGeometryManager methods ! 
owner: aWindowBuilder

    owner := aWindowBuilder! !

!WBTreeNode methods !  
asFlatList

    | newList |

    newList := OrderedCollection new.

    (self isRoot) ifFalse: [
        newList add: self.
    ].

    children do: [ :c |
        newList addAll: c asFlatList.
    ].

    ^newList! !

!WBEventManagerWindow methods !
handlerListBoxDrawItem: drawIndex pane: aPane

    "Callback for the #drawItem: event triggered in the MultipleSelectListBox named 'handlerListBox'.
     (Generated by WindowBuilder)"

    | showSource showEvent aHandler aWBDisplayContext box |
    showSource := self widgetSelections size > 1 | self handlerShowAll.
    showEvent := self eventSelections size > 1 | self handlerShowAll.
    aHandler := aPane lineAt: drawIndex.
    aWBDisplayContext := aPane wbDisplayContext.
    showSource ifTrue: [
        box := aWBDisplayContext splitCellLeftRatio: (showEvent ifTrue: [1/4] ifFalse: [1/3]).
        aHandler source wbNameAndClass wbDisplayWith: aWBDisplayContext.
        aWBDisplayContext cellBox: box].
    showEvent  ifTrue: [
        box := aWBDisplayContext splitCellLeftRatio: 1/3.
        aHandler event wbDisplayWith: aWBDisplayContext.
        aWBDisplayContext cellBox: box].
    box := aWBDisplayContext splitCellLeftRatio: 1/2.
    aHandler receiver wbNameAndClass wbDisplayWith: aWBDisplayContext.
    aWBDisplayContext cellBox: box.
    aHandler selector wbDisplayWith: aWBDisplayContext.! !

!WBLookPolicy methods !   
drawMaximizeButtonWith: aPen at: aRect

    ^self draw3DBoxWith: aPen at: aRect.! !

!WBResizeBitmap methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| allRadioButton buttonBitmap cancelButton groupBox1 
	groupBox2 groupBox3 mainView oldHeightField oldWidthField 
	sameExtentRadioButton scaledButton staticText1 staticText2 
	staticText3 staticText4 xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	newHeightField := EnhancedEntryField new.
	newWidthField := EnhancedEntryField new.
	okButton := Button new.
	
		"Temporary Variables"
	allRadioButton := RadioButton new.
	buttonBitmap := CheckBox new.
	cancelButton := Button new.
	groupBox1 := GroupBox new.
	groupBox2 := GroupBox new.
	groupBox3 := GroupBox new.
	oldHeightField := EnhancedEntryField new.
	oldWidthField := EnhancedEntryField new.
	sameExtentRadioButton := RadioButton new.
	scaledButton := CheckBox new.
	staticText1 := StaticText new.
	staticText2 := StaticText new.
	staticText3 := StaticText new.
	staticText4 := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Resize Bitmap';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -66 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -121/2 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -66 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -121/2 * yDU).
	self addView: mainView.
	
	newWidthField "EnhancedEntryField"
		owner: self;
		setName: 'newWidthField';
		when: #textChanged: send: #updateOk to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 98 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		contents: '0000';
		startGroup;
		font: SysFont;
		character: #okPositiveInteger:;
		field: #okInteger;
		right.
	mainView
		addSubpane: newWidthField;
		subPaneWithFocus: newWidthField.
	
	newHeightField "EnhancedEntryField"
		owner: self;
		setName: 'newHeightField';
		when: #textChanged: send: #updateOk to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 98 * xDU;
				topRatio: 0; topInset: 26 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 0; bottomInset: -38 * yDU);
		contents: '0000';
		startGroup;
		font: SysFont;
		character: #okPositiveInteger:;
		field: #okInteger;
		right.
	mainView addSubpane: newHeightField.
	
	allRadioButton "RadioButton"
		owner: self;
		setName: 'allRadioButton';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 12 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 0; rightInset: -60 * xDU;
				bottomRatio: 0; bottomInset: -80 * yDU);
		contents: 'All selected';
		startGroup;
		font: SysFont.
	mainView addSubpane: allRadioButton.
	
	sameExtentRadioButton "RadioButton"
		owner: self;
		setName: 'sameExtentRadioButton';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 12 * xDU;
				topRatio: 0; topInset: 82 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 0; bottomInset: -92 * yDU);
		contents: 'Selected with same extent';
		noTabStop;
		font: SysFont.
	mainView addSubpane: sameExtentRadioButton.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 56 * xDU;
				topRatio: 0; topInset: 102 * yDU;
				rightRatio: 0; rightInset: -90 * xDU;
				bottomRatio: 0; bottomInset: -117 * yDU);
		defaultPushButton;
		contents: 'OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: okButton.
	
	cancelButton "Button"
		owner: self;
		setName: 'cancelButton';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 94 * xDU;
				topRatio: 0; topInset: 102 * yDU;
				rightRatio: 0; rightInset: -128 * xDU;
				bottomRatio: 0; bottomInset: -117 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancelButton.
	
	oldWidthField "EnhancedEntryField"
		owner: self;
		setName: 'oldWidthField';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 34 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		readOnly;
		contents: '0000';
		startGroup;
		noTabStop;
		font: SysFont;
		character: #okPositiveInteger:;
		field: #okInteger;
		right.
	mainView addSubpane: oldWidthField.
	
	oldHeightField "EnhancedEntryField"
		owner: self;
		setName: 'oldHeightField';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 34 * xDU;
				topRatio: 0; topInset: 26 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 0; bottomInset: -38 * yDU);
		readOnly;
		contents: '0000';
		startGroup;
		noTabStop;
		font: SysFont;
		character: #okPositiveInteger:;
		field: #okInteger;
		right.
	mainView addSubpane: oldHeightField.
	
	staticText1
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -32 * xDU;
				bottomRatio: 0; bottomInset: -22 * yDU);
		rightJustified;
		contents: 'Width:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: staticText1.
	
	staticText2
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 0; rightInset: -32 * xDU;
				bottomRatio: 0; bottomInset: -36 * yDU);
		rightJustified;
		contents: 'Height:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: staticText2.
	
	staticText3
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 70 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -96 * xDU;
				bottomRatio: 0; bottomInset: -22 * yDU);
		rightJustified;
		contents: 'Width:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: staticText3.
	
	staticText4
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 70 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 0; rightInset: -96 * xDU;
				bottomRatio: 0; bottomInset: -36 * yDU);
		rightJustified;
		contents: 'Height:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: staticText4.
	
	buttonBitmap "CheckBox"
		owner: self;
		setName: 'buttonBitmap';
		when: #clicked: send: #isButtonBitmap:pane: to: self withArgument: buttonBitmap;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 12 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 0; rightInset: -42 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		contents: 'Button';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: buttonBitmap.
	
	scaledButton "CheckBox"
		owner: self;
		setName: 'scaledButton';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 60 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 0; rightInset: -92 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		contents: 'Scaled';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: scaledButton.
	
	groupBox1
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -63 * xDU;
				bottomRatio: 0; bottomInset: -42 * yDU);
		contents: 'Old Size';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: groupBox1.
	
	groupBox2
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 68 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -127 * xDU;
				bottomRatio: 0; bottomInset: -42 * yDU);
		contents: 'New Size';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: groupBox2.
	
	groupBox3
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 44 * yDU;
				rightRatio: 0; rightInset: -128 * xDU;
				bottomRatio: 0; bottomInset: -98 * yDU);
		contents: 'Resize';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: groupBox3! !

!WBAddInManager methods ! 
getHelpText

	WBAbstractAddInModule allSubclasses do: [:class |
		selection = class commonName
			ifTrue: [^class comment]].
	self wbEditorClass listAddIns do: [:sym |
		selection = (self wbEditorClass perform: sym with: #name)
			ifTrue: [^self wbEditorClass perform: sym with: #help]].
	^''! !

!WBUndoManager methods !   
setCantUndo

    self
        setUndoState: false;
        setUndoLabel: 'Can''t Undo'! !

!WBTabOrderLayoutForm methods !  
addHandlesFor: aWidget

	aWidget isGrouper ifFalse: [^self].
	super addHandlesFor: aWidget.! !

!WBScrollingPane methods !   
visibleExtent

    ^self extent - 2! !

!WBAttributeWindow methods !  
activated
		"Check to see if the receiver needs to be updated."
	self checkUpdate.! !

!Bitmap methods !  
cpCopy
	"Private - WBPro Development."

	#obsoleteMethod.
	^self wbCopy! !

!PComboBox methods !
mutationExceptions

    ^#(#CPScrollingPane)! !

!WBCodePolicy methods !  
hasMethodChanged: aCodeModule
		"Answer true if the method has changed."
	aCodeModule sourceString isEmpty ifTrue: [ ^false ].
	^(self existingSourceFor: aCodeModule) ~= aCodeModule sourceString! !

!WBInterfaceObject methods !  
eventsTriggered
	| eventsTriggered answer |
	(eventsTriggered := self realClass eventsTriggered) isNil ifTrue: [^#( )].
	(answer := self importantEvents asOrderedCollection)
		addAll: (eventsTriggered reject: [:sym |
			(answer includes: sym) or: [self removeEvents includes: sym]]) asSortedCollection.
	^answer! !

!WBDevelopmentWindow methods !
updateFramingButton: palette for: currentWidget
	"Update the Framing button"

	(currentWidget notNil 
		and: [currentWidget usesFraming 
		and: [currentWidget isFrameObject not
		and: [self okToSetFraming]]])
		ifTrue: [palette enableItem: #setFraming]
		ifFalse: [palette disableItem: #setFraming].! !

!PRadioButtonGroup methods !
children

	^children ifNil: [children := OrderedCollection new].! !

!WBTreeListBox methods ! 
cr

    (self contents asFlatList size = self selection) ifTrue: [
        self insertAfterSelection.
    ] ifFalse: [
        self moveSelectionDown.
    ].! !

!WindowBuilder methods !
invoke: aClass selecting: anObject

    | existing |
    (existing := outboards detect: [:window |
        window class == aClass]
        ifNone: [nil]) isNil
        ifTrue: [
            aClass new
                openOn: self
                selecting: anObject]
        ifFalse: [
            existing
                select: anObject;
                activate].! !

!WBInterfaceObject methods !   
wbCopyTo: copy

	super wbCopyTo: copy.
	self == copy 
		ifFalse: [copy wbRealWidget: self wbRealWidget wbCopy].
	^copy! !

!WBLayoutWizard methods !   
menusToGenerate

    ^(self paneNamed: 'standardMenusList') value! !

!PropertyAccessor methods ! 
wbNLSAccessor
	"Answer true if the receiver is an NLS accessor."

	^(self propertyAt: #wbNLSAccessor) ifNil: [false]! !

!WBChooseClassDialog methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel mainView nonWBView ok xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	classListBox := ListBox new.
	
		"Temporary Variables"
	cancel := Button new.
	nonWBView := Button new.
	ok := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Choose a Class:';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -79 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -64 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -79 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -64 * yDU).
	self addView: mainView.
	
	classListBox "ListBox"
		owner: self;
		setName: 'classListBox';
		when: #doubleClicked: send: #selectedClass: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -154 * xDU;
				bottomRatio: 0; bottomInset: -104 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: classListBox;
		subPaneWithFocus: classListBox.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 108 * yDU;
				rightRatio: 0; rightInset: -36 * xDU;
				bottomRatio: 0; bottomInset: -124 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 40 * xDU;
				topRatio: 0; topInset: 108 * yDU;
				rightRatio: 0; rightInset: -72 * xDU;
				bottomRatio: 0; bottomInset: -124 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	nonWBView "Button"
		owner: self;
		setName: 'nonWBView';
		when: #clicked send: #openNonWBView to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 88 * xDU;
				topRatio: 0; topInset: 108 * yDU;
				rightRatio: 0; rightInset: -154 * xDU;
				bottomRatio: 0; bottomInset: -124 * yDU);
		contents: '&Non WB View...';
		startGroup;
		font: SysFont.
	mainView addSubpane: nonWBView! !

!WBPMenuItem methods !   
initialize

	super initialize.
	self setListString: ''.
	isDivider := false.! !

!WBDevelopmentDialog class methods !   
isWBInternalClass

    ^true! !

!WBListEditor methods !  
disable

    (self paneNamed: 'change') disable.
    (self paneNamed: 'delete') disable.
    item setFocus.! !

!PListBox methods ! 
displayWith: aPen clipRect: clipRect
    | list newPoint region innerRect theBackColor |
    innerRect := self lookPolicy
        displayWithRightScrollBar: aPen
        rect: self rect
        backColor: self backColor.
    "Draw the list contents"
    (list := self contents) isNil
        ifFalse: [
            theBackColor :=  (self asRGBColor: self backColor) = (self asRGBColor: self defaultBackColor)
                ifTrue: [self lookPolicy defaultWidgetBackColor]
                ifFalse: [self backColor].
            aPen
                rgbColorMode;
                foreColor: self foreColor;
                backColor: theBackColor;
                font: self font.
            region := aPen setClipRect: (innerRect intersect: clipRect).
            newPoint := innerRect leftTop right: 2.
            1 to: list size do: [:i |
                aPen
                    setTextAlign: TaTop;
                    displayText: (list at: i) at: newPoint.
                newPoint := newPoint down: aPen font height].
            aPen
                resetColorMode;
                destroyRegion: region].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PToggle methods !  
defaultForeColor

    ^Color windowText! !

!WBPoolManagerWindow methods !
menuOptionShowActiveCategory

    "Callback for the menu item titled 'Show active category'.
     (Generated by WindowBuilder)"

	self isActiveCategoryVisible
		ifTrue: [self hideActiveCategory]
		ifFalse: [self showActiveCategory].! !

!WBCallOutEditor methods !  
shellChildren
        "Answer the children of the shell."
    ^self shell children, (self shell modelObjects reject: [:model | model isWBPrimaryModel])! !

!WBFontSelectionWindow methods !  
closed
	"The receiver has been closed."

	super closed.
	self poolManager removeAllActionsWithReceiver: self.! !

!WBManagedPNLSString methods !
widthFor: aFont
	"Answer the string width of the receiver's value.
		If NLS-Autosize is enabled, then answer the maximum
		string width of all NLS strings for that key."

	| pool width string |
	width := aFont wbStringWidth: self value.
	self nlsAutosize ifTrue: [
		(pool := self managedPool) notNil ifTrue: [
			pool categories do: [:each |
				(string := pool at: self key in: each ifAbsent: [nil]) isString ifTrue: [
					width := width max: (aFont wbStringWidth: string)]]]].
	^width! !

!PButton methods ! 
contents: aString

    super contents: aString.! !

!WBTargetObject methods ! 
wbEventsTriggered

	^eventsTriggered ifNil: [#( )]! !

!WBPoolManagerWindow methods ! 
categoryListDrawItem: drawIndex pane: aPane

    "Callback for the #drawItem: event triggered in the MultipleSelectListBox named 'categoryListBox'.
     (Generated by WindowBuilder)"

	| aCategory aKeyAndPool aKey aPool aString |
	aCategory := self categories at: drawIndex.
	(aKeyAndPool := self selectedKeyAndPool) notNil
		ifTrue: [
			aKey := aKeyAndPool key.
			aPool := aKeyAndPool value].
	aString := self
		valueStringAt: aKey
		in: aCategory
		pool: aPool.
	self
		categoryListDraw: aCategory
		value: aString
		pane: aPane.! !

!WBCodeModule methods ! 
varNameFor: anObject ifAbsentPut: aString
		"Set the variable name (temporary variable or instance variable)
			for the specified object."
	varNames at: anObject ifAbsentPut: aString! !

!WBLayoutWizard methods ! 
initWindow

    modelList printSelector: #name.
    self
        loadModels;
        loadStandardButtons;
        loadStandardMenus;
        updateSourceButtons;
        disableFields! !

!WBLookPolicyWin95 methods !
wordBreak

    ^"DtWordbreak" 16! !

!LayoutFrame methods !   
asFramingBlockForWindowFromDialogTopPane

	"The framingBlock for DialogTopPane and TopPane are passed 
		a rectangle in pixels.  DialogTopPane expects its framingBlock to
		return dialog units whereas TopPane expects its framingBlock to return pixels.
		Convert the insets from dialog units to pixels and *un*-skew the ratios
		that when they are multiplied against the input (a rectangle in pixels),
		they will return a ratio *and* convert the pixels to dialog units."

	| xDU yDU xR yR xDUReal yDUReal |
	"xDU := (WindowDialog dialogUnit x / WindowDialog unitMultiplier x * 2) ceiling / 2."
	"xDU := WindowDialog dialogUnit x / WindowDialog unitMultiplier x."
	"yDU := WindowDialog dialogUnit y / WindowDialog unitMultiplier y."

	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	xDUReal :=  (SysFont width roundTo: 2) / 4.
	yDUReal := SysFont height / 8.
	xR := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yR := 1.

	^self wbCopy
		leftRatio: self leftRatio * xDUReal;
		leftInset: self leftInset * xDU / xR;
		topRatio: self topRatio * yDUReal;
		topInset: self topInset * yDU / yR;
		rightRatio: self rightRatio * xDUReal;
		rightInset: self rightInset * xDU / xR;
		bottomRatio: self bottomRatio * yDUReal;
		bottomInset: self bottomInset * yDU / yR;
		yourself! !

!PButton class methods !
styleFrom: style

	^(style bitIsOn: BsDefpushbutton)
		ifTrue: [#defaultPushButton]
		ifFalse: [#pushButton].! !

!WBPoolManagerWindow methods !
promptForNewFileName: defaultFileName title: titleString
	"Prompt the user for a new file."

	^FileDialog new
		saveTitle: titleString
		fileName: defaultFileName;
		file! !

!WBListEditor methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| add cancel change delete insert mainView ok sort xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	item := WBEntryField new.
	listBox := ListBox new.
	
		"Temporary Variables"
	add := Button new.
	cancel := Button new.
	change := Button new.
	delete := Button new.
	insert := Button new.
	ok := Button new.
	sort := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'List Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -87 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -95/2 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -87 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -95/2 * yDU).
	self addView: mainView.
	
	item "WBEntryField"
		owner: self;
		setName: 'item';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: item;
		subPaneWithFocus: item.
	
	listBox
		owner: self;
		setName: 'listBox';
		when: #clicked: send: #select: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 9/2 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -126 * xDU;
				bottomRatio: 0; bottomInset: -76 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: listBox.
	
	add "Button"
		owner: self;
		setName: 'add';
		when: #clicked send: #add to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 130 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -170 * xDU;
				bottomRatio: 0; bottomInset: -18 * yDU);
		defaultPushButton;
		contents: '&Add';
		startGroup;
		font: SysFont.
	mainView addSubpane: add.
	
	insert "Button"
		owner: self;
		setName: 'insert';
		when: #clicked send: #insert to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 130 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -170 * xDU;
				bottomRatio: 0; bottomInset: -34 * yDU);
		contents: '&Insert';
		startGroup;
		font: SysFont.
	mainView addSubpane: insert.
	
	change "Button"
		owner: self;
		setName: 'change';
		when: #clicked send: #change to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 130 * xDU;
				topRatio: 0; topInset: 36 * yDU;
				rightRatio: 0; rightInset: -170 * xDU;
				bottomRatio: 0; bottomInset: -50 * yDU);
		contents: '&Change';
		startGroup;
		font: SysFont.
	mainView addSubpane: change.
	
	delete "Button"
		owner: self;
		setName: 'delete';
		when: #clicked send: #delete to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 130 * xDU;
				topRatio: 0; topInset: 52 * yDU;
				rightRatio: 0; rightInset: -170 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		contents: '&Delete';
		startGroup;
		font: SysFont.
	mainView addSubpane: delete.
	
	sort "Button"
		owner: self;
		setName: 'sort';
		when: #clicked send: #sort to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 130 * xDU;
				topRatio: 0; topInset: 78 * yDU;
				rightRatio: 0; rightInset: -170 * xDU;
				bottomRatio: 0; bottomInset: -92 * yDU);
		contents: '&Sort';
		startGroup;
		font: SysFont.
	mainView addSubpane: sort.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 9/2 * xDU;
				topRatio: 0; topInset: 78 * yDU;
				rightRatio: 0; rightInset: -81/2 * xDU;
				bottomRatio: 0; bottomInset: -92 * yDU);
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 44 * xDU;
				topRatio: 0; topInset: 78 * yDU;
				rightRatio: 0; rightInset: -80 * xDU;
				bottomRatio: 0; bottomInset: -92 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel! !

!PToggle methods !
isGroupable

    ^true! !

!WBCreateClassDialog methods ! 
defaultPackage

    ^self class defaultPackage! !

!WBLookPolicyWin95 methods !   
scrollBarColor

    ^RGBColor red: 224 green: 224 blue: 224! !

!WBHorizontalScrollBar class methods !
isWBInternalClass

    ^true! !

!WBEventManagerWindow methods !  
handlerSelections
    "Answer the currently selected handlers."

    ^handlerListBox selectedItems! !

!WBTabOrderEditor methods !   
addGroup

	layoutForm addGroupingPane.! !

!WBAddInManager methods !  
done

    changed
        ifTrue: [
            self updateProperties.
                (Smalltalk platformIsOS2
                    ifTrue: [self mainView pmOwner]
                    ifFalse: [self mainView parent]) owner class isWBInternalClass
                ifTrue: [MessageBox messageNote: 'You must restart WindowBuilder for these changes to take effect.']].
    self close! !

!Boolean methods !
wbFullCopyReal: aDictionary
	"Answer a copy of the receiver which shares
		 the receiver instance variables.  Because
		 the receiver is unique (cannot be copied),
		 answer the receiver."

	#addedByOSI.
	^self! !

!PRadioButtonGroup methods !  
numColumns: anInteger

	numColumns := anInteger.
	style := anInteger asString, ' Column'.
	numColumns isNil ifTrue: [^nil].
	self addSubpanes.! !

!WBPoolManagerWindow methods !  
keysAndPools
	"Answer a collection of keys/pool associations in the selected pools."

	^keyListBox contents! !

!WBEditClassDialog class methods !   
filter: aString

    Filter := aString! !

!WBLayoutForm methods !
hideHandlesExceptFor: aWidget

    self hideHandles: (self handlesRejecting: aWidget).! !

!WBEditClassDialog class methods ! 
filterList

    ^FilterList ifNil: [FilterList := self defaultFilterList]! !

!WindowBuilder methods !
updateMenuSize

	(self menuTitled: 'Size') updateEnabled.! !

!WindowBuilder methods !
defaultCodePolicy
	"Private - Answer the default code policy."

	^(self class codePolicyClass ifNil: [^nil]) new! !

!WBCodeModule methods ! 
generateTemporaries: aCollectionOfTempNames
		"Private - Generate the temporary variables."
	aCollectionOfTempNames isNil ifTrue: [ ^self ].
	aCollectionOfTempNames isEmpty ifTrue: [ ^self ].
	self stream
	   cr;
		nextPut: $| ;
		space.
	aCollectionOfTempNames asSortedCollection do: [ :eachTempName |
		self stream
			nextPutAll: eachTempName;
			space ].
	self stream
		nextPutNoWrap: $| ;
		cr.! !

!WBInterfaceObject methods !   
backColor: aColor

	(backColor := aColor) isInteger
		ifTrue: [backColor := IndexedColor index: aColor].! !

!WBCodeStream methods ! 
nextPutAllNoWrap: aString
		"Append aString to the code stream.
			Keep all characters in aString on the same line."
	self checkEnd.
	"(self isSpaceOnLine: aString size) ifFalse: [ self cr ]."
	stream nextPutAll: aString.! !

!WBInterfaceObject methods ! 
scrollBarColor

    ^self isWindows95
        ifTrue: [RGBColor red: 224 green: 224 blue: 224]
        ifFalse: [Color white].! !

!WBCreateMenuModule class methods !  
defaultMessageSelector
		"Private - Answer the default message selector."
	^#createMenus:! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBNLSManager methods !
defaultCodeGenerationStyle
	"Answer the code generation style.
		Answer #key to generate code that references the pool key directly.
		Answer #pool to generate code that is '(<pool> at: <key>)'.
		Answer #manager to generate code that is
			'(<valueClass> named: <key>)'  or  '(<managerClass> system at: <key>)'."

	^#key! !

!WBInterfaceObject methods !   
usesBackColor

    ^true! !

!WBModelDefinitionEditor methods !   
modelType

	^Smalltalk at: ((self paneNamed: 'modelTypes') selectedItem ifNil: [^nil])! !

!WindowBuilder class methods ! 
initTranscriptMenu
	"Prompt the user to initialize the transcript menu."

	WBAboutDialog initTranscriptAfterClose: true.
	(Message 
		receiver: WindowBuilder 
		selector: #aboutWB) performDeferred.! !

!WBMultiToolPalette methods !   
pageNamed: name
    ^self pages at: name ifAbsent: [ self addPage: self newPage name: name ]! !

!WBLookPolicyOS2 methods !
drawEntryField: anEntryField with: aPen clipRect: clipRect

    | innerRect contents region displayContents justification backColor |
    backColor := (self class isDefault not
        and: [(self asRGBColor: anEntryField backColor) = (self asRGBColor: anEntryField defaultBackColor)])
        ifTrue: [self defaultWidgetBackColor]
        ifFalse: [anEntryField backColor].
    innerRect := (self
        displayWithBorder: aPen
        rect: anEntryField rect
        backColor: backColor) insetBy: 1.
    "Draw the initialization text"
    (contents := anEntryField contents) isNil
        ifFalse: [
            displayContents := (anEntryField style == #password)
                ifTrue: [contents copy atAllPut: $*]
                ifFalse: [contents].
            justification := anEntryField justification == #left
                ifTrue: [self class default leftJustification]
                ifFalse: [
                    anEntryField justification == #right
                        ifTrue: [self class default rightJustification]
                        ifFalse: [self class default centerJustification]].
            region := aPen setClipRect: innerRect.
            aPen
                rgbColorMode;
                font: anEntryField font;
                foreColor: anEntryField foreColor;
                backColor: backColor;
                setTextAlign: WBDisplayContext defaultTextAlign;
                winDrawText: displayContents in: innerRect format: justification;
                resetColorMode;
                destroyRegion: region].! !

!WBTreeListBox methods !  
drawItem: aDrawStruct

    "Private - Draw the requested control item."

    | backColor foreColor |

    aDrawStruct itemState & OdsSelected = OdsSelected ifTrue:[
        backColor := Color highlightBackground.
        foreColor := Color highlightText.
    ] ifFalse: [
        backColor := self backColor.
        foreColor := self foreColor.
    ].

    graphicsTool
        fill: self drawBox color:  backColor;
        backColor: backColor;
        foreColor: foreColor;
        setTextAlign: TaTop;
        displayText: (self flatList at: self drawIndex) listString at: self drawBox leftTop.! !

!WindowBuilder class methods !
gridPropertyString

    ^#GridProperties! !

!WBLayoutForm methods !  
motionState: aSelector
    "Set the value of motionState."

    motionState := aSelector! !

!WBLayoutForm methods ! 
showOrder
    "Answer the value of showOrder."

    ^showOrder! !

!WBFontManagerWindow methods !
valueStringAt: aKey in: aCategory pool: aPool
	"Answer the value to be displayed."

	aKey isNil | aCategory isNil | aPool isNil ifTrue: [^nil].
	^(aPool at: aKey in: aCategory ifAbsent: [^'']) wbFontDescription! !

!WBPoolManagerWindow methods !   
opened

    "Callback for the #opened event in the TopPane 'mainView'.
     (Generated by WindowBuilder)"

	super opened.
	self pools notEmpty ifTrue: [self selectedPool: self pools first].
	self categories notEmpty ifTrue: [self selectedCategory: self categories first].
	self poolManager
		when: #poolAdded: send: #updatePools to: self;
		when: #poolRemoved: send: #updatePools to: self;
		when: #fileNameChanged:pool: send: #updatePoolPath to: self;

		when: #categoryAdded:pool: send: #updateCategories to: self;
		when: #categoryRemoved:pool: send: #updateCategories to: self;
		when: #fileNameChanged:in:pool: send: #updateCategoryPath to: self;
		when: #activeCategoryChanged: send: #updateActiveCategory: to: self;

		when: #keyAdded:pool: send: #updateKeys to: self;
		when: #key:renamed:pool: send: #updateKey:to:pool: to: self;
		when: #keyRemoved:pool: send: #updateKeys to: self;

		when: #valueChanged:at:in:pool: send: #updateValue:at:in:pool: to: self.! !

!PEntryFieldGroup methods !  
usesMenu

     ^false! !

!WBGraphicObject methods !  
bottomRight

	^rect bottomRight! !

!WBLookPolicyOS2 methods !
borderWidthFrom: aFrameObject

    ^aFrameObject isModal
        ifTrue: [self frameWidthDialog]
        ifFalse: [
            (aFrameObject style includes: #sizable)
                ifTrue: [self frameWidthSizable]
                ifFalse: [self frameWidthBorder]].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBStatusPaneEditor methods !   
initWindow

    list contents: (boxes collect: [ :box | box name asString ]).

    (self paneNamed: 'paste') disable.
    (self paneNamed: 'auto') selection: true.

    boxes isEmpty ifFalse: [
        list selection: 1.
        self selectBox: 1
    ] ifTrue: [
        self updateBoxes.
    ].! !

!PEntryField methods !  
framingBlock: framer

	framer isFramingParameters
		ifTrue: [framer indent: 0@0].
    super framingBlock: framer.! !

!WindowBuilder methods !  
menuAddAddCustomPane

	| newPaneClass aName customPanes |
	customPanes := self customPanes, 
		((self menuTitled: 'Add') allMenuItemSelectors select: [:selector | selector isString]).
	(newPaneClass := (WBChoosePaneDialog new
		classList: (SubPane allSubclasses reject: [:class |
			(class symbol beginsWith: ' ') | class isWBInternalClass |
			(customPanes includes: class name)])) result) isNil
		ifTrue: [^self].
	(self customPanes includes: newPaneClass name)
		ifFalse: [
			aName := newPaneClass name.
			self customPanes add: aName.
			customSubMenu
				insertItemDynamically: aName
				selector: aName
				atIndex: customSubMenu numberOfItems + 1].
	self updateMenuAdd.
	self addWidget: newPaneClass name! !

!WindowBuilder methods !
closed
	"The receiver has been closed."

	WBNLSManager current removeAllActionsWithReceiver: self.
	self triggerEvent: #closed.! !

!SexPane class methods !
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #setToFemale ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #sexChanged: ;
                argumentNames: #('anObject'));
        wbAddEvent: (
            WBEventDescription new
                event: #setToMale ;
                argumentNames: #( ));
        yourself! !

!WBInterfaceObject methods ! 
autoSizeFrom

    ^#leftJustified! !

!WBInterfaceObject methods !
style

    ^style! !

!WBLayoutWizard methods !   
setDefaultType

    (self widgetMapFor: attributesList selectedItem object)
        remove: widgetType value ifAbsent: [];
        addFirst: widgetType value.! !

!WBKeyAccel methods !
isAlt

    ^isAlt ifNil: [false]! !

!PropertyManager methods !   
wbRemoveEventNamed: eventName
	"Remove the event definition."

	#addedByOSI.
	self wbEvents removeKey: eventName ifAbsent: [ ].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCodePolicy methods !
createClassFor: aWBClassDefinition
        "Define and answer a new class.
        Answer nil if one could not be created."
    | transcript |
    self removeScratchSelectorsFor: aWBClassDefinition.
    transcript := Transcript.
    Transcript := WriteStream on: String new.
    ^[self basicCreateClassFor: aWBClassDefinition]
        ensure: [Transcript := transcript]! !

!WindowBuilder methods !  
updatePasteButton

	self updateMenuEdit.
	toolBar updateEnabled: #pasteSelections.! !

!WBOutboardAttributeWindow methods !  
currentWidgets: aCollection
	"Update the receiver's contents to reflect
		the new widget."

	currentWidgets := aCollection.! !

!WBLayoutForm methods ! 
button1MotionResizing: aPoint
    "Process a motion event that occurred while we are resizing a widget."

    | x y contentRect |
    contentRect := self shell frameContentRect.
    x := aPoint x left: self cursorOffset first x.
    y := aPoint y up: self cursorOffset first y.
    self useGrid
        ifTrue: [
            x := contentRect left distanceRight: x.
            y := contentRect top distanceDown: y.
            x := contentRect left right: (x roundTo: (self gridSize x max: 1)).
            y := contentRect top down: (y roundTo: (self gridSize y max: 1))].
    self useFence
        ifTrue: [
            x := (x rightMost: contentRect left) leftMost: contentRect right.
            y := (y lowerOf: contentRect top) higherOf: contentRect bottom].
    self
        drawBand;
        resizeBand: x @ y;
        drawBand.

    self notifyModelOfSizeOrPositionChange: bandRect.
! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLookPolicy methods !
scrollBarWidth

    ^self class default scrollBarWidth! !

!PWBToolBar methods !  
displayWith: aPen clipRect: clipRects

	aPen fill: rect color: self backColor.
	self elements isEmpty 
		ifTrue: [
			aPen
				place: rect origin;
				box: rect corner]
		 ifFalse: [
			1 to: self elements size do: [:index | 
				self displayElement: index with: aPen]].! !

!WBTreeListBox methods !   
highlight: drawStruct

    "Mask out behavior in ControlPane - we do our own highlighting in drawItem: method."
    self drawItem: drawStruct! !

!WBTabOrderLayoutForm methods !
createAllGroups

	self 
		clearSelections;
		removeGroupingPanes;
		groups: Dictionary new;
		setSmartGroups.! !

!WBInterfaceObject methods !
wbDirectEdit

    ^nil! !

!WBLookPolicy class methods !  
initializePolicy

    ^(self wbEditorClass lookPolicy
        ifNil: [self defaultPolicy]) new! !

!WBLookPolicyWin31 methods !  
drawHorizontalScrollBar: aScrollBar with: aPen clipRect: clipRect

    self drawHScrollBarWith: aPen at: aScrollBar rect.! !

!WBClassDefinition class methods !  
nonNLSPoolNames
		"Answer a collection of symbols representing
			pool dictionaries that are NOT NLS pools."
	^#(
		#CharacterConstants
		#CoffImageConstants
		#CoffSectionConstants
		#ColorConstants
		#CommonDialogConstants
		#CursorConstants
		#FileConstants
		#GraphicsConstants
		#HiddenNames
		#ObjectStoreExternalTypes
		#OperatingSystemConstants
		#OperatingSystemEventsExtra
		#OSErrorDescriptions
		#PARTSConstants
		#PARTSNotebookConstants
		#PeDataDirectoryKeys
		#PMConstants
		#PMToWinKeyMap
		#StackOffsets
		#SystemColorConstants
		#SystemValueConstants
		#VirtualKeyConstants
		#VirtualMachineConstants
		#WBBitmaps
		#WBConstants
		#WBDevelopmentBitmaps
		#WBMonthStrings
		#WBSystemBitmaps
		#WinConstants
		#WinToPMKeyMap
		)
! !

!WBAboutDialog methods !   
getVersion: aPane
	"Display the version number."

	aPane contents: self wbEditorClass versionNumberString.! !

!WBInterfaceObject methods !  
usesTitle

    ^false! !

!Point methods !
extentFromCenterTop: aPoint
        "Private - WBPro Development."
        "Added by OSI - Answer a Rectangle whose center top point is
         the receiver at the center top point and extent is aPoint."
    #addedByOSI.
    ^Rectangle
        leftTop: ((self x left: (aPoint x // 2))@ (self y))
        rightBottom: ((self x right: (aPoint x // 2)) @ (self y down: aPoint y))! !

!PropertyAccessor methods !
wbUserDefault
	"Answer the user default value for this property."

	#addedByOSI.
	^self propertyAt: #wbDefault ifAbsent: [self wbDefault]! !

!WBCompositePaneTester methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| mainView xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'CompositePane Tester';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -75 * xDU;
				topRatio: 1/2; topInset: -109/2 * yDU;
				rightRatio: 1/2; rightInset: -75 * xDU;
				bottomRatio: 1/2; bottomInset: -91/2 * yDU).
	self addView: mainView! !

!WBAttributeEditor methods ! 
popupNlsMenu: aPane

    | menu subMenu subMenus nlsPool nlsPools checkItem assoc array answer |

    (nlsPools := thePane parent nlsPools asArray) isEmpty
        ifTrue: [^aPane setPopupMenu: nil].

    menu := Menu new
        owner: aPane;
        selector: #contents:;
        yourself.

    nlsPools size == 1
        ifTrue: [
            ((array := (nlsPool := Smalltalk at: nlsPools first) keys asSortedCollection asArray) 
				copyFrom: 1 to: (array size min: 24)) do: [:key |
                assoc := nlsPool associationAt: key.
                menu appendItem: ('#',assoc key, ' - ', assoc value printString) selector: ('#', assoc key) asSymbol].
			array size > 24
				ifTrue: [
					menu appendSeparator;
						appendItem: 'Other...' action:
							(Message receiver: [
								(answer := WBListChooser 
									fromList: (array collect: [:key |
										assoc := nlsPool associationAt: key.
										('#',assoc key, ' - ', assoc value printString)])
									prompt: 'Select NLS Key') isNil
									ifFalse: [aPane contents: (answer upTo: $ )]] selector: #value)]]
        ifFalse: [
            subMenus := OrderedCollection new: nlsPools size.
            nlsPools do: [:sym |
                menu appendSubMenu:
                    (subMenu := Menu new
                        title: sym;
                        owner: aPane;
                        selector: #contents:;
                        yourself).
                subMenus add: subMenu.
                ((array := (nlsPool := Smalltalk at: sym) keys asSortedCollection asArray) 
					copyFrom: 1 to: (array size min: 24)) do: [:key |
                    assoc := nlsPool associationAt: key.
                    subMenu appendItem: ('#',assoc key, ' - ', assoc value printString) selector: ('#', assoc key) asSymbol].
				array size > 24
					ifTrue: [
						subMenu appendSeparator;
							appendItem: 'Other...' action:
								(Message receiver: [
									(answer := WBListChooser 
										fromList: (array collect: [:key |
											assoc := nlsPool associationAt: key.
											('#',assoc key, ' - ', assoc value printString)])
										prompt: 'Select NLS Key') isNil
										ifFalse: [aPane contents: (answer upTo: $ )]] selector: #value)]]].
    checkItem := ((self nlsKeyFor: aPane contents) ifNil: ['']) asSymbol.
    subMenus isNil
        ifTrue: [menu checkItem: checkItem]
        ifFalse: [
            subMenus do: [:sub |
                sub checkItem: checkItem]].

    aPane setPopupMenu: menu.! !

!WBLayoutForm methods !
placeNewWidgets: newWidgets at: aPoint
	"Place the <newWidgets> at <aPoint>"

	| x y boundingBox contentRect |
	x := aPoint x.
	y := aPoint y.
	boundingBox := self boundingBoxFor: newWidgets.
	contentRect := self shell frameContentRect.
	self useGrid
		ifTrue: [
			x := contentRect left distanceRight: x.
			y := contentRect top distanceDown: y.
			x := contentRect left right: (x roundTo: (self gridSize x max: 1)).
			y := contentRect top down: (y roundTo: (self gridSize y max: 1))].
	self useFence
		ifTrue: [
			x := (x leftMost: (contentRect right left: boundingBox width)) rightMost: contentRect left.
			y := (y higherOf: (contentRect bottom up: boundingBox height)) lowerOf: contentRect top].
	newWidgets do: [:aWidget |
		self
			placeNewWidget: aWidget
			at:
				((x right: aWidget x) left: boundingBox leftTop x) @
				((y + aWidget y) - boundingBox leftTop y)].! !

!WBPrototype methods !  
realDialogUnit

    ^(SysFont width + 1 / 4) @  (SysFont height / 8).! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder methods !   
menuToolsInspectOperatingSystemConstants

    OperatingSystemConstants inspect! !

!WindowFrameObject methods !   
usesForeColor

    ^false! !

!WBTreeListBox methods !
selectIndex: itemIndex
        "Private - Select the item at itemIndex. Index starts at 1."
    | index |
    self isHandleOk ifFalse: [^self].
    itemIndex isNil
        ifTrue: [index := 65535]
        ifFalse: [index := itemIndex - 1].
    UserLibrary sendMessage: handle
            msg: LbSetcursel
            wparam: index
            lparam: 0! !

!WBListEntryField methods !  
wmChar: char with: lParam
		"Private - Process the character input message."
	| answer |
	answer := super wmChar: char with: lParam.
	char = ReturnKey ifTrue: [ ^1 ].
	^answer! !

!WindowBuilder methods !   
defaultCodeModulesFor: anObject
	"Private - Answer the default code module."

	| answer |
	answer := OrderedCollection new.
	self codeModuleClasses do: [:each |
		answer addAll: (each codeModulesFor: anObject)].
	self class addInModuleClass modulesModifyingCodeGeneration do: [:module |
		module modifyCodeGeneration: answer].
	^answer! !

!LayoutFrame methods ! 
storeForDialogTopPaneOn: aStream indentString: indentString
	"Append the definition of the receiver to aStream."

	| xDU yDU xR yR xDUExpression yDUExpression |
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	xR := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yR := 1.
	xDUExpression := ' / ((SysFont width roundTo: 2) / 4)'.
	yDUExpression := ' / (SysFont height / 8)'.

	aStream
		nextPutAll: indentString;
		nextPutAll: self class name;
		space;
		nextPutAll: #new;
		indentBy: 1.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #leftRatio: ;
		space;
		nextPutAll: (leftRatio * xDU) printString;
		nextPutAll: xDUExpression;
		endMessage.

	aStream cr;
		nextPutAll: #leftInset: ;
		space;
		nextPutAll: (self leftInset / xDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #xDU;
		endMessage.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #topRatio: ;
		space;
		nextPutAll: (self topRatio * yDU) printString;
		nextPutAll: yDUExpression;
		endMessage.

	aStream cr;
		nextPutAll: #topInset: ;
		space;
		nextPutAll: (self topInset / yDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #yDU;
		endMessage.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #rightRatio: ;
		space;
		nextPutAll: (self rightRatio * xDU) printString;
		nextPutAll: xDUExpression;
		endMessage.

	aStream cr;
		nextPutAll: #rightInset: ;
		space;
		nextPutAll: (self rightInset / xDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #xDU;
		endMessage.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #bottomRatio: ;
		space;
		nextPutAll: (self bottomRatio * yDU) printString;
		nextPutAll: yDUExpression;
		endMessage.

	aStream cr;
		nextPutAll: #bottomInset: ;
		space;
		nextPutAll: (self bottomInset / yDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #yDU;
		indentBy: -1.! !

!WBInterfaceObject methods ! 
displayWithLeftScrollBar: aPen

    ^self lookPolicy
        displayWithRightScrollBar: aPen
        rect: self rect
        backColor: self backColor! !

!WBGeometryManager methods !
hasSelections

    ^self selections notEmpty! !

!WindowBuilder methods ! 
menuViewRemove

	| nameString |
	(nameString := WBListChooser new 
		fromList: self viewList 
		prompt: 'Remove Which View?') isNil
		ifFalse: [
			self prototype removeWindow: nameString.
			self updateMenuView.
			self layoutFormChanged].! !

!WindowBuilder class methods !
propertyValueAt: aSymbol put: aValue

    | property |
    (property := self propertyAt: aSymbol) ifNil: [^nil].
    property value: aValue.
    ^aValue! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBMenuItem methods !
updateState
	"Update the receiver's state"
	self
		updateEnabled;
		updateToggled.! !

!WBLookPolicyWin31 methods ! 
scrollBarArrowHeight

    ^scrollBarArrowHeight ifNil: [
        scrollBarArrowHeight := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCyvscroll" 20]
            ifFalse: [super scrollBarArrowHeight]]! !

!WBTabOrderEditor methods !  
createMenus: aPane

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	#generated.
	aPane menuWindow
	    yourself;
	    addMenu: (
	        Menu new
	            title: '~Tab Order';
	            owner: self;
	            appendSubMenu: (
	                Menu new
	                    title: 'Smart Set';
	                    owner: self;
	                    appendItem: 'By ~Z-Order' selector: #setByZOrder acceleratorString: '';
	                    appendItem: 'By ~Column Major Order' selector: #setByColumnMajorOrder acceleratorString: '';
	                    appendItem: 'By ~Row Major Order' selector: #setByRowMajorOrder acceleratorString: ''
	            );
	            appendSeparator;
	            appendItem: '~Clear All	Alt+C' selector: #clearAll acceleratorString: 'Alt+C';
	            appendItem: '~Reset' selector: #reset acceleratorString: '';
	            appendSeparator;
	            appendItem: 'Re~verse' selector: #reverseOrder acceleratorString: '';
	            appendSeparator;
	            appendItem: 'Exit	Alt+F4' selector: #ok acceleratorString: 'Alt+35'
	    );
	    addMenu: (
	        Menu new
	            title: '~Groups';
	            owner: self;
	            appendItem: '~Add	Alt+A' selector: #addGroup acceleratorString: 'Alt+A';
	            appendItem: '~Remove	Alt+R' selector: #removeGroup acceleratorString: 'Alt+R';
	            appendSeparator;
	            appendItem: '~Create All' selector: #createAllGroups acceleratorString: '';
	            appendSeparator;
	            appendItem: '~Include Outer' selector: #includeOuter acceleratorString: ''
	    )! !

!WBModelInstVar methods !
initialized

    ^initialized! !

!WBGeometryManager methods !
moveByPixelDown
    "Move the selected widgets down one pixel"

    | selections |
    (selections := self selections copy) isEmpty
        ifTrue: [^self owner setWindowPosition: (self shell x @ (self shell y + 1))].
    (self undoManager
        add: 'Move Pixel Down'
        undo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    moveWidget: aWidget x
                    y: (aWidget y up: 1);
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections]
        redo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    moveWidget: aWidget x
                    y: (aWidget y down: 1);
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections])
        redoAction value.
    self updateWidget.! !

!PEntryFieldGroup methods !   
children: aCollection

    children := aCollection! !

!WBLayoutForm methods !
isCurrentLayoutForm

    ^self model notNil and: [self model layoutForm == self]! !

!WBCreateClassDialog methods !   
cancel

    newClass := nil.
    self close.! !

!WindowBuilder methods !
isOkToOpen: aClass
	"Trigger the event and check the responces."

	| answer |
	self triggerEvent: #aboutToOpen: with: aClass.
	answer := (self propertyAt: #abortOpen) ~= true.
	self propertyAt: #abortOpen put: nil.
	^answer! !

!WBCallOutModule methods !   
generatePane
        "Private - Generate the pane definition."

    self stream
        cr; cr;
        indentBy: 1;
        openParenthesis;
        nextPutAll: (self varNameFor: self object);
        nextPutAll: ' := ';
        nextPutAll: self object realClass name;
        space;
        nextPutAll: #new;
        closeParenthesis; cr;
        nextPutAll: #definedIn:; space;
        nextPut: $#; nextPutAll: self object creationMethodSelector;
        endMessage.
    self
        generatePaneOwner: self object;
        generatePaneName: self object;
        generatePaneClipStyle: self object;
        generatePaneBody: self object.
    self stream
        endExpression;
        indentBy: -1; cr;
        nextPut: $^;
        nextPutAll: (self varNameFor: self object)! !

!WBTabPosition methods ! 
inGroup

    ^groupPosition notNil! !

!WBModelCodeModule methods !   
cleanup

    (toBeRemoved isNil or: [toBeRemoved isEmpty])
        ifTrue: [^self].
    toBeRemoved do: [:symbol |
        ((self instVars first okToGenerateMethod: symbol)
            and: [self targetClass includesSelector: symbol asSymbol])
            ifTrue: [self targetClass removeSelector: symbol asSymbol]].
    ((toBeRemoved includes: #constructEventsTriggered)
        and: [self instVars first okToGenerateEventsTriggered
        and: [self targetClass class includesSelector: #constructEventsTriggered]])
        ifTrue: [self targetClass class removeSelector: #constructEventsTriggered].! !

!WBNLSSubPool methods !
fileOut: anAssociation on: aStream
	"File out the specified key/value pair."

	self stringDictionaryReaderClass
		fileOutToken: anAssociation key
		value: anAssociation value
		indent: 4
		on: aStream.! !

!WBGeometryManager methods !   
statusPaneHelp: aKey
	"Answer the default dictionary used by
    the status bar for help support"

	^self owner statusPaneHelp: aKey! !

!WBCreateMenuModule methods !  
menu: aMenuDefinition
		"Set the receiver's menu definition."
	menu := aMenuDefinition.! !

!WindowBuilder methods !  
menuFileOpen

    self confirmSaveChanges
        ifTrue: [self editClass: (self getEditedClass ifNil: [^nil])].! !

!WBTabOrderLayoutForm methods ! 
initializeFonts

	"
	largeFont := Font face: 'Helv' size: 8@18 fixedWidth: true attributes: 0.
	smallFont := Font face: 'Helv' size: 5@10 fixedWidth: false attributes: 0.
	"
	largeFont := SysFont.
	smallFont := WBDevelopmentWindow editorFont.! !

!WindowBuilder methods !  
menuOptionsAutoSize

    self class togglePropertyValueAt: #AutoSize.
    self updateMenuOptions.! !

!PWBStaticGraphic methods !
styles
    ^#(#fixedSize #stretchToFit)! !

!LayoutFrame methods ! 
printOn: aStream

	| stream |
	stream := WBCodeStream new.
	self storeOn: stream indentString: ''.
	aStream nextPutAll: stream contents.! !

!PDrawnButton methods !   
usesTitle

    ^self style ~= #invisible! !

!WBCompositePaneScratchWindow class methods !
isWBInternalClass

    ^true! !

!WindowBuilder class methods !   
companyNamePrim
	"Answer the window builder company's name."

	^self editorClass
		propertyValueAt: #CompanyName
		category: self userPropertyString.! !

!PRadioButtonGroup methods ! 
label: aString

	label := aString.
	self children isEmpty
		ifFalse: [self children first contents: aString]! !

!WBToolBarEditor methods ! 
activated

    | element selection bitmaps |
    self getBitmaps: (bitmaps := self paneNamed: 'bitmaps').
    (selection := list selection) isNil ifTrue: [ ^nil ].
    (element := elements at: selection) isNil ifTrue: [ ^nil ].
    bitmaps selectItem: element bitmapSelector asString.! !

!WBTreeNode methods !
parent: aNode

    parent removeChild: self.
    aNode addChild: self.! !

!PCompositePane methods ! 
usesMenu

    ^true! !

!PGraphPane methods ! 
genReceiveWindowMessagesOn: aStream indentString: spaceString
    "Don't generate method for GraphPanes"! !

!WBOutboardWindow methods !   
outboards

	^self owner outboards! !

!WindowBuilder class methods !  
addToolbarTool

	| class |
	class := Smalltalk at: #MDISystem ifAbsent: [nil].
	class notNil
		ifTrue: [class addExtraTool: self toolBarTool].
	! !

!StandardWindowPolicy methods !  
addWindowBuilderMenu
	"Private - WBPro Development.
	 Add WindowBuilder menu to the menu bar."

	#addedByOSI.
	(Smalltalk includesKey: #WindowBuilder) ifFalse: [^self].
	window menuWindow addMenu: self wbEditorClass windowBuilderMenu.! !

!WBBitmapSubPool methods ! 
fileOutFooterOn: aStream
	"File out the receiver's footer."

	aStream
		nextPutAll: self managerClass tagEnd;
		cr.! !

!WBScrapbookRetrieve methods ! 
displayImage: aPane

    | aPage mergeRect centerPoint offset |
    aPane doGraphics: [
        aPane
            backColor: aPane class defaultBackColor;
            erase].
    chapter isNil | page isNil ifTrue: [^nil].
    aPage := (scrapbook at: self owner chapter) at: page.
    aPage isArray ifTrue: [aPage := aPage first].
    centerPoint := aPane rectangle center.
    mergeRect := aPage first rect.
    aPage do: [:pObject | mergeRect := mergeRect merge: pObject rect].
    offset := centerPoint leftAndUp: mergeRect center.
    aPage do: [:pObject | pObject rect moveBy: offset].
    aPane doGraphics: [
        aPage do: [:pObject |
            aPane
                backColor: aPane class defaultBackColor;
                foreColor: aPane class defaultForeColor.
            pObject isNil
                ifFalse: [
                    pObject isCompositePane ifTrue: [pObject realClass: pObject realClass].
                    pObject displayWith: aPane pen clipRect: aPane rectangle]]].! !

!WBLookPolicyWin31 methods !   
rightJustification

    ^"SsRight" 2! !

!WBCodeStream methods !  
nextPut: aCharacter
		"Append aCharacter to the code stream."
	self checkEnd.
	(self isSpaceOnLine: 1) ifFalse: [ self cr ].
	stream nextPut: aCharacter.! !

!WBEditClassDialog class methods !
filter

    ^Filter ifNil: [Filter := self filterList first]! !

!PRadioButtonGroup methods ! 
label

	^label ifNil: [label := 'RadioButtonGroup']! !

!WBAboutDialog methods !  
preInitWindow

    super preInitWindow.
    self shouldInitTranscript ifTrue: [WindowBuilder promptForUserInfo].! !

!WBEventManagerWindow class methods !   
widgetFilters
	"Answer a dictionary mapping strings to filter selectors."

	^widgetFilters ifNil: [
		widgetFilters := self defaultWidgetFilters]! !

!WBClassDefinition methods !  
className
		"Answer the name of the class."
	^self classField name! !

!PButtonListBox methods !  
displayWith: aPen clipRect: clipRect
    | list newPoint region innerRect checkBitmap buttonOffset stringOffset imageOffset |
    innerRect := self lookPolicy
        displayWithRightScrollBar: aPen
        rect: self rect
        backColor: self backColor.
    "Draw the list contents"
    (list := self contents) isNil
        ifFalse: [
            aPen
                foreColor: self foreColor;
                backColor: self backColor;
                font: self font.
            region := aPen setClipRect: (innerRect intersect: clipRect).
            newPoint := innerRect leftTop.
            checkBitmap := ButtonListBox buttonImages first.
            buttonOffset := (self font height - checkBitmap height + 1) // 2.
            stringOffset := checkBitmap width + (buttonOffset * 2).
            self useImages
                ifTrue: [
                    imageOffset := stringOffset @ buttonOffset.
                    stringOffset := stringOffset right: (16 + (buttonOffset * 2))].
            1 to: list size do: [:i |
                aPen
                    copyBitmap: checkBitmap
                        from: checkBitmap boundingBox
                        at: (newPoint rightAndDown: buttonOffset + (checkBitmap extent * Rectangle leftTopUnit)).
                imageOffset isNil
                    ifFalse: [
                        aPen
                            backColor: Color darkGray;
                            rectangleFilled: ((newPoint rightAndDown: imageOffset + 2) extentFromLeftTop: checkBitmap extent - 2);
                            backColor: Color red;
                            rectangleFilled: ((newPoint rightAndDown: imageOffset) extentFromLeftTop: checkBitmap extent - 2);
                            backColor: Color black;

                            "ellipse: ((newPoint rightAndDown: imageOffset + 2) extentFromLeftTop: checkBitmap extent - 6);"

                            backColor: self backColor].
                aPen displayText: (list at: i) at: (newPoint right: stringOffset).
                newPoint := newPoint down: aPen font height].
            aPen destroyRegion: region].
    self propertyAt: #stringOffset put: stringOffset.! !

!WBGraphicObject methods ! 
maxSize

    ^32000@32000! !

!PLinkButton methods !  
link: aString

    link := aString! !

!WBGeometryManager methods !   
copySelections

    self hasSelections
        ifTrue: [
            self clipboard: self selectionsInZorder.
            self owner updatePasteButton].! !

!WBModelDefinitionEditor methods !
newModel

	| modelTypes modelType result |
	modelType := (modelTypes := self paneNamed: 'modelTypes') selectedItem.
	modelType := (modelType == #ViewManager or: [modelType == #ApplicationCoordinator])
		ifTrue: ['Window']
		ifFalse: [
			(modelType == #WindowDialog or: [modelType == #DialogCoordinator])
				ifTrue: ['Dialog']
				ifFalse: [
					modelType == #CompositePane
						ifTrue: ['CompositePane']
						ifFalse: ['EventManager']]].
	(result := (self wbEditorClass wbCreateClassDialog new forWindowType: modelType) result) notNil
		ifTrue: [
			self codeGenerator generateCodeUsing:
				(WBVersionCodeModule new targetClass: result).
			modelTypes selectItem: (self modelTypeList reversed detect: [:type |
				result inheritsFrom: (Smalltalk at: type)] ifNone: [nil]).
			self loadModels.
			models selectItem: result.
				self select: result].! !

!ControlPane methods !  
isATabStopPrim
	"Private - WindowBuilder Pro Development.
		Answer true if the receiver is a tabstop"

	#addedByOSI.
	^self hasStyle: WsTabstop! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowFrameObject methods !  
style

	| propertyManager |
	^style ifNil: [
		propertyManager := self wbRealWidget wbPropertyManager.
		style := OrderedCollection new.
		self realStyleNames associationsDo: [:each |
			(propertyManager
				getProperty: each value
				for: self wbRealWidget
				ifAbsent:[false])
					ifTrue: [style add: each key]].
		style]! !

!WBInterfaceObject methods ! 
creationMethodSelector: aSymbol
		"Set the selector of the creation method (like #createViews)."
	creationMethodSelector := aSymbol.! !

!WBFontManagerWindow methods !   
menuOptionPortableFileOut

	[self poolManager generatePortableFontCode: true]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].
	self updateOptionMenu.! !

!WBEventManagerWindow methods !
eventList

    ^eventListBox contents! !

!WBFontSelectionWindow methods !
fontSelected: selectedItem pane: aPane

	"Callback for the #changed: event in fontList [ListBox].
		(Generated by WindowBuilder Pro)"

	self selectedFont: selectedItem value.
	self dirty: true.! !

!WBUndoManager methods !
undoableActions

    ^undoList copyFrom: 1 to: current! !

!WBCodeGenerator methods ! 
forceUpdate

    ^(self propertyAt: #forceUpdate) == true! !

!WBClassDefinition methods !
classVarNamesString
		"Answer the receiver's class  variables as a string."
	| stream |
	stream := WriteStream on: (String new: 20).
	self classVarNames
		do: [ :eachName | stream nextPutAll: eachName ]
		andBetweenDo: [ stream space ].
	^stream contents! !

!WBMenuEditor methods !   
action

    "Link this menu option to an action"

    | item list itemIndex |

    list := menuItemsEditor contents asFlatList.
    itemIndex := menuItemsEditor selection.
    list size < itemIndex ifTrue: [
        ^self
    ].
    item := list at: itemIndex.

    WBActionEditor new openOn: item.

    self fillInCurrentItem.! !

!PEnhancedEntryField methods !   
case: aSymbol

    case := aSymbol! !

!WBTemplateEditor methods !
initWindow

	(self paneNamed: 'sizeButton')
		contents: (WBSizeSysBitmap handle; yourself).
	self sizeLabel font: self editorFont.
	self 
		loadList;
		updateFields.! !

!PropertyAccessor methods !
wbDefaultStoreAction

	^nil! !

!WBLayoutFrameEditor methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| afterLabel applyButton attachGroup beforeLabel 
	bottomAttachLabel button1 exampleGroup leftAttachLabel 
	mainView okButton rightAttachLabel toolBar1 toolBar2 
	topAttachLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	bottomAttachField := WBComboBox new.
	exampleAfter := WBFramerExample new.
	exampleBefore := WBFramerExample new.
	leftAttachField := WBComboBox new.
	rightAttachField := WBComboBox new.
	topAttachField := WBComboBox new.
	
		"Temporary Variables"
	afterLabel := StaticText new.
	applyButton := Button new.
	attachGroup := GroupBox new.
	beforeLabel := StaticText new.
	bottomAttachLabel := StaticText new.
	button1 := Button new.
	exampleGroup := GroupBox new.
	leftAttachLabel := StaticText new.
	okButton := Button new.
	rightAttachLabel := StaticText new.
	toolBar1 := WBToolBar new.
	toolBar2 := WBToolBar new.
	topAttachLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		removeMinimizeButtonStyle;
		removeMaximizeButtonStyle;
		removeSizingBorderStyle;
		addBorderStyle;
		labelWithoutPrefix: 'Framing Editor';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -104 * xDU;
				topRatio: 1/2; topInset: -159/2 * yDU;
				rightRatio: 1/2; rightInset: -104 * xDU;
				bottomRatio: 1/2; bottomInset: -141/2 * yDU).
	self addView: mainView.
	
	leftAttachField "WBComboBox"
		owner: self;
		setName: 'leftAttachField';
		when: #clicked: send: #leftAttachSelected: to: self;
		when: #textChanged: send: #leftAttachSelected: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 38 * xDU;
				topRatio: 0; topInset: 50 * yDU;
				rightRatio: 0; rightInset: -110 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		dropDown;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont;
		contents: #( 'Window left' 'Window center' 'Window right' 'Proportional' ).
	mainView
		addSubpane: leftAttachField;
		subPaneWithFocus: leftAttachField.
	
	topAttachField "WBComboBox"
		owner: self;
		setName: 'topAttachField';
		addClipsiblingsStyle;
		when: #clicked: send: #topAttachSelected: to: self;
		when: #textChanged: send: #topAttachSelected: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 38 * xDU;
				topRatio: 0; topInset: 66 * yDU;
				rightRatio: 0; rightInset: -110 * xDU;
				bottomRatio: 0; bottomInset: -116 * yDU);
		dropDown;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont;
		contents: #( 'Window top' 'Window center' 'Window bottom' 'Proportional' ).
	mainView addSubpane: topAttachField.
	
	rightAttachField "WBComboBox"
		owner: self;
		setName: 'rightAttachField';
		addClipsiblingsStyle;
		when: #clicked: send: #rightAttachSelected: to: self;
		when: #textChanged: send: #rightAttachSelected: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 38 * xDU;
				topRatio: 0; topInset: 82 * yDU;
				rightRatio: 0; rightInset: -110 * xDU;
				bottomRatio: 0; bottomInset: -132 * yDU);
		dropDown;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont;
		contents: #( 'Window left' 'Window center' 'Window right' 'Proportional' 'Pane left' ).
	mainView addSubpane: rightAttachField.
	
	bottomAttachField "WBComboBox"
		owner: self;
		setName: 'bottomAttachField';
		addClipsiblingsStyle;
		when: #clicked: send: #bottomAttachSelected: to: self;
		when: #textChanged: send: #bottomAttachSelected: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 38 * xDU;
				topRatio: 0; topInset: 98 * yDU;
				rightRatio: 0; rightInset: -110 * xDU;
				bottomRatio: 0; bottomInset: -124 * yDU);
		dropDown;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont;
		contents: #( 'Window top' 'Window center' 'Window bottom' 'Proportional' 'Pane top' ).
	mainView addSubpane: bottomAttachField.
	
	applyButton "Button"
		owner: self;
		setName: 'applyButton';
		when: #clicked send: #apply to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 120 * yDU;
				rightRatio: 0; rightInset: -38 * xDU;
				bottomRatio: 0; bottomInset: -135 * yDU);
		contents: 'Apply';
		startGroup;
		font: SysFont.
	mainView addSubpane: applyButton.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		addClipsiblingsStyle;
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 42 * xDU;
				topRatio: 0; topInset: 120 * yDU;
				rightRatio: 0; rightInset: -76 * xDU;
				bottomRatio: 0; bottomInset: -135 * yDU);
		defaultPushButton;
		contents: 'OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: okButton.
	
	button1
		owner: self;
		addClipsiblingsStyle;
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 80 * xDU;
				topRatio: 0; topInset: 120 * yDU;
				rightRatio: 0; rightInset: -114 * xDU;
				bottomRatio: 0; bottomInset: -135 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: button1.
	
	toolBar1 "WBToolBar"
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -114 * xDU;
				bottomRatio: 0; bottomInset: -18 * yDU);
		postAutomatic;
		startGroup;
		noTabStop;
		font: SysFont;
		useSystem: true;
		fontExtent: (7/16) @ (1/2);
		add: WBFramingAttachLeftTopSysBitmap selector: #attachLeftTop;
		add: WBFramingAttachRightTopSysBitmap selector: #attachRightTop;
		add: WBFramingAttachLeftBottomSysBitmap selector: #attachLeftBottom;
		add: WBFramingAttachRightBottomSysBitmap selector: #attachRightBottom;
		add: WBFramingAttachLeftTopRightSysBitmap selector: #attachLeftTopRight;
		add: WBFramingAttachLeftBottomRightSysBitmap selector: #attachLeftBottomRight;
		add: WBFramingAttachLeftTopBottomSysBitmap selector: #attachLeftTopBottom;
		add: WBFramingAttachRightTopBottomSysBitmap selector: #attachRightTopBottom.
	mainView addSubpane: toolBar1.
	
	leftAttachLabel "StaticText"
		owner: self;
		setName: 'leftAttachLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 52 * yDU;
				rightRatio: 0; rightInset: -36 * xDU;
				bottomRatio: 0; bottomInset: -60 * yDU);
		rightJustified;
		contents: 'Left:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: leftAttachLabel.
	
	topAttachLabel "StaticText"
		owner: self;
		setName: 'topAttachLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 68 * yDU;
				rightRatio: 0; rightInset: -36 * xDU;
				bottomRatio: 0; bottomInset: -76 * yDU);
		rightJustified;
		contents: 'Top:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: topAttachLabel.
	
	rightAttachLabel "StaticText"
		owner: self;
		setName: 'rightAttachLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 84 * yDU;
				rightRatio: 0; rightInset: -36 * xDU;
				bottomRatio: 0; bottomInset: -92 * yDU);
		rightJustified;
		contents: 'Right:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: rightAttachLabel.
	
	bottomAttachLabel "StaticText"
		owner: self;
		setName: 'bottomAttachLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 100 * yDU;
				rightRatio: 0; rightInset: -36 * xDU;
				bottomRatio: 0; bottomInset: -108 * yDU);
		rightJustified;
		contents: 'Bottom:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: bottomAttachLabel.
	
	exampleAfter "WBFramerExample"
		owner: self;
		setName: 'exampleAfter';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 247/2 * xDU;
				topRatio: 0; topInset: 159/2 * yDU;
				rightRatio: 0; rightInset: -395/2 * xDU;
				bottomRatio: 0; bottomInset: -263/2 * yDU);
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: exampleAfter.
	
	exampleBefore "WBFramerExample"
		owner: self;
		setName: 'exampleBefore';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 247/2 * xDU;
				topRatio: 0; topInset: 47/2 * yDU;
				rightRatio: 0; rightInset: -359/2 * xDU;
				bottomRatio: 0; bottomInset: -135/2 * yDU);
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: exampleBefore.
	
	afterLabel "StaticText"
		owner: self;
		setName: 'afterLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 122 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 0; rightInset: -144 * xDU;
				bottomRatio: 0; bottomInset: -78 * yDU);
		contents: 'After:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: afterLabel.
	
	beforeLabel "StaticText"
		owner: self;
		setName: 'beforeLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 122 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -150 * xDU;
				bottomRatio: 0; bottomInset: -22 * yDU);
		contents: 'Before:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: beforeLabel.
	
	toolBar2 "WBToolBar"
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 22 * yDU;
				rightRatio: 0; rightInset: -74 * xDU;
				bottomRatio: 0; bottomInset: -36 * yDU);
		postAutomatic;
		startGroup;
		noTabStop;
		font: SysFont;
		useSystem: true;
		fontExtent: (7/16) @ (1/2);
		add: WBFramingAttachAllSysBitmap selector: #attachAll;
		add: WBFramingAttachPercentSysBitmap selector: #attachPercent;
		add: WBFramingAttachLeftTop2SysBitmap selector: #attachProportionalLeftTop;
		add: WBFramingAttachLeftTopRight2SysBitmap selector: #attachProportionalLeftTopRight;
		add: WBFramingAttachLeftBottomRight2SysBitmap selector: #attachProportionalLeftBottomRight.
	mainView addSubpane: toolBar2.
	
	exampleGroup "GroupBox"
		owner: self;
		setName: 'exampleGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 239/2 * xDU;
				topRatio: 0; topInset: 3/2 * yDU;
				rightRatio: 0; rightInset: -403/2 * xDU;
				bottomRatio: 0; bottomInset: -271/2 * yDU);
		contents: 'Resizing example';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: exampleGroup.
	
	attachGroup "GroupBox"
		owner: self;
		setName: 'attachGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 38 * yDU;
				rightRatio: 0; rightInset: -114 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		contents: 'Attachment';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: attachGroup! !

!WBKeyEntryField methods !
wmGetdlgcode: wParam with: lParam

    ^DlgcWantmessage! !

!WBActionEditor methods ! 
compilerError: errorMessage
        at: sourcePosition
        in: sourceCode
        for: aClass

    | offset methodPane |
    offset := (methodPane := self paneNamed: 'method') propertyAt: #offset.
    methodPane
        selectFrom: sourcePosition - offset to: sourcePosition - offset;
        insertAfterSelection: errorMessage;
        sendInputEvent: #setFocus! !

!WBLookPolicyWin95 methods !   
drawCloseButtonWith: aPen at: aRect

    | innerRect |
    innerRect := self
        drawTitleBarBoxWith: aPen
        at: aRect.
    aPen
        foreColor: Color black;
        lineFrom: (innerRect leftTop rightAndDown: 3@2) to: (innerRect rightBottom leftAndUp: 3@2 + Rectangle leftTopUnit y);
        lineFrom: (innerRect leftTop rightAndDown: 4@2) to: (innerRect rightBottom leftAndUp: 2@2 + Rectangle leftTopUnit y);
        lineFrom: (innerRect leftBottom rightAndUp: 3@3) to: (innerRect rightTop leftAndDown: 3@1 + Rectangle leftTopUnit y);
        lineFrom: (innerRect leftBottom rightAndUp: 4@3) to: (innerRect rightTop leftAndDown: 2@1 + Rectangle leftTopUnit y)! !

!WBScratchWindow class methods !   
isWBInternalClass

    ^true! !

!WBTreeNode methods !
parent: aNode positioningAfter: sibling

    parent removeChild: self.
    aNode addChild: self afterNode: sibling.! !

!WBPMenuItem methods !   
accelBits

    keyAccel isNil ifTrue: [ ^nil ].

    ^keyAccel accelBits! !

!MenuWindow methods !  
asWBPMenu
        "Private - WBPro Development."
    | mw |
    #addedByOSI.
    mw :=  WBPMenu new.
    menus do: [ :m |
        mw addChild: m asPMenuItem.
    ].

    mw updateListStrings.

    ^mw! !

!WBLayoutForm methods ! 
moveBand: aPoint
    "Move the outline band by aPoint."

    self bandRect: (aPoint extentFromLeftTop: self bandRect extent).! !

!WBActionEditor methods !  
newName: aString

    aString isEmpty ifTrue: [
        self getAuthor: (self paneNamed: 'authorField').
        (self paneNamed: 'add')
            contents: '&Add';
            disable
    ] ifFalse: [(WBAction listActions includes: aString) ifTrue: [
        changed ifTrue: [
            self getAuthor: (self paneNamed: 'authorField').
            (self paneNamed: 'add')
                contents: '&Change';
                enable
        ] ifFalse: [
            (self paneNamed: 'authorField') setContents: author.
            (self paneNamed: 'add')
                contents: '&Change';
                disable
        ].
    ] ifFalse: [
        self getAuthor: (self paneNamed: 'authorField').
        (self paneNamed: 'add')
            contents: '&Add';
            enable
    ]].! !

!WBLayoutForm methods !   
allowMove: aBoolean
    "Set the value of allowMove."

    allowMove := aBoolean.! !

!Object methods !  
isInstVar: aBoolean
        "Set true if the receiver is referenced by an instance variable."

    self propertyAt: #isInstVar put: aBoolean.! !

!WBPropertyDescriptor methods !
printOn: aStream indent: indentString

    super printOn: aStream indent: indentString.
    aStream
        cr; tab; nextPutAll: indentString; nextPutAll: 'default: '; nextPutAll: default printString; nextPut: $;;
        cr; tab; nextPutAll: indentString; nextPutAll: 'category: '; nextPutAll: category printString; nextPut: $;.

    self resourceValues isNil
        ifTrue: [aStream cr; tab; nextPutAll: indentString; nextPutAll: 'resourceValues: nil;']
        ifFalse: [
            aStream cr; tab; nextPutAll: indentString; nextPutAll: 'resourceValues: (IdentityDictionary new'.
            self resourceValues keysDo: [:key |
                aStream cr; tab; tab; nextPutAll: 'at: '; nextPutAll: key printString; nextPutAll: ' put: ('.
                (self resourceValues at: key) printOn: aStream indent: indentString, (String with: Character wbTab with: Character wbTab).
                aStream nextPutAll: ');'].
            aStream cr; tab; tab; nextPutAll: indentString; nextPutAll: 'yourself);'].

    aStream cr; tab; nextPutAll: indentString; nextPutAll: 'yourself'! !

!WindowBuilder methods !   
setWindowPosition: aPoint

    self shell rect: (aPoint extent: self shell rect extent).
    self shell framingBlock: (
		LayoutFrame new
			leftInset: aPoint x;
			topInset: aPoint y).
    self setSizeAndPositionForWidgets: self shell rect.! !

!WBAbstractPrompter class methods !
prompt: promptString title: titleString list: aCollection default: defaultObject
	"Prompt for an entry in a list."

	^self new
		createViews;
		list: aCollection;
		default: defaultObject;
		prompt: promptString;
		title: titleString;
		open;
		result! !

!PComboBox methods !  
hitRect

	style == #simpleList
		ifTrue: [^super hitRect].
	^rect leftTop extentFromLeftTop: rect width @ (self font height + 8)! !

!WBHandle methods !
displayHollowOn: aPen color: color

    self displayOn: aPen color: Color white.
    aPen foreColor: color.
    aPen drawRectangle: self displayBox.! !

!WBPoolManagerWindow methods ! 
categoryMenu

	^self menuTitled: 'Category'! !

!Object class methods !   
wbTestOpenIn: aRectangle
	"Open a new instance of the receiver."

	self open.! !

!WBLayoutWizard class methods !
menuDefinitions: aDictionaryOfMenus

    MenuDefinitions := aDictionaryOfMenus! !

!WBChoosePaneDialog class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBHandle class methods !
on: aFigure at: aSymbol with: anArgument

     ^self new setLocator: (WBLocator on: aFigure at: aSymbol with: anArgument)! !

!WBStyleEditor methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| applyButton cancelButton mainView multipleSelectListBox1 
	okButton xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	applyButton := Button new.
	cancelButton := Button new.
	multipleSelectListBox1 := MultipleSelectListBox new.
	okButton := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Style Editor';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -97 * xDU;
				topRatio: 1/2; topInset: -157/2 * yDU;
				rightRatio: 1/2; rightInset: -97 * xDU;
				bottomRatio: 1/2; bottomInset: -139/2 * yDU).
	self addView: mainView.
	
	multipleSelectListBox1
		owner: self;
		when: #changed: send: #styleChanged:pane: to: self withArgument: multipleSelectListBox1;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 45/2 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: multipleSelectListBox1;
		subPaneWithFocus: multipleSelectListBox1.
	
	applyButton "Button"
		owner: self;
		setName: 'applyButton';
		when: #clicked send: #apply to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -114 * xDU;
				topRatio: 1; topInset: -37/2 * yDU;
				rightRatio: 1; rightInset: 80 * xDU;
				bottomRatio: 1; bottomInset: 7/2 * yDU);
		contents: 'Apply';
		startGroup;
		font: SysFont.
	mainView addSubpane: applyButton.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -76 * xDU;
				topRatio: 1; topInset: -37/2 * yDU;
				rightRatio: 1; rightInset: 42 * xDU;
				bottomRatio: 1; bottomInset: 7/2 * yDU);
		defaultPushButton;
		contents: 'OK';
		noTabStop;
		font: SysFont.
	mainView addSubpane: okButton.
	
	cancelButton "Button"
		owner: self;
		setName: 'cancelButton';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -38 * xDU;
				topRatio: 1; topInset: -37/2 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 7/2 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		noTabStop;
		font: SysFont.
	mainView addSubpane: cancelButton! !

!WBCreateBitmap class methods ! 
lastBitmapType: aSymbol

	^lastBitmapType := aSymbol! !

!WBLookPolicyWin95 methods ! 
drawCheckBox: aCheckBox with: aPen clipRect: clipRect

    | aPoint iconRect |
    self
        drawToggle: aCheckBox
        with: aPen
        clipRect: clipRect.
    aPoint := aCheckBox rect left @ (aCheckBox rect center y up: self iconExtent y // 2).
    self
       displayWithMinorBorder: aPen
        rect: (iconRect := aPoint extentFromLeftTop: self iconExtent)
        backColor: aCheckBox backColor.
    aPen fill: (iconRect insetBy: 2) color: Color white! !

!WindowBuilder methods !  
popupGridSize: aPane

	| selection labels gridLabel menu |
	labels := #('Grid Off' '2 x 2' '3 x 3' '4 x 4' '5 x 5' '6 x 6' '8 x 8' '10 x 10').
	gridLabel := self gridSize x.
	gridLabel = 1
		ifTrue: [gridLabel := 'Grid Off']
		ifFalse: [gridLabel := gridLabel asString , ' x ' , gridLabel asString].
	(menu := Menu new
			labels: labels
			lines: #(1)
			selectors: labels) checkItem: gridLabel.
	"aPane setPopupMenu: menu."
	Notifier consumeInputUntil: [:event |
			event selector = #button2Up:].
	selection := menu popUpIn: aPane.
	aPane setPopupMenu: nil.
	selection isNil ifTrue: [^nil].
	(gridLabel := selection upTo: 'x') = 'Grid Off'
		ifTrue: [
			self
				drawGrid: false;
				gridSize: 1 @ 1]
		ifFalse: [self gridSize: gridLabel asInteger @ gridLabel asInteger].! !

!WBPoolManagerWindow methods ! 
addEditorCompositePaneTo: aModel

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	
	(editorCompositePane := WBPoolEditorCompositePane new)
		definedIn: #addEditorCompositePaneTo:;
		owner: aModel;
		setName: 'editorCompositePane';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 2 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 3 * yDU);
		startGroup.
	^editorCompositePane! !

!WindowBuilder class methods !
promptForUserInfo
	"Open the dialog asking for user's name/company/serial#."

	WBUserInfoDialog new open.! !

!PropertyManager methods ! 
wbEventNamed: eventName ifAbsent: aBlock
	"Answer the event definition."

	#addedByOSI.
	^self wbEventsForEdit
		associationAt: eventName
		ifAbsent: [
			metaProperties isNil
				ifTrue: [aBlock value]
				ifFalse: [
					metaProperties
						wbEventNamed: eventName
						ifAbsent: aBlock]]! !

!WBScrapbookStore methods !
cancel

	Notifier isAltKeyDown
		ifTrue: [^self wbEditorClass scrapbook inspect].
	self close! !

!WBAbstractPrompter methods ! 
listField

	^self paneNamed: 'list'! !

!WBCreateBitmap methods ! 
bitmapWidth

	^widthField contents asInteger! !

!WBTargetObject methods !
constructInstVarMapFor: aClass

	| answer avoid names allPlaceHolders |
	answer := Dictionary new.
	avoid := aClass wbReservedInstVarNames.
	names := aClass allInstVarNames.
	allPlaceHolders := invalidInstVars copy.
	instVarMap associationsDo: [:each |
		each value isWBInstVarObject ifTrue: [
			allPlaceHolders add: each]].
	(Array with: self prototype shell),
		self prototype children, self prototype modelObjects
	do: [:each |
		(each isInstVar and: [(avoid includes: each paneName) not]) ifTrue: [
			answer at: each paneName put: each]].
	names do: [:each |
		(avoid includes: each) ifFalse: [
			answer at: each ifAbsentPut: [
				allPlaceHolders at: each ifAbsent: [
					WBInstVarObject new
						owner: self;
						name: each;
						yourself]]]].
	^answer! !

!WBBitmapManager class methods !  
convertBitmapsFromModuleToImage
		"Convert all bitmaps that are loaded from a module (resource DLL)
			to bitmaps that are stored in the image."
		"
		To convert ALL window builder bitmaps, evaluate
			WBBitmapManager convertBitmapsFromModuleToImage.

		To convert the window builder SYSTEM bitmaps, evaluate
			WBBitmapManager system convertBitmapsFromModuleToImage.

		To convert the window builder USER bitmaps, evaluate
			WBBitmapManager current convertBitmapsFromModuleToImage.
		"

	self managers do: [:each | each convertBitmapsFromModuleToImage].! !

!WBAbstractCodeModule methods !   
targetClassDefinition
		"Answer the target class definition."
	^targetClassDefinition ifNil: [
		targetClassDefinition := self classDefinitionFor: self targetClass ]! !

!WBTreeNode methods !  
addChild: aChild  beforeNode: aNode

    children add: aChild before: aNode.
    aChild setParent: self.! !

!WBLayoutFrameEditor methods !  
rightAttachSelected: selectedItem

	"Callback for the #clicked: event in rightAttachField [WBComboBox].
		(Generated by WindowBuilder Pro)"

	self
		setRightAttach: selectedItem;
		updateFramingBlocks;
		updateExample;
		dirty: true.! !

!WindowBuilder methods ! 
menuOptionsUseGrid

	self class togglePropertyValueAt: #UseGrid.
	self updateOptionsMenu.! !

!PDrawnButton methods !
readSpecificsFrom: aWidget

	self contents:
		(aWidget cpContents isString
			ifTrue: [aWidget cpContents]
			ifFalse: ['']).
	aWidget drawSelector = #isotropic: ifTrue: [style := #fixedSize].
	aWidget drawSelector = #anisotropic: ifTrue: [style := #stretchToFit].
	aWidget drawSelector = #invisible: ifTrue: [style := #invisible].
	style isNil
		ifTrue: [style := self styles first].! !

!WBCodeGenerator methods !   
createMethods
		"Private - Compile and save the code."
	modules
		do: [ :eachClassModules |
			eachClassModules
				do: [ :eachModule |
					eachModule createMethod = false ifTrue: [
						self createMethodsError: eachModule]]].! !

!WBApplicationCoordinatorMenuModule class methods ! 
defaultMessageSelector
        "Private - Answer the default message selector."
    ^#buildMenus:forModel:! !

!WBXoteryXCodePolicy methods ! 
basicCompileMethodFor: aCodeModule
		"Private - Compile and store the method.
			Answer an association with key = selector and value = compiled method
			if sucessful, else answer nil."
	^aCodeModule targetClass compile: aCodeModule sourceString! !

!WindowBuilder methods !  
confirmSaveChanges

    | answer |
    self isDirty
        ifTrue: [
            (answer := MessageBox
                yesNoCancelTitled: 'Save Changes?'
                text: 'Save Changes to: [',(self classNameFor: self editedClass),']?') isNil
                ifTrue: [^false].
            answer == #yes
                ifTrue: [
                    self menuFileSave isNil
                        ifTrue: [^false]]].
    ^true! !

!WBPrototype methods !
shell: aFrameObject

	shell := aFrameObject! !

!WBLayoutForm methods !   
selectionOrigin
    "Answer the origin, in local coordinates, of the selected pane.  Assumes
     one pane is selected."

    ^self shell frameContentRect leftTop distanceRightAndDown: self selections first rect leftTop! !

!WBFontEditorCompositePane class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!PDrawnButton methods !  
usesColor

    ^Smalltalk platformIsOS2! !

!WBPoolManagerWindow methods !
showActiveCategory

	| pane listBox |
	(listBox := self paneNamed: 'categoryListBox') framingBlock
		topInset: categoryListBoxFramingBlock topInset.
	listBox isHandleOk ifTrue: [listBox resize: self mainView rectangle].
	(self paneNamed: 'activeCategoryLabel') showWindow.
	(pane := self paneNamed: 'activeCategoryField') showWindow.

	self optionMenu
		checkItem: #menuOptionShowActiveCategory.! !

!WBEventManagerWindow methods !   
handlerList

	^handlerListBox contents! !

!WBInterfaceObject methods !   
usesFont

     ^true! !

!WBLookPolicyWin31 methods ! 
leftJustification

    ^"SsLeftnowordwrap" 12! !

!WindowBuilder methods !
initializePalettesMap
	"Answer a mapping of names to bitmap names
	 for those bitmaps not named in a standard fashion."

	^self 
		propertyAt: #initializePalettesMap 
		ifAbsent: [self initializePalettesMapDefault].! !

!WinDialogInfo methods !  
items
        "Private - WBPro Development."

    | items s r resID style classID b text |

    #addedByOSI.
    s := ReadWriteStream on: (contents copyFrom: 14 to: contents size).

    "Skip menu name, class name, and text"
    s upTo: 0; upTo: 0; upTo: 0.

    (self style bitIsOn: (OperatingSystemConstants at: 'DsSetfont')) ifTrue: [
        s nextTwoBytes; upTo: 0.
    ].

    items := OrderedCollection new.
    self numberOfItems timesRepeat: [
        r := (s nextTwoBytes @ s nextTwoBytes extent: s nextTwoBytes @ s nextTwoBytes).
        resID := s nextTwoBytes.
        style := s nextFourBytes.
        classID := s next.
        classID < 128 ifTrue: [
            classID := String with: classID asCharacter.
            [ (b := s next) = 0 ] whileFalse: [
                classID := classID, (String with: b asCharacter).
            ].
        ].
        text := ''.
        [ ( b := s next ) = 0 ] whileFalse: [
            text := text, (String with: b asCharacter)
        ].
        items add:
            (WBInterfaceObject
                newFromStyle: style
                classID: classID
                rect: r
                text: text
                resID: resID
            ).
        s next.
    ].

    ^items! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBTeamVCodePolicy methods !
wbGeneratedPackageName

	^'** WindowBuilder Pro Generated **'! !

!WBAbstractAddInModule class methods !  
unloadAddIn
    "Unload the receiver and perform any cleanup."

    self loaded: false.
    self cleanUpOnUnload.! !

!WBResizeBitmap methods ! 
oldHeight

    ^(self paneNamed: 'oldHeightField') contents asInteger! !

!WBLayoutFrameEditor methods !  
setBottomAttach: aString

    | ratio |
    aString = self proportional ifTrue: [
        ^self currentFramingBlocks do: [:each |
            each wbBottomProportional: true.
            each wbBottomAttachedToTop: false]].
    aString = self paneTop ifTrue: [
        ^self currentFramingBlocks do: [:each |
            each wbBottomProportional: false.
            each wbBottomAttachedToTop: true]].
    ratio := self class verticalRatioStrings keyAtValue: aString ifAbsent: [
        aString isNumber
            ifTrue: [ratio := aString asRational]
            ifFalse: [ratio := ((self compilerEvaluate: aString) ifNil: [^self]) asRational]].
    self currentFramingBlocks do: [:each |
        each wbBottomProportional: false.
        each wbBottomAttachedToTop: false.
        each bottomRatio: ratio].! !

!PCompositePane methods ! 
update

	self realClass: self realClass updateExtent: false.
	super update.! !

!PropertyManager methods !   
wbMutateFrom: anObject to: copyObject
	"Answer a mutation of anObject."

	| propMgr |
	#addedByOSI.
	propMgr := copyObject wbPropertyManager.
	self associationsDo: [:each | each wbMutateFrom: anObject to: copyObject using: propMgr].
	^copyObject! !

!LayoutFrame methods ! 
storeOn: aStream indentString: indentString
	"Append the definition of the receiver to aStream."

	| xDU yDU |
	"xDU := (WindowDialog dialogUnit x / WindowDialog unitMultiplier x * 2) ceiling / 2."
	"yDU := WindowDialog dialogUnit y / WindowDialog unitMultiplier y."

	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.

	aStream
		nextPutAll: indentString;
		nextPutAll: self class name;
		space;
		nextPutAll: #new;
		indentBy: 1.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #leftRatio: ;
		space;
		nextPutAll: self leftRatio printString;
		endMessage.

	aStream
		nextPut: $ ;
		nextPutAll: #leftInset: ;
		space;
		nextPutAll: (self leftInset / xDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #xDU;
		endMessage.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #topRatio: ;
		space;
		nextPutAll: self topRatio printString;
		endMessage.

	aStream
		nextPut: $ ;
		nextPutAll: #topInset: ;
		space;
		nextPutAll: (self topInset / yDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #yDU;
		endMessage.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #rightRatio: ;
		space;
		nextPutAll: self rightRatio printString;
		endMessage.

	aStream
		nextPut: $ ;
		nextPutAll: #rightInset: ;
		space;
		nextPutAll: (self rightInset / xDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #xDU;
		endMessage.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #bottomRatio: ;
		space;
		nextPutAll: self bottomRatio printString;
		endMessage.

	aStream
		nextPut: $ ;
		nextPutAll: #bottomInset: ;
		space;
		nextPutAll: (self bottomInset / yDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #yDU;
		indentBy: -1.! !

!WBGeometryManager methods !  
selectAll

    self layoutForm selectAll! !

!PCompositePane class methods !  
styleFrom: style

	^(style bitIsOn: WsBorder)
		ifFalse: [#defaultStyle]
		ifTrue: [
			(style bitIsOn: WsVscroll)
				ifFalse: [#borders]
				ifTrue: [
					(style bitIsOn: WsHscroll)
						ifFalse: [#verticalScrollBar]
						ifTrue: [#scrollbars]]].! !

!WBLayoutWizard methods ! 
stateFor: anItem

    ^anItem propertyAt: #inLayout! !

!PropertyManager methods !
wbNLSAccessorsDo: aBlock
	"Eavaluate aBlock with all accessors that may be NLS-ized."

	self associationsDo: [:each |
		each wbNLSAccessor ifTrue: [
			aBlock value: each]].
	metaProperties notNil ifTrue: [
		metaProperties wbNLSAccessorsDo: aBlock].! !

!WBInterfaceObject methods !  
fullCopy: copy

	| framer |
	framer := self wbEditorClass useLayoutFrame
		ifTrue: [self framingBlock asLayout]
		ifFalse: [self framingBlock asFramingParameters: self rect].
	super fullCopy: copy.
	copy
		realClass: self realClass;
		rect: self rect deepCopy;
		style: self style;
		font: self font;
		menu: (self menu notNil
			ifTrue: [self menu fullCopy]
			ifFalse: [nil]);
		framingBlock: framer;
		tabPosition: self tabPosition;
		foreColor: self foreColor;
		backColor: self realBackColor.
	copy usesTitle
		ifTrue: [copy contents: self contents copy].
	self copySpecificsTo: copy.! !

!WindowBuilder methods ! 
menuToolsInspectSmalltalk

    Smalltalk inspect! !

!WBGraphicObject methods !   
displayWith: aPen clipRect: aRect

	self displayWith: aPen.! !

!WBManagedPValue methods !
updateKey
	"Update the key/association based on the new value."

	self pools do: [:eachPool |
		eachPool associationsDo: [:each |
			each value == value ifTrue: [
				association := each.
				^key := each key]]].
	^association := key := nil! !

!PMultipleSelectListBox methods !  
importantEvents

    ^super importantEvents
        remove: #clicked:;
        addFirst: #changed:;
        yourself! !

!WindowBuilder class methods !
childPaneVarName
	"Answer the child pane var name used in #createViews."

	^'p'! !

!WBFontSelectionWindow methods ! 
findEqualFont: aFont
	"Answer a managed font equivlent to aFont, or answer aFont."

	self poolManager pools do: [:each |
		each pool do: [:eachFont |
			(aFont wbEquals: eachFont) ifTrue: [
				^eachFont]]].
	(aFont wbEquals: SysFont) ifTrue: [^SysFont].
	^aFont! !

!WBPoolManagerWindow methods !   
updateKeysPrim
	"Update the list of keys."

	keyListBox update.
	self selectedKeysAndPools: updateKeys.
	updateKeys := nil.! !

!WBLayoutForm methods !
hideOrderSymbolsFor: aCollectionOfWidgets
    "Hide the order symbols for a <aCollectionOfWidgets>"

    | center font fontHeight radius diameter |
    self showOrder ifFalse: [^self].
    font :=  SysFont.
    fontHeight := font height.
    radius := (((font stringWidth: (self children size asString)) // 2) max: fontHeight // 2) + 3.
    diameter := radius * 2 + 1.
    aCollectionOfWidgets do: [:widget |
        center := widget boundingBox center.
        self invalidateRect: ((center leftAndUp: radius) extentFromLeftTop: diameter) erase: false].! !

!WBFontSelectionWindow methods !  
opened

	super opened.
	self poolManager when: #changed send: #ownerChanged to: self.! !

!PStatusPane methods ! 
manageChild

	super manageChild.
	(self editor ifNil: [^nil]) layoutForm redraw.! !

!WindowBuilder class methods !  
codeModulesFor: anObject
	"Private - Answer the code module class."

	^Array with: (self codeModuleClassFor: anObject realClass) new! !

!WBPoolManagerWindow methods !  
hideActiveCategory

	| pane listBox |
	(self paneNamed: 'activeCategoryLabel') hideWindow.
		"Don't hide the drop down list... just put in bottom of z order."
	(pane := self paneNamed: 'activeCategoryField') "hideWindow".	
	(listBox := self paneNamed: 'categoryListBox') framingBlock
		topInset: pane framingBlock topInset.
	listBox isHandleOk ifTrue: [listBox resize: self mainView rectangle].

	self optionMenu
		uncheckItem: #menuOptionShowActiveCategory.! !

!WindowBuilder class methods !
generateCopyright

    ^self editorClass
        propertyValueAt: #GenerateCopyright
        category: self codeGenerationPropertyString.! !

!WBLookPolicyWin95 class methods !
purgeCache
    " WBLookPolicyWin95 purgeCache "

    RadioBitmap notNil ifTrue: [RadioBitmap release].
    SystemMenuBitmap notNil ifTrue: [SystemMenuBitmap release].
    RadioBitmap := SystemMenuBitmap := nil.! !

!WBLookPolicyOS2 methods !  
minimizeButtonSize

    ^self titleBarHeight asPoint! !

!WBPoolManagerWindow methods !   
createMenus: aPane

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	#generated.
	aPane menuWindow
	    yourself;
	    addMenu: (
	        Menu new
	            title: 'Pool';
	            owner: self;
	            appendItem: 'New...' selector: #menuPoolNew acceleratorString: '';
	            appendItem: 'Add existing...' selector: #menuPoolAddExisting acceleratorString: '';
	            appendItem: 'Update dependent classes...' selector: #menuPoolUpdateDependentClasses acceleratorString: '';
	            appendSeparator;
	            appendItem: 'File in...' selector: #menuPoolFileIn acceleratorString: '';
	            appendItem: 'File out...' selector: #menuPoolFileOut acceleratorString: '';
	            appendItem: 'File out separately...' selector: #menuPoolFileOutSeparately acceleratorString: '';
	            appendSeparator;
	            appendItem: 'Remove' selector: #menuPoolRemove acceleratorString: '';
	            appendItem: 'Delete' selector: #menuPoolDelete acceleratorString: ''
	    );
	    addMenu: (
	        Menu new
	            title: 'Category';
	            owner: self;
	            appendItem: 'New...' selector: #menuCategoryNew acceleratorString: '';
	            appendItem: 'Rename...' selector: #menuCategoryRename acceleratorString: '';
	            appendItem: 'Add suggested...' selector: #menuCategoryAddSuggested acceleratorString: '';
	            appendSeparator;
	            appendItem: 'File out...' selector: #menuCategoryFileOut acceleratorString: '';
	            appendItem: 'File out separately...' selector: #menuCategoryFileOutSeparately acceleratorString: '';
	            appendSeparator;
	            appendItem: 'Delete' selector: #menuCategoryDelete acceleratorString: '';
	            appendSeparator;
	            appendItem: 'Show all' selector: #menuCategoryShowAll acceleratorString: '';
	            appendItem: 'Show selected' selector: #menuCategoryShowSelected acceleratorString: ''
	    );
	    addMenu: (
	        Menu new
	            title: 'Active';
	            owner: self
	    );
	    addMenu: (
	        Menu new
	            title: 'Key';
	            owner: self;
	            appendItem: 'New...' selector: #menuKeyNew acceleratorString: '';
	            appendItem: 'Rename...' selector: #menuKeyRename acceleratorString: '';
	            appendItem: 'Move...' selector: #menuKeyMove acceleratorString: '';
	            appendItem: 'Browse references...' selector: #menuKeyBrowseReferences acceleratorString: '';
	            appendSeparator;
	            appendItem: 'Delete' selector: #menuKeyDelete acceleratorString: ''
	    );
	    addMenu: (
	        Menu new
	            title: 'Option';
	            owner: self;
	            appendItem: 'Show active category' selector: #menuOptionShowActiveCategory acceleratorString: '';
	            appendItem: 'Show path' selector: #menuOptionShowPath acceleratorString: '';
	            appendSeparator;
	            appendItem: 'Allow duplicate keys' selector: #menuOptionAllowDuplicateKeys acceleratorString: ''
	    )! !

!WBGraphicObject class methods !  
new

    ^super new initialize! !

!GraphicsTool methods !
resetColorMode
	"Do nothing... for compatibility with OS/2"
! !

!WBModelObjectEditor methods !   
disableFields

    name disable; contents: self emptyString.
    instVar disable; selection: false.
    when disable; contents: #().
    send disable; contents: self emptyString.! !

!WBLayoutForm methods ! 
button1Down: aPoint
    "Dragging the window via the title bar to the PARTS workbench?"
    "If yes, then allow the normal drag/drop mechanism to work."

    (self isLocalDragSource and: [self isDragButton: 1])
        ifTrue: [
            (self inTitle: aPoint) & self wbEditorClass partsSupportEnabled
                ifTrue: [^super button1Down: aPoint]].
    self triggerEvent: #gettingFocus.
    self 
        useLeftButton;
        buttonDown: aPoint.! !

!WBTemplateEditor methods !   
textLabel

	^textLabel! !

!WBLayoutForm methods !
pen

	^drawingBitmap notNil
		ifTrue: [drawingBitmap pen]
		ifFalse: [super pen].! !

!String methods ! 
asSelectorToken
		"Answer the receiver as a valid token."
	| answer word tokens stream |
	answer := self select: [ :each | each = $: | each isAlphaNumeric ].
	answer isEmpty ifTrue: [ ^'a' ].
	tokens := OrderedCollection new.
	stream := ReadStream on: answer.
	[	word := stream upTo: $: .
		word notEmpty ifFalse: [ word := 'a' ].
		word first isLetter ifFalse: [ word := 'a', word ].
		tokens add: word.
		stream atEnd ] whileFalse: [ ].
	(tokens size = 1) & (answer last ~= $:) ifTrue: [ ^tokens first ].
	stream := WriteStream on: (String new: answer size + 5).
	tokens do: [ :each | stream nextPutAll: each; nextPut: $: ].
	^stream contents! !

!WBNLSDictionaryReader class methods !  
fileOutPoolName: aString on: aStream
	"File out a token/value pair inside a comment."

	^self
		fileOutToken: WBNLSManager tagPoolName
		value: aString
		inCommentOn: aStream! !

!WBLocator class methods ! 
on: anObject at: aSymbol with: anElement
        ^self new setReceiver: anObject selector: aSymbol arguments: (Array with: anElement)! !

!PWBToolBar methods !
elements

	^elements ifNil: [elements := OrderedCollection new].! !

!Object methods !
isWBPrimaryModel

    ^(self propertyAt: #primaryModel) == true! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBFramingEditor methods !   
originXAnchorChanged: selectedItem

    selectedItem = 'Pane right'
        ifTrue:
            [cornerXAnchor disableItem: 'Pane left'.
            ]
        ifFalse:
            [cornerXAnchor enableItem: 'Pane left'.
            ].
    self setExampleRects.! !

!WindowBuilder methods !  
editClass: aViewClass
    "The windows are built.  Set this thing up to edit a new class (either at start or in open...)."
    | temp vMenu |
    aViewClass isScratchWindow
        ifTrue: [
            cleanedOutCode := false.
            self prototype: (WBPrototype on: aViewClass defaultClass owner: self).
            self editedClass: aViewClass.]
        ifFalse: [
            self setDefaultFonts.
            [temp := [WBPrototype on: aViewClass owner: self]
                on: Error
                do: [:ex |
                    MessageBox message:
                        'WindowBuilder Pro cannot edit the specified window: [ ',
                        ex description,' ]. Hold the ALT key down when clicking OK to see the full walkback.'.
                    Notifier isAltKeyDown
                        ifTrue: [ex pass]
                        ifFalse: [self dumpErrorToTranscript: ex].
                    self inENVY ifFalse: [WBScratchWindow resetToDefault].
                    self editClass: WBScratchWindow.
                    ^nil].
            ] ensure: [self sendInputEvent: #resetFonts].
            temp isNil
                ifTrue: [
                    MessageBox message: 'WindowBuilder Pro cannot edit the specified window'.
                    self inENVY ifFalse: [WBScratchWindow resetToDefault].
                    self editClass: WBScratchWindow.
                    ^nil].
            self prototype: temp].
    self labelWithoutPrefix: self label.
    (vMenu := self menuTitled: 'View') notNil
        ifTrue: [
            vMenu disableAll.
            (self shell isDialog or: [self shell isCompositePane])
                ifFalse: [self updateMenuView]].
    self reinitWindowBuilder.
    "Check if clipboard is an object pasteable (is that a word?) for us"
    self sendInputEvent: #clearDirty.! !

!PScrollBar methods ! 
pageIncrement: integer

    pageIncrement := integer! !

!WBAbstractCodeModule methods !  
targetClass: aClass
		"Set the receiver's target class."
	targetClass := aClass.! !

!WBLayoutForm methods !  
showOrder: aBoolean
    "Set the value of showOrder."

    showOrder := aBoolean.
    self updateWidget.! !

!WBUndoManager methods !   
redoableActions

    ^undoList copyFrom: current + 1 to: undoList size! !

!WBBitmapPool methods !
fileOutBDTKeys: keyCollection categories: categoryCollection on: aStream
	"File out the receiver's contents in BDT file format."

	| aSubPool |
	categoryCollection asSortedCollection do: [:each |
		(aSubPool := self subPoolFor: each) notNil ifTrue: [
			aSubPool
				fileOutBDTKeys: keyCollection
				on: aStream]].! !

!WindowBuilder class methods !  
preOpen

	! !

!WBPropertyEditor methods !
setValue: aValue

	aValue isString | aValue isPoint | aValue isNumber
		ifTrue: [
			valueTrue hideWindow.
			valueFalse hideWindow.
			valueString
				enable;
				contents: aValue asString;
				showWindow]
		ifFalse: [
			aValue isBoolean
				ifTrue: [
					valueString hideWindow.
					aValue
						ifTrue: [
							valueTrue selection: true.
							valueFalse selection: false]
						ifFalse: [
							valueTrue selection: false.
							valueFalse selection: true].
					valueTrue showWindow.
					valueFalse showWindow]
				ifFalse: [
					aValue isNil
						ifTrue: [
							valueTrue hideWindow.
							valueFalse hideWindow.
							valueString
								disable;
								contents: '<No Property Selected>';
								showWindow]]].! !

!WBPlaceHolderObject methods !
owner: anObject

	owner := anObject.! !

!WBCreateClassDialog methods !   
cacheAt: superClassSymbol
put: classList

    ^cache at: superClassSymbol put: classList! !

!WBCreateViewModule methods !   
menuModuleClass
		"Answer the menu code module class."
	^WBCreateMenuModule! !

!WBBitmapSubPool methods !
fileOutBDTKeys: aCollection on: aStream
	"File out the receiver's contents."

	| assoc |
	aCollection asSortedCollection do: [:each |
		assoc := self associationAt: each ifAbsent: [nil].
		assoc notNil ifTrue: [self fileOut: assoc on: aStream]].! !

!WBPoolManager methods !
isIndirectCodeGenerationStyle

	^self codeGenerationStyle ~= #key! !

!PRealWidgetControl methods !   
backColor: aColor

	#osiHack.
	"This should probably be moved up..."
	self wbRealWidget backColor: aColor.! !

!PToggle methods !   
importantEvents

    ^super importantEvents
        addFirst: #clicked:;
        yourself! !

!WBListEditor class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBAbstractCodeModule methods !  
generatedSymbol

    ^#generated! !

!WBMenu methods !
add: aSelector label: aLabelString mnemonic: aChar enable: enable toggle: toggle for: theOwner accelerator: aString

    | menuItemOwner |
    menuItemOwner := theOwner isNil
        ifTrue: [self owner]
        ifFalse: [theOwner].
    ^(self appendItem:
            (aLabelString replaceEscapeCharacters",
            (String with: Tab),
            aString")
        selector: ((aSelector isSymbol and: [theOwner notNil])
            ifTrue: [
                Message
                    receiver: menuItemOwner
                    selector: aSelector]
            ifFalse: [aSelector])
        acceleratorString: aString)
        enableSelector: enable;
        toggleSelector: toggle;
        owner: menuItemOwner.! !

!WBDialogScratchWindow methods ! 
perform: selector with: arg
    "Scratch windows should not perform any events"
    self perform: selector! !

!WBInterfaceObject methods !   
resID

    ^resID! !

!WBKeyAccel methods !   
fullKeyName

    | titleString |

    titleString := ''.

    self isCtrl ifTrue: [
        titleString := titleString, 'Ctrl+'.
    ].
    self isAlt ifTrue: [
        titleString := titleString, 'Alt+'.
    ].
    self isShift ifTrue: [
        titleString := titleString, 'Shift+'.
    ].

    ^titleString, (self keyName ifNil: [''])! !

!Object methods ! 
storeOn: aStream indentString: indentString
    "Private - WBPro Development."! !

!WBLookPolicy class methods !   
reset
    " WBLookPolicy reset "
    Current := Default := nil! !

!WindowBuilder methods !   
menuOptionsMiniHelpEnabled

    self class togglePropertyValueAt: #MiniHelpEnabled.
    self updateOptionsMenu.! !

!WBLayoutForm methods !  
findAllChildrenFor: aPoint

    ^self allChildren select: [:widget |
        widget rect containsPoint: aPoint].! !

!WBPoolManagerWindow methods !  
pools
	"Answer the collection of pools."

	^poolListBox contents! !

!WindowBuilder methods !
popupTitleMenu: textPane

    | menu subMenu subMenus nlsPool nlsPools checkItem assoc array answer |

    (nlsPools := self shell nlsPools asArray) isEmpty
        ifTrue: [^textPane setPopupMenu: nil].

    menu := Menu new
        owner: textPane;
        selector: #contents:;
        yourself.

    nlsPools size == 1
        ifTrue: [
            ((array := (nlsPool := Smalltalk at: nlsPools first) keys asSortedCollection asArray) 
				copyFrom: 1 to: (array size min: 24)) do: [:key |
                assoc := nlsPool associationAt: key.
                menu appendItem: ('#',assoc key, ' - ', assoc value printString) selector: ('#', assoc key) asSymbol].
			array size > 24
				ifTrue: [
					menu appendSeparator;
						appendItem: 'Other...' action:
							(Message receiver: [
								(answer := WBListChooser 
									fromList: (array collect: [:key |
										assoc := nlsPool associationAt: key.
										('#',assoc key, ' - ', assoc value printString)])
									prompt: 'Select NLS Key') isNil
									ifFalse: [textPane contents: (answer upTo: $ )]] selector: #value)]]
        ifFalse: [
            subMenus := OrderedCollection new: nlsPools size.
            nlsPools do: [:sym |
                menu appendSubMenu:
                    (subMenu := Menu new
                        title: sym;
                        owner: textPane;
                        selector: #contents:;
                        yourself).
                subMenus add: subMenu.
                ((array := (nlsPool := Smalltalk at: sym) keys asSortedCollection asArray) 
					copyFrom: 1 to: (array size min: 24)) do: [:key |
                    assoc := nlsPool associationAt: key.
                    subMenu appendItem: ('#',assoc key, ' - ', assoc value printString) selector: ('#', assoc key) asSymbol].
				array size > 24
					ifTrue: [
						subMenu appendSeparator;
							appendItem: 'Other...' action:
								(Message receiver: [
									(answer := WBListChooser 
										fromList: (array collect: [:key |
											assoc := nlsPool associationAt: key.
											('#',assoc key, ' - ', assoc value printString)])
										prompt: 'Select NLS Key') isNil
										ifFalse: [textPane contents: (answer upTo: $ )]] selector: #value)]]].
    checkItem := ((self nlsKeyFor: thePane text) ifNil: ['']) asSymbol.
    subMenus isNil
        ifTrue: [menu checkItem: checkItem]
        ifFalse: [
            subMenus do: [:sub |
                sub checkItem: checkItem]].
    textPane setPopupMenu: menu.! !

!WBHandle methods ! 
isActive
        ^true! !

!WBDefaultCompositePaneScratchWindow class methods !
isWBInternalClass

    ^true! !

!WBPropertyEditor methods !  
selectProperty: selectedItem

    | property |
    property := self selectedProperty.
    self setValue: (changes at: property ifAbsent: [property value]).
    comment contents: property comment.! !

!StatusWindow class methods !  
wbConstructPropertyManager
	"Construct the WindowBuilder property manager
		based on the Digitalk property manager."

	#addedByOSI.
	^super wbConstructPropertyManager
		add: (SelectorPropertyAccessor new
			name: 'Contents';
			get: #wbContents;
			set: #contents:;
			format: 'OrderedCollection');
		add: (SelectorPropertyAccessor new 
			name: 'Height'; 
			get: #wbHeight; 
			set: #height:; 
			format: 'Integer');
		add: (StylePropertyAccessor new
			name: 'SizeGrip';
			style: 'SbarsSizegrip';
			pool: WinCommonControlConstants;
			wbAddStyle: #'includeSizeGrip: true';
			wbRemoveStyle: #'includeSizeGrip: false');
		add: (StylePropertyAccessor new
			name: 'PlaceAtTop';
			style: 'CcsTop';
			pool: WinCommonControlConstants;
			wbAddStyle: #placeAtTop);
		wbAddEvent: (
			WBEventDescription new
				event: #drawItem: ;
				argumentNames: #('anObject'));
		yourself! !

!WBLayoutForm methods !
dragSourceCutDefault: dragSession
		"Private - perform default cut action if no handler is provided."
	#osiHack.
	"Support for WB drag to PARTS workbench... do nothing."! !

!WBScrapbookStore methods !
initWindow

    (self paneNamed: 'name') contents: ''.
    (self paneNamed: 'ok') disable.
    isQuick := false.! !

!WBLayoutForm methods !
drawGrid: aPen rect: aRect

	| x y top bottom left right gridColor contentRect |
	x := self gridSize x.
	y := self gridSize y.
	(x < 2 or: [y < 2]) ifTrue: [^self].

	gridColor := self shell backColor asRGBColor = Color gray asRGBColor
		ifTrue: [Color darkGray] 
		ifFalse: [Color gray].

	contentRect := self shell frameContentRect.
	left := contentRect left distanceRight: aRect left.
	right := contentRect left distanceRight: aRect right.
	top := contentRect top distanceDown: aRect top.
	bottom := contentRect top distanceDown: aRect bottom.
	left := contentRect left right: (left roundTo: x).
	right := contentRect left right: (right roundTo: x).
	top := contentRect top down: (top roundTo: y).
	bottom := contentRect top down: (bottom roundTo: y).

	(left min: right) to: (left max: right) by: x do: [:xPos | 
		aPen
			foreColor: gridColor;
			lineFrom: xPos @ aRect top to: xPos @ aRect bottom].

	(top min: bottom) to: (top max: bottom) by: y do: [:yPos |
		aPen
			foreColor: gridColor;
			lineFrom: aRect left @ yPos to: aRect right @ yPos].

	"(left min: right) to: (left max: right) by: x do: [:xPos | 
		(top min: bottom) to: (top max: bottom) by: y do: [:yPos |
		aPen
			foreColor: gridColor;
			rectangleFilled: (xPos @ yPos extent: 1@1)]]."! !

!WBMenu methods !
uncheckItem: item
        "Remove the check mark from an item.
         item can be the label or the selector."
    (self isThere: item) ifFalse: [^nil].
    (self getMenuItem: item) uncheck.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBScrollingPane methods ! 
amountToPageUp

    ^(self visibleExtent y - 10) max: 20! !

!PScrollBar methods !
scrollBarColor

    ^self backColor! !

!WindowFrameObject methods !  
wbRealWidget: aWidget

	super wbRealWidget: aWidget.
	style := nil.! !

!WBResizeBitmap methods !
isScaled

    ^isScaled ifNil: [self isButtonBitmap not]! !

!WBInterfaceObject methods ! 
colorDefaults

    | colorDefaults |
    colorDefaults := Dictionary new.
    self usesColor
        ifTrue: [
            self usesForeColor
                ifTrue: [colorDefaults at: 'Fore Color' put: self defaultForeColor].
            self usesBackColor
                ifTrue: [colorDefaults at: 'Back Color' put: self defaultBackColor]].
    ^colorDefaults! !

!WBClassDefinition methods !   
basicNLSPools
		"Answer a collection of pool dictionaries."
	^(self poolNames asOrderedCollection
		reject: [ :eachPoolName | self class nonNLSPoolNames includes: eachPoolName ])
		collect: [ :eachPoolName | Smalltalk at: eachPoolName ]! !

!WBKeyEntryField methods ! 
accelerator

    ^accelerator! !

!WBLayoutWizard methods !   
setInstVar: aBoolean

    attributesList selectedItem object
        propertyAt: #instVar
        put: aBoolean! !

!WBModelSetModule methods ! 
defaultComment
        "Answer the default comment string."
    ^'Set the value of ', self object name, ' to <', self messageArguments first, '>.',
        super defaultComment! !

!WBLookPolicyWin95 methods !
drawTitleBarBoxWith: aPen at: aRect

    aPen
        foreColor: Color white;
        wbLineFrom: aRect leftTop to: (aRect rightTop left: 1);
        wbLineFrom: aRect leftTop to: (aRect leftBottom up: 1);
        foreColor: Color black;
        wbLineFrom: (aRect leftBottom up: 1) to: (aRect rightBottom up: 1);
        wbLineFrom: (aRect rightTop left: 1) to: (aRect rightBottom leftAndUp: 1);
        foreColor: Color darkGray;
        wbLineFrom: (aRect leftBottom rightAndUp: 1@2) to: (aRect rightBottom leftAndUp: (1+Rectangle leftTopUnit y)@2);
        wbLineFrom: (aRect rightTop leftAndDown: 2@1) to: (aRect rightBottom leftAndUp: 2);
        up; down;
        fill: (aRect insetBy: (1@(1 + Rectangle leftTopUnit y) extent: 1@(1 - (Rectangle leftTopUnit y * 2)))) color: Color gray;
        foreColor: Color black;
        backColor: Color black.
    ^aRect insetBy: (1@1 extent: 1@1)! !

!WBPoolManagerWindow methods !   
keyListDraw: aKey value: aString pane: aPane

	self listDraw: aKey value: aString pane: aPane.! !

!WindowBuilder class methods ! 
userBitmapFileName
	"Answer the name of the available user bitmap DLL."

	UserBitmapFileName isNil
		ifTrue: [
			UserBitmapFileName := self userBitmapFileNames 
				detect: [:each | (File findFileName: each) notNil] 
				ifNone: [^self userBitmapFileNames first]].
	^UserBitmapFileName! !

!WindowBuilder methods ! 
placeCentered: ignored
	"Happens on doubleclick in palette.  Assumes select
     happened first"

	self layoutForm placeLoadedPane.! !

!PStatusPane methods !  
displayBox: box with: aPen

	| rcDraw string hRegion |

	box rectangle isNil ifTrue:[^self].
	(box rectangle right isLeftEqualOf: box rectangle left)
		ifTrue:[^nil].
	rcDraw := box rectangle.
	aPen fill: ((rcDraw leftBottom leftAndUp:(0 @ 1)) rightTop: (rcDraw leftTop rightAndDown:(1 @ 0)))
		color: self colorButtonShadow.
	aPen fill: ((rcDraw leftTop rightAndDown: (1 @ 0)) rightBottom: (rcDraw rightTop leftAndDown:(0 @ 1)))
		color: self colorButtonShadow.
	aPen fill: ((rcDraw leftBottom rightAndUp:(0 @ 0))  rightTop: (rcDraw rightBottom leftAndUp:(0 @ 1)))
		color: self colorButtonHighlight.
	aPen fill: ((rcDraw rightBottom leftAndUp:(1 @ 0)) rightTop: (rcDraw rightTop leftAndDown:(2 @ 0)))
		color: self colorButtonHighlight.
	box contents isNil ifTrue:[^self].
	string := box contents isString
		ifTrue: [box contents]
		ifFalse: [box contents printString].
	OperatingSystem isOS2
		ifTrue: [
			rcDraw := box rectangle insetBy: 2 @ 2.
			hRegion := aPen setClipRect: rcDraw.
			aPen
				backColor: self realBackColor;
				foreColor: self foreColor;
				displayText: string at: (rcDraw leftBottom rightAndUp: 2 @ 2);
				destroyRegion: hRegion]
		ifFalse: [
			rcDraw := box rectangle insetBy: 1 @ 1.
			aPen
				backColor: self realBackColor;
				foreColor: self foreColor;
				displayText: string at: (rcDraw leftBottom rightAndUp: (1 @ (aPen font height + 1)))
				in: rcDraw
				options: "EtoOpaque | EtoClipped" 6
				adx: nil].! !

!WBMenuEditor methods !
nlsKeyFor: aString
    | nlsKey nlsText nlsPools |
    nlsText := aString.
    (nlsPools := self nlsPools) notEmpty
        ifTrue: [
            nlsPools detect: [:sym |
               (nlsKey := (Smalltalk at: sym)
                    keyAtValue: aString
                    ifAbsent: [nil]) ~~ nil] ifNone: [].
            nlsKey notNil
                ifTrue: [nlsText := '#', nlsKey]].
    ^nlsText! !

!WBLayoutForm methods !  
redrawMovingWidget
    "Answer the flag indicating that the widget currently
     being moved must be redrawn on the next move."

    ^redrawMovingWidget! !

!WBEventMessage methods ! 
hash
        "Answer an integer hash value for the receiver. Invariants:
        the hash value of an object must be constant over time;
        two objects that compare equal must have equal hash values."

	^self basicHash! !

!UndefinedObject methods ! 
wbFullCopyReal: aDictionary
	"Answer a copy of the receiver which shares
		 the receiver instance variables.  Because
		 the receiver is unique (cannot be copied),
		 answer the receiver."

	#addedByOSI.
	^self! !

!WBLayoutForm methods !   
createCursors
    "Create all of the cursors that the widget might need"

    self cursors.! !

!PGroupbox methods ! 
staysToBack

    ^true! !

!PropertyManager methods ! 
wbInitializeDefaultFrom: anObject
	"Initialize the #wbDefault value for each property."

	self associationsDo: [:each | each wbInitializeDefaultFrom: anObject].! !

!WBPMenuItem methods !  
action: aString

    (aString isNil or: [ aString isEmpty ]) ifTrue: [ ^nil ].

     selector := (Message new)
                            receiver: (WBAction window: nil action: aString);
                            selector: #perform;
                            arguments: #();
                            yourself! !

!Window methods ! 
wbCopyTo: anObject
	"Copy of the receiver's properties to anObject."

	#addedByOSI.
	^self wbPropertyManager wbCopyFrom: self to: anObject! !

!Object methods !
eventHandlerSelectorAt: aSymbol
    "Answer the first event handler at aSymbol as a string
        or an empty string if there is no handler defined."

    ^(((self wbRealWidget actionForEvent: aSymbol) ifNil: [^''])
        asActionSequence first selector ifNil: [^''])
        asString! !

!ApplicationCoordinator methods ! 
isWBModel

	^false! !

!WBModelDefinitionEditor methods ! 
setHasEvent: aBoolean

    | selectedItem |
    selectedItem := attributes selectedItem ifNil: [^nil].
    selectedItem hasEvent == aBoolean ifTrue: [^self].
    selectedItem hasEvent: aBoolean.
    self setDirty.! !

!WBUserInfoDialog methods ! 
preInitWindow

	super preInitWindow.
	nameField contents: (self wbEditorClass userNamePrim ifNil: ['']).
	companyField contents: (self wbEditorClass companyNamePrim ifNil: ['']).
	serialNumberField contents: (self wbEditorClass serialNumberPrim ifNil: ['']).! !

!Font methods ! 
storeOn: aStream indentString: indentString
	"Private - WBPro Development."

	#addedByOSI.
	aStream nextPutFont: self indentString: indentString.! !

!PEntryFieldGroup methods !   
style: aSymbol

    super style: aSymbol.
    self addSubpanes.! !

!WBInterfaceObject methods ! 
realBackColor

    ^backColor! !

!WBPoolManagerWindow methods !  
menuOptionAllowDuplicateKeys: aBoolean

	Notifier isShiftKeyDown
	| Notifier isControlKeyDown
	| Notifier isAltKeyDown
		ifTrue: [self poolManager basicAllowDuplicateKeys: aBoolean]
		ifFalse: [self poolManager allowDuplicateKeys: aBoolean].! !

!WindowFrameObject methods !
isModal

    ^(self style includes: #modal) | (self style includes: #sysmodal)! !

!WBLayoutFrameEditor methods ! 
topAttachSelected: selectedItem

	"Callback for the #clicked: event in topAttachField [WBComboBox].
		(Generated by WindowBuilder Pro)"

	self
		setTopAttach: selectedItem;
		updateFramingBlocks;
		updateExample;
		dirty: true.! !

!WBFontSelectionWindow class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBPoolManager methods ! 
fileOutRefOn: aStream
	"File out a reference to the receiver."

	aStream
		nextPutAll: self class name;
		nextPut: $ ;
		nextPutAll: (
			self == self class current
				ifTrue: [#current]
				ifFalse: [#system]).! !

!WBCreateMenuModule methods ! 
generateMenuBody
		"Private - Generate all the menu definitions."
	self stream
		cr;
		nextPutAll: (self varNameFor: #pane);
		space;
		nextPutAll: #menuWindow;
		cr;
		nextPutAll: '    ';
		nextPutAll: #yourself.
	self menu
		storeOn: self stream indentString: ''.
	self stream
		endExpression.! !

!WBActionEditor methods !  
add

    | methodString answer methodPane |
    methodPane := self paneNamed: 'methodField'.
    author := (self paneNamed: 'authorField') contents.
    action := (self paneNamed: 'nameField') contents.
    methodString := WriteStream on: String new.
    (self paneNamed: 'add') contents = '&Add' ifTrue: [
        methodString
            nextPutAll: 'action',action;
            cr; nextPut: $";
            cr; nextPutAll: 'Created by ',author,' - ',Date today asString;
            cr; nextPut: $"; cr.
        methodPane propertyAt: #offset put: methodString position.
        methodString nextPutAll: methodPane contents.
    ] ifFalse: [
        methodString
            nextPutAll: 'action',action;
            cr; nextPut: $";
            nextPutAll: history;
            nextPutAll: 'Modified by ',author,' - ',Date today asString;
            cr; nextPut: $"; cr.
        methodPane propertyAt: #offset put: methodString position.
        methodString nextPutAll: methodPane contents.
    ].
    (WBAction isLogSourcePossible: methodString contents) ifFalse: [ ^nil ].
    answer := CompilerInterface
        compile: methodString contents
        in: WBAction
        notifying: self
        ifFail: [ ^methodPane setFocus ].
    WBAction addSelector: answer key withMethod: answer value.
    SourceManager current
        logSource: methodString contents
        forSelector: answer key
        inClass: WBAction.

    changed := false.
    self updateList.! !

!WindowBuilder methods !   
updateLookPolicy

    WBLookPolicy reset.
    self shell lookPolicy: WBLookPolicy initializePolicy.
    self
        updateOptionsMenu;
        menuOptionsRedraw.! !

!PThreeStateButton methods !   
styles

    ^#(#autoThreeState #threeState)! !

!WBAbstractCodeModule methods !   
generateCopyrightBody
        "Private - Generate the copyright."
	self stream cr; nextPutComment: self copyright.! !

!WBPoolManagerWindow methods ! 
defaultNewCategory

	^''! !

!WBPMenuItem methods !   
isSeparator: bool

    isDivider := bool! !

!WindowBuilder methods ! 
miniHelpDelay

    ^self class miniHelpDelay! !

!WindowBuilder methods ! 
whenChanged: selectedItem

	currentWhen = selectedItem 
		ifFalse: [self updateSendField].! !

!PScrollBar methods ! 
defaultBackColor

    ^Color white! !

!WBCodeStream methods !
nextPutPoolManager: aManager atKey: aKey
	"Store the reference to the pool variable."

	| aClass |
	(aClass := aManager codeKeyClass) notNil
		ifTrue: [
			self
				nextPut: $(;
				nextPutAll: aClass name;
				space;
				nextPutAll: aManager codeKeySelector;
				space;
				nextPutAll: aKey storeString;
				nextPut: $)]
		ifFalse: [
			self
				nextPut: $(;
				nextPutAll: aManager class name;
				space;
				nextPutAll: aManager codeSelector;
				space;
				nextPutAll: #at: ;
				space;
				nextPutAll: aKey storeString;
				nextPut: $)].! !

!WBToolMenuAddInModule class methods !  
modifyMenus: aMenu
    "Modify the menus"

    self
            insertMenu: #('Too\uls' nil
                #(#('Inspect \uSelections' #menuToolsInspectSelection '' nil nil nil)
            #('\uInspect Other' nil
                #(
                    #('Self' #menuToolsInspectSelf '' nil nil nil)
                    #('Prototype' #menuToolsInspectPrototype '' nil nil nil)
                    #('All Instances' #menuToolsInspectAllInstances '' nil nil nil)
                    #separator
                    #('Scrolling Form' #menuToolsInspectScrollingForm '' nil nil nil)
                    #('Layout Form' #menuToolsInspectLayoutForm '' nil nil nil)
                    #('Children' #menuToolsInspectChildren '' nil nil nil)
                    #('Menu Bar' #menuToolsInspectMenuBar '' nil nil nil)
                    #('Clipboard' #menuToolsInspectClipboard '' nil nil nil)
                    #separator
                    #('Smalltalk' #menuToolsInspectSmalltalk '' nil nil nil)
                    #('OperatingSystemConstants' #menuToolsInspectOperatingSystemConstants '' nil nil nil)
                    #separator
                    #('ColorConstants' #menuToolsInspectColorConstants '' nil nil nil)
                    #('CharacterConstants' #menuToolsInspectCharacterConstants '' nil nil nil)
                    #('CursorConstants' #menuToolsInspectCursorConstants '' nil nil nil)
                    #('GraphicsConstants' #menuToolsInspectGraphicsConstants '' nil nil nil)
                    #('SystemColorConstants' #menuToolsInspectSystemColorConstants '' nil nil nil)
                    #('SystemValueConstants' #menuToolsInspectSystemValueConstants '' nil nil nil)
                    #('VirtualKeyConstants' #menuToolsInspectVirtualKeyConstants '' nil nil nil)
                ))
            #separator
            #('\uBrowse' #menuToolsBrowseClasses:
                #(
                    #('Classes' #menuToolsBrowseClasses '' nil nil nil)
                    #('Packages' #menuToolsBrowsePackages '' nil nil nil)
                    #('Services' #menuToolsBrowseServices '' nil nil nil)
                    #separator
                    #('Window' 'Window' '')
                    #('SubPane' 'SubPane' '')
                    #('ViewManager' 'ViewManager' '')
                    #('ApplicationCoordinator' 'ApplicationCoordinator' '')
                    #('EventManager' 'EventManager' '')
                ))
            #('\uOutboards' nil
                #(
                    #('Inspect' #menuToolsInspectOutboards '' nil nil nil)
                    #('Close All' #menuToolsCloseAllOutboards '' nil nil nil)
                ))
            #('\uUndo Manager' nil
                #(
                    #('Inspect' #menuToolsInspectUndoManager '' nil nil nil)
                    #('Clear Undos' #menuToolsClearUndoManager '' nil nil nil)
                ))
            #('\uCode Generation' nil
                #(
                    #('Generate Test Code For Selection' #menuToolsGenerateTestCode '' nil nil nil)
                    #('Debug...' #menuToolsDebugCodeGeneration '' nil nil nil)
                ))
            #('\uInitialize' nil
                #(
                    #('Attributes' #menuToolsInitializeAttributes '' nil nil nil)
                    #('Extras' #menuToolsInitializeExtras '' nil nil nil)
                    #('Properties' #menuToolsInitializeProperties '' nil nil nil)
                ))
            #('O\uther' nil
                #(
                    #('Fix Framing' #menuToolsFixFraming '' nil nil nil)
                    #('View System Bitmaps' #menuToolsViewSystemBitmaps '' nil nil nil)
                ))
                #('\uDirty' #menuToolsToggleDirty '' nil #isDirty nil)))
            in: aMenu
            after: 'Add'.! !

!WBLookPolicy methods ! 
defaultOS2WidgetBackColor

    ^OperatingSystem isOS2
        ifTrue: [Color entryFieldBackground]
        ifFalse: [RGBColor red: 255 green: 255 blue: 204]! !

!WBLookPolicyOS2 methods ! 
drawGroupBox: aGroupBox with: aPen clipRect: clipRect

    | rect top textRect bottom |
    rect := aGroupBox rect.
    top := rect top down: aGroupBox font height // 2.
    bottom := rect bottom up: 1.
    aPen font: aGroupBox font.
    textRect := (rect leftTop right: 7) extentFromLeftTop:
        (aGroupBox font wbStringWidth: aGroupBox contents) @ aGroupBox font height.
    aPen
        foreColor: Color darkGray;
        wbLineFrom: rect left @ top to: rect left @ bottom;
        wbLineFrom: (rect right left: 1) @ top to: (rect right left: 1) @ bottom;
        wbLineFrom: rect left @ bottom to: rect right @ bottom;
        wbLineFrom: rect left @ top to: (rect left right: 5) @ top;
        wbLineFrom: (rect left right: ((aPen stringWidthOf: aGroupBox contents) + 12)) @ top to: rect right @ top;
        foreColor: aGroupBox foreColor;
        backColor: aGroupBox backColor;
        setTextAlign: WBDisplayContext defaultTextAlign;
        winDrawText: aGroupBox contents at: textRect origin.! !

!WBEditClassDialog class methods !   
packageChoice

    ^PackageChoice ifNil: [PackageChoice := self defaultChoice]! !

!SelectorPropertyAccessor methods !
wbMutateValue: aValue for: anObject
	"Mutate the property's value."

	| anAction |
	#addedByOSI.
	(anAction := self wbMutateAction) notNil
		ifTrue: [
			PropertyManager
				performAction: anAction
				object: anObject
				arguments: (Array with: aValue)]
		ifFalse: [
			super
				wbMutateValue: aValue
				for: anObject].! !

!PScrollBar methods ! 
maximum: max

    maximum := max! !

!WBModelDefinitionEditor methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| addButton attributeGroup attributesLabel classLabel 
	downButton editButton eventsButton mainView modelGroup 
	modelsLabel modelTypes nameLabel newButton otherClassButton 
	removeButton renameButton upButton updateButton xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	attributes := ListBox new.
	hasAccessors := CheckBox new.
	hasEvent := CheckBox new.
	initialized := CheckBox new.
	initializeValue := EntryField new.
	lazy := CheckBox new.
	models := ListBox new.
	myClass := WBComboBox new.
	name := EntryField new.
	
		"Temporary Variables"
	addButton := Button new.
	attributeGroup := GroupBox new.
	attributesLabel := StaticText new.
	classLabel := StaticText new.
	downButton := Button new.
	editButton := Button new.
	eventsButton := Button new.
	modelGroup := GroupBox new.
	modelsLabel := StaticText new.
	modelTypes := WBComboBox new.
	nameLabel := StaticText new.
	newButton := Button new.
	otherClassButton := Button new.
	removeButton := Button new.
	renameButton := Button new.
	upButton := Button new.
	updateButton := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Model Wizard';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -150 * xDU;
				topRatio: 1/2; topInset: -187/2 * yDU;
				rightRatio: 1/2; rightInset: -150 * xDU;
				bottomRatio: 1/2; bottomInset: -169/2 * yDU).
	self addView: mainView.
	
	modelTypes "WBComboBox"
		owner: self;
		setName: 'modelTypes';
		when: #changed: send: #selectModelType to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -88 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView
		addSubpane: modelTypes;
		subPaneWithFocus: modelTypes.
	
	models "ListBox"
		owner: self;
		setName: 'models';
		when: #clicked: send: #select: to: self;
		when: #doubleClicked: send: #edit to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 26 * yDU;
				rightRatio: 0; rightInset: -88 * xDU;
				bottomRatio: 1; bottomInset: 23 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: models.
	
	attributes "ListBox"
		owner: self;
		setName: 'attributes';
		when: #clicked: send: #selectAttribute: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 96 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -192 * xDU;
				bottomRatio: 1; bottomInset: 47 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: attributes.
	
	name "EntryField"
		owner: self;
		setName: 'name';
		when: #textChanged: send: #setName: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 1; rightInset: 12 * xDU;
				bottomRatio: 0; bottomInset: -40 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: name.
	
	hasAccessors "CheckBox"
		owner: self;
		setName: 'hasAccessors';
		when: #clicked: send: #setHasAccessors: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 44 * yDU;
				rightRatio: 1; rightInset: 12 * xDU;
				bottomRatio: 0; bottomInset: -54 * yDU);
		contents: 'Accessors';
		startGroup;
		font: SysFont.
	mainView addSubpane: hasAccessors.
	
	hasEvent "CheckBox"
		owner: self;
		setName: 'hasEvent';
		when: #clicked: send: #setHasEvent: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 1; rightInset: 12 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		contents: 'Changed Event';
		startGroup;
		font: SysFont.
	mainView addSubpane: hasEvent.
	
	initialized "CheckBox"
		owner: self;
		setName: 'initialized';
		when: #clicked: send: #setInitialized: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 68 * yDU;
				rightRatio: 0; rightInset: -246 * xDU;
				bottomRatio: 0; bottomInset: -78 * yDU);
		contents: 'Initialize';
		startGroup;
		font: SysFont.
	mainView addSubpane: initialized.
	
	lazy "CheckBox"
		owner: self;
		setName: 'lazy';
		when: #clicked: send: #setLazy: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 252 * xDU;
				topRatio: 0; topInset: 68 * yDU;
				rightRatio: 1; rightInset: 10 * xDU;
				bottomRatio: 0; bottomInset: -78 * yDU);
		contents: 'Lazy';
		startGroup;
		font: SysFont.
	mainView addSubpane: lazy.
	
	myClass "WBComboBox"
		owner: self;
		setName: 'myClass';
		when: #changed: send: #setClass: to: self;
		when: #textChanged: send: #setClass: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 1; rightInset: 26 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		dropDown;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: myClass.
	
	otherClassButton "Button"
		owner: self;
		setName: 'otherClassButton';
		when: #clicked send: #otherClass to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -24 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 1; rightInset: 12 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		contents: '...';
		startGroup;
		font: SysFont.
	mainView addSubpane: otherClassButton.
	
	initializeValue "EntryField"
		owner: self;
		setName: 'initializeValue';
		when: #textChanged: send: #setInitializeValue: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 102 * yDU;
				rightRatio: 1; rightInset: 12 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: initializeValue.
	
	addButton "Button"
		owner: self;
		setName: 'addButton';
		when: #clicked send: #addAttribute to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 96 * xDU;
				topRatio: 1; topInset: -43 * yDU;
				rightRatio: 0; rightInset: -118 * xDU;
				bottomRatio: 1; bottomInset: 27 * yDU);
		contents: 'Add';
		startGroup;
		font: SysFont.
	mainView addSubpane: addButton.
	
	upButton "Button"
		owner: self;
		setName: 'upButton';
		when: #clicked send: #up to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 122 * xDU;
				topRatio: 1; topInset: -43 * yDU;
				rightRatio: 0; rightInset: -142 * xDU;
				bottomRatio: 1; bottomInset: 27 * yDU);
		contents: 'Up';
		startGroup;
		font: SysFont.
	mainView addSubpane: upButton.
	
	downButton "Button"
		owner: self;
		setName: 'downButton';
		when: #clicked send: #down to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 146 * xDU;
				topRatio: 1; topInset: -43 * yDU;
				rightRatio: 0; rightInset: -176 * xDU;
				bottomRatio: 1; bottomInset: 27 * yDU);
		contents: 'Down';
		startGroup;
		font: SysFont.
	mainView addSubpane: downButton.
	
	removeButton "Button"
		owner: self;
		setName: 'removeButton';
		when: #clicked send: #removeAttribute to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 180 * xDU;
				topRatio: 1; topInset: -43 * yDU;
				rightRatio: 0; rightInset: -220 * xDU;
				bottomRatio: 1; bottomInset: 27 * yDU);
		contents: 'Remove';
		startGroup;
		font: SysFont.
	mainView addSubpane: removeButton.
	
	eventsButton "Button"
		owner: self;
		setName: 'eventsButton';
		when: #clicked send: #setEvents to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -72 * xDU;
				topRatio: 1; topInset: -43 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 1; bottomInset: 27 * yDU);
		contents: 'Extra Events...';
		startGroup;
		font: SysFont.
	mainView addSubpane: eventsButton.
	
	newButton "Button"
		owner: self;
		setName: 'newButton';
		when: #clicked send: #newModel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 0; rightInset: -44 * xDU;
				bottomRatio: 1; bottomInset: 3 * yDU);
		contents: 'New';
		startGroup;
		font: SysFont.
	mainView addSubpane: newButton.
	
	editButton "Button"
		owner: self;
		setName: 'editButton';
		when: #clicked send: #edit to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 48 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 0; rightInset: -88 * xDU;
				bottomRatio: 1; bottomInset: 3 * yDU);
		contents: 'Edit';
		startGroup;
		font: SysFont.
	mainView addSubpane: editButton.
	
	renameButton "Button"
		owner: self;
		setName: 'renameButton';
		when: #clicked send: #renameModel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 92 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 0; rightInset: -132 * xDU;
				bottomRatio: 1; bottomInset: 3 * yDU);
		contents: 'Rename';
		startGroup;
		font: SysFont.
	mainView addSubpane: renameButton.
	
	updateButton "Button"
		owner: self;
		setName: 'updateButton';
		when: #clicked send: #updateModel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -52 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 3 * yDU);
		contents: 'Update';
		startGroup;
		font: SysFont.
	mainView addSubpane: updateButton.
	
	modelsLabel "StaticText"
		owner: self;
		setName: 'modelsLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -88 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Models';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: modelsLabel.
	
	attributesLabel "StaticText"
		owner: self;
		setName: 'attributesLabel';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 98 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -144 * xDU;
				bottomRatio: 0; bottomInset: -22 * yDU);
		contents: 'Attributes';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: attributesLabel.
	
	classLabel "StaticText"
		owner: self;
		setName: 'classLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 80 * yDU;
				rightRatio: 1; rightInset: 12 * xDU;
				bottomRatio: 0; bottomInset: -88 * yDU);
		contents: 'Class';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: classLabel.
	
	nameLabel "StaticText"
		owner: self;
		setName: 'nameLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 1; rightInset: 12 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		contents: 'Name';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: nameLabel.
	
	attributeGroup "GroupBox"
		owner: self;
		setName: 'attributeGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 196 * xDU;
				topRatio: 0; topInset: 10 * yDU;
				rightRatio: 1; rightInset: 8 * xDU;
				bottomRatio: 1; bottomInset: 47 * yDU);
		contents: 'Attribute';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: attributeGroup.
	
	modelGroup "GroupBox"
		owner: self;
		setName: 'modelGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 92 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 23 * yDU);
		contents: 'Model';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: modelGroup! !

!WBBitmapEditorCompositePane methods !   
setBitmapSize

	"Callback for the #clicked event in sizeButton [DrawnButton].
		(Generated by WindowBuilder Pro)"

	Notifier isShiftKeyDown | Notifier isControlKeyDown | Notifier isAltKeyDown
		ifTrue: [self owner menuKeyResizeButton]
		ifFalse: [self owner menuKeyResize].! !

!WBGeometryManager methods !   
sendToBack
    "Send the selected widgets to the bottom of the z-order"

    self sendToBack:
        (self children select: [:child |
            self selections includes: child]).! !

!WBTreeNode methods !
descendantsCount

    | count |

    count := 1.
    children do: [ :c |
        count := count + c descendantsCount.
    ].

    ^count! !

!WBDescriptor methods !   
removeFlag: aSymbol

    flags isNil ifTrue: [^self].
    flags := (flags asOrderedCollection remove: aSymbol ifAbsent: [nil]; yourself) asArray.
    flags isEmpty ifTrue: [flags := nil].! !

!WBAttributeEditor class methods !  
isWBInternalClass

    ^true! !

!WBPool methods !
fileOutCategoryFileNames: aCollection on: aStream
	"File out the receiver's contents as a list of file names
		to files containing the actual contents."

	| aSubPool |
	aCollection asSortedCollection do: [:each |
		(aSubPool := self subPoolFor: each) notNil ifTrue: [
			aSubPool fileOutIncludeOn: aStream]].! !

!WBPropertyDescriptor methods ! 
changeBlock
    "Answer the value of changeBlock."

    ^changeBlock! !

!WBChooseClassDialog methods !  
cancel

    result := nil.
    self close.! !

!WBTabPosition methods !  
nextTabPosition

    groupPosition notNil ifTrue: [
        ^WBTabPosition new
            basicTabPosition: basicTabPosition;
            groupPosition: groupPosition + 1
    ] ifFalse: [
        ^WBTabPosition new
            basicTabPosition: basicTabPosition + 1
    ].! !

!WBLayoutForm methods !  
drawBand
    "Draws a band using the current bandRect on the root window."

    | region |
    region := self pen setClipRect: self clipRect.
    self pen
        down;
        foreColor: Color black;
        backColor: Color white;
        drawFocusRect: self bandRect.
    self pen destroyRegion: region.! !

!PCheckBox methods !   
importantEvents

    ^super importantEvents
        add: #checked;
        add: #unchecked;
        yourself! !

!WBModelObjectEditor methods !
updateEvents: selectedObject refresh: refresh

    | oldEvents theEvents triggeredEvents sel used unused |
    oldEvents := when contents.
    triggeredEvents := selectedObject class eventsTriggered.
    used := OrderedCollection new.
    unused := OrderedCollection new.
    triggeredEvents do: [:event |
        (selectedObject eventHandlerSelectorAt: event) notEmpty
                ifTrue: [used add: '*' , event]
                ifFalse: [unused add: event asString]].
    theEvents := used
        addAll: unused;
        yourself.
    theEvents = oldEvents
        ifTrue: [^self].
    refresh
        ifTrue: [
            sel := when selectedItem.
            (sel notNil and: [sel notEmpty])
                ifTrue: [
                    sel first = $*
                        ifTrue: [sel := sel copyFrom: 2 to: sel size].
                    send contents notEmpty
                        ifTrue: [sel := '*' , sel]].
            when
                contents: theEvents;
                selectItem: sel;
                invalidateRect: when rectangle]
        ifFalse: [when contents: theEvents].! !

!WBCodeGenerator methods !   
createClasses
		"Private - Create/modify classes as necessary."
	self classDefinitions
		do: [ :eachClassDef |
			eachClassDef createClass ].! !

!StylePropertyAccessor methods !  
wbDefaultStoreAction

	^#nextPutProperty:style:for:! !

!PCheckBoxGroup methods ! 
label

    ^label ifNil: [ label := 'CheckBoxGroup' ]! !

!PTextEdit methods !
mutationExceptions

    ^#(#CPChildEntryField #Toggle #CPSpinEditor)! !

!WBTemplateEditor methods !  
postEditUpdate

	super postEditUpdate.! !

!WBLookPolicyWin95 class methods ! 
sysMenuBitmap

    | temp width |
    SystemMenuBitmap isNil
        ifTrue: [
            temp := (WBBitmapClass new fromSysID: ObmClose).
            width := (Smalltalk at: #UserLibrary) getSystemMetrics: SmCxsize.
            SystemMenuBitmap := WBBitmapClass new
                ownDCScreenWidth: width
                height: temp height.
            SystemMenuBitmap pen
                copyBitmap: temp
                from: (temp boundingBox leftTop extent: (width @ temp boundingBox height))
                at: 0@0.
            0 to: SystemMenuBitmap width do: [:x |
                0 to: SystemMenuBitmap height do: [:y |
                    (SystemMenuBitmap pen getPixelColor: x@y) = 12632256
                        ifTrue: [SystemMenuBitmap pen setPixel: x@y color: Color activeTitleBar]]].
            temp release].
    ^SystemMenuBitmap! !

!WindowBuilder class methods !   
propertyValueAt: aSymbol

    | property |
    (property := self propertyAt: aSymbol) ifNil: [^nil].
    ^property value! !

!WBGraphicObject methods ! 
wbMinSize

	^self minSize! !

!WBScrapbookRetrieve methods !  
loadChapters: aPane

    aPane contents: self chapters.
    (self paneNamed: 'remove') disable.
    chapter := nil.
    page := nil.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PVideoPane methods !
hasStretch

    ^self style == #stretch or: [self style == #stretchNoBorder]! !

!WindowBuilder methods ! 
setFont
	"Set the font attributes for the current widget"

	self invoke: WBFontSelectionWindow.! !

!WBPrimaryModelInitializeModule methods !
defaultComment
    "Answer the default comment string."

    ^'Initialize the model to a ', self object primaryModel class name, '.
        Remove the #generated tag before modifying this method.
        (Generated by WindowBuilder Pro)'! !

!WBBitmapManagerWindow methods ! 
writeBDTFile: path for: keysAndPools category: aCategory

	| poolsAndKeys stream categories |
	categories := Array with: aCategory.
	poolsAndKeys := IdentityDictionary new.
	keysAndPools do: [:each |
		(poolsAndKeys at: each value ifAbsentPut: [SortedCollection new])
			add: each key].
	stream := File newFile: path.
	[	stream nextPutAll: 'BITMAPS'; cr.
		poolsAndKeys associationsDo: [:each |
			each key
				fileOutBDTKeys: each value
				categories: categories
				on: stream.
	]] ensure: [stream close].! !

!WBLayoutForm methods ! 
isLeftButton

	^(self propertyAt: #buttonUsed) == #left! !

!WBAbstractCodeModule methods !   
generateGeneratedSymbol
	"Private - Generate the method body."

	self stream cr.
	self generatedSymbol wbStoreOn: self stream.
	self stream endExpression.! !

!MetaClass methods !
isScratchWindow

    #addedByOSI.
    ^self instanceClass isScratchWindow! !

!WindowBuilder class methods ! 
reset

    WBLookPolicy purgeCache.
    self
        initializePrivateProperties;
        initializePropertiesAddIns;
        cleanUpScratchClasses;
        clearWBClasses;
        updateForMDI.! !

!WBEventManagerWindow methods !  
widgetSelected
    "Answer the currently selected widget if exactly one is selected,
        else answer nil."

    ^self widgetSelections size = 1
        ifTrue: [self widgetSelections first]
        ifFalse: [nil]! !

!WindowBuilder methods ! 
getEditedClass

	^WBEditClassDialog new open selectedClass! !

!WBBitmapManagerWindow methods !   
menuOptionSameValueForAllCategories

	self sameValueForAllCategories: self sameValueForAllCategories not.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPoolManagerWindow methods ! 
menuKeyDelete

    "Callback for the menu item titled 'Delete'.
     (Generated by WindowBuilder)"

	| msg |
	self selectedKeysAndPools isEmpty ifTrue: [^self].
	msg := self selectedKeysAndPools size = 1
		ifTrue: [ 'Delete the key named ', self selectedKeysAndPools first key, '?' ]
		ifFalse: [ 'Delete ', self selectedKeysAndPools size printString, ' keys?' ].
	(MessageBox confirm: msg) ifFalse: [^self].
	[self menuKeyDelete: self selectedKeysAndPools]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].! !

!WBScratchWindow methods ! 
when: anEvent perform: aSelector
    "Scratch windows should not perform any events"! !

!WBGraphicObject methods !
fullCopy

	| copy |
	copy := self class new.
	self wbCopyTo: copy.
	^copy! !

!WBAbstractCodeModule methods !  
object: anObject
		"Set the receiver's object."
	object := anObject.! !

!WindowBuilder methods ! 
useDirectSelect

    ^self class useDirectSelect! !

!WBTreeNode methods !
childAfter: aChild

    ^children after: aChild ifNone: [ nil ]! !

!PButtonListBox methods ! 
suggestedSize
    | stringOffset |
    ^(self contents isNil or: [self contents isEmpty])
        ifTrue: [super suggestedSize]
        ifFalse: [
            stringOffset := (self propertyAt: #stringOffset) ifNil: [0].
            (self contents inject: 0 into: [:max :item |
                max max: (self font wbStringWidth: item)]) + 8 + self lookPolicy scrollBarWidth + stringOffset
            @ ((self font height * self contents size + 8) min: self parent contentRect height)]! !

!WBFramingEditor methods ! 
initWindow

    self
            initializeOnFramer: framingParameters
            rects: currentRectList
            parentRect: parentRect.
    afterRect bringToTop.! !

!WBDescriptor methods !   
commonName
    "Answer the value of commonName."

    ^commonName! !

!WBUndoRedoDialog methods !
undoManager

	^undoManager! !

!WBCreateViewsModule methods ! 
views
		"Answer the object's views."
	^self object windows! !

!WBStatusPaneEditor methods !  
insert

    | index box |
    index := list selection.

    box := (Smalltalk at: #StatusBox) new
        name: '';
        width: 10;
        space: 7;
        contents: '';
        yourself.

    index isNil ifTrue: [
        boxes add: box.
        index := boxes size.
    ] ifFalse: [
        boxes add: box afterIndex: index.
        index := index + 1.
    ].
    list
        contents: (boxes collect: [ :each | each name asString ]);
        selection: index.

    (self paneNamed: 'name') contents: ''.
    (self paneNamed: 'width') contents: '10'.
    (self paneNamed: 'space') contents: '7'.
    (self paneNamed: 'contents') setContents: ''.

    self updateBoxes.! !

!WBDescriptor methods !
printOn: aStream

    self printOn: aStream indent: ''! !

!WindowBuilder methods !   
updateMenuOptions

	(self menuTitled: 'Options') updateToggled.! !

!WBAttributeEditor methods !  
nlsKeyFor: aString

    | nlsKey nlsText |
    nlsText := aString.
    thePane parent nlsPools notEmpty
        ifTrue: [
            thePane parent nlsPools detect: [:sym |
               (nlsKey := (Smalltalk at: sym)
                    keyAtValue: aString
                    ifAbsent: [nil]) ~~ nil] ifNone: [].
            nlsKey notNil
                ifTrue: [nlsText := '#', nlsKey]].
    ^nlsText! !

!WBTabOrderEditor methods !  
initWindow

	(self paneNamed: 'scrollingForm') resize: self mainView rectangle.
	removeGroupButton disable.
	self 
		setFirstStatus;
		setIncludeOuter.! !

!WBPoolManagerWindow methods !
preInitMenus
	"Add addition menu items here."

	self poolMenu removeItemDynamically: 'File out separately...'.
	poolListBox getPopupMenu removeItemDynamically: 'File out separately...'.
	self updateOptionMenu.! !

!PScrollBar methods !
minimum

    ^minimum! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBModelDefinitionEditor methods ! 
renameModel

    | newName |
    selectedModel ifNil: [^nil].
    (newName := Prompter
        prompt: 'Enter new name for model class [', selectedModel name, ']:'
        default: selectedModel name) ifNil: [^nil].
    newName ~= selectedModel name
        ifTrue: [
            selectedModel rename: newName.
            self loadModels.
            models selectItem: selectedModel].! !

!WindowBuilder class methods !
logScratch
    "Answer true if scratch window methods should be logged to the change log."

    ^self editorClass
        propertyValueAt: #LogScratch
        category: self codeGenerationPropertyString! !

!WBAbstractCodeModule methods ! 
comment
		"Answer the comment string."
	^comment ifNil: [ self defaultComment ]! !

!WindowBuilder class methods !
clearProperties
    "Clear the Property dictionary"
    " WindowBuilder clearProperties "

    Properties := nil.! !

!WBAbstractCreateViewsModule methods !
initVarNames
		"Private - Initialize the variable names."
	super initVarNames.
	self
		varNameFor: #target ifAbsentPut: [ self defaultTargetName ];
		varNameFor: #owner ifAbsentPut: [ self defaultOwnerName ].! !

!WBLayoutFrameEditor methods !
attachLeftTopRight

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: #(0 0 1 0).! !

!WBUndoManager methods !   
setUndoLabel: aString

    undoMenu
        changeItem: #undo
        label: aString replaceEscapeCharacters , (String with: Tab) , 'Ctrl+Z'! !

!WBEnhancedEntryFieldEditor methods !  
getCharacter: aPane

    | list |
    list := OrderedCollection new.
    list
        add: self noneString;
        addAll: thePane realClass okCharacterMethods.
    aPane contents: list! !

!Menu methods !   
asWBPMenu
         "Private - WBPro Development."
    #addedByOSI.
    ^self asPMenuItem! !

!WBTargetObject methods !   
prototype

	^self owner! !

!WBScrollingPane methods !
firstChild

    children isNil ifTrue: [
        ^nil
    ].

    ^children values asArray first! !

!WBBasicCodeModule methods ! 
sourceString
	"Return the source string."

	^sourceString! !

!WBStatusPaneEditor methods !  
copy

    | index |
    index := list selection.
    index isNil ifTrue: [ ^nil ].
    clipboard := boxes at: index .
    (self paneNamed: 'paste') enable.! !

!WindowBuilder methods !  
preInitWindow

	self class licensed
		ifFalse: [self class buyACopy].
	scrollingForm addSubpane: self createLayoutForm.
	self updateLayoutProperties.
	self buildMenus.
	(self menuTitled: 'Edit')
		accelKey: BackspaceKey accelBits: AfAlt | AfVirtualkey for: #undo;
		accelKey: DeleteKey accelBits: AfShift | AfVirtualkey for: #cutSelections;
		accelKey: InsertKey accelBits: AfChar | AfControl for: #copySelections;
		accelKey: InsertKey accelBits: AfShift | AfVirtualkey for: #pasteSelections.
	self icon: self class wbIcon.
	"Set the default font for all the controls"
	self mainView children do: [:child |
		child font: self class wbDefaultFont].
	"Add parts support if installed."
	self class partsSupportEnabled
		ifTrue: [
			attributeBar
				dragSource;
				dragSessionClass: (Smalltalk at: #PARTSCatalogDragSession) " PARTSAddPartSession ";
				when: #dragSourceNeedsObject: send: #dragPart: to: self.
			self layoutForm
				dragSource;
				dragSessionClass: (Smalltalk at: #PARTSCatalogDragSession) " PARTSAddPartSession ";
				when: #dragSourceNeedsObject: send: #dragPart: to: self].
	(status statusBoxAt: #time)
		width: (self editorFont stringWidth: '00:00 AM') + 8.
	(self paneNamed: 'styleButton') hideWindow.! !

!WBLookPolicyWin95 methods !   
drawMenuBar: aFrameObject with: aPen in: aRect

    | menuRect xPos yPos space |
    aFrameObject menu notNil
        ifTrue: [
            menuRect := (aRect leftTop down: (self titleBarHeightFrom: aFrameObject))
                extentFromLeftTop: aRect width @ self menuBarHeight.
            aPen fill: menuRect color: Color gray.
            xPos := menuRect left right: 6.
            yPos := menuRect origin y down: 2.
            space := aPen stringWidthOf: '   '.
            aPen
                font: self menuFont;
                foreColor: Color menuText;
                setBackgroundModeTransparent.
            aFrameObject menu allTitles do: [:title |
                aPen winDrawText: title at: xPos @ yPos.
                xPos := xPos right: (aPen stringWidthOf: title) + space].
            aPen setBackgroundModeOpaque].! !

!PGroupbox methods !  
mutationTypes

    ^#(#GroupBox #CP3DFrame #StaticBox)! !

!Object methods !  
wbInstVarMap
	"Answer a dictionary mapping inst var names to
		inst vars that are valid targets."

	| avoid names answer |
	avoid := self wbReservedInstVarNames.
	names := self class allInstVarNames.
	answer := Dictionary new.
	names do: [:each |
		(avoid includes: each) ifFalse: [
			answer at: each put: (
				self instVarAt: (names indexOf: each)) wbWrapper]].
	^answer! !

!WBCodeStream methods !   
nextPutPoolKey: aKey in: aPoolName
	"Store the reference to the pool key."

	self owner targetClass isScratchWindow ifTrue: [
		(self owner targetClassDefinition poolNames includes: aPoolName) ifFalse: [
			^self nextPutPool: aPoolName atKey: aKey]].
	self nextPutAll: aKey.
	self owner targetClassDefinition addPoolNamed: aPoolName.! !

!WBLayoutForm methods !
notifyModelOfShellSizeChange: aRectangle

    self triggerEvent: #changed.
    self model isNil
        ifFalse: [self model updateSize: aRectangle].! !

!WBLookPolicyWin31 methods !  
minimizeButtonSize

    ^self titleBarHeight asPoint! !

!WindowBuilder methods ! 
menuToolsInspectColorConstants

    ColorConstants inspect! !

!WBPoolManagerWindow methods ! 
valueStringAt: aKey in: aCategory pool: aPool
	"Answer the value to be displayed."

	aKey isNil | aCategory isNil | aPool isNil ifTrue: [^nil].
	^(aPool at: aKey in: aCategory ifAbsent: [^'']) printString! !

!WindowBuilder methods !   
menuToolsInitializeProperties

    self class initializeProperties.! !

!WBTreeNode methods ! 
copy

	^super copy
		setListString: listString wbManagedValue;
		yourself! !

!PDrawnButton methods !   
attributeEditor

    ^WBFileSelectorEditor
        titled: 'Select Bitmap File'
        filters: #('*.BMP')
        descriptions: #('Bitmap Files (*.BMP)')! !

!WBLayoutForm methods !
initializeCompositePane

    | newWidgets boundingBox |
    newWidgets := self clipboard collect: [:widget |
        widget wbCloneWithParent: self shell].
    boundingBox := self boundingBoxFor: newWidgets.
    self model setWindowSize: boundingBox extent + 2.
    (self
        placeNewWidgets: newWidgets
        at: self shell frameContentRect leftTop;
        createUndoRedoForNewWidgets: newWidgets
            oldWidgets: #()
            named: 'Initialize Composite')
            redoAction value.! !

!WindowBuilder methods ! 
textLabel

	^titleText! !

!Behavior methods !
wbFullCopyReal: aDictionary
	"Answer a copy of the receiver which shares
		 the receiver instance variables.  Because
		 the receiver is unique (cannot be copied),
		 answer the receiver."

	#addedByOSI.
	^self! !

!PButton methods !
importantEvents

    ^super importantEvents
        addFirst: #clicked;
        yourself! !

!WBPMenu methods ! 
allSelectors

    | allSelectors newSelectors |

    allSelectors := Dictionary new.

    children do: [ :m |
        newSelectors := m allSelectors.
        newSelectors keysDo: [ :k |
            allSelectors at: k asSymbol put: (newSelectors at: k).
        ].
    ].

    ^allSelectors.! !

!WBBitmapManagerWindow methods !
keyValueRatio
	"Answer the split ratio for displaying key and values."

	^3/4! !

!WBCreateViewModule methods !  
viewIndex: anInteger
		"Set the receiver's selector index."
	viewIndex := anInteger.! !

!WBLayoutForm methods !  
wbMinSize

    ^self wbEditorClass minWindowSize! !

!WBTreeListBox methods ! 
initialize

    super initialize.
    list := WBTreeNode new.
    noSelect := false.! !

!WBLayoutForm methods !
notifyModelOfSizeOrPositionChange: aRectangle

    self triggerEvent: #changed.
    self model isNil
        ifFalse: [
            self model newSizeOrPosition: 
                ((self shell contentLeftTop distanceRightAndDown: aRectangle topLeft) 
                    extentFromLeftTop: aRectangle extent)].! !

!WindowBuilder methods !   
openDialog

	self editedClass: WBDialogScratchWindow.
	self open.! !

!WindowBuilder methods !   
setWindowSize: aPoint

	(self 
		createUndoRedoForNewWindowSize: aPoint 
		oldSize: self shell extent)
		redoAction value! !

!WBLookPolicyWin95 methods ! 
borderWidthFrom: aFrameObject

    ^(aFrameObject hasTitleBar or: [aFrameObject style includes: #sizable])
        ifTrue: [
            aFrameObject isDialog
                ifTrue: [self frameWidthDialog]
                ifFalse: [self frameWidthSizable]]
        ifFalse: [self frameWidthBorder].! !

!WindowFrameObject methods ! 
usesFont

     ^false! !

!PScrollBar methods !   
importantEvents

    ^super importantEvents
        addFirst: #changed:;
        add: #end;
        add: #home;
        add: #nextLine;
        add: #nextPage;
        add: #previousLine;
        add: #previousPage;
        yourself! !

!WindowBuilder class methods !   
initializePropertiesAddIns

    self addInModuleClass modulesModifyingProperties do: [:module |
        module modifyProperties: Properties].
! !

!WBPoolManagerWindow methods !   
menuKeyNew

    "Callback for the menu item titled 'New...'.
     (Generated by WindowBuilder)"

	| newKey |
	newKey := Prompter prompt: 'Enter new key' default: self defaultNewKey.
	newKey isNil ifTrue: [^self].
	newKey := self checkNewKey: newKey.
	newKey isNil ifTrue: [^self].
	self menuKeyNew: (Array with: newKey).! !

!WindowFrameObject methods ! 
defaultBackColor

    ^(self realClass isNil or: [self isDialog])
        ifTrue: [Color dialogBackground]
        ifFalse: [Color windowBackground].! !

!StylePropertyAccessor methods !  
wbDefaultAddStyleAction

	#addedByOSI.
	^#addStyle:! !

!WBLayoutForm methods !  
handleSize

	^WBHandle handleSize! !

!WBModelDefinitionEditor methods !  
setName: aString

    | selectedItem |
    name disabled ifTrue: [^self].
    selectedItem := attributes selectedItem ifNil: [^nil].
    selectedItem name = aString ifTrue: [^self].
    selectedItem name: aString asSelectorToken.
    attributes
        contents: attributes contents;
        selectItem: selectedItem.
    self setDirty.! !

!WBGraphicObject methods !   
frameRelativeRectangle

    ^rect! !

!WBAbstractAddInModule class methods !  
loaded
    "Answer the value of loaded."

    ^loaded ifNil: [loaded := false].! !

!WindowBuilder methods ! 
tryToSaveChanges

    (self isDirty or: [self editedClass isScratchWindow])
        ifTrue: [
            self autoSave
                ifFalse: [
                    (MessageBox confirm: 'Your window needs to be saved first.  Save and continue?')
                        ifFalse: [^nil]].
            CursorManager execute change.
            self generateApplicationCode isNil
                ifTrue: [
                    CursorManager normal change.
                    ^nil].
            cleanedOutCode := true.
            CursorManager normal change].
    (self editedClass isScratchWindow) & (cleanedOutCode = false) & (self isDirty not)
        ifTrue: [
            self inENVY
                ifFalse: [self editedClass resetToDefault].
            cleanedOutCode := true].! !

!PTextEdit methods !
preferredLabelOrientation

    ^#top! !

!WBGeometryManager methods ! 
collectBackward: targets
    "Collect the <targets> backward in the z-order"

    | index collection |
    targets size > 1 ifFalse: [^self].
    targets size == self children size
        ifTrue: [^self sendToBack: targets].

    index := self children indexOf: targets last.
    collection := self children select: [:child |
        (self children indexOf: child) < index
        and: [(targets includes: child) not]].
    collection
        addAllLast: targets;
        addAllLast: (self children select: [:child |
        (self children indexOf: child) > index
        and: [(targets includes: child) not]]).
    self sendToBack: collection! !

!PListBox methods !   
backColor

    ^backColor.! !

!WBCreateViewModule methods !  
generateIndirectDefinition: aString for: anObject
		"Private - Generate the specified definition."
	self stream
		cr;
		nextPutAll: (self varNameFor: #owner); 
		space;
		nextPutAll: (self varNameFor: anObject);
		nextPutAll: ': ';
		nextPutAll: aString;
		endExpression.! !

!WBPoolManagerWindow methods ! 
menuKeyNew: aCollection pool: aPool

	aCollection do: [:eachKey |
		self categories do: [:eachCategory |
			aPool
				at: eachKey
				in: eachCategory
				put: (
					self
						defaultValueAt: eachKey
						category: eachCategory)]].! !

!WBTemplateEditor methods !
nlsKeyFor: aString

	^aString.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowFrameObject methods !  
iconFile

    ^iconFile! !

!WBPoolManagerWindow methods !
keyValueRatio
	"Answer the split ratio for displaying key and values."

	^1/2! !

!WBClassDefinition methods !   
superclass
		"Answer the class definition superclass."
	^self classField superclass! !

!WBEventManagerWindow methods !   
menuHandlerUp

    "Callback for the menu item titled 'Up'.
     (Generated by WindowBuilder)"

	| aHandler |
	self mustHaveOneHandlerSelected ifFalse: [^self].
	(aHandler := self handlerSelected) moveUp.
	self owner updateSendField.
	handlerListBox update.
	self handlerSelected: aHandler.! !

!WindowBuilder methods !   
menuFileDefineModelObject

    self invoke: WBModelDefinitionEditor! !

!WBGeometryManager methods !  
updateWidget: aLayoutForm

    aLayoutForm
        layoutChanged;
        updateWidget: self selections;
        drawOrderSymbols.
    aLayoutForm children do: [:child |
        ((self selections includes: child) not and: [
            child wbHasWidgetAttachment])
            ifTrue: [aLayoutForm wbLayOutChild: child]].
    self owner
        setDirty;
        setSizeAndPositionForWidgets: self selections.! !

!WindowBuilder methods ! 
menuToolsCloseAllOutboards

    self outboards do: [:each | each close].! !

!WBEventManagerWindow methods !  
menuHandlerRemove

	"Callback for the menu item titled 'Remove'.
	 (Generated by WindowBuilder)"

	self handlerSelections do: [:each | each remove].
	self owner updateSendField.
	self widgetListUpdate.! !

!WBTreeListBox methods !   
deleteAll
        "Private - Delete the whole list in the control.
         Subclassed by OSI to avoid anticipated later conflicts."

    self isHandleOk ifFalse: [^self].

    UserLibrary sendMessage: handle
        msg: LbResetcontent
        wparam: 0
        lparam: 0! !

!WBAddInManager class methods !   
isWBInternalClass

    ^true! !

!Object class methods !  
defaultCodeModuleClass
        "Answer the default code module for the receiver."
    ^nil! !

!PButtonListBox methods !  
setStyleFrom: aRealStyle
    "Do Nothing"! !

!PButton methods !   
suggestedSize

    ^((self contentsStringWidth + 20) * self autoSizeRatio) rounded @ (self font height + 14).! !

!WBScrapbookRetrieve methods !  
page
    ^page! !

!WBLayoutForm methods ! 
useDirectSelect
    "Answer the value of useDirectSelect."

    ^useDirectSelect ifNil: [false]! !

!WBCreateClassDialog methods !   
informUserOfNoApplicationChoices

    MessageBox message: 'There are no (sub) application editions into which you can save your class. This could be because either there are no applications that are editions OR that you are not a group member of any application that is an edition OR that WindowBuilderProRuntime is not a prerequisite of any application that is an edition. Please correct this situation before continuing.'.
    self close.! !

!WBLayoutFrameEditor methods !  
fields

	^Array
		with: leftAttachField
		with: topAttachField
		with: rightAttachField
		with: bottomAttachField! !

!WBEventManagerWindow methods ! 
toFieldExtensions

	^self class toFieldExtensions! !

!WBInterfaceObject methods !
displayGenericWith: aPen clipRect: clipRect

    | aName region  |
    aName := ('AEIOU' includes: self realClass name first)
        ifTrue: ['An ', self realClass name]
        ifFalse: ['A ', self realClass name].
    self lookPolicy
        displayWithBorder: aPen
        rect: self rect
        backColor: self backColor.
    region := aPen setClipRect: ((rect insetBy: 1) intersect: clipRect).
    aPen
        setBackgroundModeTransparent;
		setTextAlign: WBDisplayContext defaultTextAlign;
        foreColor: Color white;
        backColor: self backColor;
        centerWinText: aName
	        at: (rect center rightAndDown: 1);
        foreColor: Color black;
        centerWinText: aName
	        at: rect center;
        destroyRegion: region.! !

!WBInterfaceObject methods !  
storeOn: aStream indentString: indentString

	| spaceString |
	spaceString := indentString.
	self storeRectOn: aStream indentString: spaceString.
	self storeStyleOn: aStream indentString: spaceString.
	self storeContentsOn: aStream indentString: spaceString.
	self storeColorOn: aStream indentString: spaceString.
	self generateTabStopsAndGroups
		ifTrue: [
			aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'startGroup'.
			(self usesFocus & self tabPosition notNil)
				ifFalse: [
					aStream nextPutAll: ';'; cr; nextPutAll: spaceString, #noTabStop]]
		ifFalse: [
			aStream nextPutAll: ';'; cr; nextPutAll: spaceString, #noTabStop].
	self menu notNil
		ifTrue: [
			self genReceiveWindowMessagesOn: aStream indentString: spaceString.
			aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'setPopupMenu: ('; cr.
			self menu storeOn: aStream indentString: spaceString, '	'.
			aStream cr; nextPutAll: spaceString, ')'].
	self usesFont
		ifTrue: [
			aStream
				endMessage;
				cr;
				nextPutAll: spaceString;
				nextPutAll: #font: ;
				space;
				nextPutFont: self font indentString: spaceString].
	self storeSpecificsOn: aStream indentString: spaceString.! !

!WBRGBColorDialog methods !   
ok
    result := elements.
    self close! !

!WindowBuilder class methods !  
useLayoutFrame
	"Answer true if LayoutFrame should be used in code generation."

	Smalltalk at: #FramingParameters ifAbsent: [^true].
    ^self editorClass
        propertyValueAt: #UseLayoutFrame
        category: self codeGenerationPropertyString! !

!WBListEntryField methods !  
textChanged
        "Private - handle the changing of text contents."
	super textChanged.
	self setPopupMenu: nil.
	owningListBox editBoxTextChanged.! !

!WBPoolManagerWindow methods !
categoryPathNeedsContents: aPane

    "Callback for the #needsContents event triggered in the EntryField named 'categoryPathField'.
     (Generated by WindowBuilder)"

	| aString labelPane |
	labelPane := self paneNamed: 'categoryPathLabel'.
	(aString := self categoryPath) notNil
		ifTrue: [
			aPane enable.
			labelPane wbGrayEnable.
			aPane contents = aString ifFalse: [
				aPane contents: aString]]
		ifFalse: [
			aPane disable.
			labelPane wbGrayDisable.
			aPane contents: ''].! !

!WBPool methods !  
fileOutHeaderOn: aStream
	"File out the receiver's header."! !

!WBLookPolicy methods !
menuBarHeightFrom: aFrameObject

    ^aFrameObject menu notNil
        ifTrue: [self menuBarHeight]
        ifFalse: [0]! !

!WBLookPolicyWin31 methods !   
drawVerticalScrollBar: aScrollBar with: aPen clipRect: clipRect

    self drawVScrollBarWith: aPen at: aScrollBar rect.! !

!WBCodeGenerator methods !
classDefinitionFor: aClass
		"Answer the class definition for aClass."
	^self classDefinitions
		at: aClass instanceClass
		ifAbsentPut: [
			(WBClassDefinition on: aClass instanceClass)
				owner: self;
				yourself ]! !

!WBInterfaceObject methods !  
parent: aWBInterfaceObject

    parentWindow := aWBInterfaceObject.! !

!WBPMenuItem methods !
action

    (selector isNil or: [ (selector isMessage) not or: [ selector receiver isNil ]]) ifTrue: [
        ^nil
    ] ifFalse: [
        selector receiver isWBAction ifTrue: [
            ^selector receiver script asString
        ] ifFalse: [
            ^nil
        ].
    ]! !

!WBLookPolicy methods ! 
frameWidthBorder

    ^1! !

!WindowBuilder methods ! 
menuOptionsZoomLayout

    | isZoomed |
    isZoomed := self scrollingForm zoomed.
    (self menuTitled: 'Options')
        changeItem: #menuOptionsZoomLayout
        label: (isZoomed
            ifTrue: ['\uZoom Layout\tAlt+Z' replaceEscapeCharacters]
            ifFalse: ['Un\uzoom Layout\tAlt+Z' replaceEscapeCharacters]).
    self scrollingForm zoom.! !

!WBTabOrderLayoutForm methods !
setByZOrder

	| tabPosition |
	self removeGroupingPanes.
	self groups: Dictionary new.
	tabPosition := WBTabPosition fromTabPosition: 1.
	(self children select: [:widget | 
		widget isGrouper not 
		and: [widget usesFocus 
		and: [widget staysToBack not]]]) do: [:widget |
			widget tabPosition: tabPosition.
			tabPosition := tabPosition nextTabPosition].
	self setSmartGroups.! !

!WBScrapbookStore methods !  
isQuick

    ^isQuick! !

!FrameObject methods !  
contentLeftTop

    ^self frameLeftTop rightAndDown:
		(self frameRect leftTop distanceRightAndDown: self contentRect leftTop)! !

!WBInterfaceObject methods !  
resetColors
	"Deal with color changes from the control panel"
	backColor isInteger
		ifFalse: [self backColor: self defaultBackColor].
	self foreColor isInteger
		ifFalse: [self foreColor: self defaultForeColor].! !

!WBTabOrderEditor methods !   
setGroup

	self setStatus: 'Tabbing group added.'! !

!WBActionEditor methods !   
methodChanged: aString

    aString trimBlanks = method ifTrue: [
        (self paneNamed: 'add')
            contents: '&Change';
            disable.
        (self paneNamed: 'authorField') setContents: author.
    ] ifFalse: [
        (self paneNamed: 'authorField') setContents:
            (Smalltalk at: #WindowBuilderUser ifAbsent: [ author ]).
        (WBAction listActions includes: (self paneNamed: 'nameField') contents) ifTrue: [
            (self paneNamed: 'add')
                contents: '&Change';
                enable.
        ] ifFalse: [
            (self paneNamed: 'add')
                contents: '&Add';
                enable.
        ].
    ].
    changed := true.! !

!PComboBox methods !   
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	(#(#changed: #clicked: #doubleClicked:) includes: eventSymbol)
		ifTrue: [^#('selectedItem')].
	(#(#drawFocus: #drawItem: #drawSelection: #measureItem:) includes: eventSymbol)
		ifTrue: [^#('drawIndex')].
	(#(#entered: #textChanged:) includes: eventSymbol)
		ifTrue: [^#('aString')].
	eventSymbol == #changedIndex: ifTrue: [^#('selectedIndex')].
	eventSymbol == #characterTyped: ifTrue: [^#('aCharacter')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!WBTeamVCodePolicy methods !
categoriesLabel
		"Answer the categories label."
	^self annotationManager categoriesLabel! !

!WBCreateClassDialog class methods !
isWBInternalClass

    ^true! !

!BitEditor methods ! 
addAdjacentCells: cell to: queue with: cellMatrix
    "Add adjacent cells to queue and record filled cell to
     cellMatrix."
    | adjacent |
    (cellMatrix at: cell x + 1) at: (cell y + 1) put: cell.
    adjacent := cell + (0 @ 1).
    ((copy boundingBox containsPoint: adjacent) and: [
        ((cellMatrix at: adjacent x + 1) at: adjacent y + 1) isNil])
            ifTrue: [
                queue add: adjacent].
    adjacent := cell - (1 @ 0).
    ((copy boundingBox containsPoint: adjacent) and: [
        ((cellMatrix at: adjacent x + 1) at: adjacent y + 1) isNil])
            ifTrue: [
                queue add: adjacent].
    adjacent := cell - (0 @ 1).
    ((copy boundingBox containsPoint: adjacent) and: [
        ((cellMatrix at: adjacent x + 1) at: adjacent y + 1) isNil])
            ifTrue: [
                queue add: adjacent].
    adjacent := cell + (1 @ 0).
    ((copy boundingBox containsPoint: adjacent) and: [
        ((cellMatrix at: adjacent x + 1) at: adjacent y + 1) isNil])
            ifTrue: [
                queue add: adjacent]! !

!WBInterfaceObject methods ! 
usesForeColor

    ^true! !

!WBTemplateEditor methods !  
outboards

	^OrderedCollection new! !

!WBCompositePaneModule methods !   
generateTemporaries: aCollectionOfTempNames
        "Private - Generate the temporary variables."
    aCollectionOfTempNames isNil ifTrue: [ ^self ].
    aCollectionOfTempNames isEmpty ifTrue: [ ^self ].
    self stream
       cr;
        nextPut: $| ;
        space.
    aCollectionOfTempNames asSortedCollection do: [ :eachTempName |
        self stream
            nextPutAll: eachTempName;
            space ].
    self stream nextPutNoWrap: $|.! !

!WBAbstractAddInModule class methods !
comment

	^nil! !

!WBListChooser methods !   
ok: ignore

    self ok! !

!WBInterfaceObject methods !  
contents: anObject

	anObject notNil 
		ifTrue: [contents := anObject wbManagedValueFor: self].! !

!WBMethodStubModule methods !
createMethod
	"Private - Create the method."

	self methodExists ifFalse: [super createMethod].! !

!WBLookPolicyOS2 methods !   
drawSystemMenuWith: aPen at: aRect

    | innerRect |
    innerRect := self draw3DBoxWith: aPen at: aRect.
    aPen
        foreColor: Color black;
        wbLineFrom: (innerRect leftTop rightAndDown: (5 - Rectangle leftTopUnit y) @ 5) to: (innerRect center rightAndDown: Rectangle leftBottomUnit y);
        wbLineFrom: (innerRect rightTop leftAndDown: (5 + Rectangle leftBottomUnit y) @ 5) to: (innerRect center leftAndDown: Rectangle leftBottomUnit y);
        wbLineFrom: (innerRect leftTop rightAndDown: (6 - Rectangle leftTopUnit y) @ 5) to: (innerRect center rightAndUp: Rectangle leftBottomUnit y @ Rectangle leftTopUnit y);
        wbLineFrom: (innerRect rightTop leftAndDown: (6 + Rectangle leftBottomUnit y) @ 5) to: (innerRect center leftAndUp: Rectangle leftBottomUnit y @ Rectangle leftTopUnit y);
        wbLineFrom: (innerRect leftBottom rightAndUp: 5) to: (innerRect rightBottom leftAndUp: (5 + Rectangle leftTopUnit y) @ 5)! !

!Bitmap class methods ! 
screenWidth8: w height: h
	"Answer a new screen Bitmap with width w and height h."

	#addedByOSI.
	^self new screenWidth8: w height: h! !

!WBPrototype methods !   
owner

	^owner! !

!WBDevelopmentWindow methods ! 
updateAttributePalette: palette for: currentWidget 
	"Update the attribute palette"

	self
		updateFontButton: palette for: currentWidget;
		updateColorButton: palette for: currentWidget;
		updateFramingButton: palette for: currentWidget;
		updateMenuButton: palette for: currentWidget;
		updateOtherButton: palette for: currentWidget.
! !

!WBModelCodeModule methods !  
initToBeRemoved

    | removed instVar |
    toBeRemoved := Set new.
    removed := self targetClass instVarNames reject: [:instVarName |
        self targetClassDefinition instVarNames includes: instVarName].
    removed do: [:instVarName |
        (self targetClass allMethodsReferencingInstVar: instVarName) do: [:cm |
            (self instVars first okToGenerateMethod: cm selector)
                ifTrue: [toBeRemoved add: cm selector]].
        instVar := WBModelInstVar new name: instVarName.
        toBeRemoved
            add: instVar methodNameForBasicSet asSymbol;
            add: instVar methodNameForGet asSymbol;
            add: instVar methodNameForSet asSymbol;
            add: instVar methodNameForTriggeredEvent asSymbol].! !

!WBEventHandlerStubModule methods !   
defaultComment
	"Answer the default comment string."

	^'Callback for the #' , self event asString ,
		' event in ' , self source wbNameAndClass, '.
		(Generated by WindowBuilder Pro)'! !

!PDrawnButton methods !   
winClassStyle

    ^BsOwnerdraw! !

!WBDescriptor class methods ! 
name: aString commonName: aString2 comment: aString3 flags: anArray

    ^(self
            name: aString
            commonName: aString2
            comment: aString3)
            flags: anArray;
            yourself! !

!WBPrimaryModelOpenOnModule methods ! 
defaultMessageArguments

    ^Array with: (self object primaryModel class name first isVowel
        ifTrue: ['an', self object primaryModel class name]
        ifFalse: ['a', self object primaryModel class name]).! !

!WBLayoutFrameEditor methods !   
setLeftAttach: aString

    | ratio |
    aString = self proportional ifTrue: [
        ^self currentFramingBlocks do: [:each |
            each wbLeftProportional: true]].
    ratio := self class horizontalRatioStrings keyAtValue: aString ifAbsent: [
        aString isNumber
            ifTrue: [ratio := aString asRational]
            ifFalse: [ratio := ((self compilerEvaluate: aString) ifNil: [^self]) asRational]].
    self currentFramingBlocks do: [:each |
        each wbLeftProportional: false.
        each leftRatio: ratio].! !

!WBLookPolicyWin31 methods !   
drawComboBox: aComboBox with: aPen clipRect: clipRect

    | style rect aRect bottomRect buttonWidth topRect
     backColor theBackColor list region newPoint |
    style := aComboBox style.
    rect := aComboBox rect.
    backColor := (self class isDefault not
        and: [(self asRGBColor: aComboBox backColor) = (self asRGBColor: aComboBox defaultBackColor)])
        ifTrue: [self defaultWidgetBackColor]
        ifFalse: [backColor].
    theBackColor := style == #dropDownList
        ifFalse: [Color white]
        ifTrue: [aComboBox backColor].
    buttonWidth := self scrollBarWidth.
    aRect := (rect right left: buttonWidth) @ rect top
        extentFromLeftTop: buttonWidth @ (aComboBox font height + 8).
    topRect := style == #dropDown
        ifTrue: [
            topRect := (rect leftTop extentFromLeftTop: rect width @ aRect height).
            aPen fill: (topRect insetBy: 1@0) color: aComboBox backColor.
            rect leftTop extentFromLeftTop: (rect width - buttonWidth - 7) @ aRect height]
        ifFalse: [
            style == #dropDownList
                ifTrue: [rect leftTop extentFromLeftTop: (rect width - buttonWidth) @ aRect height]
                ifFalse: [rect leftTop extentFromLeftTop: rect width @ aRect height]].
    aPen drawRectangle: topRect;
        fill: (topRect insetBy: 1) color: Color white.
    style == #dropDownList
        ifTrue: [
            aPen drawRectangle: topRect;
                fill: (topRect insetBy: 2) color: theBackColor].
    style == #simpleList
        ifTrue: [
            bottomRect := (rect left right: 8) @ (rect top down: aRect height - 1) rightBottom: rect rightBottom.
            "Must be an increment of font height"
            bottomRect := bottomRect leftTop extentFromLeftTop:
                (bottomRect width @ ((bottomRect height - 2 truncateTo: aPen font height)+2)).
            aPen rectangle: bottomRect;
                fill: (bottomRect insetBy: 1) color: theBackColor.
            list := self contents.
            list isNil
                ifFalse: [
                    aPen font: aComboBox font.
                    region := aPen setClipRect: (bottomRect insetBy: 1@1).
                    newPoint := (bottomRect insetBy: 3@1) leftTop.
                    1 to: list size do: [:i |
                        aPen displayText: (list at: i) at: newPoint.
                        newPoint := newPoint down: aPen font height].
                    aPen destroyRegion: region]]
        ifFalse: [
            self drawDownArrowWith: aPen at: aRect.
            aPen
                foreColor: Color black;
                wbLineFrom: (aRect center leftAndDown: 3@5) to: (aRect center rightAndDown: (4 - Rectangle leftTopUnit y) @ 5)].! !

!WindowBuilder methods !  
has3orMoreSelections

    ^self selections size > 2! !

!WBMenuTester methods !   
preInitWindow

    | mw |

    mw := MenuWindow new.
    menus notNil ifTrue: [
        menus do: [ :m |
            m allOwners: self.
            mw addMenu: m.
        ].
    ].

    mw owner: self.

    self mainView menuWindow: mw.! !

!WBEventHandlerStubModule methods !  
source: anObject

	source := anObject.! !

!WBPoolManagerWindow methods ! 
menuPoolNew

    "Callback for the menu item titled 'New...'.
     (Generated by WindowBuilder)"

	| newPoolName existingPoolName |
	newPoolName := Prompter
		prompt: 'Enter name of new pool'
		default: ''.
	newPoolName isNil ifTrue: [^self].
	[	(existingPoolName := newPoolName asExistingSymbolOrNil) notNil ifTrue: [
			(self poolManager poolFor: existingPoolName) isNil ifTrue: [
				(Smalltalk at: existingPoolName ifAbsent: [nil]) notNil ifTrue: [
					(MessageBox confirm: 'Add existing pool named ', existingPoolName, '?') ifFalse: [^self].
					^self menuPoolAddExisting: (Array with: existingPoolName)]]].
		self menuPoolNew: (Array with: newPoolName)
	] on: WBPoolError do: [:exception | ^self menuErrorHandler: exception].! !

!WBToolBarEditor methods !
selectorFromBitmapName: aString
		"Answer a selector name from the specified bitmap."
	| answer |
	answer := aString.
	#('SysBitmap' 'Bitmap') do: [ :eachSuffix |
		(answer endsWith: eachSuffix) ifTrue: [
			answer := answer copyFrom: 1 to: answer size - eachSuffix size ] ].
	#('WB' 'CP') do: [ :eachPrefix |
		(answer beginsWith: eachPrefix) ifTrue: [
			answer := answer copyFrom: eachPrefix size + 1 to: answer size ] ].
	^answer asSuggestedUnarySelectorToken! !

!WindowBuilder class methods !
useClassHierarchyBrowser

    ^self editorClass
        propertyValueAt: #UseClassHierarchyBrowser
        category: self editorPropertyString.! !

!WBLayoutForm methods ! 
setCursor: aSymbol
    "Set the current cursor to the one defined by <aSymbol>"

	aSymbol isNil
		ifTrue: [CursorManager normal change]
		ifFalse: [(self cursors at: aSymbol) change].! !

!WBMenubarEditor methods ! 
initWindow

    super initWindow.
    self labelWithoutPrefix: 'Menubar Editor'.! !

!WBCreateClassDialog methods !  
cacheAt: superClassSymbol

    ^cache at: superClassSymbol ifAbsent: [nil]! !

!WBNLSManagerWindow methods !  
preInitMenus

	super preInitMenus.
	self poolMenu
		appendSeparator;
		appendItem: 'Extract strings...' selector: #menuPoolExtractStrings acceleratorString: '';
		appendItem: 'Replace strings...' selector: #menuPoolReplaceStrings acceleratorString: ''.! !

!WBTargetObject methods !
handlersOrNil

	^oldHandlers! !

!WBBitmapManagerWindow methods ! 
writeRCFile: path for: keysAndPools category: aCategory ids: idMap fileNames: fileNameMap

	| sortedIds stream aBitmap |
	sortedIds := SortedCollection new.
	keysAndPools do: [:eachKeyAndPool |
		aBitmap := eachKeyAndPool value
			at: eachKeyAndPool key
			in: aCategory.
		aBitmap isOperatingSystemBitmap ifFalse: [
			sortedIds add:
				(idMap at: eachKeyAndPool key)
					=> eachKeyAndPool key]].
	stream := File newFile: path.
	sortedIds do: [:eachIdAndKey |
		OperatingSystem isOS2
			ifTrue: [
				stream
					nextPutAll: 'BITMAP  ';
					nextPutAll: eachIdAndKey key printString;
					nextPutAll: ' DISCARDABLE   ']
			ifFalse: [
				stream
					nextPutAll: eachIdAndKey key printString;
					nextPutAll: '  BITMAP DISCARDABLE   '].
		stream
			nextPutAll: (fileNameMap at: eachIdAndKey value);
			nextPutAll: '.BMP /* ';
			nextPutAll: eachIdAndKey value;
			nextPutAll: ' */';
			cr].
	stream close.! !

!PStatusPane methods !   
minSize

	^1 @ self height! !

!WindowFrameObject methods !   
hasTitleBar

    ^self style includes: #titlebar! !

!WBDialogScratchWindow methods ! 
openWindow
        "Open the dialog box modal to the
         current active window."
    self mainView open! !

!WBStatusPaneEditor methods !   
setContents: aString

    | box width |
    list selection isNil ifTrue: [ ^nil ].
    box := boxes at: list selection.
    box contents: aString.

    (self paneNamed: 'auto') selection ifTrue: [
        (self paneNamed: 'width') contents:
            (width := SysFont wbStringWidth: aString) asString.
        box width: width
    ].! !

!WBFontSelectionWindow methods !
selectedFont: aFont
	"Set the currently selected font."

	selectedFont := aFont.
	sampleGroupBox isNil ifTrue: [^self].
	aFont isFont
		ifTrue: [
			sampleGroupBox
				enable;
				contents: 'Sample (', (
					aFont == SysFont
						ifTrue: ['System Font']
						ifFalse: [aFont wbFontLongDescription]), ')'.
			sampleTextEdit
				enable;
				font: aFont]
		ifFalse: [
			sampleGroupBox
				disable;
				contents: 'Sample'.
			sampleTextEdit
				disable;
				font: SysFont].! !

!WBCreatePowerViewModule methods !  
defaultMessageSelector
		"Private - Answer the default message selector."
	^#createViewsFor:owner:! !

!PComboBox methods !   
styles

	^((self realClass ifNil: [ComboBox]) inheritsFrom: WBComboBox)
		ifTrue: [
			#(#dropDown #simpleList #dropDownList #dynamicDropDown #dynamicDropDownList)]
		ifFalse: [
			#(#dropDown #simpleList #dropDownList)]! !

!WBInterfaceObject methods ! 
isGroupBox

    ^false! !

!WindowBuilder methods !   
nlsAutosize

    ^self class nlsAutosize! !

!WBTreeListBox methods ! 
deleteSelection

    | contents |

    contents := self contents.
    owningEditBox setFocus.

    (contents asFlatList size = 1) ifTrue: [
        self contents: (
            contents
                removeChild: contents children first;
                addChild: self itemType new;
                yourself
        ).
        self wbSelectIndex: 1.
        ^self
    ].

    self performOnSelection: #delete
        selectionDelta: 0
        moveWithSelection: false.

    self selectedItem isNil ifTrue: [
        self wbSelectIndex: self contents asFlatList size.
    ].! !

!WBInterfaceObject methods !
updateManagedValues
	"Update all managed values."

	| manager |
	(manager := self contentsValueManager) notNil ifTrue: [manager updateValue].
	(manager := self fontValueManager) notNil ifTrue: [manager updateValue].
	menu notNil ifTrue: [menu update].! !

!WBLayoutFrameEditor methods !
attachLeftTop

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: #(0 0 0 0).! !

!WBMenuEditor methods ! 
shiftUp

    menuItemsEditor shiftSelectionUp.! !

!WBEventDescription methods !  
argumentNames: aCollection

	self arguments: (
		aCollection asArray collect: [:each |
			WBEventArgumentDescription new
				name: each;
				yourself]).! !

!WBTreeListBox methods ! 
editBoxTextChanged

    self selectionText: owningEditBox contents.! !

!WBDevelopmentWindow methods !
getPointPrompting: promptString defaultPoint: defaultValue

	| answer |
	(answer := Prompter prompt: promptString default: defaultValue asString) isNil
		ifTrue: [^nil].
	^answer isString
		ifTrue: [
			answer := self compilerEvaluate: answer.
			answer isNumber
				ifTrue: [answer := answer @ answer].
			answer isPoint
				ifTrue: [answer := answer max: 0@0]
				ifFalse: [
					MessageBox messageNote: 'Value must be of the form ''x @ y''.'.
					nil]].! !

!WindowFrameObject methods !
defaultStyle

    ^(self realClass notNil and: [self isDialog])
        ifTrue: [#(#sysmenu #modal #titlebar)]
        ifFalse: [#(#sysmenu #minimize #maximize #sizable #titlebar)].! !

!WBColorDialog methods !  
drawItemBack: index pane: aPane

    | c s |

	(s := colors at: index) = #default
		ifTrue: [ c :=  thePane defaultBackColor ]
		ifFalse: [ c := Color perform: s ].

    aPane pen
        fill: aPane drawBox color: Color white;
        fill: ((aPane drawBox leftTop extent: self colorBarWidth @ aPane drawBox height) insetBy: 1) color: c;
        setTextAlign: WBDisplayContext defaultTextAlign;
        font: ListFont;
        displayText: s at: aPane drawBox leftTop + ((self colorBarWidth + 5) @ 0)! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!Message methods !  
asMessage

	^self! !

!WBLayoutWizard class methods ! 
initializeStandardMenus

    ^#(
            'File'
            'Edit'
            'Window'
            'Help'
        ) asOrderedCollection! !

!PListBox methods ! 
storeSpecificsOn: aStream indentString: indentString
    "Write out the list"
    self contents isNil
        ifFalse: [
            (self contents isArray and: [self contents notEmpty])
                ifTrue: [
                    aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'contents: #( '.
                    self contents do: [:item |
                        aStream nextPutAll: item asQuotedString; space].
                    aStream nextPut: $)]].! !

!Object methods !  
wbDuplicate
	"Answer a duplicate of the receiver."

	#addedByOSI.
	^self wbDuplicateTo: (
		self class isVariable
			ifTrue: [self class new: self basicSize]
			ifFalse: [self class new])! !

!WBPoolManagerWindow methods !   
menuActiveSet: aCategory

	self poolManager activeCategory: aCategory.! !

!WBScrollingPane methods ! 
scrollTopCorner: aPoint

    self scrollTopCorner: aPoint unlimited: false.! !

!WBLayoutForm methods !   
mouseMove: aPoint
    "Moved the pointer."

    | child |
    child := self findChildFor: aPoint.
    self model isNil
        ifFalse: [
            self model setStatusForWidgets: (child isNil
                ifTrue: [nil] ifFalse: [Array with: child])].! !

!WBFontSelectionWindow methods !   
promptForFont: aFont

	^FontDialog new
		sampleFont: aFont;
		open;
		chosen.! !

!WBPoolManagerWindow methods !   
poolPath: aString
	"Set the current pool path, or nil if none."

	(self selectedPool ifNil: [^nil]) fileName: aString.! !

!PStatusPane methods !
usesFocus

    ^false! !

!WBLookPolicyOS2 methods !  
menuBarHeight

	^menuBarHeight ifNil: [
		menuBarHeight := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCymenu" 35]
			ifFalse: [super menuBarHeight]]! !

!WBLayoutForm methods ! 
initialCursorOffset

    ^Array with: 0 @ 0! !

!WBMethodStubModule methods ! 
methodExists
	"Answer true if the receiver's method already exists."

	^(self policy existingMethodFor: self) notNil! !

!WindowBuilder class methods !  
propertyAt: aSymbol ifAbsent: aBlock

    | category |
    (category := self categoryWithProperty: aSymbol) ifNil: [^aBlock value].
    ^category at: aSymbol ifAbsent: [^aBlock value].! !

!CompositeFrameObject methods !
usesMenu

    ^false! !

!WindowBuilder class methods !   
insertMenu: anArray after: menuNameString

	| menus target oc aString |
	menus := self wbMenus.
	aString := menuNameString replaceEscapeCharacters stripMnemonic.
	oc := anArray asOrderedCollectionRecursively.
	target := menus detect: [:m | 	(m at: 1) stripMnemonic = aString] ifNone: [nil].
	target isNil ifFalse: [^menus add: oc after: target].
	menus do: [:menu |
		(menu at: 3) do: [:mi |
			mi isSymbol
				ifFalse: [
					(mi at: 1) stripMnemonic = aString
						ifTrue: [^(menu at: 3) add: oc after: mi].
					(mi at: 3) isString
						ifFalse: [
							(mi at: 3) do: [:msi |
								msi isSymbol
									ifFalse: [
										(msi at: 1) stripMnemonic = aString
											ifTrue: [^(mi at: 3) add: oc after: msi]]]]]]].! !

!RadioButton class methods !   
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #turnedOff ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #turnedOn ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #clicked: ;
                argumentNames: #('labelString'));
        yourself! !

!WBEventDescription methods !   
arguments

	^self value! !

!WBLookPolicyWin31 methods !  
drawHScrollBarWith: aPen at: aRect

    | nonThumbRect |
    nonThumbRect := super drawHScrollBarWith: aPen at: aRect.
    aPen
        foreColor: Color black;
        wbLineFrom: aRect leftTop to: aRect rightTop;
        wbLineFrom: (aRect leftBottom up: 1) to: (aRect rightBottom up: 1).
    ^nonThumbRect! !

!WBPrototype methods !  
windowAt: aName

	^(windows 	select: [:window |
			window paneName = aName]) first! !

!WBListChooser class methods !
fromList: aList prompt: questionString selection: s

    ^super new fromList: aList prompt: questionString selection: s! !

!WBRGBColorDialog methods !   
selectedElement

    ^(self paneNamed: 'elementsList') selectedItem! !

!WBLayoutWizard methods ! 
browseClass

    | browser globalList global toolInterface |
    self wbEditorClass envyIsInstalled
        ifTrue: [^self sourceInstance class edit].
    (self wbEditorClass teamIsInstalled and: [self wbEditorClass useClassHierarchyBrowser not xor: Notifier isAltKeyDown])
        ifTrue: [
            browser := (toolInterface := Smalltalk at: #ToolInterface) current subsystemBrowserClass openHierarchyOn: toolInterface currentSubsystem.
            globalList := browser globalList.
            global := globalList subsystem definitionOfGlobalNamed: sourceInstance class symbol.
            globalList selectionHolder value: global.
            globalList container packageList module: global package.
            browser classEditor categoryList category: '** all **']
        ifFalse: [
            (self activateClassBrowserOnClass: sourceInstance class) isNil
                ifTrue: [
                    (Message
                        receiver: ClassHierarchyBrowser new open
                        selector: #wbFindClass:
                        arguments: (Array with: sourceInstance class symbol)) performDeferred]].! !

!WBAbstractAddInModule class methods !
modifyPalette: thePalette
    "Modify the palette"! !

!WBScrapbookRetrieve methods !  
removedQuick

    ^removedQuick! !

!WBPoolEditorCompositePane methods !  
updateEditorValue

	self updateValue.! !

!WBGraphicObject methods !  
wbSuggestedTempName
		"Answer the suggested temporary variable name used in code generation."
	^self realClass name! !

!WBCreateButton methods ! 
windowTitle

	^'Create Button'! !

!WBEventHandlerStubModule methods !
defaultCategory
		"Answer the default category for the receiver."
	^'event handler'! !

!PEntryField methods !
minSize

    ^1 @ self suggestedSize y! !

!WBLayoutWizard methods !  
attributesToGenerate

    ^(attributesList contents collect: [:item |
        item object]) select: [:item |
            (item propertyAt: #inLayout) == true].! !

!WBMethodStubModule methods !   
generateComment
        "Private - Generate the comment."

    super generateComment.
    self stream cr.! !

!WBLookPolicy class methods ! 
isWindowsNT

    ^OperatingSystem isWindowsNT! !

!WindowBuilder methods !
usesLookPolicyWin31

    ^self class lookPolicy == WBLookPolicyWin31! !

!WBInstVarSetModule methods !
defaultMessageArguments

    ^Array with: 'anObject'! !

!WBLayoutWizard methods !
otherButton

    | result selections |
    result := Prompter prompt: 'Enter a New Button Label:' default: self emptyString.
    (result isNil or: [result isEmpty])
        ifFalse: [
            selections := (self paneNamed: 'standardButtonsList') value.
            selections add: result.
            self class standardButtons add: result.
            self loadStandardButtons.
            (self paneNamed: 'standardButtonsList') setValue: selections]! !

!WBLocator methods ! 
value

        ^receiver perform: selector withArguments: arguments! !

!WBPoolManagerWindow methods !
selectedValue
    "Answer the currently selected value or nil."

    | aKeyAndPool aCategory |
    aKeyAndPool := self selectedKeyAndPool ifNil: [^nil].
    aCategory := self selectedCategory ifNil: [^nil].
    ^aKeyAndPool value
        at: aKeyAndPool key
        in: aCategory
        ifAbsent: [nil]! !

!Bitmap class methods !
buttonWidth8: w height: h
	"Private - WBPro Development.
		Create a new tool bar button bitmap template"

	#addedByOSI.
	^(self screenWidth8: w * 2 height: h) wbInitButton! !

!PWBHorizontalScrollBar methods !  
mutationRotationList

    ^#(#WBVerticalScrollBar #CPVerticalBarGauge #CPVerticalSlider)! !

!WBCallOutEditor methods !   
add

    "Callback for the #clicked event triggered in the Button named 'add'.
     (Generated by WindowBuilder)"

    | selectedItems |
    (selectedItems := panesList selectedItems) do: [:pane |
        callOutMap
            at: pane
            put: (self defaultSelectorFor: pane)].
    self
        updatePaneList;
        updateCallOutList.
    selectedItems size == 1
        ifTrue: [
            callOutList selectItem: selectedItems first.
            selector contents: (callOutMap at: selectedItems first)]
        ifFalse: [selector contents: ''].! !

!PRadioButtonGroup methods ! 
usesFont

     ^true! !

!WBNLSDictionaryReader class methods !   
fileOutCategoryEndOn: aStream
	"File out a token/value pair inside a comment."

	^self fileOutToken: WBNLSManager tagEnd on: aStream! !

!WBLayoutForm methods ! 
deferRedraw: aBlock

	self noRedraw: true.
	aBlock value.
	self noRedraw: false.
	self propertyAt: #hideHandles put: false.
	self invalidateRect: nil erase: true.! !

!WBScrollingPane methods ! 
sizingWindow: aRect

    | mouseLoc deltaX deltaY visibleRect |

    mouseLoc := (Cursor offset mapToWindow: self).
    visibleRect := (0@0 extent: self extent).

    deltaX := deltaY := 0.

    (mouseLoc x isLeftOf: visibleRect left) ifTrue: [
        deltaX := (visibleRect left left: mouseLoc x).
    ] ifFalse: [
        (mouseLoc x isRightOf: visibleRect right) ifTrue: [
            deltaX := (visibleRect right left: mouseLoc x).
        ]
    ].
    (mouseLoc y isAbove: visibleRect top) ifTrue: [
        deltaY := (visibleRect top up: mouseLoc y).
    ] ifFalse: [
        (mouseLoc y isBelow: visibleRect bottom) ifTrue: [
            deltaY := (visibleRect bottom up: mouseLoc y).
        ].
    ].

    self scrollTopCorner: (deltaX@deltaY) unlimited: true.! !

!FrameObject methods !   
layoutForm

	^(self editor ifNil: [^nil]) layoutForm! !

!PWBToolBar methods !
vertical

    ^self propertyAt: #vertical ifAbsent: [false]
! !

!WinDialogInfo methods !
origin
        "Private - WBPro Development."
    #addedByOSI.
    ^(self uShortAtOffset: 5) @ (self uShortAtOffset: 7)! !

!WBInterfaceObject methods ! 
removeEvents

	^#(#display).! !

!WBAbstractCodeModule methods !  
messageSelector: aSymbol
    "Private - Set the message selector."
  selector := aSymbol notNil
        ifTrue: [ aSymbol asSymbol ]
        ifFalse: [ nil ].! !

!WBEnhancedEntryFieldEditor methods !
noneString

    ^'- None -'! !

!WBOutboardWindow methods !   
aboutToClose! !

!WBManagedPValue methods ! 
wbIsPValueManager
	"Answer true if the receiver is a value manager."

	^true! !

!WindowBuilder methods !
menuOptionsShowZOrder

    | aBoolean |
    aBoolean := self class togglePropertyValueAt: #ShowZOrder.
    self updateOptionsMenu.
    self layoutForm isNil
        ifFalse: [self layoutForm showOrder: aBoolean]! !

!WBGeometryManager methods !  
alignRight
    "Align the selected widgets along their right sides"

    | target selections origins aWidget redoBlock |
    (selections := self selections copy) size > 1 ifFalse: [^self].
    target := selections first.
    origins := selections collect: [:widget | widget origin].
    self undoManager
        add: 'Align Right'
        undo:
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (origins at: i) x
                    y: (origins at: i) y;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (target x + target width - aWidget width)
                    y: aWidget y;
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!Object methods !
osiHack
    "Documents things that need to be cleaned up...
     Execute the following to get a list of all osi hacks.

        Smalltalk sendersOf: #osiHack.

    "

    #addedByOSI.
    #osiHack.! !

!WindowBuilder methods ! 
wbMenus

	^self class 
		clearMenus;
		wbMenus.! !

!WBEditClassDialog methods !
envyApplicationChoices

    "Compute the list of applications in which the user could save the window
    class. Check that each such app:
      - is an edition
      - could be a scratch, iff that class already exists in that app
     -  it or its root application has WindowBuilderProRuntime has a prereq
     -  the current user is a group member in this application."

    | wbproApp appChoices |
	CursorManager execute change.
    wbproApp := Smalltalk at: #WindowBuilderProRuntime.
    appChoices := (Smalltalk at: #Application) currentlyLoaded select: [:app |
        app allPrerequisites includes: wbproApp].
    appChoices := appChoices
        inject: appChoices asOrderedCollection
        into: [:apps :app | apps addAllLast: app allSubApplications; yourself].
    "appChoices addAllLast: wbproApp withAllSubApplications.
    user := (Smalltalk at: #User) current.
    appChoices := appChoices select: [:each | each isEdition and: [
        each groupMembers includes: user]]."
    CursorManager normal change.
    ^(appChoices collect: [:app | app name]) asSortedCollection asArray.! !

!WBBitmapManagerWindow methods !  
categoryListDrawItem: drawIndex pane: aPane

    "Callback for the #drawItem: event triggered in the MultipleSelectListBox named 'categoryListBox'.
     (Generated by WindowBuilder)"

	| aCategory aKeyAndPool aKey aPool aBitmap |
	aCategory := self categories at: drawIndex.
	(aKeyAndPool := self selectedKeyAndPool) notNil
		ifTrue: [
			aKey := aKeyAndPool key.
			aPool := aKeyAndPool value].
	aBitmap := self
		valueAt: aKey
		in: aCategory
		pool: aPool.
	self
		categoryListDraw: aCategory
		value: aBitmap
		pane: aPane.! !

!WBNLSDictionaryReader class methods !
fileOutToken: aToken value: aString indent: anInteger on: aStream
	"File out a token/value pair."

	aStream
		cr;
		next: anInteger put: $ ;
		nextPutAll: aToken;
		space;
		nextPut: $".
	aString do: [:ch |
		aStream nextPut: ch.
		ch = $" ifTrue: [aStream nextPut: $"]].
	aStream
		nextPut: $".! !

!WBListChooser methods !   
ok

    reply := (self paneNamed: 'list') selectedItem.
    self mainView close! !

!PScrollBar methods !
lineIncrement: integer

    lineIncrement := integer! !

!WBFramingEditor methods !   
cornerXAnchorChanged: selectedItem

    selectedItem = 'Pane left'
        ifTrue:
            [originXAnchor disableItem: 'Pane right'.
            ]
        ifFalse:
            [originXAnchor enableItem: 'Pane right'.
            ].
    self setExampleRects.! !

!PStaticText class methods ! 
styleFrom: style

	^(style bitIsOn: SsRight)
		ifTrue: [#rightJustified	]
		ifFalse: [
			(style bitIsOn: SsCenter)
				ifTrue: [#centered]
				ifFalse: [
					(style bitIsOn: SsLeftnowordwrap)
						ifTrue: [#leftJustified]
						ifFalse: [#leftJustifiedWordWrap]]].! !

!WindowBuilder methods !  
morphSelectionTo: newClassName

    | newWidgetClass notAll |
	notAll := Notifier isAltKeyDown not.
    newClassName == #other
        ifTrue: [
            (newWidgetClass := (WBChoosePaneDialog new
                classList: (SubPane allSubclasses reject: [:aClass |
                    Class isWBInternalClass & notAll or: [aClass name first == $ ]])) result) isNil
                ifTrue: [^self].
            self geometryManager morphSelectionsTo: newWidgetClass name asSymbol]
        ifFalse: [self geometryManager morphSelectionsTo: newClassName].! !

!CompositeFrameObject methods ! 
borderWidth

    ^1! !

!WBNLSManagerWindow methods ! 
defaultValueAt: aKey category: aCategory

	^'<', aCategory, '-', aKey, '>'! !

!WBWindowEditor methods !  
setIconFromDialog

    "Support for setting window icons"
    | file |
    iconFile isNil ifTrue: [
        file := nil
    ] ifFalse: [
        file := (File splitPath: iconFile in: Disk) at: 3
    ].
    iconFile := (FileDialog new
                            openTitle: (file isNil
                                ifTrue: ['Select Icon File']
                                ifFalse: ['Select Icon File - ',file])
                            fileSpec: '*.ICO'
                            showFileInButton: false) file.
    iconFile isNil ifTrue: [ ^nil ].
    (iconFile asStream skipTo: $.; upTo: $.) asUpperCase = 'ICO' ifFalse: [
        MessageBox message: iconFile,' is not a valid .ICO file!!'.
        iconFile := nil
    ].! !

!WBTabOrderEditor methods !
activated

	super activated.
	self setFirstStatus.
	self labelWithoutPrefix: 'Tab Order Editor: [' , (self owner classNameFor: self owner editedClass) , ']'! !

!PEntryField methods ! 
storeRectOn: aStream indentString: indentString

	framingBlock isFramingParameters
		ifTrue: [framingBlock indent: 3@4].
	super storeRectOn: aStream indentString: indentString.! !

!WBLookPolicyOS2 methods ! 
drawVScrollBarWith: aPen at: aRect

    | nonThumbRect |
    nonThumbRect := super drawVScrollBarWith: aPen at: aRect.
    aPen
        foreColor: Color darkGray;
        wbLineFrom: aRect leftTop to: aRect leftBottom;
        wbLineFrom: (aRect rightTop left: 1) to: (aRect rightBottom left: 1).
    ^nonThumbRect! !

!Symbol methods !
wbFullCopyReal: aDictionary
	"Answer a copy of the receiver which shares
		 the receiver instance variables.  Because
		 the receiver is unique (cannot be copied),
		 answer the receiver."

	#addedByOSI.
	^self! !

!WBTabOrderLayoutForm methods !   
groups: aDictionary

	groups := aDictionary! !

!Object methods ! 
attributeEditor

    ^nil! !

!WBListChooser class methods !  
wbBasicVersion
		"Private - Answer the window builder version."
	^2.0! !

!WBPoolEditorCompositePane methods !
selectedPool

	^self owner selectedPool! !

!WindowBuilder methods !  
newSelection: aCollectionOfWidgets

	| sizeMenu |
	sizeMenu := self menuTitled: 'Size'.
	aCollectionOfWidgets isEmpty
		ifTrue: [
			self pane: self shell.
			sizeMenu
				changeItem: #menuSizeSetWidgetSize label: '\uSet Window Size...' replaceEscapeCharacters;
				changeItem: #menuSizeSetWidgetPosition label: 'Set Window \uPosition...' replaceEscapeCharacters]
		ifFalse: [
			self pane: aCollectionOfWidgets first.
			sizeMenu
				changeItem: #menuSizeSetWidgetSize label: '\uSet Widget Size...' replaceEscapeCharacters;
				changeItem: #menuSizeSetWidgetPosition label: 'Set Widget \uPosition...' replaceEscapeCharacters].
	self
		updateMenuFile;
		updateMenuEdit;
		updateMenuAttributes;
		updateMenuAlign;
		updateMenuSize.
	toolBar updateEnabled.
	self autoUpdateOutboards
		ifTrue: [self updateOutboards: aCollectionOfWidgets].
	self
		setStatusForWidgets: aCollectionOfWidgets;
		setSizeAndPositionForWidgets: aCollectionOfWidgets.! !

!PWBToolBar methods !   
useSystem

	^useSystem ifNil: [useSystem := false].! !

!WBPoolManagerWindow methods !
categoryListChanged: selectedItem pane: aPane

    "Callback for the #changed: event triggered in the MultipleSelectListBox named 'categoryListBox'.
     (Generated by WindowBuilder)"

	self selectedCategoriesChanged.! !

!WindowBuilder methods ! 
menuToolsInspectMenuBar

    self shell menu inspect! !

!WBLookPolicy methods !  
getSysColor: aColorIndex

    ^Color getSystemColor: aColorIndex! !

!Object methods !
wbReservedInstVarNames
	"Answer an array of inst var names that should be internal
		and not shown as possible targets for messages."

	^self class wbReservedInstVarNames! !

!WindowBuilder methods ! 
menuOptionsRedraw

    self scrollingForm redraw.! !

!WindowBuilder class methods !  
toolBarTool
	"Answer the tool bar tool."

	^ToolbarTool
		ifNil: [
			ToolbarTool := (Smalltalk at: #Tool) new 
				fromBitmap: WBWindowBuilderToolbarBitmapSysBitmap.
			ToolbarTool
				selector: #newWindowBuilder;
				owner: self wbEditorClass;
				name: 'WindowBuilder Tool';
				space: 11;
				yourself]! !

!WindowBuilder methods ! 
selectionsHaveMenuAttributes

	| selections |
	self hasSelections ifFalse: [^true].
	^(selections := self selections) notEmpty
		and: [(selections detect: [:widget | widget usesMenu] ifNone: [nil]) notNil]! !

!WBToolBarEditor methods !   
initWindow

    Notifier isAltKeyDown
        ifFalse: [(self paneNamed: 'system') hideWindow]
        ifTrue: [(self paneNamed: 'vertical') hideWindow].

    list contents: (elements collect: [:element |
        (element selector isNil or: [element selector == #nil]) ifTrue: [element selector: ''].
        element selector asString]).

    (self paneNamed: 'system') selection: thePane useSystem.
    (self paneNamed: 'vertical') selection: thePane vertical.
    (self paneNamed: 'cellSize') contents: thePane cellSize asString.
    (self paneNamed: 'paste') disable.

    elements isEmpty
        ifFalse: [
            list selection: 1.
            self sendInputEvent: #selectButton: with: 1]
       ifTrue: [self updateButtons].! !

!WBCreateViewModule methods !   
view: anApplicationWindow
		"Set the reciever's view."
	view := anApplicationWindow.! !

!PStaticBox methods !
winUserStyle

    ^((OrderedCollection new
            add: SsWhiterect;
            add: SsWhiteframe;
            add: SsBlackframe;
            add: SsBlackrect;
            add: SsGrayframe;
            add: SsGrayrect;
            yourself) asArray
        at: (#(#whiteRect #whiteFrame #blackFrame
                #blackRectangle #grayFrame #grayRectangle) indexOf: style))! !

!WBLayoutForm methods !  
button1Up: aPoint
    "Process a release button event."

    | ctrl alt |
    self propertyAt: #hideHandles put: false.
    self releaseState notNil
        ifTrue: [self perform: self releaseState with: aPoint].
    self motionState: nil.
    self releaseState: nil.
    self setCursor: nil.
    ctrl := Notifier isControlKeyDown.
    alt := Notifier isAltKeyDown.
    (self duplicateWidgets = self selections and: [ctrl not])
        ifFalse: [
            self
                duplicateWidgets: nil;
                duplicateOffset: nil]
        ifTrue: [self duplicateOffset: ((self duplicateOffset rightAndDown: aPoint) leftAndUp: self cursorSelectPoint)].
    self showHandles.
    self clearMouseCapture! !

!WinDialogInfo methods !  
text
        "Private - WBPro Development."
    | s t |
    #addedByOSI.
    s := ReadStream on: (contents copyFrom: 14 to: contents size).

    "Skip menu name and class name"
    s upTo: 0; upTo: 0.

    t := String new.
    (s upTo: 0) do: [:b | t := t, (String with: b asCharacter) ].

    ^t! !

!WBPoolManagerWindow methods ! 
poolListChanged: selectedItem pane: aPane

    "Callback for the #changed: event triggered in the MultipleSelectListBox named 'poolListBox'.
     (Generated by WindowBuilder)"

	self selectedPoolsChanged.! !

!WBLookPolicy methods !   
frameWidthDialog

    ^4! !

!WindowBuilder methods ! 
menuViewCreate

	| nameString |
	(nameString := Prompter prompt: 'Name for New View:' default: '') isNil
		ifFalse: [
			self prototype newWindow: nameString.
			self updateMenuView.
			self layoutFormChanged].
	! !

!Object methods !  
wbEventsTriggered

	^self class eventsTriggered! !

!WBTeamVCodePolicy methods !  
currentSubsystem
		"Answer the current team/v subsystem."
	^self class teamInterface current! !

!WBPoolEditorCompositePane methods ! 
updateKey! !

!WBTargetObject methods ! 
wbRealClass

	^self realClass! !

!WBCallOutModule methods !  
initVarNames
	"Private - Initialize the variable names."

	super initVarNames.
	self varNameFor: self targetObject put: self defaultOwnerName.! !

!WindowBuilder methods ! 
menuScrapbookQuickReference: aString

    | pageName found page |
    found := false.
    pageName := aString reject: [:char | found := ((char == $~) | (char == $&) & found not)].
    page := (self class scrapbook at: 'Quick Reference') at: pageName ifAbsent: [^nil].
    self clipboard: (page isArray ifTrue: [page first] ifFalse: [page]).
    self clipboard isNil
        ifFalse: [self geometryManager pasteSelections].! !

!WBLayoutWizard methods !
up

    | selectedItem index |
    selectedItem := attributesList selectedItem.
    index := attributesList contents indexOf: selectedItem.
    attributesList contents
        remove: selectedItem;
        add: selectedItem beforeIndex: index - 1.
    attributesList
        contents: attributesList contents;
        selectItem: selectedItem.
    self updateUpDownButtons.
! !

!WBBasicCodeModule methods ! 
defaultCategory
		"Answer the default category for the receiver."
	^'event handler'! !

!PButton methods !
changesSize

    ^true! !

!WindowBuilder methods !   
setStyle: selectedItem

	| newStyle selections snapshots redoBlock currentWidget |
	selectedItem isNil ifTrue: [^self].
	(newStyle := selectedItem trimBlanks) isEmpty ifTrue: [^self].
	newStyle := newStyle asSymbol.	
	selections := self selections select: [:widget | 
		widget styles notNil and: [
			widget styles includes: newStyle]].
	snapshots := selections collect: [:widget | widget wbCopy].
	self undoManager
		add: 'Set Style'
		undo: 
			[1 to: selections size do: [:i |
				(snapshots at: i) wbCopyTo: (selections at: i)]]
		redo: (redoBlock :=
			[selections do: [:widget |
				(widget style: newStyle) isNil
					ifTrue: [widget reframe: self shellContentRect]]]).
	redoBlock value.
	self redisplaySelection.
	currentWidget := self currentWidget.
	self 
		updateColorButton: self attributePalette for: currentWidget;
		updateFramingButton: self attributePalette for: currentWidget;
		updateText: currentWidget.! !

!WBAbstractAddInModule class methods !  
modulesModifyingProperties
    "Answer a collection of all of the Add-In Module classes
     that modify the properties"

    ^self loadedModules select: [:module |
        module modifiesProperties]! !

!PButton methods ! 
displayWith: aPen clipRect: clipRect

    self lookPolicy
        drawButton: self
        with: aPen
        clipRect: clipRect! !

!WBActionLinkAddInModule class methods !  
modifyPalette: thePalette
	"Modify the palette"

	self
		insertMenu: #('~ActionButton' 'ActionButton' '')
			in: thePalette
			after: '~ThreeStateButton';
		insertMenu: #('~LinkButton' 'LinkButton' '')
			in: thePalette
			after: '~ThreeStateButton'! !

!WBCreateViewModule methods !
generatePaneBody: aPane
		"Private - Generate the pane definition."
	aPane wbRealWidget wbStorePropertiesOn: self stream.
	aPane	storeOn: self stream indentString: ''.
	self stream endMessage.! !

!WBApplicationCoordinatorModule methods !  
targetClass
        "Answer the receiver's target class."
    ^super targetClass class! !

!PButton methods ! 
specialId

    ^specialId! !

!WBLayoutForm methods ! 
hideHandles

    self hideHandles: self handles.! !

!WBRGBColorDialog methods !  
colorSelected: selectedItem

    "Callback for the #clicked: event triggered in the WBListBox named 'colorList'.
     (Generated by WindowBuilder)"

    | color selectedColor selectedElement |
    selectedElement := self selectedElement.
    selectedColor := (color := (self paneNamed: 'colorList') selectedItem) = #default
        ifTrue: [defaults at: selectedElement]
        ifFalse: [Color perform: color].

    elements
        at: selectedElement
        put: selectedColor.

    self updateRGBField: selectedColor! !

!WBEnhancedAttributeEditor methods !   
fieldNames

	^self thePropertyManager keys
		select: [:each | (self paneNamed: each) notNil]! !

!WBToolBarEditor methods !  
preInitWindow

    (elements := thePane elements deepCopy) do: [:element |
        element bitmapSelector: (WBBitmapManager current
keyAtValue: element bitmap
            ifAbsent: [WBBitmapManager system keyAtValue:
element bitmap ifAbsent: [
 ^self error: 'BitmapManager does not have: ',element bitmap asSymbol]]) asSymbol].
    useSystem := thePane useSystem.
    list := self paneNamed: 'buttons'.
    list itemHeight: thePane cellSize y + 4.
! !

!WBScrapbookRetrieve methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel chapters chaptersLabel count graphic mainView name 
	nameLabel ok pages pagesLabel remove scrollbar 
	selectedPageGroup xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	chapters := ListBox new.
	chaptersLabel := StaticText new.
	count := StaticText new.
	graphic := GraphPane new.
	name := WBEntryField new.
	nameLabel := StaticText new.
	ok := Button new.
	pages := ListBox new.
	pagesLabel := StaticText new.
	remove := Button new.
	scrollbar := ScrollBar new.
	selectedPageGroup := GroupBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Retrieve from Scrapbook';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -137 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -67 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -137 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -67 * yDU).
	self addView: mainView.
	
	graphic "GraphPane"
		owner: self;
		setName: 'graphic';
		when: #display send: #yourself to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 128 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 0; rightInset: -266 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		removeHorizontalScrollbarStyle;
		removeVerticalScrollbarStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: graphic.
	
	chapters "ListBox"
		owner: self;
		setName: 'chapters';
		when: #clicked: send: #getChapter: to: self;
		when: #needsContents send: #loadChapters: to: self withArgument: chapters;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 11 * yDU;
				rightRatio: 0; rightInset: -120 * xDU;
				bottomRatio: 0; bottomInset: -45 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: chapters;
		subPaneWithFocus: chapters.
	
	pages "ListBox"
		owner: self;
		setName: 'pages';
		when: #clicked: send: #getPage: to: self;
		when: #doubleClicked: send: #ok: to: self;
		when: #needsContents send: #loadPages: to: self withArgument: pages;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 55 * yDU;
				rightRatio: 0; rightInset: -120 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: pages.
	
	name "WBEntryField"
		owner: self;
		setName: 'name';
		when: #textChanged: send: #changeName: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 152 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -266 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: name.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 116 * yDU;
				rightRatio: 0; rightInset: -81/2 * xDU;
				bottomRatio: 0; bottomInset: -130 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 44 * xDU;
				topRatio: 0; topInset: 116 * yDU;
				rightRatio: 0; rightInset: -161/2 * xDU;
				bottomRatio: 0; bottomInset: -130 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	remove "Button"
		owner: self;
		setName: 'remove';
		when: #clicked send: #remove to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 84 * xDU;
				topRatio: 0; topInset: 116 * yDU;
				rightRatio: 0; rightInset: -241/2 * xDU;
				bottomRatio: 0; bottomInset: -130 * yDU);
		contents: '&Remove';
		startGroup;
		font: SysFont.
	mainView addSubpane: remove.
	
	scrollbar
		owner: self;
		setName: 'scrollbar';
		when: #changed: send: #getScrollImage: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 158 * xDU;
				topRatio: 0; topInset: 118 * yDU;
				rightRatio: 0; rightInset: -266 * xDU;
				bottomRatio: 0; bottomInset: -127 * yDU);
		startGroup;
		font: SysFont;
		horizontal.
	mainView addSubpane: scrollbar.
	
	pagesLabel "StaticText"
		owner: self;
		setName: 'pagesLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -30 * xDU;
				bottomRatio: 0; bottomInset: -54 * yDU);
		contents: 'Pages:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: pagesLabel.
	
	chaptersLabel "StaticText"
		owner: self;
		setName: 'chaptersLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -38 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Chapters:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: chaptersLabel.
	
	nameLabel "StaticText"
		owner: self;
		setName: 'nameLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 126 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -149 * xDU;
				bottomRatio: 0; bottomInset: -22 * yDU);
		rightJustified;
		contents: 'Name:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: nameLabel.
	
	count "StaticText"
		owner: self;
		setName: 'count';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 128 * xDU;
				topRatio: 0; topInset: 119 * yDU;
				rightRatio: 0; rightInset: -156 * xDU;
				bottomRatio: 0; bottomInset: -127 * yDU);
		rightJustified;
		contents: '';
		foreColor: Color darkBlue;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: count.
	
	selectedPageGroup "GroupBox"
		owner: self;
		setName: 'selectedPageGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 124 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -270 * xDU;
				bottomRatio: 0; bottomInset: -130 * yDU);
		contents: 'Selected Page';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: selectedPageGroup! !

!Array methods !
wbStoreOn: aStream
        "Answer the receiver represented as a String
         from which it can be reconstructed."
    #addedByOSI.
    aStream nextPutAll: '#('.
    self
		do: [:element | aStream nextPutArrayElement: element]
		andBetweenDo: [aStream space].
    aStream nextPut: $).! !

!PLinkButton methods !  
link

    ^link! !

!WBBitmapManagerWindow methods !  
menuBitmapFromScreenIntoButtonDown

	| aBitmap selectedBitmap |
	selectedBitmap := self selectedValue ifNil: [^self].
	aBitmap := WBBitmapClass fromUser ifNil: [^self].
	selectedBitmap wbButtonDown: aBitmap.
	self updateEditor.! !

!WBCodeStream methods !   
nextPutAssignment
	"Append an assignment to the receiver."

	stream nextPutAll: ' := '.! !

!WBTopPane methods ! 
partOverlappedWindowOS2: aPoint
		"Private - Answer the receiver's sibling window that
          contains aPoint."
	^nil! !

!WBCreateViewModule methods !   
generateDefinitionFor: anObject
		"Private - Generate the specified definition."

	self 
		generateDefinitionFor: anObject 
		instVar: false! !

!WBUndoRedoDialog class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBInterfaceObject methods ! 
wbCloneWithParent: aParent width: width height: height

	^(self wbCloneWithParent: aParent)
		extent: width @ height;
		yourself! !

!PGenericSubpane methods ! 
displayWith: aPen clipRect: r

    self displayGenericWith: aPen clipRect: r! !

!PComboBox methods ! 
containsPoint: point

    ^self hitRect containsPoint: point! !

!PButtonListBox methods !
readSpecificsFrom: aPane

    self contents: aPane wbContents.
    super style: (aPane isThreeState
        ifTrue: [
            aPane useImages
                ifTrue: [#threeState]
                ifFalse: [#threeStateNoImages]]
        ifFalse: [
            aPane useImages
                ifTrue: [#defaultStyle]
                ifFalse: [#noImages]]).! !

!WBMenuItem methods ! 
check
        "Check the receiver."
	self attribute: self attribute | MfChecked.
	self update.! !

!WBStatusPaneEditor methods ! 
remove

    | index |
    index := list selection.
    index isNil ifTrue: [ ^nil ].
    boxes removeIndex: index.
    list
        contents: (boxes collect: [ :box | box name asString ]);
        selection: (index min: boxes size).

    self updateBoxes.! !

!PEnhancedEntryField methods !
character: aSymbol

    character := aSymbol! !

!WBTabOrderEditor class methods !
includeOuter

	^IncludeOuter ifNil: [IncludeOuter := true].! !

!WBWindowEditor methods ! 
supportsNoTitlebar

    ^true! !

!WBClassDefinition methods !
classVarNames
		"Answer the receiver's class  variables."
	^self classField classVarNames! !

!PRadioButtonGroup methods !
backColor

	^backColor ifNil: [
		self isWindows95
			ifTrue: [Color gray]
			ifFalse: [nil]]! !

!WBLookPolicyWin31 methods ! 
drawRightArrowWith: aPen at: aRect

    | innerRect side |
    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class rightArrow
                from: self class rightArrow boundingBox
                to: aRect]
        ifFalse: [
            innerRect := self draw3DBoxWith: aPen at: aRect.
            side := (innerRect width min: innerRect height) // 7.
            aPen
                polygonFilled: (Array
                    with: (innerRect center right: side + 2)
                    with: (innerRect center leftAndUp:  (side - 1) @ (side * 2 + 1))
                    with: (innerRect center leftAndDown:  (side - 1) @ (side * 2 + 1)));
                fill: ((innerRect center leftAndUp: (side*2-2) @ (side + Rectangle leftTopUnit y))
                    extentFromRightTop: (side*2+1) @ (side*2+1)) color: Color black].! !

!WBClassDefinition methods ! 
addInstVarName: aString
		"Add an instance variable name."
	(self allInstVarNames includes: aString) ifFalse: [
		instVarNames := self instVarNames, (Array with: aString).
		allInstVarNames := self allInstVarNames, (Array with: aString) ].! !

!WindowBuilder class methods !  
scrapbook

	Scrapbook isNil
		ifTrue: [
			Scrapbook := Dictionary new.
			Scrapbook at: 'Quick Reference' put: Dictionary new].
	^Scrapbook! !

!WBInterfaceObject methods ! 
boundingBox
        "Answer the bounding box of the receiver."
    ^self hitRect copy! !

!PWBToolBar methods !   
cellSize

	^cellSize ifNil: [cellSize := self defaultCellSize].! !

!WindowBuilder class methods !
defineGridProperties: collection
    "Define the grid properties used in WindowBuilder Pro"

    collection

        add: (WBPropertyDescriptor new
            name: #GridSize;
            commonName: 'Grid Size';
            comment: 'Specifies the grid size used in the WindowBuilder Pro editor. When the grid is on, all move and size operations are constrained to multiples of the grid size.';
            category: self gridPropertyString;
            default: 4@4;
            yourself);

        add: (WBPropertyDescriptor new
            name: #UseGrid;
            commonName: 'Use Grid';
            comment: 'Specifies whether the grid is turned on or off within WindowBuilder Pro. When the grid is on, all move and size operations are constrained to multiples of the grid size.';
            category: self gridPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #DrawGrid;
            commonName: 'Draw Grid';
            comment: 'Specifies whether the grid is visible within WindowBuilder Pro.';
            category: self gridPropertyString;
            default: false;
            yourself);

        yourself! !

!PDrawnButton methods !  
suggestedSize

	^(self fileExists: self contents)
		ifTrue: [self bitmapExtent]
		ifFalse: [((self font wbStringWidth: (self justFileName: self contents)) + 20) @ (self font height + 14)]! !

!WBTimerEditor methods !
initWindow

    period contents: (thePane period ifNil: [1000]) asString.! !

!WBBitmapPool methods ! 
fileOutFooterOn: aStream
	"File out the receiver's footer."

	aStream
		nextPutAll: self managerClass tagPoolEnd;
		cr.! !

!WBPoolManagerWindow methods ! 
menuKeyNew: aCollection

	| aPool keysAndPools |
	aCollection isEmpty ifTrue: [^self].
	self categories isEmpty ifTrue: [
		self menuCategoryNew.
		self categories isEmpty ifTrue: [^self]].
	aPool := self selectedPoolOrPrompt: 'Add key to which pool?'.
	aPool isNil ifTrue: [^self].
	[self menuKeyNew: aCollection pool: aPool]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].
	keysAndPools := aCollection collect: [:each |
		(each isAssociation ifTrue: [each key] ifFalse: [each]) => aPool].
	self selectedKeysAndPools: keysAndPools.
	keyListBox setTopIndex: (
		(keyListBox contents indexOf: keysAndPools asSortedCollection first)
			- 4 max: 1).! !

!WindowFrameObject methods !  
realClass: aClass
    super realClass: aClass.
    (self children ifNil: [^self]) do: [:child |
        child setWindowClass: aClass].! !

!WindowBuilder methods !  
menuToolsInspectCursorConstants

    CursorConstants inspect! !

!WBInterfaceObject methods ! 
foreColor

    ^foreColor! !

!WBCreateClassDialog methods !  
setViewManager
    "Callback for the #turnedOn event triggered in the RadioButton named 'setViewManager'.
     (Generated by WindowBuilder)"

    | superClassSymbol |
    superClassSymbol := (limitTo = 'Window'
        ifTrue: [#ViewManager]
        ifFalse: [#WindowDialog]).
    (self paneNamed: 'superclassName')
        contents: (self superclassListFor: superClassSymbol);
        selectItem: (self defaultSuperClassFor: superClassSymbol) asString;
        getSelection.! !

!Object methods !
isWBModel

	^true! !

!WindowBuilder class methods !  
wbInitializeSystemBitmaps
	"Gather the development system bitmaps."

	WBBitmapManager system 
		addFixedBitmapPoolNamed: #WBDevelopmentBitmaps.
	"WBBitmapManager validateSystem."
	! !

!WBAboutDialog class methods !   
isWBInternalClass

    ^true! !

!Window methods !
wbWrapper: aWBInterfaceObject

	self propertyAt: #wbWrapper put: aWBInterfaceObject.
	aWBInterfaceObject wbRealWidget: self.! !

!WBGeometryManager methods !
repositionSelectedWidgets: aPoint
    "Reposition the selected widgets to a position defined by <aPoint>"

    | offset |
    self selections isEmpty ifTrue: [^self].
    self hideHandles.
    offset := aPoint - self layoutForm selectedRect topLeft.
    self selections do: [:aWidget |
        aWidget
            configureWidget: (aWidget x + offset x)
            y: (aWidget y + offset y)
            width: aWidget width
            height: aWidget height
            borderWidth: aWidget borderWidth;
            wbUpdateConstraints].
    self updateWidget.! !

!WBCreateViewModule methods ! 
generateFontDefinitions
	"Generate a definition for each of the view's elements."

	| first |
	first := true.
	varNames associationsDo: [:each |
		each key isFont ifTrue: [
			first ifTrue: [
				self stream cr; indentBy: 1 during: [
					self stream cr; nextPutComment: 'Font Definitions'].
				first := false].
			self stream cr;
				nextPutAll: each value;
				nextPutAssignment;
				noParenthesis.
			(self stream nextPutFontRef: each key) ifFalse: [
				self localFonts add: each key].
			self stream endExpression]].! !

!WindowBuilder class methods !  
companyName
    "Answer the window builder company's name."

    | answer |
    self licensed ifFalse: [^''].
    answer := self companyNamePrim.
    "
    answer = '' | answer isNil ifTrue: [
        self promptForUserInfo.
        answer := self companyNamePrim].
    "
    ^answer ifNil: ['']! !

!WBInterfaceObject methods ! 
storeStyleOn: aStream indentString: spaceString

    | styleMap |
    (self style notNil and: [self generateAllStyles | (self style ~= self defaultStyle)])
        ifTrue: [
            (styleMap := self styleMap at: self style ifAbsent: [nil]) isNil
                ifTrue: [
                    aStream nextPutAll: ';'; cr; nextPutAll: spaceString.
                    self style printOn: aStream]
                ifFalse: [
                    styleMap do: [:selector |
                        aStream nextPutAll: ';'; cr; nextPutAll: spaceString.
                        selector printOn: aStream]]].! !

!WindowBuilder class methods ! 
envyIsInstalled
	" Private - answer whether ENVY is currently installed. "

	^Smalltalk includesKey: #EnvyBrowser! !

!WBTabOrderLayoutForm methods !
tabCount

	^(self children select: [:widget | 
		widget isGrouper not & widget usesFocus & widget tabPosition notNil]) size.! !

!WBAbstractCodeModule methods ! 
useInstVars
		"Answer true if the receiver should generate instVar references."
	^self owner useInstVars! !

!WBEventManagerWindow methods !  
createMenus: aPane

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	#generated.
	aPane menuWindow
	    yourself;
	    addMenu: (
	        Menu new
	            title: 'Handler';
	            owner: self;
	            appendItem: 'Add	Alt+A' selector: #menuHandlerAdd acceleratorString: 'Alt+A';
	            appendItem: 'Remove	Alt+R' selector: #menuHandlerRemove acceleratorString: 'Alt+R';
	            appendSeparator;
	            appendItem: 'Top' selector: #menuHandlerTop acceleratorString: '';
	            appendItem: 'Up' selector: #menuHandlerUp acceleratorString: '';
	            appendItem: 'Down' selector: #menuHandlerDown acceleratorString: '';
	            appendItem: 'Bottom' selector: #menuHandlerBottom acceleratorString: '';
	            appendSeparator;
	            appendItem: 'Show All	Ctrl+A' selector: #menuHandlerShowAll acceleratorString: 'Ctrl+A'
	    );
	    addMenu: (
	        Menu new
	            title: 'Method';
	            owner: self;
	            appendItem: 'Save	Alt+S' selector: #menuMethodSave acceleratorString: 'Alt+S'
	    );
	    addMenu: (
	        Menu new
	            title: 'Option';
	            owner: self;
	            appendItem: 'Show all selectors' selector: #menuOptionSendFieldShowAll acceleratorString: '';
	            appendItem: 'Show buttons' selector: #menuOptionShowButtons acceleratorString: '';
	            appendItem: 'Drag drop handlers' selector: #menuOptionDragDropHandlers acceleratorString: ''
	    )! !

!WBCodeStream methods !
generateByteArrayCode

	^(self propertyAt: #generateByteArrayCode)
		ifNil: [self wbEditorClass generateByteArrayCode]! !

!WBInterfaceObject methods !  
fontValueManager

    ^font wbIsPValueManager
		ifTrue: [font]
		ifFalse: [nil]! !

!WBPoolManager methods !
codeKeyClass
	"Answer the named method class field, so that the
		code generator can generate expressions such as
		'Bitmap named: <aKey>'   or   'Font named: <aKey>'."

	^nil! !

!WBManagedPNLSString methods ! 
managedPool
	"Answer the pool managed by the WBNLSManager."

	^WBNLSManager current poolFor: (
		self poolNames
			detect: [:sym | (Smalltalk at: sym) includesKey: self key]
			ifNone: [^nil])! !

!WindowFrameObject methods ! 
sortChildrenByTabOrder

    self children: (self children asSortedCollection:
        self class tabOrderSortBlock) asOrderedCollection! !

!FrameObject methods !   
lookPolicy

    ^lookPolicy ifNil: [lookPolicy := self initializeLookPolicy]! !

!WBScrapbookRetrieve methods !   
pages

    ^chapter isNil ifTrue: [
        OrderedCollection new
    ] ifFalse: [
        (scrapbook at: chapter) keys asSortedCollection
    ]! !

!PWBToolBar methods !
displayElement: key with: aPen

	| element |
	element := self elements at: key.
	element isNil ifTrue: [^nil].
	aPen
		copy: element pen
		from: element boundingBox
		to: (element rectangle translateBy: 
			(OperatingSystem isOS2
				ifTrue: [rect leftBottom rightAndUp: 1]
				ifFalse: [
					self vertical
						ifTrue: [rect leftTop down: 1]
						ifFalse: [rect leftTop right: 1]]))! !

!WBTreeNode methods !  
update
	"Update the receiver."

	self updateManagedValues.
	self children do: [:each |
		each
			setParent: self;
			update].! !

!MultipleSelectListBox class methods ! 
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbRemoveEventNamed: #changedIndex: ;
        wbRemoveEventNamed: #clicked: ;
        yourself! !

!WBMultiToolPalette methods !   
add: aBitmapFile selector: aSelector on: name
    | key point temp element |
    temp := self elements.
    self elements: (self pageNamed: name).
    key := self elements size + 1.
    point := ((key - 1)\\(self size x)+1) @ ((key + (self size x - 1))//(self size x )).
    element := self at: point put: aBitmapFile selector: aSelector.
    self elements: temp.
    ^element! !

!ButtonEditor methods !
open
    self openOn: 'TEMP2522.BMP'! !

!WBTemplateEditor methods !   
setSize

	| newExtent |
	template isNil ifTrue: [^self].
	newExtent := self 
		getPointPrompting: 'New size:' 
		defaultPoint: template rect extent.
	newExtent notNil
		ifTrue: [
			template rect: 
				(template rect leftTop extentFromLeftTop: 
					((newExtent max: template minSize) min: template maxSize)).
			self 
				updateSize: template;
				redraw].! !

!BitEditor methods !
grid: anInteger
        "Draw grid lines with anInteger spacing
         on the receiver medium."

    | width height i |
	width := copy width * scale.
    height := copy height * scale.
    bitPen foreColor: Color white.
    i := 0.
    [i < width]
        whileTrue: [
            bitPen place: (i + 1)@ 0;
                goto: (i + 1) @ height;
                place: (i + anInteger - 1) @ 0;
                goto: (i + anInteger - 1) @ height.
            i := i + anInteger].
    i := 0.
    [i < height]
        whileTrue: [
            bitPen place: 0 @ (i + 1);
                goto: width @ (i + 1);
                place: 0 @ (i + anInteger - 1);
                goto: width @ (i + anInteger - 1).
            i := i + anInteger].
    bitPen foreColor: Color black.
    i := 0.
    [i < width]
        whileTrue: [
            bitPen place: i @ 0;
                goto: i @ height.
            i := i + anInteger].
    i := 0.
    [i < height]
        whileTrue: [
            bitPen place: 0 @ i;
                goto: width @ i.
            i := i + anInteger]! !

!WBScrollBarEditor class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBModelDefinitionEditor methods !   
openOnModel: aModelClass

    selectedModel := aModelClass.
    self open.! !

!WBPropertyEditor methods !   
initWindow

    super initWindow.
    categoryList contents: WindowBuilder categories.
    self setValue: nil.! !

!WBManagedPNLSString methods !   
poolNames
	"Answer a collection of pools names the receiver can use."

	^self owner nlsPools! !

!PStatusPane methods !  
updateBoxesLeftJustified

	| xPos aRect box |
	xPos := self updateBoxesLeftJustifiedFixed.
	self statusBoxes isEmpty ifTrue: [^self].
	box := self statusBoxes last.
	xPos := xPos left: box width + 6.
	aRect := Rectangle leftTop: xPos @ rect top rightBottom: (rect width left: self height - 12) @ (rect bottom down: 2).
	aRect := aRect insetBy: (0 @ self inset).
	box rectangle: aRect.! !

!WBAbstractCreateViewsModule methods !
filterEventTable: anEventTable for: anObject
	"Answer the event table for anObject."

	| answer selfOrPane actions |
	anObject wbWrapper creationMethodSelector isNil ifTrue: [^anEventTable].
	answer := anObject wbRealWidget eventTableCreate.
	(selfOrPane := OrderedCollection new)
		add: #self;
		add: self view prototype targetObject;
		add: anObject wbWrapper;
		add: anObject wbRealWidget.

	"Cannot do this because the inst var may not be defined when the callout method is called."
	"
	self view prototype targetObject validInstVars associationsDo: [:each |
		selfOrPane
			add: each key wbWrapper;
			add: each key wbRealWidget].
	"

	anEventTable associationsDo: [:eachAssoc |
		actions := nil.
		eachAssoc value asActionSequence do: [:eachMsg |
			(selfOrPane includes: eachMsg receiver) ifFalse: [
				actions := actions isNil
					ifTrue: [eachMsg asActionSequence]
					ifFalse: [actions copyWith: eachMsg]]].
		actions notNil ifTrue: [
			answer at: eachAssoc key put: actions]].
	^answer! !

!PEntryField methods !
displayWith: aPen clipRect: clipRect

    self lookPolicy
        drawEntryField: self
        with: aPen
        clipRect: clipRect! !

!WBModelObjectEditor methods !
update

	self
		updateLabel;
		updateObjectList;
		disableFields.
	editButton disable.
	removeButton disable.! !

!PStaticText methods ! 
usesTitle

    ^true! !

!WindowBuilder class methods !   
versionNumberString
	"Answer the window builder version number string."

	^self osiProductRegistry versionOf: #WindowBuilder! !

!BitEditor class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowBuilder class methods !   
drawGrid

    ^self editorClass
        propertyValueAt: #DrawGrid
        category: self gridPropertyString.! !

!WBCreateViewsModule methods !
generateBody
		"Private - Generate the method body."
	| viewSelector index |
	self stream indentBy: 1 during: [
		self generateGeneratedSymbol.
		index := 1.
		self views do: [ :eachView |
			viewSelector := self
				constructMessageSelector: self messageSelector
				index: index.
			self
				generateView: eachView
				selector: viewSelector
				index: index.
			self generateViewMessage: viewSelector.
			index := index + 1 ] ].! !

!WBCodePolicy class methods !
currentClass
	"Answer the default code policy class."

	self wbEditorClass teamIsInstalled ifTrue: [^WBTeamVCodePolicy].
	self wbEditorClass envyIsInstalled ifTrue: [^WBENVYCodePolicy].
	self wbEditorClass xoteryxIsInstalled ifTrue: [^WBXoteryXCodePolicy].
	^WBStandardCodePolicy! !

!WBAbstractCodeModule methods !   
messageSelector
    "Private - Answer the message selector."
  ^selector ifNil: [
        (self defaultMessageSelector
            ifNil: [ ^nil ]
         ) asSymbol ]! !

!WBUndoManager methods !  
undoString

    ^'\uUndo'! !

!WBInterfaceObject methods !
displayWithBothScrollBars: aPen

    ^self lookPolicy
        displayWithRightBottomScrollBars: aPen
        rect: self rect
        backColor: self backColor! !

!WBCreateBitmap methods !   
bitmapKey: aString

	keyField contents: aString.! !

!WBTabOrderLayoutForm methods !  
setupDragTabPosition: widget
    "Setup the dragging tab position state."

	self
		dragWidget: widget;
		releaseState: #buttonReleaseMovingTabPosition:;
		setCursor: #move.! !

!PScrollBar methods !
lineIncrement

    ^lineIncrement! !

!WBPoolEditorCompositePane methods !
updateCategory! !

!Character methods ! 
wbFullCopyReal: aDictionary
	"Answer a copy of the receiver which shares
		 the receiver instance variables.  Because
		 the receiver is unique (cannot be copied),
		 answer the receiver."

	#addedByOSI.
	^self! !

!WBFramingEditor class methods !  
isWBInternalClass

    ^true! !

!WindowBuilder class methods !   
windowBuilderMenu
	"Answer the WindowBuilder menu used in the System Transcript."
	" WindowBuilder resetTranscript "

	^Menu new
		owner: self wbEditorClass;
		title: self wbEditorClass menuName;
		appendItem: 'New \uWindow\tAlt+W' replaceEscapeCharacters
			selector: #newWindowBuilder accelKey: $w accelBits: AfAlt | AfChar;
		appendItem: 'New \uDialog\tAlt+D' replaceEscapeCharacters
			selector: #newDialogWindowBuilder accelKey: $d accelBits: AfAlt | AfChar;
		appendItem: 'New \uCompositePane' replaceEscapeCharacters
			selector: #newCompositeWindowBuilder accelKey: nil accelBits: nil;
		appendItem: '\uEdit Window...\tAlt+E' replaceEscapeCharacters
			selector: #editWindow accelKey: $e accelBits: AfAlt | AfChar;
		appendSeparator;
		appendItem: 'M\uodel Wizard...' replaceEscapeCharacters
			selector: #openModelDefinitionEditor;
		appendItem: '\uTemplates...' replaceEscapeCharacters
			selector: #openTemplateEditor;
		appendItem: '\uProperties...' replaceEscapeCharacters
			selector: #openPropertyEditor;
		appendSubMenu:
			(Menu new
				owner: self wbEditorClass;
				title: '\uManager' replaceEscapeCharacters;
				appendItem: '\uAdd-In Manager...' replaceEscapeCharacters
					selector: #openAddInManager;
				appendItem: '\uBitmap Manager...\tAlt+B' replaceEscapeCharacters
					selector: #openBitmapManager accelKey: $b accelBits: AfAlt | AfChar;
				appendItem: '\uFont Manager...\tAlt+F' replaceEscapeCharacters
					selector: #openFontManager accelKey: $f accelBits: AfAlt | AfChar;
				appendItem: '\uNLS Manager...\tAlt+N' replaceEscapeCharacters
					selector: #openNlsManager accelKey: $n accelBits: AfAlt | AfChar;
				yourself);
		appendSubMenu:
			(Menu new
				owner: self wbEditorClass;
				title: 'T\uranslator' replaceEscapeCharacters;
				appendItem: 'Standard \uTranslation...' replaceEscapeCharacters
					selector: #openTranslator;
				appendSeparator;
				appendItem: '\uEvent Translation...' replaceEscapeCharacters
					selector: #openEventTranslator;
				appendItem: 'Event \uMappings...' replaceEscapeCharacters
					selector: #openEventMappings;
				yourself);
		appendSeparator;
		appendItem: ('\uAbout ' , self wbEditorClass labelName , '...') replaceEscapeCharacters 
			selector: #aboutWB;
		appendItem: 'Installed \UProducts...' replaceEscapeCharacters 
			selector: #installedProducts;
		yourself.! !

!WBDevelopmentObject class methods !   
isWBInternalClass
        "Private - WBPro Development."
    ^true! !

!WindowBuilder methods !   
pane: aPane

    aPane == thePane ifTrue: [^self].
    thePane := aPane.
    self updateText: thePane.
    thePane paneName isNil
        ifFalse: [
            name contents: thePane paneName.
            self paneNameIsInstVar: thePane isInstVar.
            self paneNameIsValidInstVar: thePane paneName]
        ifTrue: [
            name contents: self emptyString.
            self paneNameIsInstVar: false.
            self paneNameIsValidInstVar: self emptyString].
    self updateEvents: false.
    when selection: 1.
    self
        updateSendField;
        updateStyle: thePane;
        updateAttributePalette: attributeBar for: thePane;
        setSizeAndPositionForWidgets: self selections;
        resetFocus.! !

!WindowBuilder methods !  
menuEditMorph

    ^self morphSelectionTo: #other! !

!ApplicationCoordinator class methods ! 
isScratchWindow
         "Private - WBPro Development."
    #addedByOSI.
    ^false! !

!PEntryFieldGroup methods !  
storeContentsOn: aStream indentString: spaceString! !

!WBAbstractCodeModule methods !  
generatePostCopyright

	(self wbEditorClass generateCopyright
		and: [self wbEditorClass copyrightAfterBody])
		ifTrue: [
			self stream cr.
			self generateCopyright].! !

!WBPoolManagerWindow methods !   
menuCategoryShowSelected

    "Callback for the menu item titled 'Show selected'.
     (Generated by WindowBuilder)"

	self showAllCategories: false.! !

!WBEventManagerWindow methods !  
methodTextFor: aHandler

	| cls mth sel |
	aHandler isNil ifTrue: [^''].
	aHandler selector isEmpty ifTrue: [^''].
	cls := aHandler receiver == self targetObject
		ifTrue: [self targetClass]
		ifFalse: [aHandler receiver class].
	cls isScratchWindow ifTrue: [^nil].
	(sel := aHandler selector asExistingSymbolOrNil) notNil ifTrue: [
		[cls notNil] whileTrue: [
	   		(mth := cls compiledMethodAt: sel) notNil ifTrue: [^mth sourceString].
   			cls := cls superclass]].
	^WBEventHandlerStubModule new
		source: aHandler source;
		event: aHandler event;
		message: aHandler asMessage;
		generateCode;
		sourceString! !

!WBCallOutModule methods !  
defaultMessageSelector
        "Private - Answer the default message selector."
    ^self object creationMethodSelector! !

!WBListEditor methods !   
initWindow

	| listEditorLabel |
	(list := thePane isCollection
		ifTrue: [thePane]
		ifFalse: [thePane contents]) isNil
		ifTrue: [list := OrderedCollection new]
		ifFalse: [list := list asOrderedCollection].
	listBox contents: list.
	listEditorLabel := (thePane propertyAt: #listEditorLabel) 
		ifNil: [thePane listEditorLabel].
	listEditorLabel isNil
		ifFalse: [self mainView labelWithoutPrefix: listEditorLabel].
	self disable.! !

!WBTeamVCodePolicy class methods !
toolInterface: aToolInterface
		"Set the Team/V tool interface."
		"WBTeamVCodePolicy toolInterface: nil."
		"WBTeamVCodePolicy toolInterface: WBTeamVCodePolicy defaultToolInterface."
	WBTeamVToolInterface := aToolInterface.! !

!PGroupbox methods !   
displayWith: aPen clipRect: clipRect

    self lookPolicy
        drawGroupBox: self
        with: aPen
        clipRect: clipRect! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBGeometryManager methods !   
alignLeft
    "Align the selected widgets along their left sides"

    | target selections origins aWidget redoBlock |
    (selections := self selections copy) size > 1 ifFalse: [^self].
    target := selections first.
    origins := selections collect: [:widget | widget origin].
    self undoManager
        add: 'Align Left'
        undo:
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (origins at: i) x
                    y: (origins at: i) y;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: target x
                    y: aWidget y;
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!WindowBuilder methods ! 
setTabbing

	self invoke: WBTabOrderEditor! !

!WBFileSelectorEditor methods !
title: anObject

    title := anObject! !

!WBEnhancedEntryFieldEditor methods !  
justificationDict

    ^Dictionary new
        at: 'Left' put: #left;
        at: 'Right' put: #right;
        at: 'Centered' put: #centered;
        yourself! !

!WBLookPolicy methods !
systemMenuWidth

    ^self class default systemMenuWidth! !

!WBUndoManager methods ! 
undo

    self undo: 1! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBModelDefinitionEditor methods !   
updateModel

	| answer localInstVars |
	self analyzeInstVars ifFalse: [^false].
	(localInstVars := self localInstVars)
		propertyAt: #events put: events.
	CursorManager execute changeFor: [
		answer := self codeGenerator generateCodeUsing: (Array
			with: (WBModelCodeModule new
				object: localInstVars;
				targetClass: selectedModel)
			with: (WBVersionCodeModule new
				targetClass: selectedModel))].
	answer == false
		ifTrue: [MessageBox message: 'Compilation errors during code generation... see System Transcript']
		ifFalse: [self clearDirty].
	[selectedModel initializeEventsTriggered] on: Error do: [].
	^true! !

!WBInterfaceObject methods !
redraw

	^self updateWidget! !

!PScrollBar methods ! 
maximum

    ^maximum! !

!WBCreateBitmap class methods ! 
isWBInternalClass

    ^true! !

!WBCreateViewsModule methods !   
createViewModuleClass
		"Answer the code module used to generate the create view."
	^WBCreateViewModule! !

!WBInterfaceObject methods !  
genReceiveWindowMessagesOn: aStream indentString: spaceString

	(self realClass canUnderstand: #receiveAllWindowMessages) 
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'receiveAllWindowMessages'].! !

!WBPropertyEditor methods ! 
initialize
    "Private - Initialize the reciever"

    super initialize.
    self clearChanges! !

!PRadioButton methods ! 
styles

    ^#(#autoRadioButton #radioButton)! !

!WBGeometryManager methods !
sendToBack: targets
    "Send the <targets> to the bottom of the z-order"

    | zOrder children aLayoutForm |
    zOrder := (children := self children) copy.
    aLayoutForm := self layoutForm.
    (self undoManager
        add: 'Send To Back'
        undo:
            [zOrder reverseDo: [:child |
                child bringToFront.
                children
                    remove: child;
                    addFirst: child.
                child wbSetDirty].
            self owner updateOutboardZOrderChange: zOrder.
            self updateWidget: aLayoutForm]
        redo:
            [targets do: [:child |
                child sendToBack.
                children
                    remove: child;
                    addLast: child.
                child wbSetDirty].
            self owner updateOutboardZOrderChange: targets.
            self updateWidget: aLayoutForm])
        redoAction value.! !

!WBCreateViewModule methods ! 
generateDefinition: aString for: anObject
		"Private - Generate the specified definition."
	self stream
		cr;
		nextPutAll: (self varNameFor: anObject);
		nextPutAll: ' := ';
		nextPutAll: aString;
		endExpression.! !

!PVideoPane methods ! 
style: newStyle

    style == newStyle ifTrue: [^self].
    style := newStyle.
    self wbRealWidget stretch: self hasStretch.
    self hasBorder
        ifTrue: [self wbRealWidget addBorderStyle]
        ifFalse: [self wbRealWidget removeBorderStyle].! !

!Color methods !
basicStoreColorOn: aStream
		"Private - Store the color definition."
    #addedByOSI.
	self implementedBySubclass.! !

!WBLayoutForm methods !   
useFence
    "Answer the value of useFence."

    ^useFence ifNil: [true]! !

!PListPane methods !   
styles

    ^nil! !

!PCompositePane methods !
readSpecificsFrom: aPane

    self style: (aPane cpStyle
        ifNil: [aPane hasBorderStyle
            ifFalse: [#defaultStyle]
            ifTrue: [
                aPane hasVerticalScrollBarStyle
                    ifFalse: [#borders]
                    ifTrue: [
                        aPane hasHorizontalScrollBarStyle
                            ifFalse: [#verticalScrollBar]
                            ifTrue: [#scrollbars]]]])! !

!WBLookPolicyOS2 methods !  
wordBreak

    ^"DtWordbreak" 16384! !

!WBActionEditor methods ! 
select: selectedItem
    | stream pos |
    changed ifTrue: [
        (MessageBox confirm: 'Save action?') ifTrue: [
            self add.
            changed := false.
        ].
    ].
    action := selectedItem.
    action isNil ifTrue: [ ^nil ].
    (self paneNamed: 'nameField') setContents: action.
    method := WBAction sourceCodeAt: ('action',action) asSymbol.
    stream := method asStream.
    stream skipTo: $".
    history := stream upTo: $".
    author := ((history asStream) skipTo: $y; skip: 1; upTo: $-) trimBlanks.
    (self paneNamed: 'authorField') setContents: author.
    pos := stream position.
    stream skipTo: $".
    stream position = stream size ifTrue: [ stream position: (stream size min: pos + 3)].
    method := stream copyFrom: stream position to: stream size.
    (self paneNamed: 'methodField')
        contents: method;
        selectAll;
        selectBefore: 1@1.
    (self paneNamed: 'add')
        contents: '&Change';
        disable.
    changed := false.! !

!Screen methods !
wbPointFromUser: aRectangle offset: anOffset
        "Private - WBPro Development.   Display aRectangle
			and answer a point selected by the user.
			Modified by OSI to erase last extra
			rectangle left on screen."

	| oldLoc oldCorner loc newCorner |
	#addedByOSI.
    oldLoc := Cursor sense - anOffset.
    oldCorner := oldLoc + aRectangle extent.
    graphicsTool setRop2: R2Notxorpen;
        place: oldLoc;
        box: oldCorner.
    Notifier consumeInputUntil: [: event |
        loc := Cursor sense - anOffset.
        oldCorner := oldLoc + aRectangle extent.
        newCorner := loc + aRectangle extent.
        loc ~= oldLoc
            ifTrue: [
                graphicsTool
                    place: oldLoc;
                    box: oldCorner;
                    place: loc;
                    box: newCorner.
                oldLoc := loc].
        event selector = #button1Up:].
    "Added by OSI."
    graphicsTool
        place: loc;
        box: newCorner.
    ^loc! !

!WindowBuilder class methods !   
useWBComboBox: aBoolean

    ^self editorClass
        propertyValueAt: #UseWBComboBox
        category: self editorPropertyString
        put: aBoolean.! !

!WBPrototype methods !   
scrollingForm

	^self owner scrollingForm! !

!WBLayoutForm methods ! 
useRightButton

	self propertyAt: #buttonUsed put: #right! !

!WBMultiToolPalette methods !   
pages: aDictionary
    pages := aDictionary! !

!WBTreeNode methods !  
canMoveDown

    ^self nextSibling notNil |
        (self isRoot not and: [ parent nextSibling notNil ]).! !

!PFormattedEntryField methods !
readSpecificsFrom: aPane

	(aPane propertyAt: #cpStyle) notNil
		ifTrue: [self style: (aPane propertyAt: #cpStyle)]
		ifFalse: [self style: self defaultStyle].
	! !

!WindowBuilder methods ! 
currentLayoutForm

    ^currentLayoutForm! !

!WBMenu methods !   
updateToggled
        "Update the toggled status of all items for the receiver."
    items do: [:mi | mi updateToggled].! !

!WBLayoutWizard methods !
setModelUpdatesWidget: aBoolean

    attributesList selectedItem object
        propertyAt: #modelUpdatesWidget
        put: aBoolean! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBTargetObject methods !
wbNameAndClass

	^#self! !

!Font methods !   
portableStoreOn: aStream indentString: indentString
	"Private - WBPro Development."

	| atleastOne |
	#addedByOSI.
	atleastOne := self bold | self italic | self strikeOut | self underscore.
	atleastOne ifTrue: [
		aStream
			openParenthesis;
			indentBy: -1].
	aStream
		nextPutAll: indentString, 'Font';
		cr; nextPutAll: indentString, 'face: ''', self faceName, '''';
		cr; nextPutAll: indentString, 'size: ', self pointSize asString;
		cr; nextPutAll: indentString, 'fixedWidth: ', self fixedWidth asString;
			"Hard code attributes to zero because DT doesn't use them anyway..."
		cr; nextPutAll: indentString, 'attributes: 0'.
	atleastOne ifTrue: [
		aStream
			closeParenthesis;
			indentBy: 1.
		self bold ifTrue: [
			aStream cr;
				nextPutAll: indentString;
				nextPutAll: #bold: ;
				space;
				nextPutAll: #true;
				endMessage].
		self italic ifTrue: [
			aStream cr;
				nextPutAll: indentString;
				nextPutAll: #italic: ;
				space;
				nextPutAll: #true;
				endMessage].
		self strikeOut ifTrue: [
			aStream cr;
				nextPutAll: indentString;
				nextPutAll: #strikeOut: ;
				space;
				nextPutAll: #true;
				endMessage].
		self underscore ifTrue: [
			aStream cr;
				nextPutAll: indentString;
				nextPutAll: #underscore: ;
				space;
				nextPutAll: #true;
				endMessage].
		aStream cr; nextPutAll: indentString, #yourself].! !

!WBModelDefinitionEditor methods !  
enableModelFields

    (self paneNamed: 'attributesLabel') foreColor: Color black.
    attributes enable.
    (self paneNamed: 'addButton') enable.
    (attributes selectedItem isNil or: [attributes selectedItem myClass ~~ selectedModel])
        ifTrue: [(self paneNamed: 'removeButton') disable]
        ifFalse: [(self paneNamed: 'removeButton') enable].
    self isDirty
        ifTrue: [(self paneNamed: 'updateButton') enable]
        ifFalse: [(self paneNamed: 'updateButton') disable].
    (self paneNamed: 'renameButton') enable.
    (self paneNamed: 'editButton') enable.
    self updateUpDownButtons.
    (self paneNamed: 'eventsButton') enable.! !

!WBUndoAction methods !  
printOn: aStream

    aStream nextPutAll: self label! !

!WBInterfaceObject methods ! 
readSpecificsFrom: aWidget
	"Do nothing"! !

!PWBToolBar methods ! 
copySpecificsTo: aPane

    aPane
        cellSize: self cellSize deepCopy;
        useSystem: self useSystem;
        elements: self elements deepCopy;
        vertical: self vertical.
! !

!TextPaneControl class methods !  
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #saved ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #controlTabbed ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #aboutToSave ;
                argumentNames: #( ));
        yourself! !

!WBDevelopmentWindow methods !  
setColor

	| currentWidget colorElements selections |
	currentWidget := self currentWidget.
	colorElements := self selections size = 1
		ifTrue: [currentWidget getColors: self]
		ifFalse: [
			WBRGBColorDialog new
				elements: currentWidget colorElements
				defaults: currentWidget colorDefaults
				paneEdited: currentWidget].
	colorElements isNil ifTrue: [^nil].
	selections := self selections isEmpty
		ifTrue: [Array with: self shell]
		ifFalse: [self selections].
	selections do: [:widget |
		widget usesColor 
			ifTrue: [widget setColorsUsing: colorElements]].
	self redisplaySelection.! !

!WBPoolManagerWindow methods !
menuCategoryDelete: aCollection

	aCollection do: [:eachCategory |
		self poolManager removeCategory: eachCategory].! !

!WBLayoutForm methods ! 
layoutChanged
    "Do nothing"! !

!WBEventManagerWindow methods ! 
toFieldNeedsContents: aPane

	"Callback for the #needsContents event triggered in the WBComboBox named 'toField'.
	 (Generated by WindowBuilder)"

	| aHandler newContents |
	newContents := 
		(self widgetList reject: [:each | each isString]),
		(self toFieldExtensions keys asSortedCollection).
	(aHandler := self handlerSelected) notNil ifTrue: [
		newContents
			detect: [:each | each == aHandler receiver]
			ifNone: [newContents := (Array with: aHandler receiver), newContents]].
	aPane
		contents: newContents;
		selection: (
			aHandler notNil
				ifTrue: [aHandler receiver]
				ifFalse: [self targetObject]).
	self zap.! !

!WBLayoutWizard class methods !  
initializeWidgetMap

    ^IdentityDictionary new
        at: Object put: #(#EnhancedEntryField #EntryField #ComboBox #ListBox #CheckBox #CP3DCheckBox) asOrderedCollection;
        at: UndefinedObject put: #(#EnhancedEntryField #EntryField #ComboBox #ListBox #CheckBox #CP3DCheckBox) asOrderedCollection;
        at: String put: #(#EnhancedEntryField #EntryField #ComboBox #ListBox) asOrderedCollection;
        at: Integer put: #(#CPNumericEditor #EnhancedEntryField #EntryField #ComboBox) asOrderedCollection;
        at: SmallInteger put: #(#CPNumericEditor #EnhancedEntryField #EntryField #ComboBox) asOrderedCollection;
        at: Float put: #(#EnhancedEntryField #EntryField #ComboBox) asOrderedCollection;
        at: Number put: #(#EnhancedEntryField #EntryField #ComboBox) asOrderedCollection;
        at: Boolean put: #(#CheckBox #CP3DCheckBox #CPToggleButton #EnhancedEntryField #EntryField) asOrderedCollection;
        at: Date put: #(#CPDateEditor #EnhancedEntryField #EntryField) asOrderedCollection;
        at: Time put: #(#CPTimeEditor #EnhancedEntryField #EntryField) asOrderedCollection;
        at: Collection put: #(#CPColumnarListBox #CPTablePane #ListBox) asOrderedCollection;
        at: OrderedCollection put: #(#CPColumnarListBox #CPTablePane #ListBox) asOrderedCollection;
        at: Array put: #(#CPColumnarListBox #CPTablePane #ListBox) asOrderedCollection;
        yourself! !

!WBCreateBitmap class methods !   
lastBitmapWidth: anInteger

	^lastBitmapWidth := anInteger! !

!WBInterfaceObject methods !   
contentsValueManager

    ^contents wbIsPValueManager
		ifTrue: [contents]
		ifFalse: [nil]! !

!WBKeyEntryField methods !  
wmCharResultFor: aCharacter
        "Private - Answer the value to return to the host operating system
       character input message when aCharacter is being entered."
	^1! !

!WBMenubarEditor methods !  
allowAttributesFor: anItem

    ^(super allowAttributesFor: anItem) & anItem parent isRoot not! !

!WindowBuilder methods !   
menuFileCreateComposite

    self geometryManager copySelections.
    self class new newCompositePaneFrom: self.! !

!WBLayoutForm methods ! 
minSize: aPoint
    "Set the value of minSize."

    minSize := aPoint.! !

!PWBToolBar methods !
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	(#(#clicked: #selecting: #doubleClick: #showHelp:) includes: eventSymbol)
		ifTrue: [^#('selector')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!WindowBuilder methods !   
menuToolsInspectVirtualKeyConstants

    VirtualKeyConstants inspect! !

!WBInterfaceObject methods ! 
text

    ^self contents! !

!WBLookPolicyWin95 methods ! 
frameWidthSizable

    ^frameWidthSizable ifNil: [
        frameWidthSizable := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxframe" 32]
            ifFalse: [super frameWidthSizable]]! !

!WBInterfaceObject class methods ! 
tabOrderSortBlock

    | children |
    ^[:a :b |
        (b tabPosition isNil)
            ifTrue: [
                a tabPosition isNil
                    ifTrue: [
                        a parent isNil
                            ifTrue: [false]
                            ifFalse: [
                                children := a parent children.
                                (children indexOf: a) <= (children indexOf: b)]]
                    ifFalse: [true]]
            ifFalse: [
                a tabPosition isNil
                    ifTrue: [false]
                    ifFalse: [a tabPosition <= b tabPosition]]].! !

!WBUndoManager methods !
owner: aWindowBuilder

    owner := aWindowBuilder.
    self bindToOwner.! !

!WBPropertyEditor methods !
valueStringChanged: aString

    | property newValue |
    newValue := valueString contents.
    (property := self selectedProperty) isNil ifTrue: [^nil].
    property value isString
        ifFalse: [
            newValue := (self compilerEvaluate: newValue) ifNil: [property value]].
    (changes at: property ifAbsent: [property value]) = newValue
        ifFalse: [
            changes at: property put: newValue.
            (self paneNamed: 'revertButton') enable.
            self updateItems].! !

!WBHandle class methods ! 
on: aFigure at: aSymbol

     ^self new setLocator: (WBLocator on: aFigure at: aSymbol)! !

!WBLayoutFrameEditor methods !
attachLeftBottomRight

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: #(0 1 1 1).! !

!WBKeyAccel methods !   
accelBits

    | accelBits |

    accelBits := 0.

    (isAlt) ifTrue: [ accelBits := accelBits + AfAlt ].
    (isControl) ifTrue: [ accelBits := accelBits + AfControl ].
    (isShift) ifTrue: [ accelBits := accelBits + AfShift ].

    ^accelBits! !

!String methods !  
asBasicToken
		"Answer the receiver as a valid token."
	| answerStream prevChar |
	#addedByOSI.
	answerStream := WriteStream on: (String new: self size).
	self do: [ :eachChar |
		eachChar isAlphaNumeric ifTrue: [
			answerStream nextPut: (
				(prevChar isNil or: [ prevChar isAlphaNumeric ])
					ifTrue: [ eachChar ]
					ifFalse: [ eachChar asUpperCase ] ) ].
		prevChar :=  eachChar ].
	^answerStream contents! !

!WBCodePolicy methods !  
compileMethodFor: aCodeModule
		"Private - Compile the method."
	^self basicCompileMethodFor: aCodeModule! !

!WBGeometryManager methods !
bringForward
    "Bring the selected widgets forward in the z-order"

    self bringForward:
        (self children select: [:child |
            self selections includes: child]).! !

!WBRGBColorDialog methods !   
chooseRGBColor

    "Callback for the #clicked event triggered in the Button named 'chooseRGBColor'.
     (Generated by WindowBuilder)"

    | newColor |
    (newColor := (ColorDialog new
        openOn: self rgbColor) chosen) isNil
        ifFalse: [
            self updateRGBField: newColor.
            self rgbChanged: nil].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventManagerWindow methods !
allEvents
	"Answer the events for the all widgets."

	| answer |
	answer := Set new.
	self widgetList do: [:each | answer addAll: each wbEventsTriggered].
	answer := answer asSortedCollection asArray.
	^answer! !

!WBMethodStubModule methods !  
generateCode
	"Generate the code..."

	self methodExists ifFalse: [super generateCode].! !

!WBAddInManager methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| done help install list mainView remove xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	done := Button new.
	help := TextEdit new.
	install := Button new.
	list := ListBox new.
	remove := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Add-In Manager';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -155/2 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -66 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -155/2 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -66 * yDU).
	self addView: mainView.
	
	help "TextEdit"
		owner: self;
		setName: 'help';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 0; rightInset: -153 * xDU;
				bottomRatio: 0; bottomInset: -112 * yDU);
		addHorizontalScrollbarStyle;
		addVerticalScrollbarStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: help.
	
	list "ListBox"
		owner: self;
		setName: 'list';
		when: #clicked: send: #select: to: self;
		when: #doubleClicked: send: #toggle: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -153 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: list;
		subPaneWithFocus: list.
	
	install "Button"
		owner: self;
		setName: 'install';
		when: #clicked send: #install to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 116 * yDU;
				rightRatio: 0; rightInset: -34 * xDU;
				bottomRatio: 0; bottomInset: -130 * yDU);
		contents: '&Enable';
		startGroup;
		font: SysFont.
	mainView addSubpane: install.
	
	remove "Button"
		owner: self;
		setName: 'remove';
		when: #clicked send: #remove to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 36 * xDU;
				topRatio: 0; topInset: 116 * yDU;
				rightRatio: 0; rightInset: -68 * xDU;
				bottomRatio: 0; bottomInset: -130 * yDU);
		contents: '&Disable';
		startGroup;
		font: SysFont.
	mainView addSubpane: remove.
	
	done "Button"
		owner: self;
		setName: 'done';
		when: #clicked send: #done to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 121 * xDU;
				topRatio: 0; topInset: 116 * yDU;
				rightRatio: 0; rightInset: -153 * xDU;
				bottomRatio: 0; bottomInset: -130 * yDU);
		contents: '&Done';
		startGroup;
		font: SysFont.
	mainView addSubpane: done! !

!WBLayoutForm methods !   
wbHalt
   self clearMouseCapture.
    super wbHalt.! !

!FrameObject methods !
importantEvents

    ^OrderedCollection new.! !

!WBPoolManager methods ! 
isIndirectCodeGenerationStyle: aBoolean

	self codeGenerationStyle: (
		aBoolean
			ifTrue: [self defaultIndirectCodeGenerationStyle]
			ifFalse: [#key]).! !

!PEntryFieldGroup methods ! 
storeStyleOn: aStream indentString: spaceString! !

!WindowBuilder methods !
menuScrapbookLoad

	| fileName |
	(Smalltalk includesKey: #ObjectFiler)
		ifFalse: [^MessageBox message: 'Loading a Scrapbook requires the ObjectFiler be loaded first.'].
	fileName := (FileDialog new
			openTitle: 'Load Scrapbook'
			fileSpec: '*.SBK'
			showFileInButton: false) file.
	fileName isNil
		ifFalse: [
			self class scrapbookLoadFile: fileName.
			self updateQuickReferenceMenu].! !

!WBListEditor methods !
add

	item contents isEmpty ifTrue: [^self].
	list add: item contents.
	listBox 
		contents: list;
		selectItem: item contents.
	item selectAll; setFocus.
	self enable! !

!WBLayoutForm methods ! 
duplicatableWidgets
    "Answer the duplicatable versions of the selected widgets"

    ^self selections collect: [:each |
        each wbDuplicate]! !

!WBCreateClassDialog class methods !   
defaultSuperClass

    ^DefaultSuperClass ifNil: [DefaultSuperClass := IdentityDictionary new]! !

!WBPoolManagerWindow methods ! 
suggestedCategories
	"Answer a collection of suggested categories."

	| answer |
	answer := self suggestedCategoriesPrim copy asSet.
	self allCategories do: [:each |
		answer remove: each ifAbsent: []].
	^answer asSortedCollection! !

!WBStatusPaneEditor methods ! 
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| auto boxesLabel cancel contents contentsLabel copy down 
	insert mainView name nameLabel ok paste remove space 
	spaceLabel statusBoxLabel up width widthLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	list := WBListBox new.
	
		"Temporary Variables"
	auto := CheckBox new.
	boxesLabel := GroupBox new.
	cancel := Button new.
	contents := WBEntryField new.
	contentsLabel := StaticText new.
	copy := Button new.
	down := Button new.
	insert := Button new.
	name := EnhancedEntryField new.
	nameLabel := StaticText new.
	ok := Button new.
	paste := Button new.
	remove := Button new.
	space := EnhancedEntryField new.
	spaceLabel := StaticText new.
	statusBoxLabel := GroupBox new.
	up := Button new.
	width := EnhancedEntryField new.
	widthLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'StatusPane Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -118 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -47 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -118 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -47 * yDU).
	self addView: mainView.
	
	nameLabel "StaticText"
		owner: self;
		setName: 'nameLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -168 * xDU;
				bottomRatio: 0; bottomInset: -22 * yDU);
		rightJustified;
		contents: 'Name:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: nameLabel.
	
	widthLabel "StaticText"
		owner: self;
		setName: 'widthLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 42 * yDU;
				rightRatio: 0; rightInset: -168 * xDU;
				bottomRatio: 0; bottomInset: -50 * yDU);
		rightJustified;
		contents: 'Width:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: widthLabel.
	
	spaceLabel "StaticText"
		owner: self;
		setName: 'spaceLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 0; rightInset: -168 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		rightJustified;
		contents: 'Space:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: spaceLabel.
	
	contentsLabel "StaticText"
		owner: self;
		setName: 'contentsLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 134 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 0; rightInset: -168 * xDU;
				bottomRatio: 0; bottomInset: -36 * yDU);
		rightJustified;
		contents: 'Contents:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: contentsLabel.
	
	list "WBListBox"
		owner: self;
		setName: 'list';
		when: #changedIndex: send: #selectBox: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -84 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: list;
		subPaneWithFocus: list.
	
	insert "Button"
		owner: self;
		setName: 'insert';
		when: #clicked send: #insert to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 86 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -124 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		contents: '&Insert';
		startGroup;
		font: SysFont.
	mainView addSubpane: insert.
	
	copy "Button"
		owner: self;
		setName: 'copy';
		when: #clicked send: #copy to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 86 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -124 * xDU;
				bottomRatio: 0; bottomInset: -48 * yDU);
		contents: '&Copy';
		startGroup;
		font: SysFont.
	mainView addSubpane: copy.
	
	paste "Button"
		owner: self;
		setName: 'paste';
		when: #clicked send: #paste to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 86 * xDU;
				topRatio: 0; topInset: 50 * yDU;
				rightRatio: 0; rightInset: -124 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		contents: '&Paste';
		startGroup;
		font: SysFont.
	mainView addSubpane: paste.
	
	up "Button"
		owner: self;
		setName: 'up';
		when: #clicked send: #up to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 0; rightInset: -44 * xDU;
				bottomRatio: 0; bottomInset: -86 * yDU);
		contents: '&Up';
		startGroup;
		font: SysFont.
	mainView addSubpane: up.
	
	down "Button"
		owner: self;
		setName: 'down';
		when: #clicked send: #down to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 0; rightInset: -84 * xDU;
				bottomRatio: 0; bottomInset: -86 * yDU);
		contents: '&Down';
		startGroup;
		font: SysFont.
	mainView addSubpane: down.
	
	remove "Button"
		owner: self;
		setName: 'remove';
		when: #clicked send: #remove to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 86 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 0; rightInset: -124 * xDU;
				bottomRatio: 0; bottomInset: -86 * yDU);
		contents: '&Remove';
		startGroup;
		font: SysFont.
	mainView addSubpane: remove.
	
	name "EnhancedEntryField"
		owner: self;
		setName: 'name';
		when: #textChanged: send: #setName: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 170 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -228 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		startGroup;
		font: SysFont;
		character: #okAlphaNumericNoSpace:.
	mainView addSubpane: name.
	
	contents "WBEntryField"
		owner: self;
		setName: 'contents';
		when: #textChanged: send: #setContents: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 170 * xDU;
				topRatio: 0; topInset: 26 * yDU;
				rightRatio: 0; rightInset: -228 * xDU;
				bottomRatio: 0; bottomInset: -38 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: contents.
	
	width "EnhancedEntryField"
		owner: self;
		setName: 'width';
		when: #textChanged: send: #setWidth: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 170 * xDU;
				topRatio: 0; topInset: 40 * yDU;
				rightRatio: 0; rightInset: -202 * xDU;
				bottomRatio: 0; bottomInset: -52 * yDU);
		startGroup;
		font: SysFont;
		setTextLimit: 4;
		character: #okInteger:.
	mainView addSubpane: width.
	
	auto "CheckBox"
		owner: self;
		setName: 'auto';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 204 * xDU;
				topRatio: 0; topInset: 42 * yDU;
				rightRatio: 0; rightInset: -228 * xDU;
				bottomRatio: 0; bottomInset: -52 * yDU);
		contents: 'Auto';
		startGroup;
		font: SysFont.
	mainView addSubpane: auto.
	
	space "EnhancedEntryField"
		owner: self;
		setName: 'space';
		when: #textChanged: send: #setSpace: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 170 * xDU;
				topRatio: 0; topInset: 54 * yDU;
				rightRatio: 0; rightInset: -202 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		startGroup;
		font: SysFont;
		setTextLimit: 4;
		character: #okInteger:.
	mainView addSubpane: space.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 166 * xDU;
				topRatio: 0; topInset: 74 * yDU;
				rightRatio: 0; rightInset: -198 * xDU;
				bottomRatio: 0; bottomInset: -90 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 200 * xDU;
				topRatio: 0; topInset: 74 * yDU;
				rightRatio: 0; rightInset: -232 * xDU;
				bottomRatio: 0; bottomInset: -90 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	statusBoxLabel "GroupBox"
		owner: self;
		setName: 'statusBoxLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 132 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -232 * xDU;
				bottomRatio: 0; bottomInset: -70 * yDU);
		contents: 'StatusBox';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: statusBoxLabel.
	
	boxesLabel "GroupBox"
		owner: self;
		setName: 'boxesLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -128 * xDU;
				bottomRatio: 0; bottomInset: -90 * yDU);
		contents: 'Status Boxes';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: boxesLabel! !

!WBGraphicObject methods ! 
propertyAt: key 
		"Answer the value associated with key
		in the properties dictionary."
	properties isNil ifTrue: [^nil].
	^properties at: key ifAbsent: [nil]! !

!WBCodeStream methods !
openParenthesis
	"Append a '(' to the code stream."

	noParenthesis
		ifTrue: [
			parenthesis add: false.
			noParenthesis := false]
		ifFalse: [
			parenthesis add: true.
			stream nextPut: $(].
	self indentBy: 1.! !

!PTextEdit methods !  
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	eventSymbol == #entered: ifTrue: [^#('aString')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!WBAbstractAddInModule class methods !  
modulesModifyingPalette
    "Answer a collection of all of the Add-In Module classes
     that modify the palette"

    ^self loadedModules select: [:module |
        module modifiesPalette]! !

!WBScrapbookStore methods ! 
getChapter: selectedItems

    (self paneNamed: 'name') contents isEmpty ifTrue: [
        (self paneNamed: 'ok') disable
    ] ifFalse: [
        selectedItems isEmpty ifTrue: [
            (self paneNamed: 'ok') disable
        ] ifFalse: [
            (self paneNamed: 'ok') enable
        ].
    ]! !

!Object methods !   
wbStoreOn: aStream
        "Append the ASCII representation of the
         receiver to aStream from which the
         receiver can be reinstantiated."
    #addedByOSI.
    ^self storeOn: aStream! !

!WindowBuilder class methods !
listAddIns

	| list class |
	list := OrderedCollection new.
	class := self.
	[class symbol == #ViewManager] whileFalse: [
		list addAll:
			(class class methodDictionary keys asSortedCollection select: [:selector |
				(selector beginsWith: 'addIn') and: [selector last == $:]]).
			class := class superclass].
	^list! !

!WBTreeListBox methods !
setEditBox


        owningEditBox setContents: (
            self selectedItem notNil ifTrue: [
                self selectedItem title
            ] ifFalse: [
                ''.
            ]
        ).
        owningEditBox selectAll.! !

!WindowBuilder class methods !
createMethod: bodyString titled: title in: aClass loggingSource: logSource

	| methodString def annotationManager |
	methodString := title , '
' , bodyString.
	"Consolidate all code creation"
	def := self
		createMethod: methodString
		in: aClass
		loggingSource: logSource.
	self teamIsInstalled & logSource
		ifTrue: [
			def isNil
				ifTrue: [^MessageBox message: 'There has been a serious source code generation error. See the Transcript for details'].
			annotationManager := Smalltalk at: #AnnotationManager.
			def annotationNamed: annotationManager categoriesLabel put: 'private'.
			def annotationNamed: annotationManager versionLabel put: 'Generated by WindowBuilder Pro'].
	! !

!WindowBuilder methods !
setEvents

	self invoke: WBEventManagerWindow.! !

!WBFontSelectionWindow methods !   
preInitWindow

	(self paneNamed: 'fontList') ownerDrawFixed.
	super preInitWindow.
	self updateContents.
	sampleTextEdit contents:
		'The quick brown fox jumped over the sleeping dog.'! !

!WBFramerExample methods !   
updateSliders! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPoolManagerWindow methods !   
optionMenu

	^self menuTitled: 'Option'! !

!WindowBuilder methods !  
redisplaySelection

	self layoutForm hideHandles.
	thePane isFrameObject
		ifTrue: [
			self layoutForm
				hideShellHandles;
				hideWindow;
				reframeAll;
				showWindow]
		ifFalse: [self layoutForm redisplaySelection].
	self layoutForm showHandles.
	thePane isFrameObject
		ifTrue: [self layoutForm showShellHandles].
	self layoutFormChanged.! !

!WBHandle methods !
containsPoint: aPoint

    ^self bounds containsPoint: aPoint! !

!WBGraphicObject methods !  
propertyAt: key ifAbsent: aBlock
		"Answer the value associated with key
		in the properties dictionary; if absent, 
		answer the result of evaluating aBlock."
	properties isNil ifTrue: [^aBlock value].
	^properties at: key ifAbsent: aBlock! !

!WBInterfaceObject methods !  
isGroupable

    ^false! !

!Object methods ! 
wbFullCopyReal: aDictionary
	"Answer a full copy of the receiver."

	#addedByOSI.
	^self wbFullCopyObject: aDictionary! !

!WBPoolManagerWindow methods !   
menuKeyMove

    "Callback for the menu item titled 'Move...'.
     (Generated by WindowBuilder)"

	| keysAndPools pool |
	(keysAndPools := self selectedKeysAndPools) isEmpty ifTrue: [^self].
	pool := WBListChooser new
		fromList: (self pools collect: [:each | each poolName]) asSortedCollection
		prompt: 'Move key(s) to which pool?'
		selection: keysAndPools first value poolName.
	pool := self poolManager poolFor: pool.
	pool isNil ifTrue: [^self].
	keysAndPools := keysAndPools reject: [:each | each value == pool].
	keysAndPools isEmpty ifTrue: [^self].
	keysAndPools do: [:each |
		(pool includesKey: each key) ifTrue: [
			^MessageBox message:
				each key printString, ' already exists in ', pool poolName]].
	[self menuKeyMove: keysAndPools toPool: pool]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].! !

!WBCodeGenerator methods !  
useInstVars
	"Answer true if the receiver should generate instVar references."

	^useInstVars ifNil: [useInstVars := self wbEditorClass useInstVars]! !

!WBResizeBitmap methods !   
oldHeight: anInteger

	(self paneNamed: 'oldHeightField') contents: anInteger asString.! !

!PropertyManager methods !
wbEventsForEdit
	"Answer the event definitions."

	#addedByOSI.
	^(self propertyAt: #wbEvents) ifNil: [
		self propertyAt: #wbEvents put: Dictionary new.
		self propertyAt: #wbEvents]! !

!String methods ! 
asSelectorTokenWithArgCount: anInteger
		"Answer the receiver as a valid token."
	| answer word tokens stream |
	answer := self select: [ :each | each = $: | each isAlphaNumeric ].
	tokens := OrderedCollection new.
	stream := ReadStream on: answer.
	[	word := stream upTo: $: .
		word notEmpty ifFalse: [ word := 'arg' ].
		word first isLetter ifFalse: [ word := 'a', word ].
		tokens add: word.
		stream atEnd ] whileFalse: [ ].
	anInteger = 0 ifTrue: [ ^tokens first ].
	stream := WriteStream on: (String new: answer size + 5).
	1 to: anInteger do: [ :index |
		stream nextPutAll: (
			index <= tokens size
				ifTrue: [ tokens at: index ]
				ifFalse: [ 'arg' ] ); nextPut: $: ].
	^stream contents! !

!WBLayoutForm methods !  
children
    "Answer a collection of the children of the receiver."

    ^self shell children
! !

!WBAbstractCodeModule methods !  
messageArgumentCount
		"Private - Answer the default message selector argument count."
	^Message numberOfArgumentsFor: self messageSelector! !

!WBLayoutForm methods !   
directEditor: aWBDirectEditorManager event: event
    "Set the value of directEditor."

    aWBDirectEditorManager isNil ifTrue: [^self].
    self directEditor: aWBDirectEditorManager.
    aWBDirectEditorManager
        layoutForm: self event: event;
        run.! !

!WBLayoutForm methods !  
getNewNameFor: aClass
    "Answer a valid name for the new widget"

    | baseName proposedName widgetNames count |

    baseName := 'a', aClass name.
    proposedName := baseName.
    widgetNames := self allChildren collect: [:each | each name].
    count := 0.
    [widgetNames includes: proposedName]
        whileTrue: [
            count := count + 1.
            proposedName := baseName, count printString].
    ^proposedName! !

!Class methods !  
wbTranslate
    "Open window builder translator on the receiver."

    (Smalltalk at: #WBTranslator) new translate: self.! !

!WBNLSDictionaryReader class methods ! 
fileOutInclude: aFileName on: aStream
	"File out a token/value pair inside a comment."

	^self
		fileOutToken: 'INCLUDE'
		value: aFileName
		inCommentOn: aStream! !

!WBTemplateEditor methods !
loadList

	templateList contents: self templateKeys.
	removeButton disable.! !

!WBTabOrderEditor methods !  
cancel

	Notifier isAltKeyDown ifTrue: [^layoutForm inspect].
	self cleanUp.
	layoutForm restoreOldTabPositions.
	result := false.
	self close! !

!WindowBuilder methods !   
abortOpen
	"Trigger the event and check the responces."

	self propertyAt: #abortOpen put: true.! !

!WBModelBasicSetModule methods !
defaultComment
        "Answer the default comment string."
    ^'Private - set the value of ', self object name, ' to <', self messageArguments first, '>.',
        super defaultComment! !

!WBClassDefinition methods !  
initialize: aClass
		"Private - Initialize the receiver."
	classField := aClass.! !

!WBTreeNode methods !
withoutEmptyNodes

    | newNode |

    newNode := self copy.

    newNode children: (
        (children select: [ :c |
            c title trimBlanks notEmpty
        ]) collect: [ :c |
            c withoutEmptyNodes.
        ]
    ).

    ^newNode! !

!WBInterfaceObject methods !   
initialize

	super initialize.
	framingBlock := LayoutFrame new.
	self font: self defaultFont.
	foreColor := self defaultForeColor.
	backColor := self defaultBackColor.! !

!WBPoolManagerWindow methods !   
menuKeyRename

    "Callback for the menu item titled 'Rename...'.
     (Generated by WindowBuilder)"

	| keysAndPools newKey oldKey pattern result |
	(keysAndPools := self selectedKeysAndPools) isEmpty ifTrue: [^self].
	keysAndPools size > 1
		ifTrue: [
			(oldKey := Prompter
				prompt: 'Rename ', keysAndPools size printString, ' keys from...'
				default: '*') ifNil: [^self].
			pattern := Pattern new: oldKey.
			keysAndPools := keysAndPools select: [:each |
				(result := pattern match: each key index: 1) notNil and: [
					result x = 1 and: [result y = each key size]]].
			keysAndPools isEmpty ifTrue: [
				^MessageBox message: 'No keys matched ', oldKey printString]]
		ifFalse: [
			oldKey := keysAndPools first key.
			pattern := Pattern new: oldKey].
	(newKey := Prompter
		prompt: 'Rename ', oldKey printString, ' to...'
		default: oldKey) ifNil: [^self].
	keysAndPools := keysAndPools collect: [:each |
		each => (pattern wbTranslate: each key using: newKey)].
	result := Set new.
	keysAndPools do: [:each |
		(each key value isValidNewKey: each value) ifFalse: [
			(each key value isValidKey: each value)
				ifTrue: [
					^MessageBox message:
						'Duplicate key: ', each value printString]
				ifFalse: [
					^MessageBox message:
						'Invalid key: ', each value printString]].
		(result includes: each value) ifTrue: [
			^MessageBox message:
				'Cannot rename multiple keys to ', each value printString].
		result add: each value].
	[self menuKeyRename: keysAndPools]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].
	keysAndPools := keysAndPools collect: [:each | each value => each key value].
	keyListBox setTopIndex: (
		(keyListBox contents indexOf: keysAndPools first)
			- 4 max: 1).! !

!WBLinkEditor methods ! 
selectType: selectedItem

    (self paneNamed: 'typeDescription') contents:
        (self class descriptions at: selectedItem)! !

!WBLayoutForm methods !   
handlesFor: aWidget

    ^self handles select: [:aHandle | aHandle owner == aWidget].! !

!WBLayoutForm methods ! 
shell
    "Answer the current window."

    ^self model shell
! !

!WBCreateClassDialog class methods ! 
defaultPackage

    ^DefaultPackage ifNil: [DefaultPackage := '** unpackaged **']! !

!WBLayoutForm methods ! 
setupPlacing: aPoint
    "Setup for the placing a widget."

    self releaseState: #buttonReleasePlacing:.
    self motionState: #button1MotionResizing:.
    self minSize: self loadedWidgets first wbMinSize.
    self maxSize: self loadedWidgets first wbMaxSize.
    self setupInWhiteSpace: aPoint.
    self currentNib: #bottomRight.
    self setCursor: #bottomRight.! !

!WBManagedPFont methods !   
pools
	"Answer the pools to search."

	^WBFontManager current pools asArray collect: [:each | each pool]! !

!WBLookPolicyWin31 class methods !  
upArrow

    ^Up ifNil: [Up := WBBitmapClass new  fromSysID: ObmUparrow]! !

!PCheckBox class methods !   
styleFrom: style

	^(style bitIsOn: BsAutocheckbox)
		ifFalse: [#checkBox]
		ifTrue: [#autoCheckBox].! !

!WBClassDefinition methods !  
basicPoolNames
		"Private - Answer the receiver's poolNames."
	^self classField sharedPools asSet! !

!WBUndoManager methods !
redo: aCount

    | newUndo |
    self deferRedraw:
        [self setInUndo.
        1 to: aCount do: [:i |
            current == undoList size
                ifFalse: [
                    current := current + 1.
                    (newUndo := undoList at: current) redo]].
        newUndo isNil
            ifFalse: [
                current == undoList size
                    ifTrue: [self setCantRedo]
                    ifFalse: [self setRedoLabel: self redoString, ' ', (undoList at: current + 1) label].
                self
                    setUndoLabel: self undoString, ' ', newUndo label;
                    setUndoState: true].
            self resetInUndo].! !

!WBInterfaceObject methods ! 
defaultForeColor

    ^Color windowText! !

!WBModelInitializeModule methods !
defaultComment
        "Answer the default comment string."
    ^'Private- initialize the receiver.',
        super defaultComment! !

!WBNLSManagerWindow methods ! 
windowTitle

	^'NLS Manager'! !

!WindowBuilder methods ! 
menuOptionsTargetIsFirst

    | aBoolean |
    aBoolean := self class togglePropertyValueAt: #TargetIsFirst.
    self updateOptionsMenu.
    self layoutForm isNil
        ifFalse: [self layoutForm targetIsFirst: aBoolean]! !

!WBTreeNode methods !   
exdent

    parent  isRoot ifFalse: [
        self parent: parent parent positioningAfter: parent.
        self shiftLeft.
    ].! !

!WindowFrameObject methods ! 
realStyleNames

	^Dictionary new
		at: #maximize put: 'Maximize';
		at: #minimize put: 'Minimize';
		at: #sizable put: 'Sizable';
		at: #sysmenu put: 'SysMenu';
		at: #titlebar put: 'TitleBar';
		at: #sysmodal put: 'SysModal';
		at: #modal put: 'Modal';
		yourself! !

!WBLayoutForm methods !  
button2Down: aPoint
    "Dragging the window via the title bar to the PARTS workbench?"
    "If yes, then allow the normal drag/drop mechanism to work."

    (self isLocalDragSource and: [self isDragButton: 2])
        ifTrue: [
            (self inTitle: aPoint) & self wbEditorClass partsSupportEnabled
                ifTrue: [^super button2Down: aPoint]].
    self triggerEvent: #gettingFocus.
    self loadedWidgets isNil
        ifTrue: [^self triggerEvent: #rightButtonDown: with: self].
    self 
        useRightButton;
        buttonDown: aPoint.! !

!WBFramingEditor methods !
newFramerForRect: aRect
parentRect: parentsRect

    | anchor coord framer |
    framer := (Smalltalk at: #FramingParameters) new.
    framer initialExtent: framingParameters initialExtent.
    (xCenteredCheckBox selection)
        ifTrue:
            [framer xCentered.
            ]
        ifFalse:
            [anchor := originXAnchor selectedItem.
            coord := aRect left.
            (originXStyleFixed selection) & (anchor ~= 'Pane right')
                ifTrue:
                    [(anchor = 'Window right')
                        ifTrue:
                            [coord := parentsRect width - coord.
                            framer left: coord relativeTo: #right.
                            ]
                        ifFalse:
                            [(anchor = 'Window center')
                                ifTrue:
                                    [coord := coord - (parentsRect width // 2).
                                    framer left: coord relativeTo: #center.
                                    ]
                                ifFalse:
                                    [framer left: coord relativeTo: #left.
                                    ]].
                    ].
            (originXStyleScaled selection)
                ifTrue:
                    [coord := coord / parentsRect extent x.
                    framer leftProportional: coord.
                    ].
            anchor := cornerXAnchor selectedItem.
            coord := aRect right.
            (cornerXStyleFixed selection) & (anchor ~= 'Pane left')
                ifTrue:
                    [(anchor = 'Window right')
                        ifTrue:
                            [coord := parentsRect width - coord.
                            framer right: coord relativeTo: #right.
                            ]
                        ifFalse:
                            [(anchor = 'Window center')
                                ifTrue:
                                    [coord := coord - (parentsRect width // 2).
                                    framer right: coord relativeTo: #center.
                                    ]
                                ifFalse:
                                    [framer right: coord relativeTo: #left.
                                    ]].
                    ].
            (cornerXStyleScaled selection)
                ifTrue:
                    [coord := coord / parentsRect extent x.
                    framer rightProportional: coord.
                    ].
            ].
    (yCenteredCheckBox selection)
        ifTrue:
            [framer yCentered.
            ]
        ifFalse:
            [anchor := originYAnchor selectedItem.
            coord := aRect top.
            (originYStyleFixed selection) & (anchor ~= 'Pane bottom')
                ifTrue:
                    [(anchor = 'Window top')
                        ifTrue:
                            [framer top: coord relativeTo: #top.
                            ]
                        ifFalse:
                            [(anchor = 'Window center')
                                ifTrue:
                                    [framer top: coord - (parentsRect height // 2) relativeTo: #center.
                                    ]
                                ifFalse:
                                    [framer top: parentsRect height - coord relativeTo: #bottom.
                                    ]].
                    ].
            (originYStyleScaled selection)
                ifTrue:
                    [coord := coord / parentsRect extent y.
                    framer topProportional: coord.
                    ].
            anchor := cornerYAnchor selectedItem.
            coord := aRect bottom.
            (cornerYStyleFixed selection) & (anchor ~= 'Pane top')
                ifTrue:
                    [(anchor = 'Window top')
                        ifTrue:
                            [framer bottom: coord relativeTo: #top.
                            ]
                        ifFalse:
                            [(anchor = 'Window center')
                                ifTrue:
                                    [framer bottom: coord - (parentsRect height // 2) relativeTo: #center.
                                    ]
                                ifFalse:
                                    [framer bottom: parentsRect height - coord relativeTo: #bottom.
                                    ]].
                    ].
            (cornerYStyleScaled selection)
                ifTrue:
                    [coord := coord / parentsRect extent y.
                    framer bottomProportional: coord.
                    ].
            ].
    framer left isNil & framer right isNil
        ifTrue:
            [framer left: aRect left relativeTo: #left.
            ].
    framer top isNil & framer bottom isNil
        ifTrue:
            [framer bottom: aRect bottom relativeTo: #bottom.
            ].
    ^framer! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PComboBox methods ! 
styleMap

    ^super styleMap
        at: #dynamicDropDown put: #(#dropDown #addDynamicListSizeStyle);
        at: #dynamicDropDownList put: #(#dropDownList #addDynamicListSizeStyle);
        yourself.! !

!WBEditClassDialog methods ! 
ok: ignore

    self ok! !

!WindowBuilder methods !  
setDirty

    self dirty: true! !

!WBInterfaceObject methods !   
sendToBackOf: aWidget

	self siblings 
		remove: self;
		add: self after: aWidget.
	self updateWidget.! !

!PListBox methods ! 
suggestedSize

	^(self contents isNil or: [self contents isEmpty])
		ifTrue: [super suggestedSize]
		ifFalse: [
			(self contents inject: 0 into: [:max :item |
				max max: (self font wbStringWidth: item)]) + 8 + self lookPolicy scrollBarWidth 
			@ ((self font height * self contents size + 8) min: self parent contentRect height)]! !

!WBInterfaceObject methods !
framingBlock

    ^framingBlock! !

!WBScrapbookStore methods !   
chapters

	^self wbEditorClass scrapbook keys asSortedCollection! !

!WBLookPolicyWin31 methods ! 
drawVScrollBarWith: aPen at: aRect

    | nonThumbRect |
    nonThumbRect := super drawVScrollBarWith: aPen at: aRect.
    aPen
        foreColor: Color black;
        wbLineFrom: aRect leftTop to: aRect leftBottom;
        wbLineFrom: (aRect rightTop left: 1) to: (aRect rightBottom left: 1).
    ^nonThumbRect! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder methods !   
geometryManager

    ^geometryManager! !

!WBMenuTester methods ! 
perform: selector
    "Scratch windows should not perform any events"
    ^MessageBox messageNote: 'Menu item selector: #',selector! !

!WBEventHandlerStubModule methods !   
eventDescription
	"Private - Answer the event description."

	^eventDescription ifNil: [
		eventDescription := self defaultEventDescription]! !

!WBDevelopmentWindow methods ! 
templates

	^WBInterfaceObject templates! !

!WBTemplateEditor methods !  
undoManager

	^WBUndoManager new! !

!WBTreeListBox methods ! 
notifySelected: aParameter
		"Private - the host signaled that an item was selected."
	| tempSelection |
	#osiHack.
	"Is tempSelection supposed to be an instance var?"
	self selectedItem isNil ifTrue: [^nil].
	self doubleClickQueued ifTrue: [ ^nil ].   "do nothing if a double click queued"
	( self commitSelection )
		ifTrue: [
			tempSelection := self selectedItem.
			previousSelection := self selection.
			self setEditBox.
			self triggerEvent: #clicked: with: tempSelection. ^nil ].
	self selectItem: tempSelection. ^nil! !

!WBTreeListBox methods !
selectionText: newText

    | selection |

    (selection := self selectedItem) notNil ifTrue: [
        self basicSelectionText: newText.
        self triggerEvent: #textChanged: with: self.
    ].! !

!PStaticText methods !
defaultForeColor

    ^Color staticText! !

!WindowBuilder class methods !
partsSupportEnabled
    "Answer true if PARTS code should be generated."

    ^self runtimeLessCode not and: [
        self partsSupportIsInstalled and: [
            self editorClass
                propertyValueAt: #PartsSupport
                category: self editorPropertyString]].! !

!WindowBuilder methods !   
menuFileSaveAsDefault

    | savedEditedClass |
    savedEditedClass := self editedClass.
    self editedClass: ((self editedClass inheritsFrom: WindowDialog)
        ifTrue: [WBDefaultDialogScratchWindow]
        ifFalse: [
            (self editedClass inheritsFrom: CompositePane)
                ifTrue: [WBDefaultCompositePaneScratchWindow]
                ifFalse: [WBDefaultScratchWindow]]).
    self setDirty.
    self generateApplicationCode isNil ifTrue: [^nil].
    self setDirty.
    self editedClass: savedEditedClass.
    ! !

!WBGeometryManager methods ! 
handles

    ^self layoutForm handles! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCodeStream methods !
generatePortableFontCode

	^(self propertyAt: #generatePortableFontCode)
		ifNil: [self wbEditorClass generatePortableFontCode]! !

!WBBitmapManagerWindow methods ! 
menuKeyFileOutRCFile8

	self menuKeyFileOutRCFile: #wbCopy8.! !

!WBPoolManagerWindow methods !   
menuCategoryAddSuggested

    "Callback for the menu item titled 'Add suggested...'.
     (Generated by WindowBuilder)"

	| suggested |
	(suggested := self suggestedCategories) isEmpty ifTrue: [
		^MessageBox message: 'All suggested categories have already been added.'].
	suggested := WBMultiListChooser
		fromList: suggested
		prompt: 'Select categories to add'.
	suggested isNil ifTrue: [^self].
	suggested isEmpty ifTrue: [^self].
	[self menuCategoryAddSuggested: suggested]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].
	self selectedCategory: suggested first.! !

!WBTreeListBox methods !  
insertAfterSelection

    self performOnSelection: #insert
        selectionDelta: 1
        moveWithSelection: false! !

!WBEditClassDialog methods !  
loadMostFrequent

    mostFrequent
        contents: self mostFrequentList;
        selectItem: self emptyString.! !

!WindowBuilder methods !  
scrollingForm

    ^scrollingForm! !

!WBListEntryField methods ! 
setContents: aString
		"Set the receiver's contents without triggering a textChanged event."
    self
		setPopupMenu: nil;
		contents: aString;
		removeTextChangedEvent;
		selectAll.! !

!OrderedCollection methods !   
wbStoreOn: aStream
        "Answer the receiver represented as a String
         from which it can be reconstructed."
    aStream
        nextPutAll: '(';
        nextPutAll: self class name;
        nextPutAll: ' new';
        indentBy: 1.
    (self inject: true into: [:firstTime :element |
        firstTime
            ifFalse: [aStream nextPut: $;].
        aStream cr; nextPutAll: 'add: '.
        element wbStoreOn: aStream.
        false])
            ifFalse: [aStream nextPut: $;; cr; nextPutAll: 'yourself'].
    aStream
        nextPut: $);
        indentBy: -1.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PEntryFieldGroup methods !
usesFont

     ^false! !

!PropertyAccessor methods ! 
wbUserDefault: anObject
	"Set the user default value for this property."

	#addedByOSI.
	^self propertyAt: #wbUserDefault put: anObject! !

!WBTabOrderLayoutForm methods ! 
setSmartGroups

	| newGrouper containedWidgets |
	WBTabOrderEditor includeOuter
		ifTrue: [
			newGrouper := self groupPaneClass example
				rect: self shell frameContentRect.
			(containedWidgets := self 
				allWidgetsContainedIn: newGrouper) isEmpty
				ifFalse: [
					newGrouper rect: ((self boundingBoxFor: containedWidgets) expandBy: 8).
					self children add: newGrouper.
					self groups at: newGrouper put: containedWidgets]].

	(self children select: [:widget | widget isGroupBox]) do: [:widget |
		newGrouper := self groupPaneClass example
			rect: widget rect.
		(containedWidgets := self 
			allWidgetsContainedIn: newGrouper) isEmpty
			ifFalse: [
				newGrouper rect: ((self boundingBoxFor: containedWidgets) expandBy: 8).
				self children add: newGrouper.
				self groups at: newGrouper put: containedWidgets]].

	((self children select: [:widget | widget isGrouper])
		asSortedCollection: [:a :b | 
			(self groups at: a) size > (self groups at: b) size]) do: [:group |
			self groups 
				at: group 
				put: ((self groups at: group) reject: [:widget | 
					(self groups keys
						detect: [:grp | grp ~~ group and: [(self groups at: grp) includes: widget]]
						ifNone: [nil]) notNil])].

	self groups keys do: [:group |
		(self groups at: group) size <= 1
			ifTrue: [
				self children remove: group ifAbsent: [nil].
				self groups removeKey: group ifAbsent: [nil]]
			ifFalse: [
				group rect: ((self boundingBoxFor: (containedWidgets := self groups at: group)) expandBy: 8).
				containedWidgets first tabPosition notNil
					ifTrue: [
						group
							tabPosition: (WBTabPosition fromTabPosition: (containedWidgets first tabPosition basicTabPosition))]]].

	self 
		moveGroupboxesToBack;
		resetGroups;
		normalizeTabOrder.

	self groups keys do: [:group |
		(containedWidgets := self 
			widgetsFrom: self children 
			containedIn: group) size <= 1
			ifTrue: [
				self children remove: group ifAbsent: [nil].
				self groups removeKey: group ifAbsent: [nil]]
			ifFalse: [
				self groups at: group put: containedWidgets.
				group rect: ((self boundingBoxFor: containedWidgets) expandBy: 8).
				containedWidgets first tabPosition notNil
					ifTrue: [
						group
							tabPosition: (WBTabPosition fromTabPosition: (containedWidgets first tabPosition basicTabPosition))]]].

	((self children select: [:widget | widget isGrouper])
		asSortedCollection: [:a :b | 
			(self groups at: a) size > (self groups at: b) size]) do: [:group |
			(self groups keys 
				detect: [:grp | grp ~~ group and: [grp rect intersects: group rect]]
				ifNone: [nil]) notNil
				ifTrue: [
					self children remove: group ifAbsent: [nil].
					self groups removeKey: group ifAbsent: [nil]]].

	self 
		moveGroupboxesToBack;
		resetGroups;
		normalizeTabOrder;
		updateWidget.! !

!WBNLSEditorCompositePane methods !   
addSubpanes

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| xDU yDU |
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	
		"Instance Variables"
	categoryEditField := EntryField new.
	categoryEditLabel := StaticText new.
	keyEditField := EntryField new.
	keyEditLabel := StaticText new.
	valueEditField := EntryField new.
	valueEditLabel := StaticText new.
	
	self
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -123/2 * xDU;
				topRatio: 1/2; topInset: -53 * yDU;
				rightRatio: 1/2; rightInset: -123/2 * xDU;
				bottomRatio: 1/2; bottomInset: -53 * yDU);
		backColor: Color gray.
	
	valueEditField "EntryField"
		owner: self;
		setName: 'valueEditField';
		when: #entered: send: #entered: to: self;
		when: #textChanged: send: #valueEditFieldChanged:pane: to: self withArgument: valueEditField;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 69 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 0; bottomInset: -81 * yDU);
		startGroup;
		font: SysFont.
	self addSubpane: valueEditField.
	
	keyEditField "EntryField"
		owner: self;
		setName: 'keyEditField';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 83/2 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 0; bottomInset: -107/2 * yDU);
		readOnly;
		backColor: Color gray;
		startGroup;
		font: SysFont.
	self addSubpane: keyEditField.
	
	categoryEditField "EntryField"
		owner: self;
		setName: 'categoryEditField';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 29/2 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 0; bottomInset: -53/2 * yDU);
		readOnly;
		backColor: Color gray;
		startGroup;
		font: SysFont.
	self addSubpane: categoryEditField.
	
	valueEditLabel "StaticText"
		owner: self;
		setName: 'valueEditLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 119/2 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 0; bottomInset: -135/2 * yDU);
		contents: 'Value';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: valueEditLabel.
	
	keyEditLabel "StaticText"
		owner: self;
		setName: 'keyEditLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 0; bottomInset: -40 * yDU);
		contents: 'Key';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: keyEditLabel.
	
	categoryEditLabel "StaticText"
		owner: self;
		setName: 'categoryEditLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 5 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 0; bottomInset: -13 * yDU);
		contents: 'Category';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: categoryEditLabel! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBDefaultScratchWindow class methods !   
isWBInternalClass

    ^true! !

!WBGeometryManager methods ! 
sizeByPixelLeft
    "Size the selected widgets left one pixel"

    | selections |
    (selections := self selections copy) isEmpty
        ifTrue: [^self owner setWindowSize: (self shell width - 1 @ self shell height)].
    (self undoManager
        add: 'Size Pixel Left'
        undo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    configureWidget: aWidget x
                    y: aWidget y
                    width: aWidget width + 1
                    height: aWidget height
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections]
        redo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    configureWidget: aWidget x
                    y: aWidget y
                    width: (aWidget width - 1 max: 0)
                    height: aWidget height
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections])
        redoAction value.
    self updateWidget.! !

!String methods ! 
asTempVarToken
		"Answer the receiver as a inst var token."
	| answer |
	#addedByOSI.
	((answer := self asBasicToken) isEmpty
		or: [ answer first isLetter not ])
			ifTrue: [ answer := 'temp', answer ].
	^answer! !

!WindowBuilder class methods !  
serialNumberPrim
	"Answer the window builder serial number."

	^self editorClass
		propertyValueAt: #SerialNumber
		category: self userPropertyString! !

!WBTreeNode methods !
children: c

    children := c! !

!WBModelDefinitionEditor methods ! 
setInitValue: initValue

    ^((initValue class inheritsFrom: String)
        or: [(initValue class inheritsFrom: Number)
        or: [initValue class inheritsFrom: Boolean]])
        ifTrue: [initValue]
        ifFalse: [nil]! !

!WBOutboardWindow methods !
opened

	self owner notNil ifTrue: [
		self owner outboards add: self.
		self owner when: #changed send: #ownerChanged to: self].! !

!PStaticGraphic methods ! 
suggestedSize

    ^32@32! !

!WBLayoutForm class methods !   
isWBInternalClass

    ^true! !

!WBMultiToolPalette methods !
at: key on: name put: aBitmapFileName selector: aSelector
    | temp element |
    temp := self elements.
    self elements: (self pageNamed: name).
    element := self at: key put: aBitmapFileName selector: aSelector.
    self elements: temp.
    ^element! !

!WindowBuilder methods ! 
menuFileSaveAs

    | temp windowType |
    windowType := self shell isDialog
        ifTrue: ['Dialog']
        ifFalse: [
            self shell isCompositePane
                ifTrue: ['CompositePane']
                ifFalse: ['Window']].
    (temp := (self class wbCreateClassDialog new forWindowType: windowType) result) notNil
        ifTrue: [
            self editedClass: temp.
            self labelWithoutPrefix: self label.
            self setDirty.
            self generateApplicationCode.
            windowType = 'Window'
                ifTrue: [
                    (self menuTitled: 'View') notNil
                        ifTrue: [self updateMenuView]]]
        ifFalse: [^nil].! !

!WBDevelopmentWindow methods !   
emptyString

	^''.! !

!WindowBuilder methods !   
setStatusForToolBarWidget: selector

    | message |
    selector isNil     ifTrue: [^nil].
    message := selector = 'ArrowTool'
        ifTrue: ['Use the arrow to select a pane for further editing.']
        ifFalse: ['Load the cursor with a ' , selector , '.'].
    self setStatus: message.! !

!WBTabOrderLayoutForm methods !
resetGroups

	| newGroup |
	self soloWidgets: (self children select: [:widget | 
		widget isGrouper not]).
	self groups: Dictionary new.
	(self children select: [:widget | widget isGrouper]) do: [:group |
		newGroup := self soloWidgets select: [:widget |
			widget staysToBack not 
			and: [(group rect containsPoint: widget rect leftTop) 
			and: [group rect containsPoint: widget rect rightBottom]]].
		self soloWidgets: (self soloWidgets reject: [:widget |
			newGroup includes: widget]).
		self groups at: group put: newGroup].
	self soloWidgets addAll: self groups keys.! !

!WBNLSManagerWindow class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowBuilder methods ! 
gridSize

    ^self class gridSize! !

!WBToolPalette class methods ! 
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #showHelp: ;
                argumentNames: #('anObject'));
        wbAddEvent: (
            WBEventDescription new
                event: #doubleClick: ;
                argumentNames: #('anObject'));
        wbAddEvent: (
            WBEventDescription new
                event: #selecting: ;
                argumentNames: #('anObject'));
        wbAddEvent: (
            WBEventDescription new
                event: #clicked: ;
                argumentNames: #('anObject'));
        yourself! !

!WBModelSetModule methods ! 
defaultCategory
        "Answer the default category for the receiver."
    ^'accessing'! !

!WBLayoutForm methods !  
nlsSelect

    ^self model nlsSelect! !

!WBCreateMenuModule methods !
defaultOwnerName
		"Answer the default owner name."
	^'self'! !

!WBCodeGenerator methods !   
policy: aCodePolicy
		"Set the receiver's code policy."
	policy := aCodePolicy.! !

!WBCallOutEditor methods !
initWindow

    panesList printSelector: #wbNameAndClass.
    callOutList printSelector: #wbNameAndClass.
    self
        initializeCallOutMap;
        updatePaneList;
        updateCallOutList.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventArgumentDescription methods !   
name: aString

	self key: aString.! !

!WindowBuilder methods !   
undoManager

    ^undoManager! !

!WBEventManagerWindow methods ! 
eventSelections
    "Answer the currently selected events."

	^eventListBox selectedItems! !

!WBAbstractCodeModule methods !
defaultLayoutComment
		"Answer the comment string."
	^' WARNING!!
			This method was automatically generated by WindowBuilder.
			Code you add here which does not conform
			to the WindowBuilder API will probably be lost the next time
			you save your layout definition.'.! !

!WBTargetObject methods !
modelObjects: aCollection

	modelObjects := aCollection.! !

!WBTemplateEditor methods !  
layoutFormChanged! !

!WBLookPolicy class methods ! 
default

    ^Default ifNil: [Default := self defaultPolicy new]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PStatusPane methods !  
contents: ignore

    super contents: nil.! !

!WBInterfaceObject methods !   
asRGBColor: aColor

    ^[aColor asRGBColor]
            on: Error
            do: [RGBColor fromInteger: aColor asInteger].! !

!WBLookPolicyOS2 methods ! 
frameWidthSizable

	^frameWidthSizable ifNil: [
		frameWidthSizable := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCxsizeborder" 4]
			ifFalse: [super frameWidthSizable]]! !

!WindowBuilder methods !   
menuToolsClearUndoManager

    self undoManager reset! !

!WBKeyAccel methods !   
accelBits: accelBits

    accelBits isNil ifTrue: [
       ^isAlt := isControl := isShift := false
    ].

    isAlt := ((accelBits bitAnd: AfAlt) ~= 0).
    isControl := ((accelBits bitAnd: AfControl) ~= 0).
    isShift := ((accelBits bitAnd: AfShift) ~= 0).! !

!WBLayoutWizard class methods ! 
initializeDefaultButtons

    ^#(
            'OK'
            'Cancel'
        ) asOrderedCollection! !

!WBFramingEditor methods !   
initializeExampleRects

	| fpClass |
	fpClass := Smalltalk at: #FramingParameters.
    (parentRect width > parentRect height)
        ifTrue:
            [beforeScaleFactor := (beforeRect extent x / fpClass newDialogUnit x) / parentRect width.
            ]
        ifFalse:
            [beforeScaleFactor := (beforeRect extent y / fpClass newDialogUnit y) / parentRect height.
            ].
    beforeRect frameRect: (0 @ 0 extent: (parentRect extent * beforeScaleFactor) rounded * 2).
    afterRect frameRect: (0 @ 0 extent: (afterRect extent / fpClass newDialogUnit) rounded * 2).
    largeParentRect := parentRect leftBottom extentFromLeftBottom: ((afterRect frameRect extent / beforeRect frameRect extent) * parentRect extent) rounded.! !

!WBLookPolicy methods !  
scrollBarThumbWidth

    ^self class default scrollBarThumbWidth! !

!WindowBuilder class methods !   
categories

    ^(self properties keys reject: [:sym | 
		sym == self privateString]) asSortedCollection asArray.! !

!WBDevelopmentWindow methods ! 
updateSize: aRect
	"Update the size label"

	| point |
	point := aRect extent.
	self sizeLabel contents: 
		point x asString , 'x' , 
		point y asString.! !

!WBPrototype methods ! 
styleFromWinClass: aClass

	| theStyle |
	theStyle := OrderedCollection new.
	aClass isModal
		ifTrue: [theStyle add: #modal].
	((aClass defaultFrameStyle bitAnd: (OperatingSystemConstants at: 'WsSysmenu')) = 0)
		ifFalse: [theStyle add: #sysmenu].
	((aClass defaultFrameStyle bitAnd: (OperatingSystemConstants at: 'WsMaximizebox')) = 0)
		ifFalse: [theStyle add: #maximize].
	((aClass defaultFrameStyle bitAnd: (OperatingSystemConstants at: 'WsMinimizebox')) = 0)
		ifFalse: [theStyle add: #minimize].
	((aClass defaultFrameStyle bitAnd: (OperatingSystemConstants at: 'WsThickframe')) = 0)
		ifFalse: [theStyle add: #sizable].
	((aClass defaultFrameStyle bitAnd: (OperatingSystemConstants at: 'WsCaption')) = 0)
		ifFalse: [theStyle add: #titlebar].
	^theStyle asArray! !

!WBPoolManagerWindow methods !
poolPathNeedsContents: aPane

    "Callback for the #needsContents event triggered in the EntryField named 'poolPathField'.
     (Generated by WindowBuilder)"

	| aString labelPane |
	labelPane := self paneNamed: 'poolPathLabel'.
	(aString := self poolPath) notNil
		ifTrue: [
			aPane enable.
			labelPane wbGrayEnable.
			aPane contents = aString ifFalse: [
				aPane contents: aString]]
		ifFalse: [
			aPane disable.
			labelPane wbGrayDisable.
			aPane contents: ''].! !

!WBPrototype methods ! 
wbConvertEventTables: widgetMap

	(Array with: self targetObject), self children, self modelObjects
		do: [:each | each wbRealWidget wbConvertEventTable: widgetMap].! !

!WBUndoManager methods !   
resetInUndo

    inUndo := false! !

!WBResourceDescriptor methods !  
value: anObject
    "Set the value of value."

    value := anObject! !

!Object methods !   
wbWrapper

	^self! !

!PDrawnButton methods ! 
fileExists: fileName

	| array file exists extension |
	(fileName includes: $*) ifTrue: [^false].
	array := File splitPath: fileName in: Disk.
	((file := array at: 3) includes: $.) ifFalse: [^false].
	exists := ((file ~= '.') and: [(file ~= '..') and: [File exists: fileName]]).
	exists ifTrue: [
		file := file asStream.
		extension := (file skipTo: $.; upTo: $.) asUpperCase.
		extension = 'BMP' ifTrue: [^true]].
	^false! !

!PWBToolBar methods !
defaultBackColor

    ^Color buttonFace! !

!WBLookPolicyWin31 class methods !
leftArrow

    ^Left ifNil: [Left := WBBitmapClass new  fromSysID: ObmLfarrow]! !

!WBLayoutWizard methods !  
setInitValue: initValue

    ^((initValue class inheritsFrom: String)
        or: [(initValue class inheritsFrom: Number)
        or: [initValue class inheritsFrom: Boolean]])
        ifTrue: [initValue]
        ifFalse: [nil]! !

!WBDevelopmentWindow methods ! 
templateKeys

	^self templates keys asSortedCollection! !

!WBCodeStream methods !
nextPutProperty: aWBProperty value: aValue for: anObject
    "Store the property in the receiver."

    aWBProperty wbDefault = aValue ifTrue: [^self].
    self cr;
        nextPutAll: aWBProperty setAction;
        space.
    aValue wbStoreOn: self.
    self endMessage.! !

!WBCompositePaneScratchWindow class methods !   
resetToDefault

    | fileInStream methodString |

    methodString := WBDefaultCompositePaneScratchWindow sourceCodeAt: #addSubpanes.
    fileInStream := ReadWriteStream on: (String new: methodString size).
    fileInStream
        nextPutAll: '!! WBCompositePaneScratchWindow methods !!';
        nextChunkPut: methodString;
        nextChunkPut: String new.
    fileInStream reset; fileIn.! !

!WBDescriptor methods !  
isEventDescriptor

    ^false! !

!WBLookPolicyWin31 methods !
wordBreak

    ^"DtWordbreak" 16! !

!WBTabOrderLayoutForm methods !  
restoreOldTabPositions

	self children do: [:widget | 
		widget tabPosition: (widget propertyAt: #oldTabPosition)].! !

!WBMenuEditor methods !  
getTestItMenu: button

    | menu list |

    self updateItem: menuItemsEditor selection.
    (list := menuItemsEditor listAttribute asFlatList) do: [:each |
        each
            title: (self nlsStringFor: each title);
            selector: nil].
    (menu :=  menuItemsEditor contents asMenu) isCollection ifTrue: [^self].
    list do: [:each | each title: (self nlsKeyFor: each title)].
    menu owner: self.
    button setPopupMenu: menu.! !

!WBAboutDialog methods !  
initWindow
    | font |
    font := SysFont.
    (self paneNamed: 'version') font: font.
    (self paneNamed: 'registeredTo') font: font.
    (self paneNamed: 'user') font: font.
    (self paneNamed: 'copyright')
        font: font;
        contents: (OperatingSystem isOS2
            ifTrue: ['(c) Copyright Objectshare Systems, Inc. 1993-1996\n(c) Copyright Cooper & Peters, Inc. 1991, 1992' replaceEscapeCharacters]
            ifFalse: ['(c) Copyright Objectshare Systems, Inc. 1993-1996\n(c) Copyright Cooper && Peters, Inc. 1991, 1992' replaceEscapeCharacters]).
    (self paneNamed: 'window') contents: WBWindowSysBitmap.
    (self paneNamed: 'osilogo') contents: WBOsilogoSysBitmap.
    (self paneNamed: 'wbpro') contents: WBWbproSysBitmap.
    (self paneNamed: 'address') contents: WBAddressSysBitmap.
    (Message
        receiver: self mainView
        selector: #bringToTop)
        performDeferred.! !

!WBModelBasicSetModule methods ! 
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self generateGeneratedSymbol.
        self stream
            cr; nextPutAll: self object name;
            nextPutAll: ' := '; nextPutAll: self messageArguments first;
            endExpression].! !

!WBCodeStream methods !
nextPutFontRef: aFont
	"Look up the receiver in the Font pools to find a match.
		If found, then include the pool variable in the code
		and answer true, else include a font definition,
		and answer false."

	^self nextPutFontRef: aFont indentString: ''! !

!WindowBuilder methods !
inENVY

	^self class envyIsInstalled! !

!WBEventManagerWindow methods !  
handlerListDrag: dragSession pane: aPane

    "Callback for the #dragSourceNeedsObject: event triggered in the MultipleSelectListBox named 'handlerListBox'.
     (Generated by WindowBuilder)"

    | objects dragDropObject |
    objects := OrderedCollection new.
    aPane selectedItems do: [ :item |
        dragDropObject := dragSession objectClass new
            object: item;
            string: item printString;
            format: 'WBEventMessage' data: item;
            yourself.
        objects add: dragDropObject ].
    dragSession objects: objects! !

!WBInterfaceObject class methods !   
templateAt: aClassName

	^self templates 
		at: aClassName asSymbol 
		ifAbsent: [nil].! !

!WBClassDefinition methods !
nlsPools
		"Answer a collection of pool dictionaries."
	^nlsPools ifNil: [ nlsPools := self basicNLSPools ]! !

!WBCreateViewsModule methods !
defaultMessageSelector
		"Private - Answer the default message selector."
	^self objectHasMultipleViews
		ifTrue: [ self createMultipleViewsSelector ]
		ifFalse: [ nil ]! !

!WBMenu methods ! 
add: aSelector label: aLabelString enable: enable toggle: toggle for: theOwner accelerator: aString

    ^self
        add: aSelector
        label: aLabelString
        mnemonic: nil
        enable: enable
        toggle: toggle
        for: theOwner
        accelerator: aString.! !

!WBCreateButton class methods !  
defaultBitmapType

    ^#buttonWidth:height:! !

!WBPoolManager methods ! 
codeGenerationStyle: aSymbol
	"Set the code generation style."

	self propertyAt: #codeGenerationStyle put: aSymbol.! !

!WBFontSelectionWindow methods !
poolNeedsContents: aPane

	"Callback for the #needsContents event in poolList [WBComboBox].
		(Generated by WindowBuilder Pro)"

	aPane
		printSelector: #poolName;
		contents: (self poolManager pools asSortedCollection: [:a :b | a poolName < b poolName]);
		selection: self selectedPool.! !

!WBLookPolicyWin31 methods !
drawMenuBar: aFrameObject with: aPen in: aRect

    | menuRect xPos yPos space |
    aFrameObject menu notNil
        ifTrue: [
            menuRect := (aRect leftTop down: (self titleBarHeightFrom: aFrameObject))
                extentFromLeftTop: aRect width @ self menuBarHeight.
            aPen
                fill: menuRect color: Color white;
                foreColor: Color windowBorder;
                wbLineFrom: menuRect left @ (menuRect bottom up: 1) to: menuRect right @ (menuRect bottom up: 1).
            xPos := menuRect left right: 6.
            yPos := menuRect origin y down: 2.
            space := aPen stringWidthOf: '  '.
            aPen
                font: self menuFont;
                foreColor: Color menuText;
                setBackgroundModeTransparent.
            aFrameObject menu allTitles do: [:title |
                aPen winDrawText: title at: xPos @ yPos.
                xPos := xPos right: (aPen stringWidthOf: title) + space].
            aPen setBackgroundModeOpaque].! !

!WBApplicationCoordinatorModule methods ! 
defaultViewName
        "Answer the default view name."
    ^'aView'! !

!WBCallOutModule methods !   
defaultOwnerName
        "Answer the default owner name."
    ^'aModel'! !

!WindowFrameObject methods !  
eventHandlerArgNamesFor: eventSymbol
    "Answer an array of argument names."

    eventSymbol = #timer: ifTrue: [ ^#( 'timerID' ) ].
    ^super eventHandlerArgNamesFor: eventSymbol! !

!WBRGBColorDialog methods !   
updateColorList: selectedItem

    | color theColor defaultColor |
    (theColor := elements at: selectedItem) = (defaults at: selectedItem)
        ifTrue: [color := #default]
        ifFalse: [
            color := theColor isRGBColor
                ifTrue: [nil]
                ifFalse: [
                    Color defaultColorClass defaultColors
                        keyAtValue: theColor
                        ifAbsent: [#default]]].

    defaultColor := Color defaultColorClass defaultColors
        keyAtValue: (defaults at: selectedItem)
        ifAbsent: [nil].

    (self paneNamed: 'colorList')
        contents: (tempColors := colors reject: [:sym | (sym = defaultColor) | (sym = #paleGray)]);
        selection: (color = #paleGray ifTrue: [#gray] ifFalse: [color]).! !

!PTextPane methods !
mutationTypes

    ^#(#EntryField #StaticText #Toggle #CPSpinEditor)! !

!WBLayoutCodeModule methods !
layoutTemporaryExpressions

	^Array
		with: #xDU => '(SysFont width + 1 roundTo: 2) / 4'
		with: #yDU => 'SysFont height / 8'! !

!WBInterfaceObject methods !  
foreColor: aColor

	(foreColor := aColor) isInteger
		ifTrue: [foreColor := IndexedColor index: aColor].! !

!WBCompositePaneModule methods !
generateDefinitions
		"Generate a definition for each of the view's elements."
	self
		generateChildDefinitions;
		generateFontDefinitions.! !

!WBScrollingPane methods !  
wmHScroll: wordInteger with: longInteger
        "This is the main entry point for scrolling frame communication with
    the ScrollingPane.  Subclassed from Subpane to avoid their turning everything
    into a percentage.  Using pixel absolutes is faster and more straightforward."

    | type |

    type := wordInteger lowWord.
    type = SbLineup         ifTrue: [self scrollHorizontal: self amountToScrollLeft ].
    type = SbLinedown     ifTrue: [self scrollHorizontal: self amountToScrollLeft negated].
    type = SbPageup        ifTrue: [self scrollHorizontal: self amountToPageLeft ].
    type = SbPagedown    ifTrue: [self scrollHorizontal: self amountToPageLeft negated].

    type = SbThumbposition ifTrue: [
        self updateHorizontalSliderTo: wordInteger highWord.
        ^nil
    ].

    type = SbThumbtrack ifTrue: [
        self scrollHorizontal: topCorner x - wordInteger highWord.
        ^nil
    ].

    self updateHorizontalSlider.

   ^nil! !

!WindowBuilder class methods !  
register: extraName removeMenu: aString

	| slot |
	slot := self extras at: extraName ifAbsent: [OrderedCollection new].
	slot add:
		(Message new
			receiver: self wbEditorClass
			selector: #removeMenu:
			arguments: (Array with: aString)).
	self extras at: extraName put: slot.! !

!WBMenuItem methods ! 
menu
        "Answer the menu parent of the menu item."
    ^menu! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBInterfaceObject methods !   
style: aStyle

    style := aStyle! !

!WBCodeModule methods !
localFonts
	"Answer a collection of locally defined fonts."

	^localFonts ifNil: [
		localFonts := OrderedCollection new]! !

!WBInterfaceObject methods !  
bringToFront

	| widgets firstBackPane |
	(widgets := self siblings)
		 remove: self.
	firstBackPane := widgets 
		detect: [:widget | widget staysToBack]
		ifNone: [nil].
	self staysToBack
		ifTrue: [
			firstBackPane isNil
				ifTrue: [widgets addLast: self]
				ifFalse: [widgets add: self before: firstBackPane]]
		ifFalse: [widgets addFirst: self].
	self updateWidget.! !

!PropertyAccessor methods !  
wbInitializeDefaultFrom: anObject
	"Initialize the #wbDefault value for each property."

	self wbDefault: (self getValueFor: anObject).! !

!WBFramingEditor methods !   
result

    ^result! !

!WindowBuilder class methods !
openModelDefinitionEditor

    WBModelDefinitionEditor new openOn: nil.! !

!WBDevelopmentWindow class methods !  
editorFont

	^Smalltalk platformIsWin32
		ifTrue: [
			Font new fromByteArray: 
				#(244 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 
					2 1 2 34 72 101 108 118 101 116 105 99 97 0 0 0 0 0 0 0 
					0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)]
		ifFalse: [
			Font
				face: 'Helv'
				size: 5 @ 13
				fixedWidth: false
				attributes: 0].! !

!WBToolBarEditor methods !  
selectButton: index

    | element |
    element := elements at: index.
    (self paneNamed: 'bitmaps') selectItem: element bitmapSelector asString.
    (self paneNamed: 'selector') setContents: element selector.
    (self paneNamed: 'rbSelector') setContents: element rbSelector.
    (self paneNamed: 'numSpaces') contents: element numSpaces asString.

    self updateButtons.! !

!WBLayoutForm methods !  
currentNib
    "Answer the value of currentNib."

    ^currentNib! !

!WindowBuilder class methods ! 
initProperties
    "Set up the Properties dictionary"
	" WindowBuilder initProperties "
	self initializeProperties.! !

!WBLookPolicyOS2 methods !   
frameWidthDialog

	^frameWidthDialog ifNil: [
		frameWidthDialog := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCxdlgframe" 28]
			ifFalse: [super frameWidthDialog]]! !

!Object methods !   
addedByOSI
    "Added by OSI. Execute the following to get a list
     of all methods added to base classes by WindowBuilder.

        Smalltalk sendersOf: #addedByOSI.

    "
    #addedByOSI! !

!WBCodeStream methods !  
nextPutFont: aFont indentString: indentString
	"Look up the receiver in the Font pools to find a match.
		If found, then include the pool variable in the code
		and answer true, else include a font definition,
		and answer false."

	| varName |
	(varName := self owner varNameForFont: aFont ifAbsent: [nil]) notNil
		ifTrue: [self nextPutAll: varName]
		ifFalse: [
			(aFont wbEquals: SysFont)
				ifTrue: [self nextPutAll: #SysFont]
				ifFalse: [self nextPutFontRef: aFont indentString: indentString]].! !

!WBChooseClassDialog methods ! 
selectedClass: ignore

    "Assumes the class is already selected"

    self ok.! !

!WindowBuilder methods !   
usesLookPolicyWin95

    ^self class lookPolicy == WBLookPolicyWin95! !

!WindowBuilder methods ! 
dirty: aBoolean

	| toolsMenu |
	dirty := aBoolean.
	self updateMenuFile.
	toolBar updateEnabled: #menuFileSave.
	(toolsMenu := self menuTitled: 'Tools') notNil
		ifTrue: [toolsMenu updateToggled].! !

!WBLayoutWizard methods !  
otherMenu

    | result selections |
    result := Prompter prompt: 'Enter a New Menu Label:' default: self emptyString.
    (result isNil or: [result isEmpty])
        ifFalse: [
            selections := (self paneNamed: 'standardMenusList') value.
            selections add: result.
            self class standardMenus add: result.
            self loadStandardMenus.
            (self paneNamed: 'standardMenusList') setValue: selections]! !

!WBInterfaceObject methods ! 
menuEditor

    ^WBMenuEditor new! !

!WBModelInstVar methods !   
methodNameForBasicSet

    ^'basic', self name asProperNoun, ':'! !

!WBPoolManager methods ! 
editorClass
    "Answer a pool manager window class for the receiver."

    ^WBPoolManagerWindow! !

!LayoutFrame methods !  
wbLeftProportional: aBoolean
	"Set true if the receiver is left proportional (inset = 0)."

	self propertyAt: #wbLeftProportional put: aBoolean.
	^aBoolean! !

!WBTeamVCodePolicy methods !
categoryFor: aCodeModule
		"Answer the category for aCodeModule."
	^aCodeModule category! !

!WBScrapbookRetrieve methods !   
cancel

    Notifier isAltKeyDown ifTrue: [^scrapbook inspect].
    self close! !

!WindowBuilder class methods !
wbInitializeSessionEvents
	"Link to events triggered by SessionModel."

	SessionModel
		current removeAllActionsWithReceiver: self;
		when: #startup send: #startup to: self.! !

!WBMenuItem methods !
isChecked

	^(self attribute bitAnd: MfChecked) ~= 0! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPoolManagerWindow methods !  
menuActiveSetOther

	| aCategory |
	(aCategory := 	WBListChooser new
		fromList: self allCategories
		prompt: 'Select new active category...'
		selection: self poolManager activeCategory
	) notNil ifTrue: [
		self menuActiveSet: aCategory].! !

!WBMenu methods !  
disableItem: item
        "Disable an item.  item can be the label or the selector."
    (self isThere: item) ifFalse: [^self].
    (self getMenuItem: item) disable.! !

!WBTemplateEditor methods !
invoke: aClass

	aClass new openOn: self! !

!WindowBuilder methods ! 
cursorUnloaded

    entries selectItem: (entries elementAtSelector: 'ArrowTool').! !

!WBClassDefinition methods !
instVarNamesString
		"Answer the receiver's instance variables as a string."
	| stream |
	stream := WriteStream on: (String new: 20).
	self instVarNames
		do: [ :eachName | stream nextPutAll: eachName ]
		andBetweenDo: [ stream space ].
	^stream contents! !

!WindowBuilder methods !  
buildMenus
    "Build WindowBuilder's menu bar"
    | menus mw aMenu aSubMenu |
    menus := self wbMenus.
    mw := self mainView menuWindow.
    menus do: [:m |
        (aMenu := WBMenu new)
            title: (m at: 1) replaceEscapeCharacters;
            owner: self.
        (m at: 3) do: [:mi |
            mi == #separator
                ifTrue: [aMenu appendSeparator]
                ifFalse: [
                    (mi at: 3) isString
                        ifTrue: [
                            mi size > 3
                                ifTrue: [
                                    aMenu
                                        add: (mi at: 2)
                                        label: (mi at: 1) replaceEscapeCharacters
                                        enable: (mi at: 4)
                                        toggle: (mi at: 5)
                                        for: (self perform: ((mi at: 6) ifNil: [#yourself]))
                                        accelerator: (mi at: 3)]
                                ifFalse: [
                                    aMenu
                                        add: (mi at: 2)
                                        label: (mi at: 1) replaceEscapeCharacters
                                        accelerator: (mi at: 3)]]
                        ifFalse: [
                            (aSubMenu := WBMenu new)
                                title: (mi at: 1) replaceEscapeCharacters;
                                owner: self.
                            (mi at: 2) isNil
                                ifFalse: [aSubMenu selector: (mi at: 2)].
                            (mi at: 3) do: [:msi |
                                msi == #separator
                                    ifTrue: [aSubMenu appendSeparator]
                                    ifFalse: [
                                        msi size > 3
                                            ifTrue: [
                                                aSubMenu
                                                    add: (msi at: 2)
                                                    label: (msi at: 1) replaceEscapeCharacters
                                                    enable: (msi at: 4)
                                                    toggle: (msi at: 5)
                                                    for: (self perform: ((msi at: 6) ifNil: [#yourself]))
                                                    accelerator: (msi at: 3)]
                                            ifFalse: [
                                                aSubMenu
                                                    add: (msi at: 2)
                                                    label: (msi at: 1) replaceEscapeCharacters
                                                    accelerator: (msi at: 3)]]].
                            aMenu
                                appendSubMenu: aSubMenu]]].
        mw addMenu: aMenu]! !

!WBGroupBox class methods !
isWBInternalClass

    ^true! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPropertyEditor methods ! 
labelForProperty: property

	property ifNil: [^self emptyString].
    ^property commonName, ' : ', (changes at: property ifAbsent: [property value]) asString.! !

!WBFontEditorCompositePane methods !  
setFontSize: aString pane: aPane

	"Callback for the #textChanged: event in sizeField [WBComboBox].
		(Generated by WindowBuilder Pro)"

	| oldSelection |
	oldSelection := aPane entryField selection.
	self setFont.
	aPane entryField
		selectFrom: (oldSelection x min: aString size + 1)
		to: (oldSelection y min: aString size).! !

!WBStyleEditor methods !  
styleChanged: selectedItem pane: aPane
    "Callback for the #changed: event in <Unnamed> [MultipleSelectListBox]
	    (Generated by WindowBuilder Pro)"! !

!WBTemplateEditor methods !  
templateSelected: selectedItem

    "Callback for the #clicked: event triggered in the ListBox named 'templateList'.
     (Generated by WindowBuilder)"

	selectedItem isNil ifTrue: [^self].
	template := self templateAt: selectedItem asSymbol.
	templateGroup contents: 'Template: ', selectedItem.
	removeButton enable.
	self updateFields.! !

!WBLookPolicyWin95 methods ! 
drawButton: aButton with: aPen clipRect: clipRect

    | innerRect clip region |
	innerRect := aButton rect.
    aButton style == #defaultPushButton
        ifTrue: [
            aPen drawRectangle: innerRect.
            innerRect := innerRect insetBy: 1].
    aPen
        foreColor: Color white;
        wbLineFrom: innerRect leftTop to: (innerRect rightTop left: 1);
        wbLineFrom: innerRect leftTop to: (innerRect leftBottom up: 1);
        foreColor: Color black;
        wbLineFrom: (innerRect leftBottom up: 1) to: (innerRect rightBottom up: 1);
        wbLineFrom: (innerRect rightTop left: 1) to: (innerRect rightBottom leftAndUp: 1);
        foreColor: Color darkGray;
        wbLineFrom: (innerRect leftBottom rightAndUp: 1@2) to: (innerRect rightBottom leftAndUp: (1+ Rectangle leftTopUnit y)@2);
        wbLineFrom: (innerRect rightTop leftAndDown: 2@1) to: (innerRect rightBottom leftAndUp: 2);
        fill: (innerRect insetBy: (1@(1+ Rectangle leftTopUnit y) extent: 1@(1 - (Rectangle leftTopUnit y * 2)))) color: aButton defaultBackColor.
    clip := ((innerRect insetBy: 3) intersect: clipRect).
    (clip left isRightOf: clip right) | (clip top isBelow: clip bottom)
        ifFalse: [
            region := aPen setClipRect: clip.
            aPen
                setBackgroundModeTransparent;
                foreColor: aButton foreColor;
                font: aButton font;
                setTextAlign: WBDisplayContext defaultTextAlign;
                centerWinText: aButton contents at: innerRect center;
                setBackgroundModeOpaque;
                destroyRegion: region].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBBitmapManagerWindow methods !   
writeBMPFiles: aDirPath for: keysAndPools category: aCategory fileNames: fileNameMap copySelector: copySelector

	| aBitmap |
	keysAndPools do: [:eachKeyAndPool |
		aBitmap := eachKeyAndPool value
			at: eachKeyAndPool key
			in: aCategory.
		aBitmap isOperatingSystemBitmap ifFalse: [
			aBitmap := aBitmap perform: copySelector.
			aBitmap wbOutputToFile:
				aDirPath, '\',
				(fileNameMap at: eachKeyAndPool key), '.bmp']].! !

!WBInterfaceObject methods !
bringToFrontOf: aWidget

	self siblings 
		remove: self;
		add: self before: aWidget.
	self updateWidget.! !

!WBFramingEditor methods !   
originYStyleChanged: styleRadio

    (styleRadio contents = 'Scaled') & (styleRadio selection)
        ifTrue:
            [originYAnchor selection: 'Window top'.
            originYAnchor disable.
            topRelative disable.
            ]
        ifFalse:
            [topRelative enable.
            originYAnchor enable.
            ].
    self setExampleRects.! !

!WBLookPolicy methods !   
scrollBarColor

    ^Color white! !

!WBCreateButton class methods !  
bitmapTypes
	"Answer a mapping of pane names to bitmap types."

	^bitmapTypes ifNil: [
		bitmapTypes := Dictionary new
			at: 'monoButton' put: nil;
			at: 'colorButton' put: #buttonWidth:height: ;
			at: 'color4BitButton' put: #buttonWidth4:height: ;
			at: 'color8BitButton' put: #buttonWidth8:height: ;
			yourself]! !

!WBEventMessage class methods ! 
numberOfArgumentsFor: aSelector
        "Answer the number of arguments required by a message whose
        selector is <aSelector>, assuming <aSelector> is a legal
        method selector."

	aSelector isNil ifTrue: [^0].
	aSelector isEmpty ifTrue: [^0].
	^super numberOfArgumentsFor: aSelector! !

!WBAbstractCodeModule methods !  
defaultPartsComment
		"Answer the default comment string."
	^'WARNING!!  This method was automatically generated by
      WindowBuilder.  Code you add here which does not conform
      to the WindowBuilder API will probably be lost the next time
      you save your wb-parts definition.'! !

!WBPrototype methods ! 
convertClass: aWindowClass

    | tempInstance oldOpenWindow oldOpenModeless
    openMethodType numArgs args isAC useAll avoidName |
    self layoutForm notNil ifTrue: [
        self layoutForm shellHandles: #( )].
    self scrollingForm notNil ifTrue: [
        self scrollingForm hideWindow].
    useAll := true.
    (isAC := aWindowClass inheritsFrom: ApplicationCoordinator)
        ifTrue: [
            openMethodType := #buildView:forModel:.
            avoidName := 'handlers']
        ifFalse: [
            (aWindowClass inheritsFrom: CompositePane)
                ifTrue: [
                    openMethodType := #addSubpanes.
                    useAll := false]
                ifFalse: [
                    openMethodType := self wbEditorClass openMethodType.
                    avoidName := 'views']].
    openMethodType notNil
        ifTrue: [
            self propertyAt: #keepOpenMethod put: (aWindowClass includesSelector: #open).
            tempInstance := aWindowClass new.
            self initializeInstVarsFor: tempInstance.
            isAC
                ifTrue: [
                    windows := [Array with: (tempInstance class constructViewFor: tempInstance)]
                        on: Error do: [Array with: WBDefaultScratchWindow new createViews mainView]]
                ifFalse: [
                    numArgs := openMethodType occurrencesOf: $:.
                    args := (Array new: numArgs) atAllPut: tempInstance.
                    tempInstance wbPreOldVersionSupport.
                    tempInstance := (tempInstance perform: openMethodType withArguments: args)
                        ifNil: [tempInstance addView: WBDefaultScratchWindow new createViews mainView].
                    self wbPreOldVersionSupport.
                    tempInstance wbOldVersionSupport]].
    tempInstance isNil
        ifTrue: [
            self propertyAt: #keepOpenMethod put: nil.
            oldOpenWindow := aWindowClass sourceCodeAt: #openWindow.
            self wbEditorClass createMethod: '' titled: 'openWindow' in: aWindowClass loggingSource: false.
            oldOpenModeless := aWindowClass sourceCodeAt: #openModeless.
            self wbEditorClass createMethod: '' titled: 'openModeless' in: aWindowClass loggingSource: false.
            tempInstance := aWindowClass new.
            self initializeInstVarsFor: tempInstance.
            [tempInstance open] ensure: [
                oldOpenWindow == #openWindow
                    ifFalse: [self wbEditorClass createMethod: oldOpenWindow titled: '' in: aWindowClass loggingSource: true]
                    ifTrue: [aWindowClass removeSelector: #openWindow].
                oldOpenModeless == #openModeless
                    ifFalse: [self wbEditorClass createMethod: oldOpenModeless titled: '' in: aWindowClass loggingSource: true]
                    ifTrue: [aWindowClass removeSelector: #openModeless]]].
    tempInstance isNil ifTrue: [^nil].
    isAC ifFalse: [windows := tempInstance views].
    windows := (windows collect: [:window |
        self convertWindow: window inClass: (aWindowClass isScratchWindow
            ifTrue: [aWindowClass defaultClass]
            ifFalse: [aWindowClass])]) reject: [:vi | vi isNil].
    self propertyAt: #tempInstance put: nil.
    windows first nlsPools: (aWindowClass sharedPools select: [:sym |
        (Smalltalk at: sym) isValidNLSDictionary]).
    "PARTS Support"
    self wbEditorClass partsSupportIsInstalled
        ifTrue: [
            self wbPartEvents:
                (tempInstance wbPartEvents
                    updatePanes: windows;
                    updateReceiver: self;
                    yourself).
            self wbPartMessages:
                (tempInstance wbPartMessages
                    updatePanes: windows;
                    updateSource: self;
                    yourself)].
    windows do: [:window |
        window == windows first
            ifFalse: [
                window nlsPools: windows first nlsPools.
                shell := window.
                window children do: [:widget |
                    widget reframe: window frameContentRect]]].
    self switchToWindow: windows first.
    tempInstance wbBecome: (WBTargetObject for: tempInstance owner: self).

    "For compatibility... force the pStyle to be nil once the window has been converted."
    self shell wbRealWidget isCompositePane ifFalse: [
        self shell wbRealWidget propertyAt: #pStyleOld put: (
            self shell wbRealWidget propertyAt: #pStyle).
        self shell wbRealWidget propertyAt: #pStyle put: nil].! !

!WindowBuilder methods !   
menuToolsInspectCharacterConstants

    CharacterConstants inspect! !

!WBEditClassDialog class methods ! 
recentClasses

    ^RecentClasses ifNil: [RecentClasses := OrderedCollection new: self recentClassMaxSize + 1]! !

!WBEventMessage methods !  
source
	"Answer the receiver's source."

	^source! !

!WBTabOrderLayoutForm methods !
groups

	^groups! !

!WBPoolManagerWindow methods !   
defaultNewKey

	^''! !

!WBCreatePowerViewModule methods !
defaultMessageArguments
		"Private - Answer the default message selector arguments."
	^Array
		with: self defaultTargetName
		with: self defaultOwnerName! !

!WBChoosePaneDialog methods ! 
abstractPaneList
    ^#(
        #ControlPane
        #Toggle
        #CPChildEntryField
        #StaticPane
        #CPSubPane
        #CPScrollingPane
        #CPSpinEditor
        #CPValuator
        #CPGuage
        #CPSlider
        ).! !

!WindowBuilder methods !   
menuOptionsLookPolicyDefault

    self class lookPolicy: nil.
    OperatingSystem isWindows95
        ifTrue: [
            self shell backColor asRGBColor = Color white asRGBColor
                ifTrue: [self shell backColor: Color gray]]
        ifFalse: [
            self shell backColor asRGBColor = Color gray asRGBColor
                ifTrue: [self shell backColor: Color white]].
    self updateLookPolicy! !

!PEntryFieldGroup methods !   
contents

    ^super contents ifNil: [#( )]! !

!StaticText methods ! 
wbGrayEnable
	"Private - WBPro Development."

	#addedByOSI.
	OperatingSystem isWindows95
		ifTrue: [self enable]
		ifFalse: [self foreColor: Color black].! !

!WBModelInstVar methods !  
valueClass

    ^valueClass ifNil: [Object]! !

!Rectangle methods !  
offsetFromLeftTop: aRect
        "Private - WBPro Development.
     Answer a Point that is the offset difference between self's leftTop
	 and aRect's leftTop, where positive values indicate aRect is below and
     to the right of self."
    #addedByOSI.
    ^self leftTop distanceRightAndDown: aRect leftTop! !

!PComboBox methods !  
readSpecificsFrom: aWidget

	super readSpecificsFrom: aWidget.
	(aWidget isKindOf: WBComboBox)
		ifTrue: [
			aWidget hasDynamicListSizeStyle
				ifTrue: [
					style = #dropDown
						ifTrue: [style := #dynamicDropDown].
					style = #dropDownList
						ifTrue: [style := #dynamicDropDownList]]].! !

!TopPane class methods !
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager

        "*** The names of these styles when lowercased
            match the original p-styles to ease the
            translation from pStyle to style ***"

        add: (StylePropertyAccessor new
            name: 'Maximize';
            wbFrameStyle: (
                OperatingSystem isOS2
                    ifTrue: ['FcfMaxbutton']
                    ifFalse: ['WsMaximizebox']);
            pool: OperatingSystemConstants;
            wbAddStyle: #addMaximizeButtonStyle;
            wbRemoveStyle: #removeMaximizeButtonStyle);
        add: (StylePropertyAccessor new
            name: 'Minimize';
            wbFrameStyle: (
                OperatingSystem isOS2
                    ifTrue: ['FcfMinbutton']
                    ifFalse: ['WsMinimizebox']);
            pool: OperatingSystemConstants;
            wbAddStyle: #addMinimizeButtonStyle;
            wbRemoveStyle: #removeMinimizeButtonStyle);
        add: (StylePropertyAccessor new
            name: 'Sizable';
            wbFrameStyle: (
                OperatingSystem isOS2
                    ifTrue: ['FcfSizeborder']
                    ifFalse: ['WsThickframe']);
            pool: OperatingSystemConstants;
            wbAddStyle: #(#removeBorderStyle #addSizingBorderStyle);
            wbRemoveStyle: #(#removeSizingBorderStyle #addBorderStyle));
        add: (StylePropertyAccessor new
            name: 'SysMenu';
            wbFrameStyle: (
                OperatingSystem isOS2
                    ifTrue: ['FcfSysmenu']
                    ifFalse: ['WsSysmenu']);
            pool: OperatingSystemConstants;
            wbAddStyle: #addSystemMenuStyle;
            wbRemoveStyle: #removeSystemMenuStyle);
        add: (StylePropertyAccessor new
            name: 'TitleBar';
            wbFrameStyle: (
                OperatingSystem isOS2
                    ifTrue: ['FcfTitlebar']
                    ifFalse: ['WsCaption']);
            pool: OperatingSystemConstants;
            wbAddStyle: #("#removePopupStyle" #addTitleBarStyle);
            wbRemoveStyle: #(#removeStyle: #addPopupStyle));
        add: (
            SelectorPropertyAccessor new
                name: 'Title';
                get: #label ;
                set: #labelWithoutPrefix: ;
                format: 'String' ;
                wbNLSAccessor: true;
                wbStore: nil);
        wbAddEvent: (
            WBEventDescription new
                event: #opened ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #help ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #timer: ;
                argumentNames: #('anObject'));
        wbAddEvent: (
            WBEventDescription new
                event: #maximized ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #aboutToDisplayMenu ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #resized ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #menuBarBuilt ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #closed ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #rightClicked ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #activated ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #aboutToClose ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #validated ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #deactivated ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #restored ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #minimized ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #button1Down ;
                argumentNames: #( ));
        yourself! !

!WBScrollingPane methods ! 
scrollToOrigin

    self sendInputEvent: #scrollTopCorner:  with: self topCorner.! !

!WBMenuEditor methods ! 
link

    "Link this menu option to a ViewManager"

    | item list itemIndex |

    list := menuItemsEditor contents asFlatList.
    itemIndex := menuItemsEditor selection.
    list size < itemIndex ifTrue: [
        ^self
    ].
    item := list at: itemIndex.

    WBLinkEditor new openOn: item.

    self fillInCurrentItem.! !

!WBLayoutForm methods !  
findOneChildAtEachLevel: aPoint

    | nestedChildren justOne depth depthSet |
    depthSet := Set new.
    justOne := true.
    nestedChildren := OrderedCollection new.
    (self findAllChildrenFor: aPoint) do: [:each |
        (depthSet includes: (depth := each wbDepthInWidgetHierarchy)) not
            ifTrue: [
                justOne
                    ifTrue: [
                        nestedChildren add: each.
                        depthSet add: depth].
                each isWBDrawingForm ifFalse: [justOne := false]]].
    ^nestedChildren! !

!WBLookPolicyWin31 methods !   
drawTitleBarText: aFrameObject with: aPen in: aRect

    | titleRect |
    titleRect := aRect leftTop extentFromLeftTop: aRect width @ (self titleBarHeightFrom: aFrameObject).
    aFrameObject hasTitleBar
        ifTrue: [
            aPen
                fill: titleRect color: Color activeTitleBar;
                font: aFrameObject font;
                setTextAlign: WBDisplayContext defaultTextAlign;
                foreColor: Color titleBarText;
                setBackgroundModeTransparent;
                winDrawText: aFrameObject contents in: (titleRect insetBy: 1) format: self titleJustification;
                setBackgroundModeOpaque].
    aFrameObject isDialog
        ifTrue: [
            aPen
                foreColor: Color white;
                wbLineFrom: titleRect leftTop to: titleRect rightTop].! !

!StylePropertyAccessor methods ! 
wbAlwaysGenerate	

	self wbStore: #nextPutPropertyIgnoreDefault:style:for: .! !

!WBLayoutForm methods !  
drawToBitmap

    ^drawingBitmap notNil! !

!WBPropertyDescriptor methods !   
resourceValues: anIdentityDictionary
    "Set the value of resourceValues."

    resourceValues := anIdentityDictionary! !

!WBFontSelectionWindow methods ! 
defaultPoolManager

	self owner notNil ifTrue: [
		self owner editedClass isScratchWindow ifFalse: [
			self owner editedClass isWBInternalClass ifTrue: [
				^WBFontManager system]]].
	^WBFontManager current! !

!WBPrototype methods !   
targetFor: aString
	"Answer the target object for the target named aString, or nil."

	| index |
	aString isString ifFalse: [^nil].
	aString = #self ifTrue: [^self targetObject].
	self targetInstVarNames do: [:each |
		aString = each ifTrue: [
			(index := self targetObject class allInstVarNames indexOf: each) > 0 ifTrue: [
				^self targetObject instVarAt: index]]].
	^nil! !

!WBFontSelectionWindow methods !  
poolSelected: selectedItem pane: aPane

	"Callback for the #changed: event in poolList [WBComboBox].
		(Generated by WindowBuilder Pro)"

	self selectedPool: selectedItem.
	(self paneNamed: 'fontList') update.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLocator class methods ! 
on: anObject at: aSymbol
        ^self new setReceiver: anObject selector: aSymbol arguments: #()! !

!WBListChooser methods ! 
opened
        "Private - Dialog is opened, select the text
         and set the initial focus."

    | list |
    list := self paneNamed: 'list'.
    sel notNil ifTrue: [
        list selection: sel.
    ] ifFalse: [
        list contents notEmpty ifTrue: [
            list selectIndex: 1.
        ].
    ].
    list setFocus.! !

!WBGraphicObject methods !
lookPolicy

    ^nil! !

!WBLayoutForm methods !  
dragOutline
    "Answer the value of dragOutline."

    ^dragOutline ifNil: [true]! !

!WBLookPolicyOS2 methods !
drawMenuBar: aFrameObject with: aPen in: aRect

    | menuRect xPos yPos space |
    aFrameObject menu notNil
        ifTrue: [
            menuRect := (aRect leftTop down: (self titleBarHeightFrom: aFrameObject))
                extentFromLeftTop: aRect width @ self menuBarHeight.
            aPen
                fill: menuRect color: Color gray;
                foreColor: Color windowBorder;
                wbLineFrom: menuRect left @ (menuRect bottom up: 1) to: menuRect right @ (menuRect bottom up: 1).
            xPos := menuRect left right: 6.
            yPos := menuRect origin y down: 2.
            space := aPen stringWidthOf: '  '.
            aPen
                font: self menuFont;
                foreColor: Color menuText;
                setBackgroundModeTransparent.
            aFrameObject menu allTitles do: [:title |
                aPen winDrawText: title at: xPos @ yPos.
                xPos := xPos right: (aPen stringWidthOf: title) + space].
            aPen setBackgroundModeOpaque].! !

!WBEventManagerWindow methods !
targetObject

	^self prototype targetObject! !

!WBCodePolicy methods !   
existingSourceFor: aCodeModule
		"Private - Answer the method source in the specified class or nil.
			Search class then superclasses for a method with that selector."
	^((self existingMethodFor: aCodeModule) ifNil: [ ^'' ]) sourceString! !

!PButton class methods !   
autoRecognizeOkCancel

    "By default, OK and Cancel buttons are automatically
     recognized and assigned the ID_OK and ID_CANCEL
     styles. Whenever the 'Enter' key is pressed, the #clicked
     event handler of the OK button is executed. Whenever
     the 'Esc' key is pressed, the #clicked event handler of
     the Cancel button is executed."

    ^AutoRecognizeOkCancel ifNil: [true]! !

!WBLookPolicyWin31 methods ! 
displayWithRightScrollBar: aPen rect: aRect backColor: aColor

	| innerRect newInnerRect backColor |
	backColor := (self class isDefault not 
		and: [(self asRGBColor: aColor) = (self asRGBColor: self defaultOS2WidgetBackColor)])
		ifTrue: [self defaultWidgetBackColor]
		ifFalse: [aColor].
	innerRect := self displayWithBorder: aPen rect: aRect backColor: backColor.
	newInnerRect := innerRect leftTop rightBottom: (innerRect rightBottom left: self scrollBarWidth).
	self
		drawVScrollBarWith: aPen
		at: ((newInnerRect rightTop up: 1)
			rightBottom: (innerRect rightBottom rightAndDown: 1)).
	^newInnerRect! !

!WBEditClassDialog methods ! 
loadClassList

    | filterChoice packageChoice classList windowClassList wbCreatedClasses |
	filterChoice := self filterChoice.
    packageChoice := self packageChoice.
    ((self inTeamV or: [self inENVY or: [self inXoteryX]]) and: [packageChoice ~= self class defaultChoice])
        ifTrue: [
            self inTeamV
                ifTrue: [
                    packageChoice := self packageChoices detect: [:pack |
                        pack name = packageChoice] ifNone: [^nil].
                    classList := OrderedCollection new.
                    packageChoice allDefinitionsDo: [:def | def isClass
                        ifTrue: [classList add: (Smalltalk at: def className)]]]
                ifFalse: [
                    self inXoteryX
                        ifTrue: [classList := ((Smalltalk at: #XoPackage) named: packageChoice) ownedClasses]
                        ifFalse: [classList := (Smalltalk at: packageChoice asSymbol) defined]].
            windowClassList := ViewManager allSubclasses
                addAll: ApplicationCoordinator allSubclasses;
                addAll: CompositePane allSubclasses;
                yourself.
            classList := classList select: [:aClass | windowClassList includes: aClass].
            filterChoice = self class defaultChoice
                ifTrue: [
                    wbCreatedClasses := ViewManager wbCreatedClasses
                        addAll: ApplicationCoordinator wbCreatedClasses;
                        addAll: CompositePane wbCreatedClasses;
                        yourself.
                    classList := classList select: [:aClass | wbCreatedClasses includes: aClass].
                    alt ifFalse: [classList := classList reject: [:aClass | aClass isWBInternalClass]]]
                ifFalse: [
                    filterChoice = self class nonWBChoice
                        ifTrue: [
                            wbCreatedClasses := ViewManager wbCreatedClasses
                                addAll: ApplicationCoordinator wbCreatedClasses;
                                addAll: CompositePane wbCreatedClasses;
                                yourself.
                            classList := classList reject: [:aClass |
                                (wbCreatedClasses includes: aClass) or: [aClass isWBInternalClass]]]
                        ifFalse: [
                            filterChoice := Smalltalk at: filterChoice asSymbol ifAbsent: [ViewManager].
                            classList := classList select: [:aClass | (aClass inheritsFrom: filterChoice) and: [aClass wbCreated]].
                            alt ifFalse: [classList := classList reject: [:aClass | aClass isWBInternalClass]]]]]
        ifFalse: [
            filterChoice = self class defaultChoice
                ifTrue: [
                    classList := ViewManager wbCreatedClasses
                        addAll: ApplicationCoordinator wbCreatedClasses;
                        addAll: CompositePane wbCreatedClasses;
                        yourself.
                    alt ifFalse: [classList := classList reject: [:aClass | aClass isWBInternalClass]]]
                ifFalse: [
                    filterChoice = self class nonWBChoice
                        ifTrue: [
                            wbCreatedClasses := ViewManager wbCreatedClasses
                                addAll: ApplicationCoordinator wbCreatedClasses;
                                addAll: CompositePane wbCreatedClasses;
                                yourself.
                            classList := ViewManager allSubclasses
                                addAll: ApplicationCoordinator allSubclasses;
                                addAll: CompositePane allSubclasses;
                                yourself.
                            classList := classList reject: [:aClass |
                                (wbCreatedClasses includes: aClass) or: [aClass isWBInternalClass]]]
                        ifFalse: [
                            filterChoice := Smalltalk at: filterChoice asSymbol ifAbsent: [ViewManager].
                            classList := filterChoice wbCreatedClasses.
                            alt ifFalse: [classList := classList reject: [:aClass | aClass isWBInternalClass]]]]].
    (classList isNil or: [classList isEmpty]) ifTrue: [classList := #()].
    list contents: (classList collect: [:aClass | aClass name]) asSortedCollection asArray.
    selectedClass := nil.
    self setWindowTitle! !

!WBTabOrderEditor methods !
children

	^self owner children! !

!WBTemplateEditor methods !   
preInitWindow

	self mainView children do: [:each |
		each font: SysFont].! !

!PColumnListBox methods ! 
contents

    ^(self wbRealWidget columnWidths ifNil: [#( )]) asArray
        collect: [:width | width asString]! !

!WBTabOrderLayoutForm methods ! 
reverseTabOrder

	| theGroup |
	self selections isEmpty
		ifTrue: [
			self children do: [:widget |
				widget tabPosition notNil
					ifTrue: [widget tabPosition basicTabPosition: widget tabPosition basicTabPosition negated]]]
		ifFalse: [
			theGroup := self selections first.
			(self groups at: theGroup) do: [:widget |
				widget tabPosition notNil
					ifTrue: [widget tabPosition groupPosition: widget tabPosition groupPosition negated]]].
	self 
		resetGroups;
		normalizeTabOrder;
		updateWidget.! !

!PGraphPane methods ! 
usesColor

    ^false! !

!WBColorDialog methods !
colorBarWidth

    ^50! !

!WBEntryListPrompter methods ! 
resultPrim

	^self listField text ifNil: [result]! !

!WindowBuilder methods !
setColor
	"Set the color attributes for the current widget"

	| selections colorElements oldColorElements currentWidget redoBlock |
	(selections := self selections isEmpty
		ifTrue: [Array with: self shell]
		ifFalse: [
			self selections select: [:widget | 
				widget usesColor]]) isEmpty ifTrue: [^self].
	oldColorElements := selections collect: [:widget | widget colorElements].
	currentWidget := self currentWidget.
	colorElements := self selections size = 1
		ifTrue: [currentWidget getColors: self]
		ifFalse: [
			WBRGBColorDialog new
				elements: currentWidget colorElements
				defaults: currentWidget colorDefaults
				paneEdited: currentWidget].
	colorElements isNil ifTrue: [^nil].
	self undoManager
		add: 'Set Color'
		undo:
			[1 to: selections size do: [:i |
				(selections at: i) setColorsUsing: (oldColorElements at: i)]]
		redo: (redoBlock :=
			[1 to: selections size do: [:i |
				(selections at: i) setColorsUsing: colorElements]]).
	redoBlock value.
	self redisplaySelection.! !

!WBKeyAccel methods ! 
isCtrl

    ^isControl ifNil: [false]! !

!LayoutFrame methods !  
newFramerFromNewRect: newRect parentRect: containerRect
	"Create a new instance of the receiver's class for this pane,
		 based on the values of self (i.e. update the relative values). "

	| answer inset multiplier width height |
	answer := self wbCopy.
	multiplier := 1 @ 1.				"WindowDialog dialogUnit / WindowDialog unitMultiplier"
	width := containerRect width max: 1.
	height := containerRect height max: 1.
	inset := containerRect left distanceRight: newRect left.
	self wbLeftProportional
		ifTrue: [
			answer leftRatio: inset / width.
			answer leftInset: 0]
		ifFalse: [
			answer leftInset: (inset - (width * self leftRatio)) * multiplier x].
	inset := containerRect left distanceRight: newRect right.
	self wbRightProportional
		ifTrue: [
			answer rightRatio: inset / width.
			answer rightInset: 0]
		ifFalse: [
			self wbRightAttachedToLeft ifTrue: [answer rightRatio: answer leftRatio].
			answer rightInset: ((width * self rightRatio) - inset) * multiplier x].
	inset := containerRect top distanceDown: newRect top.
	self wbTopProportional
		ifTrue: [
			answer topRatio: inset / height.
			answer topInset: 0.]
		ifFalse: [
			answer topInset: (inset - (height * self topRatio)) * multiplier y].
	inset := containerRect top distanceDown: newRect bottom.
	self wbBottomProportional
		ifTrue: [
			answer bottomRatio: inset / height.
			answer bottomInset: 0]
		ifFalse: [
			self wbBottomAttachedToTop ifTrue: [answer bottomRatio: answer topRatio].
			answer bottomInset: ((height * self bottomRatio) - inset) * multiplier y].
	^answer! !

!WBTabOrderEditor class methods !   
includeOuter: aBoolean

	IncludeOuter := aBoolean! !

!WBTabOrderLayoutForm methods ! 
mouseMove: aPoint
    "Do nothing"! !

!Object methods !   
isScratchWindow

	^false! !

!PWBVerticalScrollBar methods !  
storeSpecificsOn: aStream indentString: indentString

    super storeSpecificsOn: aStream indentString: indentString.
    aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'vertical'.! !

!WBPoolManagerWindow methods !  
selectedPoolOrPrompt: aString
	"Answer the currently selected pool.  If exactly one
		is not selected, then prompt the user for a pool."

	| list poolName |
	(list := self selectedPools) isEmpty ifTrue: [
		(list := self pools) isEmpty ifTrue: [
			^nil]].
	list size = 1 ifTrue: [^list first].
	poolName := WBListChooser
		fromList: (list collect: [:each | each poolName]) asSortedCollection
		prompt: aString.
	^self poolManager poolFor: poolName! !

!WindowBuilder class methods ! 
propertyValueAt: aSymbol category: categorySymbol put: aValue

    | property |
    (property := self propertyAt: aSymbol category: categorySymbol asSymbol) ifNil: [^nil].
    property value: aValue.
    ^aValue! !

!WBRGBColorDialog methods !
updateRGBField: theColor

    | rgbColor |
    rgbColor := [theColor asRGBColor]
        on: Error
        do: [RGBColor fromInteger: theColor asInteger].
    (self paneNamed: 'red') setContents: rgbColor red asString.
    (self paneNamed: 'green') setContents: rgbColor green asString.
    (self paneNamed: 'blue') setContents: rgbColor blue asString.
    self fillColorPaneWith: rgbColor.! !

!WindowBuilder class methods !  
purgeCustomPanes
	" WindowBuilder purgeCustomPanes  "

	WBClasses := nil.
	CustomPanes := OrderedCollection new.! !

!WBLookPolicyWin31 methods !   
drawGroupBox: aGroupBox with: aPen clipRect: clipRect

    | rect top textRect bottom |
    rect := aGroupBox rect.
    top := rect top down: aGroupBox font height // 2.
    bottom := rect bottom up: 1.
    aPen font: aGroupBox font.
    textRect := (rect leftTop rightAndDown: 7 @ 3) extentFromLeftTop:
        (aGroupBox font wbStringWidth: aGroupBox contents) @ aGroupBox font height.
    aPen
        foreColor: Color black;
        wbLineFrom: rect left @ top to: rect left @ bottom;
        wbLineFrom: (rect right left: 1) @ top to: (rect right left: 1) @ bottom;
        wbLineFrom: rect left @ bottom to: rect right @ bottom;
        wbLineFrom: rect left @ top to: (rect left right: 5) @ top;
        wbLineFrom: (rect left right: ((aPen stringWidthOf: aGroupBox contents) + 12)) @ top to: rect right @ top;
        foreColor: aGroupBox foreColor;
        backColor: aGroupBox backColor;
        setTextAlign: WBDisplayContext defaultTextAlign;
        winDrawText: aGroupBox contents at: textRect origin.! !

!WBPoolManagerWindow methods !   
selectedKeysAndPools
	"Answer a collection of selected keys."

	^keyListBox selectedItems! !

!PropertyAccessor methods !
wbPoolName: aString

	#addedByOSI.
	self propertyAt: #wbPoolName put: aString.
	^aString! !

!WBMenuEditor methods !
disableAttributes: aBoolean

	| currentItem |
	currentItem := menuItemsEditor selectedItem.
	aBoolean
		ifTrue: [
			hasAccelCheckBox disable.
			isAlt disable.
			isCtrl disable.
			isShift disable.
			keyShortCutEditor disable.
			selectorEditor disable.
			(self paneNamed: 'linkButton') disable.
			(self paneNamed: 'actionButton') disable]
		ifFalse: [
			hasAccelCheckBox enable.
			isAlt enable.
			isCtrl enable.
			isShift enable.
			keyShortCutEditor enable.
			selectorEditor enable.
			self wbEditorClass supportsActionAndLinkButtons
				ifTrue: [
					(self paneNamed: 'linkButton') enable.
					(self paneNamed: 'actionButton') enable]].! !

!WBLayoutWizard methods !   
useSourceExpression

    self expressionChanged: (self paneNamed: 'expressionField') contents! !

!WindowFrameObject methods !
defaultFont

    ^self isWindows95
        ifTrue: [
            (Font
                face: 'MS Sans Serif'
                size: 8
                fixedWidth: false
                attributes: 0)
                bold: true]
        ifFalse: [SysFont]! !

!WindowBuilder methods ! 
showZOrder

    ^self class showZOrder! !

!WBBitmapManagerWindow methods !   
menuKeyFileOutRCFile4

	self menuKeyFileOutRCFile: #wbCopy4.! !

!WBEventManagerWindow methods !  
handlerShowAll: aBoolean
	"Set true if the handler should show all hanlders at once."

	| panes oldSelection |
	(panes := OrderedCollection new)
		add: widgetFilterBox;
		add: widgetListBox;
		add: eventListBox;
		add: toField;
		add: toLabel;
		add: sendField;
		add: sendLabel.
	(handlerShowAll := aBoolean)
		ifTrue: [
			panes do: [:each | each hideWindow].
			handlerListBox framingBlock
				leftInset: widgetListBox framingBlock leftInset;
				leftRatio: widgetListBox framingBlock leftRatio;
				bottomInset: widgetListBox framingBlock bottomInset;
				bottomRatio: widgetListBox framingBlock bottomRatio.
			handlerListBox
				resize: self mainView rectangle;
				update.
			self handlerMenu
				checkItem: #menuHandlerShowAll]
		ifFalse:  [
			oldSelection := self handlerSelections.
			handlerListBox framingBlock
				leftInset: handlerListBoxFramingBlock leftInset;
				leftRatio: handlerListBoxFramingBlock leftRatio;
				bottomInset: handlerListBoxFramingBlock bottomInset;
				bottomRatio: handlerListBoxFramingBlock bottomRatio.
			handlerListBox
				update;
				resize: self mainView rectangle.
			panes do: [:each | each showWindow].
			"Need to update the toField so that it will be displayed.
			For some reason, it was not being displayed with
			a #showWindow message and needed an extra kick."
			toField update.
			self handlerMenu
				uncheckItem: #menuHandlerShowAll.
			oldSelection notEmpty ifTrue: [
				self widgetSelections:
					(oldSelection collect: [:each | each source]) asSet asArray.
				self eventSelections:
					(oldSelection collect: [:each | each event]) asSet asArray.
				self handlerSelections: oldSelection]].! !

!WBKeyEntryField class methods ! 
isWBInternalClass

    ^true! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutWizard methods !   
generateWidgets

    | layoutForm offset newWidgets expansion extent vOwner |
    layoutForm := self owner layoutForm.
    offset := self offset.
	extent := self shell extent.
	vOwner := self owner.
    (newWidgets := self generateWidgetsFor: self attributesToGenerate) notEmpty
        ifTrue: [
            expansion := (offset * 2) +
                (self shell rect extent - self shell contentRect extent).
            (self undoManager
               add: 'Layout Wizard Window Size'
                undo: [vOwner setWindowSizePrim: extent shifted: true]
                redo: [vOwner setWindowSizePrim: (vOwner layoutForm boundingBoxFor: newWidgets) extent + expansion shifted: true])
                redoAction value.
            layoutForm
                placeNewWidgets: newWidgets
                at: (self shell contentLeftTop rightAndDown: offset);
                createUndoRedoForNewWidgets: newWidgets
                    oldWidgets: #()
                    named: 'Layout Wizard Widgets'].! !

!PCompositePane methods !   
defaultBackColor: aColor

    defaultBackColor := aColor! !

!WindowBuilder methods ! 
methodHeaderFor: aSelectorString

	(aSelectorString includes: $:)
		ifTrue: [^aSelectorString , ' aPane']
		ifFalse: [^aSelectorString].
	! !

!WBCodeStream methods ! 
indentBy: anInteger during: aBlock
		"Indent the receiver."
	| answer |
	self indentBy: anInteger.
	answer := aBlock value.
	self indentBy: anInteger negated.
	^answer! !

!WBLocator methods !  
asPoint
    ^self value! !

!Integer methods ! 
storeColorOn: aStream
		"Store the color definition."
	#addedByOSI.
	self asColor storeColorOn: aStream! !

!WBLayoutWizard class methods !  
labelJustification

    ^LabelJustification ifNil: [LabelJustification := #rightJustified]! !

!PEntryField methods ! 
changesSize

    ^true! !

!WBModelInstVar methods !  
name

    ^name! !

!Object methods ! 
isWBInternalClass
        "Private - WBPro Development."
    #addedByOSI.
    ^false! !

!WBLookPolicy class methods !   
defaultPolicy

    ^WBLookPolicy allSubclasses
        detect: [:cls | cls isDefault]
        ifNone: [self]! !

!WBChooseClassDialog methods ! 
classList: listOfClasses

    ^self classList: listOfClasses default: nil"(
         listOfClasses notEmpty ifTrue: [
            listOfClasses first
        ] ifFalse: [
            nil
        ]
    )    "! !

!PStatusPane methods !  
moveWidget: x y: y
	"Do nothing."! !

!WBEditClassDialog methods ! 
inTeamV

	^self wbEditorClass teamIsInstalled! !

!WindowBuilder methods !
initializePalettesBitmapFor: aString
	"Answer the bitmap for..."

    | key |
    ^WBBitmapManager system
        at: (key := aString, 'SysBitmap')
        ifAbsent: [
            WBBitmapManager system
                at: (key := key select: [:char | char isAlphaNumeric])
                ifAbsent: [
                    WBBitmapManager system
                        at: 'WB', key
                        ifAbsent: [
                            key := self initializePalettesMap
                                at: aString
                                ifAbsent: [^nil].
		                    WBBitmapManager system
        		                at: key
                		        ifAbsent: [nil]]]].! !

!WBModelDefinitionEditor methods !
modelTypeList

	^#(
			#EventManager
			#ViewManager
			#WindowDialog
			#ApplicationCoordinator
			#DialogCoordinator
			#CompositePane
			)! !

!WBLookPolicyOS2 methods !   
drawRightArrowWith: aPen at: aRect

    | innerRect side point |
    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class rightArrow
                from: self class rightArrow boundingBox
                to: aRect]
        ifFalse: [
            innerRect := self draw3DBoxWith: aPen at: aRect.
            side := (innerRect width min: innerRect height) // 7.
            point := innerRect center right: side.
            aPen
                foreColor: Color black;
                wbLineFrom: (point up: 1) to: ((point up: 1) leftAndUp: side * 2 + 1);
                wbLineFrom: point to: (point leftAndUp: side * 2 + 1);
                wbLineFrom: (point down: 1) to: ((point down: 1) leftAndUp: side * 2 + 1);
                wbLineFrom: point to: (point leftAndDown: side * 2 + 1);
                wbLineFrom: (point down: 1) to: ((point down: 1) leftAndDown: side * 2 + 1);
                wbLineFrom: (point up: 1) to: ((point up: 1) leftAndDown: side * 2 + 1)]! !

!WBLookPolicyWin95 methods !
drawVerticalScrollBar: aScrollBar with: aPen clipRect: clipRect

    | nonThumbRect |
    nonThumbRect := self drawVScrollBarWith: aPen at: aScrollBar rect.
    aPen
        fill: nonThumbRect color: aScrollBar backColor;
        foreColor: Color darkGray;
        wbLineFrom: nonThumbRect leftTop to: nonThumbRect leftBottom;
        wbLineFrom: (nonThumbRect rightTop left: 1) to: (nonThumbRect rightBottom left: 1);
        foreColor: Color gray;
        wbLineFrom: (nonThumbRect leftTop right: 1) to: (nonThumbRect leftBottom right: 1);
        wbLineFrom: (nonThumbRect rightTop left: 2) to: (nonThumbRect rightBottom left: 2).
    ^nonThumbRect! !

!WBFontEditorCompositePane methods !
addSubpanes

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| xDU yDU |
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	
		"Instance Variables"
	boldCheckBox := CheckBox new.
	fixedWidthCheckBox := CheckBox new.
	italicCheckBox := CheckBox new.
	nameField := WBComboBox new.
	nameLabel := StaticText new.
	sampleGroupBox := GroupBox new.
	sampleTextEdit := TextEdit new.
	selectButton := Button new.
	sizeField := WBComboBox new.
	sizeLabel := StaticText new.
	strikeOutCheckBox := CheckBox new.
	underscoreCheckBox := CheckBox new.
	
	self
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -68 * xDU;
				topRatio: 1/2; topInset: -52 * yDU;
				rightRatio: 1/2; rightInset: -68 * xDU;
				bottomRatio: 1/2; bottomInset: -52 * yDU);
		backColor: Color gray.
	
	selectButton "Button"
		owner: self;
		setName: 'selectButton';
		when: #clicked send: #selectFont to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -35 * xDU;
				topRatio: 1; topInset: -25/2 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 1; bottomInset: 0 * yDU);
		contents: 'Select';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: selectButton.
	
	nameField "WBComboBox"
		owner: self;
		setName: 'nameField';
		when: #changed: send: #setFont to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 8 * yDU;
				rightRatio: 1; rightInset: 43 * xDU;
				bottomRatio: 0; bottomInset: -20 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: nameField.
	
	sizeField "WBComboBox"
		owner: self;
		setName: 'sizeField';
		when: #clicked: send: #setFont to: self;
		when: #textChanged: send: #setFontSize:pane: to: self withArgument: sizeField;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -40 * xDU;
				topRatio: 0; topInset: 8 * yDU;
				rightRatio: 1; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -20 * yDU);
		dropDown;
		addDynamicListSizeStyle;
		startGroup;
		noTabStop;
		font: SysFont;
		contents: #( '8' '9' '10' '11' '12' '14' '16' '18' '20' '22' '24' '26' '28' '36' '48' '72' ).
	self addSubpane: sizeField.
	
	boldCheckBox "CheckBox"
		owner: self;
		setName: 'boldCheckBox';
		when: #clicked: send: #setFont to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 22 * yDU;
				rightRatio: 0; rightInset: -14 * xDU;
				bottomRatio: 0; bottomInset: -32 * yDU);
		contents: 'B';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: boldCheckBox.
	
	italicCheckBox "CheckBox"
		owner: self;
		setName: 'italicCheckBox';
		when: #clicked: send: #setFont to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 22 * xDU;
				topRatio: 0; topInset: 22 * yDU;
				rightRatio: 0; rightInset: -38 * xDU;
				bottomRatio: 0; bottomInset: -32 * yDU);
		contents: 'I  ';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: italicCheckBox.
	
	strikeOutCheckBox "CheckBox"
		owner: self;
		setName: 'strikeOutCheckBox';
		when: #clicked: send: #setFont to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 42 * xDU;
				topRatio: 0; topInset: 22 * yDU;
				rightRatio: 0; rightInset: -56 * xDU;
				bottomRatio: 0; bottomInset: -32 * yDU);
		contents: 'S';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: strikeOutCheckBox.
	
	underscoreCheckBox "CheckBox"
		owner: self;
		setName: 'underscoreCheckBox';
		when: #clicked: send: #setFont to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 64 * xDU;
				topRatio: 0; topInset: 22 * yDU;
				rightRatio: 0; rightInset: -78 * xDU;
				bottomRatio: 0; bottomInset: -32 * yDU);
		contents: 'U';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: underscoreCheckBox.
	
	fixedWidthCheckBox "CheckBox"
		owner: self;
		setName: 'fixedWidthCheckBox';
		when: #clicked: send: #setFont to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 86 * xDU;
				topRatio: 0; topInset: 22 * yDU;
				rightRatio: 0; rightInset: -114 * xDU;
				bottomRatio: 0; bottomInset: -32 * yDU);
		contents: 'Fixed';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: fixedWidthCheckBox.
	
	sampleTextEdit "TextEdit"
		owner: self;
		setName: 'sampleTextEdit';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 44 * yDU;
				rightRatio: 1; rightInset: 7 * xDU;
				bottomRatio: 1; bottomInset: 23 * yDU);
		removeHorizontalScrollbarStyle;
		removeVerticalScrollbarStyle;
		addBorderStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: sampleTextEdit.
	
	sizeLabel "StaticText"
		owner: self;
		setName: 'sizeLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -40 * xDU;
				topRatio: 0; topInset: 0 * yDU;
				rightRatio: 1; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -8 * yDU);
		contents: 'Size';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: sizeLabel.
	
	nameLabel "StaticText"
		owner: self;
		setName: 'nameLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 0 * yDU;
				rightRatio: 1; rightInset: 43 * xDU;
				bottomRatio: 0; bottomInset: -8 * yDU);
		contents: 'Name';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: nameLabel.
	
	sampleGroupBox "GroupBox"
		owner: self;
		setName: 'sampleGroupBox';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 1; rightInset: 1 * xDU;
				bottomRatio: 1; bottomInset: 17 * yDU);
		contents: 'Sample';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: sampleGroupBox! !

!WBLayoutForm methods !   
buttonReleaseMovingWidget: aPoint
    "Process a button release event after moving a widget."

    | sel startOrigins origins |
	self showHandles.
    sel := self selections copy.
    (sel detect: [:aWidget |
        aWidget origin ~= (aWidget propertyAt: #startOrigin)]
        ifNone: [nil]) isNil ifTrue: [^self].
    startOrigins := sel collect: [:aWidget |
        aWidget propertyAt: #startOrigin].
    origins := sel collect: [:widget | widget origin].
    self undoManager
        add: 'Move'
        undo:
            [self hideHandles.
            1 to: sel size do: [:index |
                (sel at: index)
                    moveWidget: (startOrigins at: index) x
                    y: (startOrigins at: index) y;
                    wbUpdateConstraints].
            self
                updateWidgetAttachments: sel;
                showHandles;
                notifyModelOfSizeOrPositionChange]
        redo:
            [self hideHandles.
            1 to: sel size do: [:index |
                (sel at: index)
                    moveWidget: (origins at: index) x
                    y: (origins at: index) y;
                    wbUpdateConstraints].
            self
                updateWidgetAttachments: sel;
                showHandles;
                notifyModelOfSizeOrPositionChange].! !

!WBPoolManagerWindow methods ! 
selectedPools: aCollectionOfPools
	"Set the collection of pools."

	poolListBox selection: aCollectionOfPools.
	self selectedPoolsChanged.! !

!PButton methods !   
winUserStyle

	style == #defaultPushButton
		ifTrue: [^BsDefpushbutton].
	^BsPushbutton! !

!WBMenuTester methods ! 
menubar: aMenuList

    menus := aMenuList.! !

!WBCreateClassDialog methods !
inENVY

	^self wbEditorClass envyIsInstalled! !

!Object methods !
eventHandlerTargetAt: aSymbol put: aString prototype: prototype
	"Set the first event handler at aSymbol as a string
		or an empty string if there is no handler defined."

	| actions newReceiver msg |
	actions := self wbRealWidget actionListForEvent: aSymbol.
	(newReceiver := aString) isString ifTrue: [
		newReceiver := prototype targetFor: aString].
	newReceiver isNil ifTrue: [^self].
	newReceiver := newReceiver wbRealWidget.
	msg := actions notEmpty
		ifTrue: [
			Message new
				receiver: newReceiver;
				selector: actions first selector;
				arguments: actions first arguments;
				yourself]
		ifFalse: [
			Message new
				receiver: newReceiver;
				selector: '';
				yourself].
	self wbRealWidget
		setActionList: msg asActionSequence, (actions copyFrom: 2 to: actions size)
		forEvent: aSymbol.! !

!WBLayoutCodeModule methods !   
initLayoutTemporaries
	"Private - Initialize the variable names."

	| name |
	self layoutTemporaries do: [:each |
		self varNameFor: each ifAbsentPut: [
			name :=
				(self isVarName: each) | (self isInstVar: each)
					ifTrue: [self constructTempNameFrom: each]
					ifFalse: [each asString].
			self temporaries add: name.
			name]].! !

!WBEventManagerWindow methods ! 
sendFieldNeedsContents: aPane

	"Callback for the #needsContents event triggered in the WBComboBox named 'sendField'.
	 (Generated by WindowBuilder)"

	(aPane contents isNil or: [aPane contents notEmpty]) ifTrue: [
		aPane contents: #( ).
		(Message
			receiver: self
			selector: #sendFieldNeedsContentsDeferred:
			arguments: (Array with: aPane)) performDeferred].
	aPane text: (
		self handlerSelected notNil
			ifTrue: [self handlerSelected selector]
			ifFalse: ['']).! !

!WindowBuilder methods !
menuFileNew

    self confirmSaveChanges
        ifTrue: [
            self inENVY ifFalse: [WBScratchWindow resetToDefault].
            self editClass: WBScratchWindow].! !

!WBLookPolicyWin95 methods !   
displayWithMinorBorder: aPen rect: aRect backColor: backColor

    aPen
        foreColor: Color darkGray;
        wbLineFrom: aRect topLeft to: (aRect topRight left: 1);
        wbLineFrom: aRect topLeft to: (aRect bottomLeft up: 1);
        foreColor: Color white;
        wbLineFrom: (aRect bottomLeft up: 1) to: (aRect bottomRight leftAndUp: 1);
        wbLineFrom: (aRect topRight left: 1) to: (aRect bottomRight leftAndUp: 1@Rectangle leftTopUnit y);
        foreColor: Color gray;
        wbLineFrom: (aRect bottomLeft rightAndUp: 1@2) to: (aRect bottomRight leftAndUp: 2);
        wbLineFrom: (aRect topRight leftAndDown: 2@1) to: (aRect bottomRight leftAndUp: 2);
        foreColor: Color black;
        wbLineFrom: (aRect topLeft rightAndDown: 1) to: (aRect topRight leftAndDown: (2 + Rectangle leftTopUnit y)@1);
        wbLineFrom: (aRect topLeft rightAndDown: 1) to: (aRect bottomLeft rightAndUp: 1@(2 + Rectangle leftTopUnit y)).
    ^self
        drawFilledBoxWith: aPen
        at: aRect
        inset: 2
        backColor: backColor
! !

!WBCreateViewsStubModule methods !   
defaultComment
		"Answer the comment string."
	^self defaultLayoutComment! !

!WBCodeModule methods ! 
varNameFor: anObject ifAbsent: aBlock
        "Answer the variable name (temporary variable or instance variable)
            for the specified object."
    ^varNames at: anObject ifAbsent: [
		varNames at: anObject wbRealWidget ifAbsent: [
			varNames at: anObject wbWrapper ifAbsent: aBlock]]! !

!PStatusPane methods !  
attributeEditor

    ^WBStatusPaneEditor! !

!WindowBuilder class methods !   
basicVersionNumberString
        "Private - Answer the version number string to place in the global ServiceRegistry."
    ^'3.1'! !

!WBPoolManagerWindow methods !   
updateActiveCategoryMenu: aCategory

	self activeCategoryMenu
		uncheckAll;
		checkItem: aCategory.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBMultiToolPalette methods !  
pageNames
    ^self pages keys! !

!WBTargetObject methods !   
updateInstVars

	realClass := self prototype realClass.
	self wbInstVarMap: (self constructInstVarMapFor: self realClass).! !

!WBEventMessage methods ! 
add
	"Add the receiver to the source event table."

	self source
		when: self event
		evaluate: self asMessage.! !

!WBLookPolicyOS2 methods ! 
drawDownArrowWith: aPen at: aRect

    | innerRect side point |
    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class downArrow
                from: self class downArrow boundingBox
                to: aRect]
        ifFalse: [
            innerRect := self draw3DBoxWith: aPen at: aRect.
            side := (innerRect width min: innerRect height) // 7.
            point := innerRect center down: side.
            aPen
                foreColor: Color black;
                wbLineFrom: (point left: 1) to: ((point left: 1) leftAndUp: side * 2 + 1);
                wbLineFrom: point to: (point leftAndUp: side * 2 + 1);
                wbLineFrom: (point right: 1) to: ((point right: 1) leftAndUp: side * 2 + 1);
                wbLineFrom: point to: (point rightAndUp: side * 2 + 1);
                wbLineFrom: (point right: 1) to: ((point right: 1) rightAndUp: side * 2 + 1);
                wbLineFrom: (point left: 1) to: ((point left: 1) rightAndUp: side * 2 + 1)]! !

!WBInterfaceObject methods !   
wbNameAndClass

    ^self wbRealWidget wbNameAndClass! !

!WindowBuilder methods !
editedClass

	^self prototype realClass! !

!WindowBuilder class methods !
properties

    Properties isNil ifTrue: [self initializeProperties].
    ^Properties! !

!WBHandle methods !
displayOn: aPen color: color

    aPen isNil ifTrue: [^self].
    aPen fill: self displayBox color: color.! !

!WindowBuilder methods !  
postEditUpdate

    super postEditUpdate.
    self setDirty.
    self currentWidget changesSize
        ifTrue: [
            self autoSize
                ifTrue: [
                    self geometryManager autoSize.
                    self updateEvents: false]].! !

!WBAbstractAddInModule class methods !
insertMenu: anArray in: menus before: menuNameString

	| target oc aString |
	aString := menuNameString replaceEscapeCharacters stripMnemonic.
	oc := anArray asOrderedCollectionRecursively.
	target := menus detect: [:m | 	(m at: 1) stripMnemonic = aString] ifNone: [nil].
	target isNil ifFalse: [^menus add: oc before: target].
	menus do: [:menu |
		(menu at: 3) do: [:mi |
			mi isSymbol
				ifFalse: [
					(mi at: 1) stripMnemonic = aString
						ifTrue: [^(menu at: 3) add: oc before: mi].
					(mi at: 3) isString
						ifFalse: [
							(mi at: 3) 	do: [:msi |
								msi isSymbol
									ifFalse: [
										(msi at: 1) stripMnemonic = aString
												ifTrue: [^(mi at: 3) add: oc before: msi]]]]]]]! !

!WBTeamVCodePolicy methods !   
basicCreateClassFor: aWBClassDefinition
		"Define and answer a new class.
		Answer nil if one could not be created."
	^aWBClassDefinition superclass
		subclass: aWBClassDefinition className asSymbol
		instanceVariableNames: aWBClassDefinition instVarNamesString
		classVariableNames: aWBClassDefinition classVarNamesString
		poolDictionaries: aWBClassDefinition poolNamesString.! !

!WBCreateBitmap methods ! 
bitmapKey

	^keyField contents! !

!WBCodeStream methods !
nextPutValue: anObject key: aKey pool: aPoolRef manager: aManager
	"Append a reference to the NLS key to the stream."

	| pool |
	aManager codeGenerationStyle = #key ifTrue: [
		(pool := aManager poolFor: aPoolRef) notNil
			ifTrue: [self nextPutPoolKey: aKey in: pool poolName]
			ifFalse: [
				self wbHalt.
				anObject wbStoreOn: self]].

	aManager codeGenerationStyle = #pool ifTrue: [
		(pool := aManager poolFor: aPoolRef) notNil
			ifTrue: [self nextPutPool: pool poolName atKey: aKey]
			ifFalse: [
				self wbHalt.
				anObject wbStoreOn: self]].

	aManager codeGenerationStyle = #manager ifTrue: [
		self nextPutPoolManager: aManager atKey: aKey].! !

!WBLayoutFrameEditor methods !
attachRightBottom

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: #(1 1 1 1).! !

!FrameObject methods !  
frameRect

	^rect! !

!WBEventMessage methods !   
asMessage

	^Message new
		receiver: self receiver;
		selector: (self selector asExistingSymbolOrNil ifNil: [self selector]);
		arguments: self arguments;
		yourself! !

!WBModelInstVar methods !   
lazy: aBoolean

    lazy := aBoolean! !

!WindowBuilder class methods !   
startup
    "Force caches to be set up for path independence"

    self reset.! !

!WBCreateViewModule methods ! 
initVarNames
		"Private - Initialize the variable names."

	super initVarNames.
	self varNameFor: self targetObject put: 'self'.
	self view prototype targetObject validInstVars associationsDo: [:each |
		self targetClassDefinition addInstVarName: each value.
		self useInstVars
			ifFalse: [
				self addModule: (WBInstVarGetModule new
					targetClass: self targetClass;
					targetObject: self targetObject;
					object: each value;
					messageSelector: each value;
					yourself).
				self addModule: (WBInstVarSetModule new
					targetClass: self targetClass;
					targetObject: self targetObject;
					object: each value;
					messageSelector: each value, ':';
					yourself)].
		self varNameFor: each key wbWrapper put: each value.
		self varNameFor: each key wbRealWidget put: each value]
! !

!WBNLSEditorCompositePane methods !
updateCategory

	| aCategory |
	self addSubpanesOnce.
	(aCategory := self selectedCategory) notNil
		ifTrue: [
			categoryEditLabel wbGrayEnable.
			categoryEditField contents = aCategory ifFalse: [
				categoryEditField contents: aCategory]]
		ifFalse: [
			categoryEditLabel wbGrayDisable.
			categoryEditField contents: ''].! !

!WBEnhancedAttributeEditor methods ! 
preInitWindow

	self initFields.! !

!WindowBuilder methods ! 
updatePosition: aPoint

	positionPane contents: 
		aPoint x abs asString , ', ' , 
		aPoint y abs asString.! !

!WindowBuilder methods !
initWindow

	| mainMenu |
	CursorManager initializeWBCursors.
	self undoManager owner: self.
	self initializePalettes.
	mainMenu := self mainView menuWindow.
	customSubMenu := mainMenu wbMenuTitled: 'Custom Widgets'.
	self updateCustomPanesMenu.
	self updateQuickReferenceMenu.
	self editClass: self editedClass.
	self supportsStyleDialog
		ifFalse: [(self paneNamed: 'styleButton') hideWindow].
	Time startTimer: 99 period: 15000 forWindow: self mainView.	
	self timer: nil.! !

!PStaticBox methods ! 
styles

    ^#(#whiteRect #whiteFrame #blackFrame #blackRectangle #grayFrame #grayRectangle)! !

!WBSystemBitmapViewer methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| button1 mainView xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	graphic := WBStaticGraphic new.
	list := ListBox new.
	
		"Temporary Variables"
	button1 := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'System Bitmap Viewer';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -75 * xDU;
				topRatio: 1/2; topInset: -109/2 * yDU;
				rightRatio: 1/2; rightInset: -75 * xDU;
				bottomRatio: 1/2; bottomInset: -91/2 * yDU).
	self addView: mainView.
	
	list "ListBox"
		owner: self;
		setName: 'list';
		when: #clicked: send: #select: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -82 * xDU;
				bottomRatio: 1; bottomInset: 5/2 * yDU);
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: list.
	
	button1
		owner: self;
		when: #clicked send: #close to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 86 * xDU;
				topRatio: 1; topInset: -37/2 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1; bottomInset: 5/2 * yDU);
		contents: 'Close';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: button1.
	
	graphic "WBStaticGraphic"
		owner: self;
		setName: 'graphic';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 86 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 1; rightInset: 2 * xDU;
				bottomRatio: 1; bottomInset: 41/2 * yDU);
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: graphic! !

!WBBitmapEditorCompositePane methods !   
updateValue

	| aBitmap |
	self addSubpanesOnce.
	(aBitmap := self selectedValue) isBitmap
		ifTrue: [
			sizeButton enable.
			sizePane contents:
				aBitmap width asString, ' x ',
				aBitmap height asString, ' x ',
				aBitmap bitCount asString.
			sameBitmapButton
				enable;
				selection: self isSameValueForAllCategories.
			editBitmapButton enable.
			editButtonButton enable.
			bitmapPane
				bitmap: aBitmap;
				erase;
				update]
		ifFalse: [
			sizeButton disable.
			sizePane contents: 'width x height x bit count'.
			sameBitmapButton
				disable;
				selection: false.
			editBitmapButton disable.
			editButtonButton disable.
			bitmapPane isHandleOk ifTrue: [
				bitmapPane
					bitmap: (Bitmap screenExtent: bitmapPane extent);
					update]].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventManagerWindow methods !
sendFieldShowAll

	^sendFieldShowAll ifNil: [false]! !

!PRadioButtonGroup methods !  
defaultBackColor

	^self isWindows95
		ifTrue: [Color gray]
		ifFalse: [super defaultBackColor]! !

!Object methods !   
wbStorePropertiesOn: aCodeStream
    "Store the receiver's attributes on aCodeStream."

    self wbPropertyManager
        wbStore: self
        on: aCodeStream.! !

!WBTemplateEditor methods !  
shellFrameContentRect

    ^self template rect expandBy: 30! !

!WBLayoutFrameEditor methods !
attachLeftBottom

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: #(0 1 0 1).! !

!WBEnhancedEntryFieldEditor methods !
caseDict

    ^Dictionary new
        at: 'UPPER' put: #UPPER;
        at: 'lower' put: #lower;
        at: 'Proper' put: #Proper;
        at: 'Unchanged' put: nil;
        yourself! !

!WindowBuilder methods !   
menuFileUngroupComposite

    thePane isComposite ifFalse: [^nil].
    self layoutForm ungroupComposite! !

!RGBColor methods !  
basicStoreColorOn: aStream
		"Private - Store the color definition."
	#addedByOSI.
	aStream
		nextPut: $( ;
		nextPutAll: self class name;
		space;
		nextPutAll: #red: ;
		space;
		nextPutAll: self red printString;
		space;
		nextPutAll: #green: ;
		space;
		nextPutAll: self green printString;
		space;
		nextPutAll: #blue: ;
		space;
		nextPutAll: self blue printString;
		nextPut: $).! !

!LayoutFrame methods !
wbBottomProportional
	"Answer true if the receiver is bottom proportional (inset = 0)."

	^(self propertyAt: #wbBottomProportional) ifNil: [
		self wbBottomProportional:
			(self bottomInset = 0) & (self bottomRatio ~= 0) & (self bottomRatio ~= 1)]! !

!PRadioButtonGroup methods !  
storeStyleOn: aStream indentString: spaceString! !

!WBCodeGenerator class methods !
policy: aCodePolicy
		"Set the current code policy."
	"WBCodeGenerator policy: WBStandardCodePolicy."
	"WBCodeGenerator policy: WBTeamVCodePolicy."
	"WBCodeGenerator policy: nil."
	CurrentCodePolicy := aCodePolicy.! !

!WBEditClassDialog methods !
listSelect: selectedItem

    "Callback for the #clicked: event triggered in the ListBox named 'list'.
     (Generated by WindowBuilder)"

	selectedItem ifNil: [ ^self ].
    selectedClass := Smalltalk at: selectedItem asSymbol ifAbsent: [^nil].
    self setWindowTitle.! !

!WBLookPolicyOS2 class methods !  
isDefault

    ^self isOS2! !

!WBMultiToolPalette methods !  
buttonFrom: anBitmapFile size: aPoint
    | aBitmap |
    anBitmapFile isNil
        ifTrue: [
            aBitmap := WBBitmapClass extent: aPoint.
            aBitmap pen centerText: '?' at: aBitmap boundingBox center.
            ^aBitmap ].
    ^((anBitmapFile includes: $*) not and: [File exists: anBitmapFile])
        ifTrue: [ WBBitmapClass fromFile: anBitmapFile ]
        ifFalse: [
            aBitmap := WBBitmapClass screenExtent: aPoint.
            aBitmap pen
                draw3DButton: (self justFileName: anBitmapFile)
                rect: aBitmap boundingBox
                font: self font.
            aBitmap]! !

!Object methods ! 
isWBInterfaceObject
        "Private - WBPro Development."
    #addedByOSI.
    ^false! !

!PRadioButton methods !   
importantEvents

    ^super importantEvents
        add: #turnedOn;
        add: #turnedOff;
        yourself! !

!PEnhancedEntryField methods !   
getFocus

	^getFocus ifNil: [getFocus := #selectAll]! !

!WBPoolManagerWindow methods !   
showAllCategoriesPrim: aBoolean
	"Set true if all categories should be shown."

	(showAllCategories := aBoolean)
		ifTrue: [
			self categoryMenu
				checkItem: #menuCategoryShowAll;
				uncheckItem: #menuCategoryShowSelected.
			self categoryPopupMenu
				checkItem: #menuCategoryShowAll;
				uncheckItem: #menuCategoryShowSelected]
		ifFalse: [
			self categoryMenu
				uncheckItem: #menuCategoryShowAll;
				checkItem: #menuCategoryShowSelected.
			self categoryPopupMenu
				uncheckItem: #menuCategoryShowAll;
				checkItem: #menuCategoryShowSelected]! !

!WBAbstractCodeModule methods !
generateCommentBody
	"Private - Generate the comment."

	self wbEditorClass lineBeforeComment
		ifTrue: [self stream cr]
		ifFalse: [self stream crNoNewLine].
	self indentSuccessiveCommentLines
		ifTrue: [self stream indentBy: 1].
	self wrapComment
		ifTrue: [self stream nextPutComment: self comment]
		ifFalse: [self stream nextPutCommentNoWrap: self comment].
	self indentSuccessiveCommentLines
		ifTrue: [self stream indentBy: -1].! !

!WBUserInfoDialog methods ! 
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| companyLabel mainView nameLabel okButton 
	serialNumberLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	companyField := EntryField new.
	nameField := EntryField new.
	serialNumberField := EntryField new.
	
		"Temporary Variables"
	companyLabel := StaticText new.
	nameLabel := StaticText new.
	okButton := Button new.
	serialNumberLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'WindowBuilder Pro User Information';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -75 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -34 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -75 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -34 * yDU).
	self addView: mainView.
	
	nameField "EntryField"
		owner: self;
		setName: 'nameField';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 40 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -146 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: nameField;
		subPaneWithFocus: nameField.
	
	companyField "EntryField"
		owner: self;
		setName: 'companyField';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 40 * xDU;
				topRatio: 0; topInset: 18 * yDU;
				rightRatio: 0; rightInset: -146 * xDU;
				bottomRatio: 0; bottomInset: -30 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: companyField.
	
	serialNumberField "EntryField"
		owner: self;
		setName: 'serialNumberField';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 40 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -146 * xDU;
				bottomRatio: 0; bottomInset: -44 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: serialNumberField.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 98 * xDU;
				topRatio: 0; topInset: 48 * yDU;
				rightRatio: 0; rightInset: -146 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		defaultPushButton;
		contents: 'OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: okButton.
	
	nameLabel "StaticText"
		owner: self;
		setName: 'nameLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 6 * yDU;
				rightRatio: 0; rightInset: -36 * xDU;
				bottomRatio: 0; bottomInset: -14 * yDU);
		rightJustified;
		contents: 'Name:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: nameLabel.
	
	companyLabel "StaticText"
		owner: self;
		setName: 'companyLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -36 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		rightJustified;
		contents: 'Company:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: companyLabel.
	
	serialNumberLabel "StaticText"
		owner: self;
		setName: 'serialNumberLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 34 * yDU;
				rightRatio: 0; rightInset: -36 * xDU;
				bottomRatio: 0; bottomInset: -42 * yDU);
		rightJustified;
		contents: 'Serial #:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: serialNumberLabel! !

!WBGeometryManager methods !
autoSize
    "Auto size the selected widgets"

    | suggestedSize useGrid useFence gridX gridY
    selections boxes redoBlock contentRect |
    (selections := self selections reject: [:aWidget | aWidget preferredExtent isNil]
        ) isEmpty ifTrue: [^self].
    (useGrid := self useGrid)
        ifTrue: [
            gridX := self gridSize x.
            gridY := self gridSize y].
    boxes := selections collect: [:widget | widget boundingBox].
    contentRect := self shell frameContentRect.
    useFence := self useFence.
    self undoManager
        add: 'Auto Size'
        undo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    configureWidget: aWidget x
                    y: aWidget y
                    width: (boxes at: (selections indexOf: aWidget)) width
                    height: (boxes at: (selections indexOf: aWidget)) height
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandles.
            selections do: [:aWidget |
                suggestedSize := aWidget preferredExtent max: 16@16.
                useFence
                    ifTrue: [
                        suggestedSize x: (suggestedSize x min: (aWidget x - contentRect right) abs).
                        suggestedSize y: (suggestedSize y min: (aWidget y - contentRect bottom) abs)].
                useGrid
                    ifTrue: [
                        suggestedSize x: (suggestedSize x roundTo: gridX).
                        suggestedSize y: (suggestedSize y roundTo: gridY)].
                aWidget
                    configureWidget: (aWidget autoSizeFrom == #rightJustified
                        ifTrue: [aWidget x + aWidget width - suggestedSize x]
                        ifFalse: [
                            aWidget autoSizeFrom == #centered
                                ifTrue: [aWidget x + (aWidget width - suggestedSize x // 2)]
                                ifFalse: [aWidget x]])
                    y: aWidget y
                    width: suggestedSize x
                    height: suggestedSize y
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!WBLookPolicy methods !   
titleBarHeight

  ^self class default titleBarHeight! !

!PropertyAccessor methods !  
wbSetValue: aValue for: anObject
    "Private - Set the value of the property."

	#addedByOSI.
	^self setValue: aValue for: anObject! !

!WBLayoutForm methods !
currentClipRect

    | clipbox |
    clipbox := WinRectangle new.
    (GDILibrary
        getClipBox: self pen handle
        rectangle: clipbox asParameter).
    clipbox := clipbox asRectangle.

    ^clipbox! !

!Bitmap methods ! 
screenWidth8: w height: h
        "Private - Initialize the receiver with width w and height h."
    | planes hOldBitmap |
    planes := GDILibrary getDeviceCaps: Display deviceContext
        index: Planes.
    self
        initPenWidth: w
        height: h
        planes: planes
        bitCount: 8.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap! !

!WBInterfaceObject methods !
boundingBoxWithLast
        "Answer the bounding box of the receiver."
    ^self boundingBox merge: self lastRect! !

!WindowBuilder methods !
popupEventTarget: anObject

	| targetObject |
	self currentEventIsTriggered ifFalse: [^self].
	perform setPopupMenu: nil.
	targetObject := anObject.
	targetObject == #window: ifTrue: [
		targetObject := WBEditClassDialog new open selectedClass ifNil: [^self]].
	targetObject == #global: ifTrue: [
		targetObject := WBListChooser promptForGlobal ifNil: [^self]].
	thePane eventHandlerTargetAt: self currentEvent put: targetObject prototype: self prototype.
	self layoutFormChanged.! !

!WBDescriptor methods ! 
fontFlag

    ^#font! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBMenuEditor methods ! 
fillInCurrentItem

    | currentItem |

    currentItem := menuItemsEditor selectedItem
		ifNil: [ ^self ].

    self updateTestButton.

    currentItem selector isMessage ifTrue: [
        currentItem selector receiver isWBAction ifTrue: [
            selectorEditor contents: '<Action: ',currentItem selector receiver script 
asString,'>'
        ] ifFalse: [
            selectorEditor contents: '<Link: ',currentItem selector receiver asString,'>'
        ].
    ] ifFalse: [ currentItem selector isString ifTrue: [
        selectorEditor contents: currentItem selector asString.
    ] ifFalse: [
        selectorEditor contents: ''.
    ]].

    dividerState selection: currentItem isSeparator & currentItem hasChildren not.

    self disableAttributes: (self allowAttributesFor: currentItem) not.
    (self allowDividerFor: currentItem) ifTrue: [
        dividerState enable.
    ] ifFalse: [
        dividerState disable.
    ].

    keyShortCutEditor
        text: (currentItem accelerator isNil
            ifTrue: [''] ifFalse: [currentItem accelerator keyName]).

    (self allowAttributesFor: currentItem) ifFalse: [
        keyShortCutEditor text: ''.
    ].

    isShift selection: (currentItem hasChildren not & currentItem accelerator notNil 
and: [ currentItem accelerator isShift ]).
    isCtrl selection: (currentItem hasChildren not & currentItem accelerator notNil 
and: [ currentItem accelerator isCtrl ]).
    isAlt selection: (currentItem hasChildren not & currentItem accelerator notNil and: 
[ currentItem accelerator isAlt ]).
    hasAccelCheckBox selection: currentItem hasChildren not & keyShortCutEditor 
text notEmpty.

    currentItem canExdent not ifTrue: [
        shiftLeftButton disable.
    ] ifFalse: [
        shiftLeftButton enable.
    ].
    currentItem canIndent not ifTrue: [
        shiftRightButton disable
    ] ifFalse: [
        shiftRightButton enable.
    ].

    currentItem canMoveUp not ifTrue: [
        shiftUpButton disable.
    ] ifFalse: [
        shiftUpButton enable.
    ].

    currentItem canMoveDown not ifTrue: [
        shiftDownButton disable.
    ] ifFalse: [
        shiftDownButton enable.
    ].! !

!WBFontEditorCompositePane methods !   
preInitWindow

	| fontName |
	super preInitWindow.
	nameField contents: Font allFaces asSortedCollection.
	fontName := 'Arial'.
	boldCheckBox font: (
		(Font
			face: fontName
			size: 10
			fixedWidth: false
			attributes: 0)
			bold: true;
			yourself).
	italicCheckBox font: (
		(Font
			face: fontName
			size: 10
			fixedWidth: false
			attributes: 0)
			italic: true;
			bold: false;
			yourself).
	strikeOutCheckBox font: (
		(Font
			face: fontName
			size: 10
			fixedWidth: false
			attributes: 0)
			strikeOut: true;
			bold: false;
			yourself).
	underscoreCheckBox font: (
		(Font
			face: fontName
			size: 10
			fixedWidth: false
			attributes: 0)
			underscore: true;
			bold: false;
			yourself).
	sampleTextEdit contents:
		'The quick brown fox jumped over the sleeping dog.'! !

!WBInterfaceObject methods !
isButton

    ^false! !

!WBCodeStream methods !  
generateByteArrayCode: aBoolean

	self propertyAt: #generateByteArrayCode put: aBoolean.! !

!WBMenu methods !
isChecked: item
        "Answer true if item is checked.
         item can be the label or the selector."
	^(self getMenuItem: item) isChecked.! !

!WBBitmapManagerWindow methods ! 
menuPoolFileInBDT: aStream

	| aPool aCategory |
	aPool := self selectedPoolOrPrompt: 'File BDT into which pool?'.
	aPool isNil ifTrue: [^self].
	aCategory := self allCategories isEmpty
		ifTrue: [self poolManager class defaultCategory]
		ifFalse: [self selectedCategoryOrPrompt: 'File BDT into which category?'].
	aCategory isNil ifTrue: [^self].
	(aPool subPoolNamed: aCategory) fileInFrom: aStream.! !

!WBLookPolicyWin31 methods ! 
scrollBarThumbHeight

    ^scrollBarThumbHeight ifNil: [
        scrollBarThumbHeight := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCyvthumb" 9]
            ifFalse: [super scrollBarThumbHeight]]! !

!WBAttributeWindow methods !   
ownerAboutToClose

    "Callback for the #aboutToClose event from the owner.
     (Generated by WindowBuilder)"

	self hasChanged ifTrue: [
		self mainView bringToTop.
		self aboutToDiscardChanges
			ifTrue: [ self hasChanged: false "to prevent query user twice" ]
			ifFalse: [ self owner abortClose ] ].! !

!WBBitmapManagerWindow methods ! 
menuBitmapFileOutBitmapFile8

	| aBitmap |
	(aBitmap := self selectedValue) isBitmap ifFalse: [^self].
	self menuBitmapFileOutBitmapFile: aBitmap wbCopy8 key: self selectedKey.! !

!WBLayoutForm methods !
selectAllInHierarchy
    "Select all of the widgets in the same hierarchy as the selected widget."

    | newSelections |
    newSelections := self children select: [:child |
        child ~~ self selections first and: [
        child realClass inheritsFrom: self selections first realClass]].

    self
        selections: (newSelections addFirst: self selections first; yourself);
        showHandles! !

!WBGraphicObject methods ! 
propertyAt: key put: aValue
		"Set the value associated with key
		in the properties dictionary."
	properties isNil ifTrue: [properties := IdentityDictionary new].
	aValue isNil ifTrue: [^properties removeKey: key ifAbsent: [ ]].
	^properties at: key put: aValue! !

!WBEventDescription methods !   
event: aSymbol

	self key: aSymbol.! !

!WBPowerViewAddInModule class methods !   
commonName

	^'Power View Support'! !

!WBLayoutForm methods !
minSize
    "Answer the value of minSize."

    ^minSize! !

!PWBInvisibleGroupPane class methods !  
defaultRealClassName
	"Never really used;  just a placeholder."
	^'Object'! !

!WBModelObjectEditor methods ! 
selectedObject

    ^objectList selectedItem! !

!WBPoolEditorCompositePane methods ! 
selectedValue: anObject

	| keyAndPool |
	keyAndPool := self selectedKeyAndPool ifNil: [^nil].
	^keyAndPool value
		at: keyAndPool key
		in: (self selectedCategory ifNil: [^nil])
		put: anObject.! !

!WindowBuilder methods ! 
commentForMenu: aMenuName

	^'Callback for the menu item titled ' , 
		aMenuName stripMnemonic asQuotedString , '.'.! !

!WBEditClassDialog methods !
loadMostRecent

    | mostRecentList |
    mostRecent
        contents: (mostRecentList := self mostRecentList);
        selectItem: (mostRecentList isEmpty
            ifTrue: [self emptyString]
            ifFalse: [mostRecentList first asString]).! !

!WBPropertyManager class methods !
cacheManagers: aBoolean
	"Set true if the managers should be cached."

	cacheManagers := aBoolean = true.
	self reinitialize.! !

!WBScrollingPane methods !
totalLength

    self hasChildren  ifTrue: [
        ^self firstChild totalLength
    ] ifFalse: [
        ^0
    ].! !

!WindowFrameObject methods ! 
nlsPools: aCollection

	self propertyAt: #nlsPools put: aCollection.

	"Changed this"
	"
	self updateManagedValues.
	self children do: [:each | each updateManagedValues].
	"
	"To this"
	self update.! !

!WBCodeModule methods !
varNameForFont: aFont ifAbsent: aBlock
	"Answer the variable name (temporary variable or instance variable)
		for the specified object."

	^varNames at: aFont ifAbsent: [
		self localFonts do: [:each |
			(each wbEquals: aFont) ifTrue: [
				^varNames at: each]].
		^aBlock value]! !

!WBUndoManager class methods ! 
on: aWindowBuilder

    ^self new owner: aWindowBuilder! !

!WBUndoAction methods !   
undo
    "Perform the undo operation"

    undoAction value! !

!WindowBuilder class methods !   
maxWindowSize

    ^self editorClass
        propertyValueAt: #MaxWindowSize
        category: self editorPropertyString! !

!WBAbstractCodeModule class methods !  
codeModulesFor: anObject
		"Answer a collection of code modules for anObject."
	^Array with: self new! !

!WBModelDefinitionEditor methods !  
standardClasses

    ^(Array new: 13)
        at: 1 put: String;
        at: 2 put: Integer;
        at: 3 put: Boolean;
        at: 4 put: Float;
        at: 5 put: Array;
        at: 6 put: OrderedCollection;
        at: 7 put: Dictionary;
        at: 8 put: IdentityDictionary;
        at: 9 put: Symbol;
        at: 10 put: Object;
        at: 11 put: SmallInteger;
        at: 12 put: Date;
        at: 13 put: Time;
        yourself
! !

!WBClassDefinition methods !   
hasPoolNamesChanged
		"Answer true if the pool names have changed."
	(poolNames ifNil: [ ^false ])
		do: [ :eachPoolName |
			(self classField sharedPools includes: eachPoolName
				) ifFalse: [ ^true ] ].
	^false! !

!WBInterfaceObject class methods !  
classAndStyleDict

    ClassAndStyleDict isNil ifTrue: [
        ClassAndStyleDict := Dictionary new.
        ClassAndStyleDict
            at: 128 put: (
                OrderedCollection new
                    add: (Array with: 15 with: BsPushbutton with: Button);
                    add: (Array with: 15 with: BsDefpushbutton with: Button);
                    add: (Array with: 15 with: BsOwnerdraw with: DrawnButton);
                    add: (Array with: 15 with: BsCheckbox with: CheckBox);
                    add: (Array with: 15 with: BsAutocheckbox with: CheckBox);
                    add: (Array with: 15 with: Bs3state with: ThreeStateButton);
                    add: (Array with: 15 with: BsAuto3state with: ThreeStateButton);
                    add: (Array with: 15 with: BsRadiobutton with: RadioButton);
                    add: (Array with: 15 with: BsAutoradiobutton with: RadioButton);
                    add: (Array with: 15 with: BsGroupbox with: GroupBox);
                    yourself
            );
            at: 129 put: (
                OrderedCollection new
                    add: EntryField;
                    add: (Array with: 4 with: EsMultiline with: TextEdit);
                    yourself
            );
            at: 131 put: (
                OrderedCollection new
                    add: ListBox;
                    add: (Array with: 8 with: LbsMultiplesel with: MultipleSelectListBox);
                    yourself
            );
            at: 133 put: ComboBox;
            at: 132 put: (
                OrderedCollection new
                    add: (Array with: 1 with: SbsVert with: WBVerticalScrollBar);
                    add: (Array with: 1 with: SbsHorz with: WBHorizontalScrollBar);
                    yourself
            );
            at: 130 put: (
                OrderedCollection new
                    add: (Array with: 15 with:  SsIcon with: StaticGraphic);
                    add: (Array with: 15 with: SsBlackrect with: StaticBox);
                    add: (Array with: 15 with: SsBlackframe with: StaticBox);
                    add: (Array with: 15 with: SsWhiterect with: StaticBox);
                    add: (Array with: 15 with: SsWhiteframe with: StaticBox);
                    add: (Array with: 15 with: SsGrayrect with: StaticBox);
                    add: (Array with: 15 with: SsGrayframe with: StaticBox);
                    add: (Array with: 15 with: SsCenter with: StaticText);
                    add: (Array with: 15 with: SsLeft with: StaticText);
                    add: (Array with: 15 with: SsRight with: StaticText);
                    add: (Array with: 15 with: SsSimple with: StaticText);
                    yourself
            ).
    ].

    ^ClassAndStyleDict! !

!WBLookPolicy class methods !
current

    ^Current ifNil: [Current := self initializePolicy]! !

!WBTabOrderLayoutForm methods !   
widgetsFrom: aCollection containedIn: grouper

	^self 
		widgetsFrom: aCollection 
		containedIn: grouper 
		testBlock: self standardTestBlock.! !

!WBModelObjectEditor methods ! 
objectSelected: selectedObject

    self enableFields.
    selectedObject paneName isNil
        ifFalse: [
            name contents: selectedObject paneName.
            self setIsInstVar: selectedObject isInstVar.
            self setIsValidInstVar: selectedObject paneName]
        ifTrue: [
            name contents: self emptyString.
            self setIsInstVar: false.
            self setIsValidInstVar: self emptyString].
    self updateEvents: selectedObject refresh: false.
    when selection: 1.
    self
        updateSend: selectedObject;
        updateStyle: selectedObject.
    selectedObject attributeEditor isNil
        ifTrue: [editButton disable]
        ifFalse: [editButton enable].
    selectedObject isWBPrimaryModel
        ifTrue: [
            name disable.
            instVar disable.
            removeButton disable]
        ifFalse: [
            name enable.
            removeButton enable].! !

!PRadioButtonGroup methods !   
mutateSpecificsFrom: aPane
	| list |
	((list := aPane contents) notNil and: [list isArray])
		ifTrue: [self contents: list deepCopy].
	(aPane respondsTo: #label)
		ifTrue: [self label: aPane label].! !

!WBCodeStream methods ! 
nextPutFontRef: aFont indentString: indentString
	"Look up the receiver in the Font pools to find a match.
		If found, then include the pool variable in the code
		and answer true, else include a font definition,
		and answer false."

	WBFontManager managers do: [:eachManager |
		eachManager pools do: [:eachPool |
			eachPool pool associationsDo: [:eachAssoc |
				aFont == eachAssoc value ifTrue: [
					self
						nextPutValue: aFont
						key: eachAssoc key
						pool: eachPool
						manager: eachManager.
					^true]]]].
	self nextPutFontDef: aFont indentString: indentString.
	^false! !

!WBEnhancedEntryFieldEditor methods !  
initWindow

    | function |
    (self paneNamed: 'case') selectItem: (self caseDict keyAtValue: thePane case).
    (self paneNamed: 'justification') selectItem: (self justificationDict keyAtValue: thePane justification).
    (self paneNamed: 'getFocus') selectItem: (self getFocusDict keyAtValue: thePane getFocus).

    (self paneNamed: 'size') contents: thePane maximumSize asString.
    (self paneNamed: 'autoTab') selection: thePane autoTab.

    thePane character isNil ifTrue: [
        function := self noneString
    ] ifFalse: [
        function := thePane character copyFrom: 3 to: thePane character size - 1
    ].
    (self paneNamed: 'character') selectItem: function.

    thePane field isNil ifTrue: [
        function := self noneString
    ] ifFalse: [
        function := thePane field copyFrom: 3 to: thePane field size
    ].
    (self paneNamed: 'field') selectItem: function.

    self supportsAutoTab ifFalse: [
        (self paneNamed: 'autoTab') hideWindow
    ].
    self supportsJustification ifFalse: [
        (self paneNamed: 'justText') disable.
        (self paneNamed: 'justification') disable
    ].! !

!WBEditClassDialog methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| addFilter anyFilter anyPackage cancel clearMostFrequent 
	clearMostRecent filterGroup mainView mostFrequentLabel 
	mostRecentLabel packageLabel removeFilter xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	filter := WBComboBox new.
	list := ListBox new.
	mostFrequent := WBComboBox new.
	mostRecent := WBComboBox new.
	ok := Button new.
	package := WBComboBox new.
	
		"Temporary Variables"
	addFilter := Button new.
	anyFilter := Button new.
	anyPackage := Button new.
	cancel := Button new.
	clearMostFrequent := Button new.
	clearMostRecent := Button new.
	filterGroup := GroupBox new.
	mostFrequentLabel := StaticText new.
	mostRecentLabel := StaticText new.
	packageLabel := StaticText new.
	removeFilter := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Edit Class';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -100 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -95 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -100 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -95 * yDU).
	self addView: mainView.
	
	mostRecent "WBComboBox"
		owner: self;
		setName: 'mostRecent';
		when: #changed: send: #mostRecentSelect: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 60 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -168 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView
		addSubpane: mostRecent;
		subPaneWithFocus: mostRecent.
	
	clearMostRecent "Button"
		owner: self;
		setName: 'clearMostRecent';
		when: #clicked send: #clearMostRecent to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 172 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -198 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		contents: 'Clear';
		startGroup;
		font: SysFont.
	mainView addSubpane: clearMostRecent.
	
	mostFrequent "WBComboBox"
		owner: self;
		setName: 'mostFrequent';
		when: #changed: send: #mostFrequentSelect: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 60 * xDU;
				topRatio: 0; topInset: 18 * yDU;
				rightRatio: 0; rightInset: -168 * xDU;
				bottomRatio: 0; bottomInset: -30 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: mostFrequent.
	
	clearMostFrequent "Button"
		owner: self;
		setName: 'clearMostFrequent';
		when: #clicked send: #clearMostFrequent to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 172 * xDU;
				topRatio: 0; topInset: 18 * yDU;
				rightRatio: 0; rightInset: -198 * xDU;
				bottomRatio: 0; bottomInset: -30 * yDU);
		contents: 'Clear';
		startGroup;
		font: SysFont.
	mainView addSubpane: clearMostFrequent.
	
	package "WBComboBox"
		owner: self;
		setName: 'package';
		when: #changed: send: #packageSelect: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 60 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -168 * xDU;
				bottomRatio: 0; bottomInset: -44 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: package.
	
	anyPackage "Button"
		owner: self;
		setName: 'anyPackage';
		when: #clicked send: #anyPackage to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 172 * xDU;
				topRatio: 0; topInset: 32 * yDU;
				rightRatio: 0; rightInset: -198 * xDU;
				bottomRatio: 0; bottomInset: -44 * yDU);
		contents: 'Any';
		startGroup;
		font: SysFont.
	mainView addSubpane: anyPackage.
	
	list "ListBox"
		owner: self;
		setName: 'list';
		when: #clicked: send: #listSelect: to: self;
		when: #doubleClicked: send: #ok: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -198 * xDU;
				bottomRatio: 0; bottomInset: -148 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: list.
	
	filter "WBComboBox"
		owner: self;
		setName: 'filter';
		when: #changed: send: #filterSelect: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 158 * yDU;
				rightRatio: 0; rightInset: -144 * xDU;
				bottomRatio: 0; bottomInset: -170 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: filter.
	
	anyFilter "Button"
		owner: self;
		setName: 'anyFilter';
		when: #clicked send: #anyFilter to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 172 * yDU;
				rightRatio: 0; rightInset: -48 * xDU;
				bottomRatio: 0; bottomInset: -184 * yDU);
		contents: 'Any';
		startGroup;
		font: SysFont.
	mainView addSubpane: anyFilter.
	
	addFilter "Button"
		owner: self;
		setName: 'addFilter';
		when: #clicked send: #addFilter to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 52 * xDU;
				topRatio: 0; topInset: 172 * yDU;
				rightRatio: 0; rightInset: -96 * xDU;
				bottomRatio: 0; bottomInset: -184 * yDU);
		contents: 'Add';
		startGroup;
		font: SysFont.
	mainView addSubpane: addFilter.
	
	removeFilter "Button"
		owner: self;
		setName: 'removeFilter';
		when: #clicked send: #removeFilter to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 100 * xDU;
				topRatio: 0; topInset: 172 * yDU;
				rightRatio: 0; rightInset: -144 * xDU;
				bottomRatio: 0; bottomInset: -184 * yDU);
		contents: 'Remove';
		startGroup;
		font: SysFont.
	mainView addSubpane: removeFilter.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 152 * xDU;
				topRatio: 0; topInset: 152 * yDU;
				rightRatio: 0; rightInset: -198 * xDU;
				bottomRatio: 0; bottomInset: -168 * yDU);
		defaultPushButton;
		contents: 'OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 152 * xDU;
				topRatio: 0; topInset: 172 * yDU;
				rightRatio: 0; rightInset: -198 * xDU;
				bottomRatio: 0; bottomInset: -188 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	mostRecentLabel "StaticText"
		owner: self;
		setName: 'mostRecentLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 6 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 0; bottomInset: -14 * yDU);
		rightJustified;
		contents: 'Most Recent:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: mostRecentLabel.
	
	mostFrequentLabel "StaticText"
		owner: self;
		setName: 'mostFrequentLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		rightJustified;
		contents: 'Most Frequent:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: mostFrequentLabel.
	
	packageLabel "StaticText"
		owner: self;
		setName: 'packageLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 34 * yDU;
				rightRatio: 0; rightInset: -58 * xDU;
				bottomRatio: 0; bottomInset: -42 * yDU);
		rightJustified;
		contents: 'Package:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: packageLabel.
	
	filterGroup "GroupBox"
		owner: self;
		setName: 'filterGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 148 * yDU;
				rightRatio: 0; rightInset: -148 * xDU;
				bottomRatio: 0; bottomInset: -188 * yDU);
		contents: 'Filter';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: filterGroup! !

!WBInterfaceObject methods ! 
usesFocus

    ^true! !

!WBLayoutWizard class methods !  
initializeMenuDefinitions

    ^Dictionary new
        at: 'File' put:
            (Menu new
                title: '&File';
                owner: self;
                appendItem: '&New' selector: #menuFileNew acceleratorString: 'Alt+N';
                appendItem: '&Open..' selector: #menuFileOpen acceleratorString: 'Alt+O';
                appendSeparator;
                appendItem: '&Save' selector: #menuFileSave acceleratorString: 'Alt+S';
                appendItem: 'Save &As...' selector: #menuFileSaveAs acceleratorString: 'Alt+A';
                appendSeparator;
                appendItem: 'E&xit' selector: #menuFileExit acceleratorString: 'Alt+X') asPMenuItem;
        at: 'Edit' put:
            (Menu new
                title: '&Edit';
                owner: self;
                appendItem: '&Undo' selector: #menuEditUndo acceleratorString: 'Ctrl+Z';
                appendSeparator;
                appendItem: 'Cu&t' selector: #menuEditCut acceleratorString: 'Ctrl+X';
                appendItem: '&Copy' selector: #menuEditCopy acceleratorString: 'Ctrl+C';
                appendItem: '&Paste' selector: #menuEditPaste acceleratorString: 'Ctrl+V';
                appendSeparator;
                appendItem: 'Cl&ear' selector: #menuEditClear) asPMenuItem;
        at: 'Window' put:
            (Menu new
                title: '&Window';
                owner: self;
                appendItem: '&Tile' selector: #menuWindowTile;
                appendItem: '&Cascade' selector: #menuWindowCascade;
                appendSeparator) asPMenuItem;
        at: 'Help' put:
            (Menu new
                title: '&Help';
                owner: self;
                appendItem: '&Contents' selector: #menuHelpContents;
                appendItem: '&How to Use Help' selector: #menuHelpHowToUseHelpr) asPMenuItem;
        yourself! !

!WBLayoutWizard class methods ! 
initializeDefaultMenus

    ^OrderedCollection new! !

!WBAbstractAddInModule class methods ! 
editorClass

    ^WindowBuilder editorClass! !

!WBCallOutEditor methods !
openOn: aWindowBuilder

    owner := aWindowBuilder.
    self open.! !

!WBTabOrderLayoutForm methods !  
children: aCollectionOfWidgets
    "Set the collection of the children of the receiver."

    widgets := aCollectionOfWidgets! !

!WBPMenuItem methods ! 
canIndent

    ^super canIndent and: [ self previousSibling isSeparator not ].! !

!WBTemplateEditor methods !
setDirty! !

!PWBStaticGraphic methods !
usesFocus

    ^false! !

!WBApplicationCoordinatorModule methods !   
defaultMessageArguments
        "Private - Answer the default message selector arguments."
    ^Array
        with: self defaultViewName
        with: self defaultOwnerName! !

!PEntryFieldGroup methods !
defaultSize

    ^self bestSize! !

!WindowBuilder class methods !
openEventMappings

	(Smalltalk at: #WBEventTranslator
		ifAbsent: [^MessageBox message: 'Event Translator not installed.']) editEvents! !

!WBMenu methods ! 
updateEnabled
        "Update the enabled status of all items for the receiver."
    items do: [:mi | mi updateEnabled].! !

!WBMultiViewAddInModule class methods !  
comment

	^'WARNING!!  Using multiple views 
is discouraged and may not 
be supported in future releases'! !

!WindowBuilder class methods !
lookPolicy: aWBLookPolicy

    self propertyAt: #LookPolicy put: aWBLookPolicy! !

!WBLayoutFrameEditor methods ! 
initWindow

	self update.! !

!WBRGBColorDialog methods ! 
initWindow

    | keys indexedColor rgbColor |

    defaults associationsDo: [:assoc |
        indexedColor := assoc value asIndexedColor.
        indexedColor index = 7 ifTrue: [indexedColor := Color black]. "Black"
        indexedColor index = 0 ifTrue: [indexedColor := Color white]. "White"
        rgbColor := [indexedColor asRGBColor]
            on: Error
            do: [RGBColor fromInteger: indexedColor asInteger].
        rgbColor = assoc value
            ifTrue: [defaults at: assoc key put: indexedColor]].
    elements associationsDo: [:assoc |
        indexedColor := assoc value asIndexedColor.
        rgbColor := [indexedColor asRGBColor]
            on: Error
            do: [RGBColor fromInteger: indexedColor asInteger].
        rgbColor = assoc value
            ifTrue: [elements at: assoc key put: indexedColor]].

    colors := Color defaultColorClass defaultColors
        keys asSortedCollection asOrderedCollection.
    colors addFirst: #default.

    (self paneNamed: 'elementsList')
        contents: (keys := elements keys asSortedCollection);
        selectItem: keys first.

    (self paneNamed: 'colorList') contents: colors.
    self elementSelected: keys first.! !

!WBPrototype methods !  
windows

	^windows! !

!WBAboutDialog class methods ! 
initTranscriptAfterClose: aBoolean
    "Initialize the Transcript after an instance of the receiver
      has been opened and closed."
  InitTranscript := aBoolean.! !

!WBEventManagerWindow methods ! 
menuOptionShowButtons

    "Callback for the menu item titled 'Show buttons'.
     (Generated by WindowBuilder)"

    self showButtons:
        methodTextEdit framingBlock rightInset
            ~= methodTextEditFramingBlock rightInset! !

!WBAddInManager methods !
initWindow

	changed := false.
	self loadList! !

!WBLayoutWizard methods !  
stringFor: anItem

    ^anItem name
! !

!WBPropertyDescriptor methods ! 
resourceValues
    "Answer the value of resourceValues."

    ^resourceValues! !

!WBCodeStream methods !
nextPutFontDef: aFont
	"Append a font definition."

	^self nextPutFontDef: aFont indentString: ''! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder methods !  
commentForWidget: aWidget event: eventSymbol

	^'Callback for the #' , eventSymbol asString , ' event in ' , (self statusDescriptionFor: aWidget) , '.'.! !

!WBAbstractCodeModule methods !  
targetObject: anObject
		"Set the receiver's target object."
	targetObject := anObject.! !

!WBBitmapManagerWindow methods !  
menuBitmapFileInBitmapFile

	| aKeyAndPool aCategory path stream aBitmap |
	aKeyAndPool := self selectedKeyAndPool ifNil: [^self].
	aCategory := self selectedCategory ifNil: [^self].
	path := FileDialog new
		title: 'File in bitmap...';
		addFilter: '*.bmp' description: 'Bitmap Files (*.bmp)';
		defFilter: '*.bmp';
		openFile: '*.bmp';
		file.
	path isNil ifTrue: [^self].
	stream := File pathNameReadOnly: path.
	[[aBitmap := WBBitmapClass fromFileStream: stream]
		on: Error
		do: [:exception | ^self menuErrorHandler: exception]]
		ensure: [stream close].
	aKeyAndPool value
		at: aKeyAndPool key
		in: aCategory
		put: aBitmap.! !

!WindowBuilder methods !  
topPaneClass
	"Private - Answer the default top pane class."

	#osiHack. "WBPro does not work inside an MDI Frame..."
	"(Smalltalk includesKey: #MDISystem) ifTrue: [
        Smalltalk isRunTime ifFalse:[
            (Smalltalk at: #MDISystem) isActive ifTrue:[
                ^(Smalltalk at: #WBMDIChild ifAbsent: [ WBTopPane ])]]]."
	^WBTopPane! !

!WBUndoRedoDialog methods !  
levelsChanged: aString

    | numLevels |
    aString isEmpty ifTrue: [^self].
    numLevels := aString asNumber asInteger.
    WindowBuilder maxUndoLevels: numLevels.
    WBUndoManager maxUndoLevels: numLevels.! !

!PropertyAccessor methods !   
wbPoolKey

	#addedByOSI.
	^(self propertyAt: #wbPoolKey) ifNil: [
		self wbPoolKey: self wbDefaultPoolKey]! !

!WBInstVarObject methods !   
when: eventName send: selector to: anObject
    "Do Nothing"! !

!WBLayoutCodeModule methods ! 
constructVarNameForPane: aPane
		"Answer a new variable name for the specified object."
	| answer |
	answer := (aPane paneName ifNil: [ '' ]) asString.
	answer asSuggestedTempVarToken = answer ifTrue: [
		(self isVarName: answer) | (self isInstVar: answer) ifFalse: [
			^answer ] ].
	answer isEmpty ifTrue: [
		answer := aPane wbSuggestedTempName ].
	^self constructTempNameFrom: answer
! !

!WBMultiListChooser methods !
selectAll

    | list |
    (list := self paneNamed: 'list') contents do: [ :item | list selectItem: item ].! !

!WBLookPolicyWin95 methods !
closeButtonSize

    ^16 @14! !

!WBLookPolicyWin95 methods ! 
scrollBarArrowWidth

    ^scrollBarArrowWidth ifNil: [
        scrollBarArrowWidth := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxhscroll" 21]
            ifFalse: [super scrollBarArrowWidth]]! !

!WBMenu methods !
allMenuItemSelectors

	| allMenuItemSelectors |
	allMenuItemSelectors := OrderedCollection new.
	self allMenuItems do: [:item |
		item selector isNil
			ifFalse: [allMenuItemSelectors add: item selector]].
	^allMenuItemSelectors asSet asArray! !

!WBMenuEditor methods !   
allowDividerFor: anItem

    ^anItem hasChildren not! !

!WBLookPolicy methods !  
drawToggle: aToggle with: aPen clipRect: clipRect

    | rect textRect |
    rect := aToggle rect.
    textRect := ((rect left right: self iconExtent x + 6) @ (rect center y up: (aToggle font height // 2)))
        extentFromLeftTop: (aToggle font wbStringWidth: aToggle contents) @ aToggle font height.
    aPen
        fill: rect color: aToggle backColor;
        foreColor: aToggle foreColor;
        backColor: aToggle backColor;
        font: aToggle font;
        setTextAlign: WBDisplayContext defaultTextAlign;
        winDrawText: aToggle contents in: textRect format: self  class default leftJustification.! !

!PToggle methods ! 
mutationTypes

    ^#(#Button #CPBitmapButton)! !

!WBAttributeWindow methods !   
openOn: anObject
		"Open the receiver on the specified pane."
	owner := anObject.
	self open.! !

!WBDescriptor methods !
comment
    "Answer the value of comment."

    ^comment! !

!WBTreeNode methods !   
allRelations

    | root |

    root := self.

    [ root isRoot ] whileFalse: [
        root := root parent.
    ].

    ^root asFlatList! !

!WBToolBarEditor methods ! 
setCellSize: ignore

    self getBitmaps: (self paneNamed: 'bitmaps').! !

!WBLookPolicy methods !
drawSystemMenuWith: aPen at: aRect
    "Do Nothing"! !

!WBClassDefinition methods !   
poolNamesString
		"Answer the receiver's pool names as a string."
	| stream |
	stream := WriteStream on: (String new: 20).
	self poolNames
		do: [ :eachName | stream nextPutAll: eachName ]
		andBetweenDo: [ stream space ].
	^stream contents! !

!WBKeyAccel methods !   
isCtrl: bool

    isControl := bool! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowFrameObject methods ! 
childrenInBuildOrder

	^self children! !

!WBTreeListBox methods !
wbSelectIndex: anIndex

    self selectIndex: anIndex.
    self event: #select.
    previousSelection := anIndex.
    self setEditBox.! !

!WBPoolManagerWindow methods !  
menuCategoryFileOut: aPath
	"File out the selected pools and categories."

	| stream |
	CursorManager execute changeFor: [
		stream := File newFile: aPath.
		[self selectedPools
			do: [:each | each fileOutCategories: self selectedCategories on: stream].
		] ensure: [stream close]].! !

!WBAddInManager methods !   
remove

	| addIn |
	(addIn := WBAbstractAddInModule allSubclasses 
		detect: [:class | selection = class commonName]
		ifNone: [nil]) notNil
			ifTrue: [addIn unloadAddIn]
			ifFalse: [self wbEditorClass removeExtra: selection].
	changed := true.
	self loadList! !

!WBAbstractCodeModule methods !  
generateComment
        "Private - Generate the comment."
	self stream cr; wrapDuring: [
		self stream indentBy: 1 during: [
			self generateCommentBody]].! !

!WBMultiToolPalette methods !   
stateAt: key

    ^#up! !

!WBHandle methods !
isFor: aFigure
        ^self owner == aFigure! !

!WBTabOrderLayoutForm methods !  
insertGroupingPanes
	"Scan through the panes looking for grouped panes, and add a
     grouping pane around each of them.  Panes that are grouped have the
     same integer value in their tabposition, with a mantissa representing
     the order within the group"

	| groupsDict group groupID groupPane |
	groupsDict := Dictionary new.
	self children do: [:widget |
		(widget tabPosition notNil and: [widget tabPosition inGroup])
			ifTrue: [
				groupID := widget tabPosition basicTabPosition.
				group := groupsDict at: groupID ifAbsent: [OrderedCollection new].
				group add: widget.
				groupsDict at: groupID put: group]].
	groupsDict do: [:eachGroup |
		groupPane := self groupPaneClass example.
		groupPane rect: ((self boundingBoxFor: eachGroup) expandBy: 8).
		groupPane tabPosition: (WBTabPosition fromTabPosition: (groupsDict keyAtValue: eachGroup)).
		self children add: groupPane].! !

!Timer methods ! 
storeOn: aStream indentString: indentString
    "Private - WBPro Development."

    aStream
        cr; nextPutAll: indentString, 'period: ', (period ifNil: [1000]) asString.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBScrollingPane methods !  
childSize

    | theChild |

    (theChild := self firstChild) notNil  ifTrue: [
        ^theChild totalWidth @ theChild totalLength
    ] ifFalse: [
        ^0@0
    ].! !

!WBTreeListBox methods !  
moveSelectionDown

    self commitSelection.
    self wbSelectIndex: ((self selection + 1) min:  list asFlatList size).
    owningEditBox setFocus.! !

!WBDialogScratchWindow class methods !  
defaultClass

    ^WBDefaultDialogScratchWindow! !

!WBGeometryManager methods !  
shell

    ^self owner prototype shell! !

!Object methods !  
eventHandlerSelectorAt: aSymbol put: aString  prototype: prototype
	"Set the first event handler at aSymbol as a string
		or an empty string if there is no handler defined."

	| actions |
	actions := self wbRealWidget actionListForEvent: aSymbol.
	actions := aString notEmpty
		ifTrue: [
			actions notEmpty
				ifTrue: [
					(actions first copy
						selector: aString;
						yourself
					) asActionSequence, (actions copyFrom: 2 to: actions size)]
				ifFalse: [
					(Message new
						receiver: prototype targetObject;
						selector: aString;
						yourself
					) asActionSequence]]
		ifFalse: [
			actions notEmpty
				ifTrue: [
					"Special case:  If there are multiple actions defined for this widget
						and the user 'deletes' the handler for the first one, do not
						remove the handler but instead store a blank string here
						and determine if the handler should be removed when the
						WB 'send' field loses focus."
					actions size > 2
						ifTrue: [
							(actions first copy
								selector: '';
								yourself
							) asActionSequence, (actions copyFrom: 2 to: actions size)]
						ifFalse: [actions copyFrom: 2 to: actions size]]
				ifFalse: [actions]].
	self wbRealWidget
		setActionList: actions
		forEvent: aSymbol.! !

!PRadioButtonGroup methods ! 
usesMenu

     ^false! !

!PStaticText methods !  
suggestedSize

	^((self contentsStringExtent + (5 @ 0)) * (self autoSizeRatio @ 1)) rounded! !

!WBAbstractAddInModule class methods !
removeMenu: aString in: menus

	| target |
	target := menus detect: [:m | (m at: 1) = aString] ifNone: [nil].
	target isNil ifFalse: [^menus remove: target ifAbsent: [nil]].
	menus do: [:menu |
		(menu at: 3) do: [:mi |
			mi isSymbol
				ifFalse: [
					(mi at: 1) = aString
						ifTrue: [^(menu at: 3) remove: mi ifAbsent: [nil]].
					(mi at: 3) isString
						ifFalse: [
							(mi at: 3) do: [:msi |
								msi isSymbol
									ifFalse: [
										(msi at: 1) = aString
											ifTrue: [^(mi at: 3) remove: msi ifAbsent: [nil]]]]]]]]! !

!WBTreeNode methods !
nextSibling

    self isRoot ifTrue: [
        ^nil
    ].

    ^parent childAfter: self.! !

!WBPrimaryModelOpenOnModule methods !   
targetClass
        "Answer the receiver's target class."
    ^super targetClass instanceClass! !

!WindowBuilder methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| mainView nameText performText staticBox1 staticBox2 
	staticBox3 staticBox4 staticBox5 styleButton whenText xDU 
	yDU eventManagerButton |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	attributeBar := WBToolBar new.
	editPalette := WBToolBar new.
	entries := WBMultiToolPalette new.
	groups := WBToolPalette new.
	instVar := CheckBox new.
	name := WBEntryField new.
	perform := WBEntryField new.
	positionButton := DrawnButton new.
	positionPane := StaticText new.
	scrollingForm := WBScrollingPane new.
	sizeButton := DrawnButton new.
	sizePane := StaticText new.
	status := StatusPane new.
	styleEditor := WBComboBox new.
	styleText := StaticText new.
	titleEditor := WBEntryField new.
	titleText := StaticText new.
	toolBar := WBToolBar new.
	when := WBComboBox new.
	
		"Temporary Variables"
	eventManagerButton := Button new.
	nameText := StaticText new.
	performText := StaticText new.
	staticBox1 := StaticBox new.
	staticBox2 := StaticBox new.
	staticBox3 := StaticBox new.
	staticBox4 := StaticBox new.
	staticBox5 := StaticBox new.
	styleButton := Button new.
	whenText := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		when: #aboutToClose send: #aboutToClose to: self;
		when: #activated send: #activated to: self;
		when: #closed send: #closed to: self;
		when: #opened send: #opened to: self;
		when: #timer: send: #timer: to: self;
		labelWithoutPrefix: 'WindowBuilder: [Untitled]';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1/2; leftInset: -156 * xDU;
				topRatio: 1/2; topInset: -235/2 * yDU;
				rightRatio: 1/2; rightInset: -156 * xDU;
				bottomRatio: 1/2; bottomInset: -217/2 * yDU).
	self addView: mainView.
	
	status "StatusPane"
		owner: self;
		setName: 'status';
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 1; topInset: -21/2 * yDU;
				rightRatio: 1; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 0 * yDU);
		contents: (
		    OrderedCollection new
		        addLast: (
		            StatusBox new
		                space: 7;
		                width: 10;
		                name: #status
		        );
		        addLast: (
		            StatusBox new
		                space: 7;
		                width: 10;
		                name: #time
		        );
		        yourself
		);
		startGroup;
		noTabStop.
	mainView addSubpane: status.
	
	titleEditor "WBEntryField"
		owner: self;
		setName: 'titleEditor';
		when: #needsPopupMenu send: #popupTitleMenu: to: self withArgument: titleEditor;
		when: #textChanged: send: #textChanged: to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 56 * xDU;
				topRatio: 1; topInset: -101/2 * yDU;
				rightRatio: 1; rightInset: 154 * xDU;
				bottomRatio: 1; bottomInset: 77/2 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: titleEditor;
		subPaneWithFocus: titleEditor.
	
	styleEditor "WBComboBox"
		owner: self;
		setName: 'styleEditor';
		addClipsiblingsStyle;
		when: #changed: send: #setStyle: to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 56 * xDU;
				topRatio: 1; topInset: -75/2 * yDU;
				rightRatio: 1; rightInset: 307/2 * xDU;
				bottomRatio: 1; bottomInset: -19/2 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: styleEditor.
	
	name "WBEntryField"
		owner: self;
		setName: 'name';
		addClipsiblingsStyle;
		when: #textChanged: send: #symbolNameChanged: to: self;
		when: #losingFocus send: #checkForDuplicateName to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 56 * xDU;
				topRatio: 1; topInset: -49/2 * yDU;
				rightRatio: 1; rightInset: 307/2 * xDU;
				bottomRatio: 1; bottomInset: 25/2 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: name.
	
	when "WBComboBox"
		owner: self;
		setName: 'when';
		addClipsiblingsStyle;
		when: #changed: send: #whenChanged: to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -106 * xDU;
				topRatio: 1; topInset: -75/2 * yDU;
				rightRatio: 1; rightInset: 3 * xDU;
				bottomRatio: 1; bottomInset: -19/2 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: when.
	
	perform "WBEntryField"
		owner: self;
		setName: 'perform';
		addClipsiblingsStyle;
		when: #losingFocus send: #performTextLosingFocus: to: self withArgument: perform;
		when: #needsPopupMenu send: #popupTargetMenu: to: self withArgument: perform;
		when: #textChanged: send: #performTextChanged:pane: to: self withArgument: perform;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -106 * xDU;
				topRatio: 1; topInset: -25 * yDU;
				rightRatio: 1; rightInset: 33/2 * xDU;
				bottomRatio: 1; bottomInset: 13 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: perform.
	
	styleText "StaticText"
		owner: self;
		setName: 'styleText';
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 32 * xDU;
				topRatio: 1; topInset: -71/2 * yDU;
				rightRatio: 0; rightInset: -54 * xDU;
				bottomRatio: 1; bottomInset: 55/2 * yDU);
		rightJustified;
		contents: 'Style:';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: styleText.
	
	sizePane "StaticText"
		owner: self;
		setName: 'sizePane';
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -29 * xDU;
				topRatio: 1; topInset: -95/2 * yDU;
				rightRatio: 1; rightInset: 5 * xDU;
				bottomRatio: 1; bottomInset: 81/2 * yDU);
		contents: '0 x 0';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sizePane.
	
	positionPane "StaticText"
		owner: self;
		setName: 'positionPane';
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -67 * xDU;
				topRatio: 1; topInset: -95/2 * yDU;
				rightRatio: 1; rightInset: 43 * xDU;
				bottomRatio: 1; bottomInset: 81/2 * yDU);
		contents: '0, 0';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: positionPane.
	
	scrollingForm "WBScrollingPane"
		owner: self;
		setName: 'scrollingForm';
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 31 * xDU;
				topRatio: 0; topInset: 13 * yDU;
				rightRatio: 1; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 103/2 * yDU);
		foreColor: Color white;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: scrollingForm.
	
	editPalette "WBToolBar"
		owner: self;
		setName: 'editPalette';
		when: #showHelp: send: #setStatusForToolBar: to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 1 * xDU;
				topRatio: 1; topInset: -53/2 * yDU;
				rightRatio: 0; rightInset: -31 * xDU;
				bottomRatio: 1; bottomInset: 25/2 * yDU);
		postAutomatic;
		backColor: Color gray;
		noTabStop;
		font: SysFont;
		useSystem: true;
		add: WBEditAppCodeSysBitmap selector: #menuEditBrowseClass;
		add: WBEditTabbingSysBitmap selector: #setTabbing spaces: 3.
	mainView addSubpane: editPalette.
	
	toolBar "WBToolBar"
		owner: self;
		setName: 'toolBar';
		when: #showHelp: send: #setStatusForToolBar: to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 1 * yDU;
				rightRatio: 1; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -12 * yDU);
		postAutomatic;
		backColor: Color gray;
		noTabStop;
		font: SysFont;
		useSystem: true;
        add: WBTestWindowSysBitmap selector: #menuEditTestWindow spaces: 3;
        add: WBCreateNewSysBitmap selector: #menuFileNew spaces: 4;
        add: WBCreateNewDialogSysBitmap selector: #menuFileNewDialog;
        add: WBOpenNewSysBitmap selector: #menuFileOpen;
        add: WBSaveSysBitmap selector: #menuFileSave enable: #isDirty;
        add: WBCutSysBitmap selector: #cutSelections enable: #hasSelections owner: geometryManager spaces: 4;
        add: WBCopySysBitmap selector: #copySelections enable: #hasSelections owner: geometryManager;
        add: WBPasteSysBitmap selector: #pasteSelections enable: #clipboardHasItems owner: geometryManager;
        add: WBClearSysBitmap selector: #menuEditClear enable: #hasSelections;
        add: WBBringToFrontSysBitmap selector: #bringToFront enable: #hasSelections owner: geometryManager spaces: 4;
        add: WBSendToBackSysBitmap selector: #sendToBack enable: #hasSelections owner: geometryManager;
        add: WBDuplicateSysBitmap selector: #duplicate enable: #hasSelections owner: geometryManager;
        add: WBAutosizeSysBitmap selector: #autoSize enable: #hasSelections owner: geometryManager spaces: 4;
        add: WBReplicateWidthSysBitmap selector: #replicateWidth enable: #hasMultipleSelections owner: geometryManager;
        add: WBReplicateHeightSysBitmap selector: #replicateHeight enable: #hasMultipleSelections owner: geometryManager;
        add: WBAlignLeftSysBitmap selector: #alignLeft enable: #hasMultipleSelections owner: geometryManager spaces: 4;
        add: WBAlignCenterHorizontalSysBitmap selector: #alignCenterHorizontally enable: #hasMultipleSelections owner: geometryManager;
        add: WBAlignRightSysBitmap selector: #alignRight enable: #hasMultipleSelections owner: geometryManager;
        add: WBAlignTopSysBitmap selector: #alignTop enable: #hasMultipleSelections owner: geometryManager spaces: 2;
        add: WBAlignCenterVerticalSysBitmap selector: #alignCenterVertically enable: #hasMultipleSelections owner: geometryManager;
        add: WBAlignBottomSysBitmap selector: #alignBottom enable: #hasMultipleSelections owner: geometryManager;
        add: WBAlignDistributeVerticalSysBitmap selector: #distributeVertically enable: #has3orMoreSelections owner: geometryManager spaces: 2;
        add: WBAlignDistributeHorizontalSysBitmap selector: #distributeHorizontally enable: #has3orMoreSelections owner: geometryManager;
        add: WBSetDrawGridSysBitmap selector: #menuOptionsDrawGrid spaces: 4 rbSelector: #popupGridSize:.
	mainView addSubpane: toolBar.
	
	groups "WBToolPalette"
		owner: self;
		setName: 'groups';
		when: #gettingFocus send: #resetFocus to: self;
		when: #selecting: send: #newWidgetType: to: self;
		when: #showHelp: send: #setStatusForToolBar: to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 1 * xDU;
				topRatio: 0; topInset: 15 * yDU;
				rightRatio: 0; rightInset: -16 * xDU;
				bottomRatio: 1; bottomInset: 55/2 * yDU);
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: groups.
	
	entries "WBMultiToolPalette"
		owner: self;
		setName: 'entries';
		when: #clicked: send: #addWidget: to: self;
		when: #doubleClick: send: #addWidgetCentered: to: self;
		when: #selecting: send: #setStatusForToolBarWidget: to: self;
		when: #showHelp: send: #setStatusForToolBarWidget: to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 16 * xDU;
				topRatio: 0; topInset: 15 * yDU;
				rightRatio: 0; rightInset: -31 * xDU;
				bottomRatio: 1; bottomInset: 55/2 * yDU);
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: entries.
	
	attributeBar "WBToolBar"
		owner: self;
		setName: 'attributeBar';
		when: #showHelp: send: #setStatusForToolBar: to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -152 * xDU;
				topRatio: 1; topInset: -101/2 * yDU;
				rightRatio: 1; rightInset: 78 * xDU;
				bottomRatio: 1; bottomInset: 79/2 * yDU);
		postAutomatic;
		backColor: Color gray;
		noTabStop;
		font: SysFont;
		useSystem: true;
        add: WBSetFontSysBitmap selector: #setFont enable: #selectionsHaveFontAttributes;
        add: WBSetColorSysBitmap selector: #setColor enable: #selectionsHaveColorAttributes;
        add: WBSetFramingSysBitmap selector: #setFraming enable: #hasSelections;
        add: WBSetMenuSysBitmap selector: #setMenu;
        add: WBPartsButtonSysBitmap selector: #setParts;
        add: WBOtherSysBitmap selector: #setOther.
	mainView addSubpane: attributeBar.
	
	sizeButton "DrawnButton"
		owner: self;
		setName: 'sizeButton';
		when: #clicked send: #menuSizeSetWidgetSize to: self;
		stretchToFit;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -39 * xDU;
				topRatio: 1; topInset: -99/2 * yDU;
				rightRatio: 1; rightInset: 31 * xDU;
				bottomRatio: 1; bottomInset: 83/2 * yDU);
		noTabStop;
		font: SysFont.
	mainView addSubpane: sizeButton.
	
	positionButton "DrawnButton"
		owner: self;
		setName: 'positionButton';
		when: #clicked send: #menuSizeSetWidgetPosition to: self;
		stretchToFit;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -77 * xDU;
				topRatio: 1; topInset: -99/2 * yDU;
				rightRatio: 1; rightInset: 69 * xDU;
				bottomRatio: 1; bottomInset: 83/2 * yDU);
		noTabStop;
		font: SysFont.
	mainView addSubpane: positionButton.
	
	instVar "CheckBox"
		owner: self;
		setName: 'instVar';
		when: #clicked: send: #setPaneNameIsInstVar: to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -303/2 * xDU;
				topRatio: 1; topInset: -47/2 * yDU;
				rightRatio: 1; rightInset: 283/2 * xDU;
				bottomRatio: 1; bottomInset: 27/2 * yDU);
		contents: '';
		noTabStop;
		font: SysFont.
	mainView addSubpane: instVar.
	
	styleButton "Button"
		owner: self;
		setName: 'styleButton';
		when: #clicked send: #openStyleDialog to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -303/2 * xDU;
				topRatio: 1; topInset: -75/2 * yDU;
				rightRatio: 1; rightInset: 139 * xDU;
				bottomRatio: 1; bottomInset: 53/2 * yDU);
		contents: '...';
		noTabStop;
		font: SysFont.
	mainView addSubpane: styleButton.
	
	staticBox1
		owner: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 31 * xDU;
				topRatio: 0; topInset: 13 * yDU;
				rightRatio: 0; rightInset: -63/2 * xDU;
				bottomRatio: 1; bottomInset: 19/2 * yDU);
		blackFrame;
		backColor: Color gray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: staticBox1.
	
	staticBox2
		owner: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 1; topInset: -19/2 * yDU;
				rightRatio: 1; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 9 * yDU);
		blackFrame;
		backColor: Color gray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: staticBox2.
	
	staticBox3
		owner: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 13 * yDU;
				rightRatio: 0; rightInset: -31 * xDU;
				bottomRatio: 0; bottomInset: -27/2 * yDU);
		blackFrame;
		backColor: Color gray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: staticBox3.
	
	nameText "StaticText"
		owner: self;
		setName: 'nameText';
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 32 * xDU;
				topRatio: 1; topInset: -47/2 * yDU;
				rightRatio: 0; rightInset: -54 * xDU;
				bottomRatio: 1; bottomInset: 31/2 * yDU);
		rightJustified;
		contents: 'Name:';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: nameText.
	
	titleText "StaticText"
		owner: self;
		setName: 'titleText';
		framingBlock: (
			LayoutFrame new
				leftRatio: 0; leftInset: 34 * xDU;
				topRatio: 1; topInset: -97/2 * yDU;
				rightRatio: 0; rightInset: -54 * xDU;
				bottomRatio: 1; bottomInset: 81/2 * yDU);
		rightJustified;
		contents: 'Text:';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: titleText.
	
	performText "StaticText"
		owner: self;
		setName: 'performText';
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -136 * xDU;
				topRatio: 1; topInset: -45/2 * yDU;
				rightRatio: 1; rightInset: 108 * xDU;
				bottomRatio: 1; bottomInset: 29/2 * yDU);
		rightJustified;
		contents: 'Perform:';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: performText.
	
	whenText "StaticText"
		owner: self;
		setName: 'whenText';
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -136 * xDU;
				topRatio: 1; topInset: -71/2 * yDU;
				rightRatio: 1; rightInset: 108 * xDU;
				bottomRatio: 1; bottomInset: 55/2 * yDU);
		rightJustified;
		contents: 'When:';
		backColor: Color gray;
		noTabStop;
		font: SysFont.
	mainView addSubpane: whenText.
	
	staticBox4
		owner: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -78 * xDU;
				topRatio: 1; topInset: -101/2 * yDU;
				rightRatio: 1; rightInset: 41 * xDU;
				bottomRatio: 1; bottomInset: 79/2 * yDU);
		blackFrame;
		noTabStop;
		font: SysFont.
	mainView addSubpane: staticBox4.
	
	staticBox5
		owner: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -40 * xDU;
				topRatio: 1; topInset: -101/2 * yDU;
				rightRatio: 1; rightInset: 3 * xDU;
				bottomRatio: 1; bottomInset: 79/2 * yDU);
		blackFrame;
		noTabStop;
		font: SysFont.
	mainView addSubpane: staticBox5.
	
	eventManagerButton "Button"
		owner: self;
		setName: 'eventManagerButton';
		addClipsiblingsStyle;
		when: #clicked send: #setEvents to: self;
		framingBlock: (
			LayoutFrame new
				leftRatio: 1; leftInset: -16 * xDU;
				topRatio: 1; topInset: -49/2 * yDU;
				rightRatio: 1; rightInset: 7/2 * xDU;
				bottomRatio: 1; bottomInset: 27/2 * yDU);
		contents: '...';
		noTabStop;
		font: SysFont.
	mainView addSubpane: eventManagerButton! !

!WBLookPolicy methods !  
draw3DBoxWith: aPen at: aRect

    ^self
        draw3DBoxWith: aPen
        at: aRect
        color: Color black! !

!WindowBuilder methods ! 
declareMethod: aMethodName commentString: anArrayOrString

	| methodStream resultString def annotationManager |
	methodStream := ReadWriteStream on: String new.
	anArrayOrString isString
		ifTrue: [
			methodStream
				nextPutAll: (self methodHeaderFor: aMethodName);
				cr; cr; nextPutAll: '    "' , anArrayOrString]
		ifFalse: [
			methodStream
				nextPutAll:
					(self
						methodHeaderFor: aMethodName
						in: (anArrayOrString at: 1)
						event: (anArrayOrString at: 2));
				cr; cr; nextPutAll: '    "' , (anArrayOrString at: 3)].
	methodStream
		cr; nextPutAll: '     (Generated by WindowBuilder)"'.
	resultString := methodStream contents.
	"Consolidate all code creation"
	self inENVY
		ifTrue: [
			^self editedClass
					compile: resultString
					notifying: nil
					ifNewAddTo: self editedClass controller].
	def := self class
		createMethod: resultString
		in: self editedClass
		loggingSource: true.
	self inTeamV
		ifTrue: [
			def isNil
				ifTrue: [^MessageBox message: 'There has been a serious source code generation error. See the Transcript for details'].
			annotationManager := Smalltalk at: #AnnotationManager.
			(aMethodName includes: $:)
				ifTrue: [def annotationNamed: annotationManager categoriesLabel put: 'event handlers']
				ifFalse: [def annotationNamed: annotationManager categoriesLabel put: 'menu handlers'].
			def annotationNamed: annotationManager versionLabel put: 'Generated by WindowBuilder Pro'].
	! !

!WBHandle methods !  
center
        ^self displayBox center! !

!WBLayoutForm methods ! 
releaseState: aSelector
    "Set the value of releaseState."

    releaseState := aSelector! !

!Object methods !
isWBAction
    "Private - WindowBuilder Pro Development"

    #addedByOSI.
	self obsoleteMethod.
    ^false! !

!WBWindowEditor methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel mainView mainViewChild maximizeBox minimizeBox ok 
	setIcon sizingFrame systemMenu titleBar xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	mainViewChild := CheckBox new.
	maximizeBox := CheckBox new.
	minimizeBox := CheckBox new.
	ok := Button new.
	setIcon := Button new.
	sizingFrame := CheckBox new.
	systemMenu := CheckBox new.
	titleBar := CheckBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Window Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -71 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -32 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -71 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -32 * yDU).
	self addView: mainView.
	
	systemMenu "CheckBox"
		owner: self;
		setName: 'systemMenu';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 6 * yDU;
				rightRatio: 0; rightInset: -137/2 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		contents: '&System menu';
		startGroup;
		font: SysFont.
	mainView
		addSubpane: systemMenu;
		subPaneWithFocus: systemMenu.
	
	minimizeBox "CheckBox"
		owner: self;
		setName: 'minimizeBox';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 18 * yDU;
				rightRatio: 0; rightInset: -139/2 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		contents: 'Mi&nimize box';
		startGroup;
		font: SysFont.
	mainView addSubpane: minimizeBox.
	
	maximizeBox "CheckBox"
		owner: self;
		setName: 'maximizeBox';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 30 * yDU;
				rightRatio: 0; rightInset: -72 * xDU;
				bottomRatio: 0; bottomInset: -40 * yDU);
		contents: 'Ma&ximize box';
		startGroup;
		font: SysFont.
	mainView addSubpane: maximizeBox.
	
	titleBar "CheckBox"
		owner: self;
		setName: 'titleBar';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 78 * xDU;
				topRatio: 0; topInset: 6 * yDU;
				rightRatio: 0; rightInset: -127 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		contents: '&Title bar';
		startGroup;
		font: SysFont.
	mainView addSubpane: titleBar.
	
	sizingFrame "CheckBox"
		owner: self;
		setName: 'sizingFrame';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 78 * xDU;
				topRatio: 0; topInset: 18 * yDU;
				rightRatio: 0; rightInset: -136 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		contents: 'Sizing &frame';
		startGroup;
		font: SysFont.
	mainView addSubpane: sizingFrame.
	
	setIcon "Button"
		owner: self;
		setName: 'setIcon';
		when: #clicked send: #setIcon to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 96 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -138 * xDU;
				bottomRatio: 0; bottomInset: -60 * yDU);
		contents: 'Set &Icon...';
		startGroup;
		font: SysFont.
	mainView addSubpane: setIcon.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -40 * xDU;
				bottomRatio: 0; bottomInset: -60 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 44 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -80 * xDU;
				bottomRatio: 0; bottomInset: -60 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	mainViewChild "CheckBox"
		owner: self;
		setName: 'mainViewChild';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 78 * xDU;
				topRatio: 0; topInset: 30 * yDU;
				rightRatio: 0; rightInset: -138 * xDU;
				bottomRatio: 0; bottomInset: -40 * yDU);
		contents: '&MainView Child';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: mainViewChild! !

!ButtonEditor class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBLookPolicyOS2 methods !   
drawTitleBarText: aFrameObject with: aPen in: aRect

    | titleRect |
    titleRect := aRect leftTop extentFromLeftTop: aRect width @ (self titleBarHeightFrom: aFrameObject).
    aFrameObject hasTitleBar
        ifTrue: [
            aPen
                fill: titleRect color: Color activeTitleBar;
                font: aFrameObject font;
                setTextAlign: WBDisplayContext defaultTextAlign;
                foreColor: Color titleBarText;
                setBackgroundModeTransparent;
                winDrawText: aFrameObject contents in: (titleRect insetBy: 1) format: self titleJustification;
                setBackgroundModeOpaque].! !

!Bitmap methods ! 
wbScale: newExtent
    "Answer a new bitmap containing the contents of the receiver."

    | newBitmap |
    #addedByOSI.
    newBitmap := WBBitmapClass
        width: newExtent x
        height: newExtent y
        planes: self planes
        bitCount: self bitCount.
    newBitmap pen
        copyBitmap: self
        from: self boundingBox
        to: newBitmap boundingBox.
    ^newBitmap! !

!WBLookPolicy methods !  
displayWithMinorBorder: aPen rect: aRect backColor: backColor

    ^self
        displayWithNoBorder: aPen
        rect: aRect
        backColor: backColor! !

!PStaticBox class methods !
exampleFrom: aClassName

	| example |
	example := super exampleFrom: aClassName.
	example 
		style: #grayRectangle;
		font: example defaultFont;
		extent: example suggestedSize.
	^example! !

!WBListEntryField methods ! 
keyboardInput: aKeyboardInputEvent
		"Private - Process the character input message."
	| virtualKey defaultPushButton |

	"The defaultPushButton is triggered elsewhere in OS/2."
	OperatingSystem isOS2 ifFalse: [
		( aKeyboardInputEvent character = Cr
		and: [ ( defaultPushButton := self mainWindow defaultPushButton ) notNil
		] ) ifTrue: [ ^defaultPushButton click ]].

	((virtualKey := aKeyboardInputEvent virtualKey) = UpKey)
		| (virtualKey = DownKey)
		| (virtualKey = LeftKey)
		| (virtualKey = RightKey)
		| (virtualKey = ReturnKey)
			ifTrue: [
				owningListBox keyboardInput: aKeyboardInputEvent ]
			ifFalse: [
				super keyboardInput: aKeyboardInputEvent ].
! !

!WindowBuilder class methods !   
installAddInModules: aMenuCollection

    self addInModuleClass modulesModifyingMenus do: [:module |
        module modifyMenus: aMenuCollection].
    self addInModuleClass modulesModifyingPalette do: [:module |
        module modifyPalette: aMenuCollection].! !

!WindowBuilder class methods ! 
runtimeLessCode

    ^self editorClass
        propertyValueAt: #RuntimeLessCode
        category: self codeGenerationPropertyString! !

!WBTabOrderLayoutForm methods !
button1DownShift: aPoint
	"Do Nothing"! !

!WBMenuItem methods !   
enableSelector
        "Answer the enable selector of the menu item."
    ^enableSelector! !

!WBEventManagerWindow methods ! 
widgetListDrawItem: drawIndex pane: aPane
	"Callback for the #drawItem: event in widgetListBox [MultipleSelectListBox]
	(Generated by WindowBuilder Pro)"

	| anObject hasEvents box aWBDisplayContext |
	anObject := aPane contents at: drawIndex.
	hasEvents := anObject eventTable notEmpty.
	aWBDisplayContext := aPane wbDisplayContext.
	aWBDisplayContext cellBorder: #displayNoBorder.
	box := aWBDisplayContext splitCellLeftInset: (aPane font stringWidth: '* ').
	(hasEvents ifTrue: ['*'] ifFalse: ['']) wbDisplayWith: aWBDisplayContext.
	aWBDisplayContext cellBox: box.
	anObject wbNameAndClass wbDisplayWith: aWBDisplayContext.! !

!PScrollBar methods !   
copySpecificsTo: aPane

    aPane
        minimum: self minimum;
        maximum: self maximum;
        lineIncrement: self lineIncrement;
        pageIncrement: self pageIncrement.! !

!PStaticBox methods !   
mutationTypes

    ^#(#GroupBox #CP3DFrame #StaticBox)! !

!WBLayoutForm methods !
setShellHandlesFor: aShell

    self shellHandles: (OrderedCollection
        with: (WBHandle on: aShell at: #wbBottomRightOffset)).
    ^self shellHandles.! !

!WindowBuilder methods !   
hasSelections

    ^self selections notEmpty! !

!WBBitmapManagerWindow methods ! 
menuKeyFileOutBDTFile

	| keysAndPools aCategory path |
	(keysAndPools := self selectedKeysAndPools) isEmpty ifTrue: [^self].
	aCategory := self selectedCategoryOrPrompt: 'File out which category'.
	path := FileDialog new
		saveTitle: 'Save BDT file...' fileName: '*.bdt';
		file.
	path isNil ifTrue: [^self].
	path := path asLowercase.
	self
		writeBDTFile: path
		for: keysAndPools
		category: aCategory.! !

!WBLayoutForm methods ! 
releaseState
    "Answer the value of releaseState."

    ^releaseState! !

!WBChooseClassDialog methods !   
classList: listOfClasses default: dClass

    classList := listOfClasses.

    default := dClass.

    self open.! !

!WindowBuilder methods !
menuToolsToggleDirty

    self dirty: self dirty not.! !

!WBLookPolicy class methods !   
default: aWBLookPolicy

    Default := aWBLookPolicy! !

!WindowBuilder methods ! 
menuToolsBrowseServices

    SmalltalkToolInterface current serviceManagerWindowClass open! !

!WindowBuilder methods !   
menuNlsActiveCategory: aCategory

	WBNLSManager current activeCategory: aCategory.
	self prototype shell update.
	self layoutForm display.! !

!WindowBuilder methods ! 
dumpErrorToTranscript: exception

	| errorStream |
	errorStream := ReadWriteStream on: (String new: 800).
	Process copyStack walkbackOn: errorStream maxLevels: 20.
	errorStream reset.
	10 timesRepeat: [errorStream nextLine].
	Transcript
		cr; cr;
		show: '*** Start Error: [' , exception description , '] ***';
		show: (errorStream copyFrom: errorStream position to: (errorStream indexOf: '[] in WindowBuilder') - 1);
		show: '*** End Error ***'.
	! !

!WBFontPool methods !  
fileOutFooterOn: aStream
	"File out the receiver's footer."

	aStream
		endExpression;
		indentBy: -1;
		nextPut: $!!.! !

!PGraphPane methods !  
removeEvents

    ^#().! !

!WindowBuilder class methods !
paneNamesAsSymbols

	^false! !

!WBLayoutForm methods !   
colorBlack

    ^Color black! !

!Object methods !
wbDuplicateTo: anObject
	"Answer a duplicate of the receiver."

	#addedByOSI.
	^self wbCopyTo: anObject! !

!WBFramingEditor methods !  
cornerXStyleChanged: styleRadio

    (styleRadio contents = 'Scaled') & (styleRadio selection)
        ifTrue:
            [cornerXAnchor selection: 'Window left'.
            cornerXAnchor disable.
            rightRelative disable.
            ]
        ifFalse:
            [rightRelative enable.
            cornerXAnchor enable.
            ].
    self setExampleRects.! !

!WBTreeNode methods !
hasChildren

    ^children notEmpty! !

!WBPrimaryModelModule methods !   
defaultCategory
        "Answer the default category for the receiver."
    ^'primary model'! !

!WBLookPolicy methods !  
drawVerticalScrollBar: aScrollBar with: aPen clipRect: clipRect

    self drawVScrollBarWith: aPen at: aScrollBar rect.! !

!WBScrapbookRetrieve methods !
chapter
    ^chapter! !

!WBCallOutEditor methods !
callOutSelected: selectedItem

    "Callback for the #clicked: event triggered in the ListBox named 'callOutList'.
     (Generated by WindowBuilder)"

    selector contents: (callOutMap at: selectedItem)! !

!WindowFrameObject methods !   
createdBy: aString

    createdBy := aString! !

!WindowBuilder methods ! 
codeModuleClasses
	"Private - Answer the code module classes."

	^self 
		propertyAt: #CodeModuleClasses 
		ifAbsent: [self defaultCodeModuleClasses]! !

!WBCodeGenerator methods !   
propertyAt: key put: aValue
        "Set the value associated with key
        in the properties dictionary."
    properties isNil ifTrue: [ properties := IdentityDictionary new ].
    aValue isNil ifTrue: [ ^properties removeKey: key ifAbsent: [ ] ].
    ^properties at: key put: aValue! !

!WBPoolEditorCompositePane methods !   
addSubpanes

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| staticText1 xDU yDU |
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	
		"Temporary Variables"
	staticText1 := StaticText new.
	
	self
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -101/2 * xDU;
				topRatio: 1/2; topInset: -51/2 * yDU;
				rightRatio: 1/2; rightInset: -101/2 * xDU;
				bottomRatio: 1/2; bottomInset: -51/2 * yDU);
		backColor: Color gray.
	
	staticText1
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 9/2 * xDU;
				topRatio: 0; topInset: 5 * yDU;
				rightRatio: 0; rightInset: -76 * xDU;
				bottomRatio: 0; bottomInset: -13 * yDU);
		contents: 'Pool Manager Editor';
		startGroup;
		noTabStop;
		font: SysFont.
	self addSubpane: staticText1! !

!WBAttributeWindow methods !  
closed
		"The receiver's main view has been closed."
	self owner removeAllActionsWithReceiver: self.! !

!WBCreateClassDialog class methods ! 
defaultSuperClassFor: aType
put: aClassSymbol

    self defaultSuperClass at: aType put: aClassSymbol! !

!WBBitmapEditorCompositePane methods ! 
isSameValueForAllCategories
	"Answer true if the value is the same for the selected key for all categories."

	| first keyAndPool value matchValue categories |
	first := true.
	keyAndPool := self selectedKeyAndPool ifNil: [^false].
	categories := self owner allCategories.
	categories size < 2 ifTrue: [^self owner sameValueForAllCategories].
	categories do: [:each |
		value := keyAndPool value at: keyAndPool key in: each ifAbsent: [nil].
		first
			ifTrue: [
				matchValue := value.
				first := false]
			ifFalse: [
				matchValue == value ifFalse: [^false]]].
	^true! !

!WBLayoutWizard methods !  
generateWidgetsFor: attributes

	| newWidgets shell widgetClass newWidget labelWidget onLeft buttons farRight
	 maxLabelWidth maxTargetWidth offset point labelledWidgets down labelTarget defaultWizardEvent |
	newWidgets := OrderedCollection new.
	labelledWidgets := OrderedCollection new.
	buttons := OrderedCollection new.
	shell := self shell.
	maxLabelWidth := maxTargetWidth := 0.
	offset := self offset.
	attributes do: [:attribute |
		widgetClass := Smalltalk at: (attribute propertyAt: #widgetType).
		newWidget := widgetClass wbPseudoClass exampleFrom: widgetClass symbol.
		newWidget
			paneName: attribute name;
			parent: shell;
			isInstVar: (attribute propertyAt: #instVar) == true;
			initializeForDataType: attribute valueClass;
			extent: newWidget preferredExtent.
		(attribute propertyAt: #modelUpdatesWidget) == true
			ifTrue: [
				self primaryModel
					when: attribute eventName asSymbol
					send: #setValue:
					to: newWidget].
		(attribute propertyAt: #modelInitializesWidget) == true
			ifTrue: [
				newWidget
					when: #needsContents
					send: attribute methodNameForTriggeredEvent asSymbol
					to: self primaryModel].
		(attribute propertyAt: #widgetUpdatesModel) == true
			ifTrue: [
				(defaultWizardEvent := newWidget defaultWizardEvent) notNil
					ifTrue: [
						newWidget
							when: defaultWizardEvent
							send: attribute methodNameForSet asSymbol
							to: self primaryModel]].
		newWidget preferredLabelOrientation notNil
			ifTrue: [
				onLeft := newWidget preferredLabelOrientation == #left.
				labelWidget := PStaticText exampleFrom: #StaticText.
				labelWidget
					paneName: attribute name, 'Label';
					contents: attribute name asProperNoun, (onLeft ifTrue: [':'] ifFalse: ['']);
					parent: shell;
					style: (onLeft ifTrue: [self class labelJustification] ifFalse: [#leftJustified]);
					propertyAt: #labelTarget put: newWidget;
					propertyAt: #onLeft put: onLeft;
					extent: labelWidget preferredExtent.
				onLeft
					ifTrue: [
						labelledWidgets add: newWidget.
						maxLabelWidth := maxLabelWidth max: labelWidget width]
					ifFalse: [maxTargetWidth := maxTargetWidth max: newWidget width].
				newWidgets add: labelWidget]
			ifFalse: [
				newWidget usesTitle
					ifTrue: [
						newWidget
							text: attribute name asProperNoun;
							extent: newWidget preferredExtent]].
		newWidgets add: newWidget].
	maxLabelWidth := (maxLabelWidth roundTo: offset x).
	maxTargetWidth := (maxTargetWidth roundTo: offset x) + offset x + maxLabelWidth.
	newWidgets do: [:widget |
		(widget propertyAt: #onLeft) == true
			ifTrue: [widget extent: maxLabelWidth @ widget height]].
	point := self shell contentLeftTop rightAndDown: offset x @ offset y.
	(newWidgets reject: [:widget | labelledWidgets includes: widget]) do: [:widget |
		labelTarget := widget propertyAt: #labelTarget.
		widget
			moveWidgetPrim: point x
			y: (labelTarget isNil
				ifTrue: [point y]
				ifFalse: [point y down: offset y]).
		down := widget height.
		(widget propertyAt: #onLeft) == true
			ifTrue: [
				labelTarget
					moveWidgetPrim: (widget topRight x right: offset x)
					y: point y.
				down := down max: (widget propertyAt: #labelTarget) hitRect height]
			ifFalse: [
				widget extent: (maxTargetWidth max: widget width) @ widget height].
		point := point down: down + offset y].
	maxLabelWidth := 0.
	self buttonsToGenerate do: [:buttonLabel |
		newWidget := PButton exampleFrom: #Button.
		newWidget
			paneName: buttonLabel asLowercase asInstVarToken, 'Button';
			contents: buttonLabel;
			parent: shell;
			extent: newWidget preferredExtent;
			when: #clicked send: buttonLabel asLowercase asInstVarToken asSymbol to: self targetObject.
		maxLabelWidth := maxLabelWidth max: newWidget width.
		buttons add: newWidget].
	self owner useGrid
		ifTrue: [maxLabelWidth := maxLabelWidth roundTo: self owner gridSize x].
	buttons do: [:widget |
		widget
			extent: maxLabelWidth @ widget height;
			moveWidgetPrim: point x y: point y.
		point := point right: widget width + offset x].
	farRight := (buttons isEmpty
		ifTrue: [0] ifFalse: [buttons last rect right]).
	newWidgets do: [:widget |
		(widget propertyAt: #onLeft) == true
			ifFalse: [
				(widget rect right isLeftOf: farRight)
					ifTrue: [widget rect right: farRight]]].
	newWidgets addAll: buttons.
	shell children addAll: newWidgets.
	^newWidgets! !

!WBTabOrderEditor methods !   
groupsMenu

    ^self menuTitled: 'Groups'! !

!WBInterfaceObject methods !   
paneName

    ^self wbRealWidget paneName! !

!WBAddInManager methods !   
select: selectedItem

	(selectedItem beginsWith: '*')
		ifTrue: [
			(self paneNamed: 'install') disable.
			(self paneNamed: 'remove') enable.
			selection := selectedItem copyFrom: 2 to: selectedItem size	]
		ifFalse: [
			(self paneNamed: 'install') enable.
			(self paneNamed: 'remove') disable.
			selection := selectedItem].
	(self paneNamed: 'help') contents: self getHelpText.! !

!WBDefaultScratchWindow methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| mainView xDU yDU |
	
	#generated.
	xDU := (WindowDialog dialogUnit x / WindowDialog unitMultiplier x * 2) ceiling / 2.
	yDU := WindowDialog dialogUnit y / WindowDialog unitMultiplier y.
	mainView := self topPaneClass new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'New Window';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
        (LayoutFrame new
            leftRatio: 1/2; leftInset: -75 * xDU;
            topRatio: 1/2; topInset: -109/2 * yDU;
            rightRatio: 1/2; rightInset: -75 * xDU;
            bottomRatio: 1/2; bottomInset: -91/2 * yDU).
	self addView: mainView! !

!ViewManager class methods !  
wbReservedInstVarNames
		"Answer a collection of reserved inst var names."
	^ViewManager allInstVarNames! !

!PRadioButtonGroup methods ! 
text: aString

    ^self label: aString! !

!WBUndoManager methods !  
undoRedoList

    WBUndoRedoDialog new openOn: self! !

!WBLayoutFrameEditor methods !
setTopAttach: aString

    | ratio |
    aString = self proportional ifTrue: [
        ^self currentFramingBlocks do: [:each |
            each wbTopProportional: true]].
    ratio := self class verticalRatioStrings keyAtValue: aString ifAbsent: [
        aString isNumber
            ifTrue: [ratio := aString asRational]
            ifFalse: [ratio := ((self compilerEvaluate: aString) ifNil: [^self]) asRational]].
    self currentFramingBlocks do: [:each |
        each wbTopProportional: false.
        each topRatio: ratio].! !

!WBTreeListBox methods ! 
previousSelection

    ^previousSelection! !

!PRadioButtonGroup methods !
backColor: aColor

	super backColor: aColor.
	aColor = self defaultForeColor
		ifTrue: [self children do: [:child | child foreColor: child defaultForeColor]]
		ifFalse: [self children do: [:child | child backColor: aColor]].! !

!WBPoolManagerWindow methods !
keyListDrawItem: drawIndex pane: aPane

	"Callback for the #drawItem: event triggered in the MultipleSelectListBox named 'keyListBox'.
	 (Generated by WindowBuilder)"

	| aKeyAndPool aString |
	aKeyAndPool := self keysAndPools at: drawIndex.
	aString := self
		valueStringAt: aKeyAndPool key
		in: self selectedCategory
		pool: aKeyAndPool value.
	self
		keyListDraw: aKeyAndPool key
		value: aString
		pane: aPane.! !

!WBEditClassDialog class methods !
clearRecentClasses

    RecentClasses := nil! !

!WBLayoutWizard methods !
setWidgetUpdatesModel: aBoolean

    attributesList selectedItem object
        propertyAt: #widgetUpdatesModel
        put: aBoolean! !

!PropertyAccessor methods !   
wbCopyFrom: anObject to: copyObject using: aPropertyManager
	"Copy the property."

	#addedByOSI.
	(aPropertyManager getAccessor: self name ifAbsent: [^self])
		setValue: (self getValueFor: anObject)
		for: copyObject.
	^copyObject! !

!WBLookPolicyOS2 methods !
drawButton: aButton with: aPen clipRect: clipRect

    | region bottom right innerRect clip |
    innerRect := aButton rect.
    bottom := innerRect bottom up: 1.
    right := innerRect right left: 1.
    aButton style == #defaultPushButton
        ifTrue: [
            aPen
                foreColor: Color black;
                wbLineFrom: innerRect left @ (innerRect top down: 1) to: innerRect left @ bottom;
                wbLineFrom: right @ (innerRect top down: 1) to: right @ bottom;
                wbLineFrom: (innerRect left right: 1) @ innerRect top to: right @ innerRect top;
                wbLineFrom: (innerRect left right: 1) @ bottom to: right @ bottom.
            innerRect := innerRect insetBy: 1.
            aPen fill: innerRect color: Color darkGray.
            bottom := innerRect bottom up: 1.
            right := innerRect right left: 1].
    aPen
        foreColor: Color darkGray;
        wbLineFrom: innerRect left @ (innerRect top down: 1) to: innerRect left @ bottom;
        wbLineFrom: right @ (innerRect top down: 1) to: right @ bottom;
        wbLineFrom: (innerRect left right: 1) @ innerRect top to: right @ innerRect top;
        wbLineFrom: (innerRect left right: 1) @ bottom to: right @ bottom;
        fill: (innerRect insetBy: 1) color: Color white;
        wbLineFrom: (innerRect left right: 1) @ (bottom up: 1) to: right @ (bottom up: 1);
        wbLineFrom: (right left: 1) @ (innerRect top down: 1) to: (right left: 1) @ bottom;
        fill: (innerRect insetBy: 2) color: aButton defaultBackColor.
    clip := ((innerRect insetBy: 3) intersect: clipRect).
    (clip left isRightOf: clip right) | (clip top isBelow: clip bottom)
        ifFalse: [
            region := aPen setClipRect: clip.
            aPen
                setBackgroundModeTransparent;
                foreColor: aButton foreColor;
                font: aButton font;
                setTextAlign: WBDisplayContext defaultTextAlign;
                centerWinText: aButton contents at: innerRect center;
                setBackgroundModeOpaque;
                destroyRegion: region].! !

!WindowBuilder methods !   
commentForEvent: aWidget event: eventSymbol selector: selectorSymbol

	^'Callback for the #' , eventSymbol asString , 
		' event triggered in ' , (self statusDescriptionFor: aWidget) , '.'.! !

!WBEditClassDialog class methods ! 
nonWBChoice

    ^'<Non WB>'! !

!WBCodeModule methods !  
initCodeGeneration
		"Private - Initialize before code generation."
	super initCodeGeneration.
	self initVarNames.
	self initTemporaries.! !

!WindowBuilder methods !  
menuSizeSetWidgetSize
    "Prompt the user for a new widget size"

    | answer |
    self hasSelections ifFalse: [^self menuSizeSetWindowSize].
    (answer := self
        getPointPrompting: 'New Widget Size:'
        defaultPoint: self selections first extent) ifNil: [^nil].
    self geometryManager resizeSelectedWidgets: answer.! !

!WBDevelopmentDialog class methods !  
wbBasicVersion

    ^2.0! !

!WBPMenuItem methods !   
asMenu

    | theMenu |

    theMenu := Menu new.
    theMenu title: self fullTitle.

    children do: [ :c |
        c appendTo: theMenu.
    ].

    ^theMenu! !

!WBListEditor methods !  
insert

	item contents isEmpty ifTrue: [^self].
	listBox selection isNil
		ifTrue: [list add: item contents beforeIndex: 1]
		ifFalse: [list add: item contents beforeIndex: listBox selection].
	listBox 
		contents: list;
		selectItem: item contents.
	item selectAll; setFocus.
	self enable! !

!WBCodeModule methods ! 
varOrGlobalNameFor: anObject ifAbsent: aBlock
        "Answer the variable name (temporary variable or instance variable)
            for the specified object."
    ^self varNameFor: anObject ifAbsent: [
		Smalltalk associationsDo: [:each |
			each value == anObject ifTrue: [^each key]].
		^aBlock value].! !

!WBTreeNode methods !  
lastChild

    children isEmpty ifTrue: [ ^nil ].

    ^children last! !

!PListBox methods !   
preferredLabelOrientation

    ^#top! !

!WindowBuilder class methods !   
basicVersionNumber
        "Private - Answer the window builder version."
    ^3.1! !

!WBInterfaceObject methods !   
contentsStringExtent
	"Answer the string extent of the receiver's contents.
		If NLS-Autosize is enabled, then answer the maximum
		string extent of all NLS strings for that key."

	| manager |
	(manager := self contentsValueManager) notNil 
		ifTrue: [
			manager class == WBManagedPNLSString
				ifTrue: [^manager extentFor: self font]].
	^self font wbStringExtent: self contents! !

!PropertyAccessor methods ! 
wbFullCopy: aDictionary from: anObject to: copyObject
	"Perform a full copy on the property."

	#addedByOSI.
	self
		setValue: ((self getValueFor: anObject) wbFullCopy: aDictionary)
		for: copyObject.! !

!WBCodeStream methods !  
nextPutVarOrGlobalNameFor: anObject
		"Append the var name for anObject to the stream."
	self nextPutAll: ( self owner varOrGlobalNameFor: anObject ).! !

!WBPoolManagerWindow methods ! 
promptForExistingFileName: titleString
	"Prompt the user for an existing file."

	^FileDialog new
		openFile: self defaultNewFileName;
		file! !

!WBFontSelectionWindow methods ! 
selectFont

	"Callback for the #clicked event in selectFontButton [Button].
		(Generated by WindowBuilder Pro)"

	| aFont findMatch |
	findMatch := Notifier isControlKeyDown not.
	(aFont := self promptForFont: self selectedFont) notNil ifTrue: [
		findMatch ifTrue: [aFont := self findEqualFont: aFont].
		self selectedFont == aFont ifFalse: [
			self selectedFont: aFont.
			self selectedPool: nil.
			(self paneNamed: 'poolList') selection: self selectedPool.
			(self paneNamed: 'fontList') update.
			self dirty: true]].! !

!WBBitmapSubPool methods !   
fileOutHeaderOn: aStream
	"File out the receiver's header."

	aStream
		nextPutAll: self managerClass tagCategory;
		nextPut: $ ;
		nextPutAll: self category;
		cr.
	self fileName notEmpty ifTrue: [
		aStream
			nextPutAll: self managerClass tagFileName;
			nextPut: $ ;
			nextPutAll: self fileName;
			cr].
	aStream
		nextPutAll: self managerClass tagBitmaps;
		cr.! !

!String methods !   
asInstVarToken
		"Answer the receiver as a inst var token."
	| answer |
	#addedByOSI.
	((answer := self asBasicToken) isEmpty
		or: [ answer first isLetter not ])
			ifTrue: [ answer := 'temp', answer ].
	answer first isUpperCase ifTrue: [
		answer :=
			(String with: answer first asLowerCase),
				(answer copyFrom: 2 to: answer size) ].
	^answer! !

!WBCreateViewModule methods !   
defaultView
		"Answer the reciever's default view."
	^self object windows first! !

!WindowBuilder class methods !
newDialogWindowBuilder

	self wbEditorClass preOpen.
	self wbEditorClass new openDialog.! !

!PButton methods !  
storeSpecificsOn: aStream indentString: indentString

    | string |
    (#(#defaultPushButton #cancelPushButton) includes: self style) ifTrue: [^self].
   self autoRecognizeOkCancel
        ifTrue: [
            string := self contents stripMnemonic asUpperCase.
            (string = 'OK' and: [(self otherButtonWithID: 1) isNil])
                ifTrue: [
                    aStream nextPutAll: ';'; cr; nextPutAll: indentString, #defaultPushButton]
                ifFalse: [
                    (string = 'CANCEL' and: [(self otherButtonWithID: 2) isNil])
                        ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, #cancelPushButton]]].! !

!WBInterfaceObject methods !
storeFramingBlockOn: aStream indentString: spaceString

	self isDialog
		ifTrue: [
			self framingBlock asFramingBlockForDialogSubPaneFromWindow
				storeForDialogSubPaneOn: aStream indentString: spaceString]
		ifFalse: [
			self framingBlock
				storeOn: aStream indentString: spaceString].! !

!WBCodePolicy methods ! 
removeKey: aKey inPoolNamed: aSymbol
    "Remove the specified key from a pool in the system."

    (Smalltalk at: aSymbol) removeKey: aKey ifAbsent: [ ].! !

!WBVersionCodeModule methods !
indentSuccessiveCommentLines

	^true! !

!WBLookPolicyOS2 methods !   
initialize

	super initialize.
	self class isDefault
		ifTrue: [
			pmWindowLibrary := Smalltalk at: #PMWindowLibrary ifAbsent: [nil].
			hwndDesktop := Smalltalk at: #HwndDesktop ifAbsent: [nil]].! !

!WBLayoutWizard methods !   
selectAttribute: selectedItem

    | attribute checkbox |
    self enableFields.
    attribute := selectedItem object.
    (self paneNamed: 'attributeClass') contents: attribute valueClass name.
    widgetType
        contents: (self widgetTypesFor: attribute);
        value: (attribute propertyAt: #widgetType).
    (self paneNamed: 'instVarButton') selection: (attribute propertyAt: #instVar).
    checkbox := self paneNamed: 'modelUpdatesWidgetButton'.
    attribute hasEvent
        ifTrue: [
            checkbox
                enable;
                selection: (attribute propertyAt: #modelUpdatesWidget)]
        ifFalse: [checkbox disable; selection: false].
    checkbox := self paneNamed: 'modelInitializesWidgetButton'.
    attribute hasEvent
        ifTrue: [
            checkbox
                enable;
                selection: (attribute propertyAt: #modelInitializesWidget)]
        ifFalse: [checkbox disable; selection: false].
    checkbox := self paneNamed: 'widgetUpdatesModelButton'.
    attribute hasAccessors
        ifTrue: [
            checkbox
                enable;
                selection: (attribute propertyAt: #widgetUpdatesModel)]
        ifFalse: [checkbox disable; selection: false].
    self updateUpDownButtons.! !

!WBTreeListBox methods !   
moveUp

    self selectedItem moveUp.
    owningEditBox setFocus.! !

!WBCodeGenerator methods ! 
policy
		"Answer the receiver's code policy."
	^policy ifNil: [ policy := self class policy new ]! !

!WindowBuilder class methods !  
cleanUpScratchClasses

    WBScratchWindow removeSelector: #createViews.
    WBDialogScratchWindow removeSelector: #createViews.
    WBScratchWindow removeSelector: #open.
    WBDialogScratchWindow removeSelector: #open.! !

!WBMenuItem methods ! 
updateEnabled
	"Update the receiver's enabled status"
	self hasSubmenu
		ifTrue: [^self submenu updateEnabled].
	self owner notNil & self enableSelector isSymbol
		ifTrue: [
			(self owner perform: self enableSelector)
				ifTrue: [self enable]
				ifFalse: [self disable]].! !

!PStatusPane methods !   
colorButtonText

    ^Color buttonText! !

!WBGraphicObject methods ! 
displayWithNoBorder: aPen

    ^self parent isDialog
        ifTrue: [
            self lookPolicy
                displayWithNoBorder: aPen
                rect: self rect
                backColor: self backColor]
        ifFalse: [
            self lookPolicy
                displayWithMinorBorder: aPen
                rect: self rect
                backColor: self backColor]! !

!WBListEditor methods !  
enable

    (self paneNamed: 'change') enable.
    (self paneNamed: 'delete') enable.! !

!WBPoolManagerWindow methods ! 
poolListDrawItem: drawIndex pane: aPane

    "Callback for the #drawItem: event triggered in the MultipleSelectListBox named 'poolListBox'.
     (Generated by WindowBuilder)"

	aPane defaultDrawItem: aPane ownerDrawStruct.! !

!WBPoolManagerWindow methods !  
activeCategoryFieldChanged: selectedItem

    "Callback for the #changed: event triggered in the WBComboBox named 'activeCategoryField'.
     (Generated by WindowBuilder)"

	self poolManager activeCategory: selectedItem.! !

!WBLayoutForm methods !   
displayWidget: widget clipRect: aRect

    | region clipRect |
    widget resetPen: self pen.
    region := self pen setClipRect: (clipRect := aRect intersect: widget rect).
    widget displayWith: self pen clipRect: clipRect.
    self pen destroyRegion: region.! !

!PToggle methods ! 
changesSize

    ^true! !

!WBFramingEditor methods ! 
cancel

    result := nil.
    self close! !

!WBENVYCodePolicy methods !
createMethod: methodSource in: aClass
    "Private - Compile a method source the context of aClass. The source of the compiled
    method is not stored in the library. The method just exists in the image."
    "Answer nil if the compilation results in an error."

    | aStream theCM |
    aStream := WriteStream on: (String new: 128).
    aStream nextPutAll: methodSource.
    theCM := aClass envyCompile: aStream contents notifying: nil ifFail: [^nil].
    theCM filePointer: nil.
    aClass addSelector: theCM selector withMethod: theCM.
    ^Association key: theCM selector value: theCM! !

!WBAbstractPrompter class methods !   
prompt: promptString title: titleString default: defaultObject
	"Prompt for an entry in a list."

	^self new
		createViews;
		default: defaultObject;
		prompt: promptString;
		title: titleString;
		open;
		result! !

!Bitmap methods ! 
wbInitButton: aBitmap
	"Private - WBPro Development.
		Create a new tool bar button bitmap template"

	self
		wbInitButton;
		wbButtonUp: aBitmap;
		wbButtonDown: aBitmap.! !

!PGroupbox methods ! 
isGroupBox

	^true! !

!WBPMenuItem methods ! 
allSelectors

    | allSelectors newSelectors |

    allSelectors := Dictionary new.
    selector isMessage ifTrue: [ ^allSelectors ].

    selector notNil ifTrue: [
        allSelectors at: selector put: self title.
    ].
    children notNil ifTrue: [
        children do: [ :m |
            newSelectors := m allSelectors.
            newSelectors keysDo: [ :k |
                allSelectors at: k put: (newSelectors at: k).
            ].
        ].
    ].

    ^allSelectors! !

!WBLayoutFrameEditor methods !   
attachProportionalLeftTop

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: (
		Array
			with: self proportional
			with: self proportional
			with: self paneLeft
			with: self paneTop).! !

!WindowFrameObject methods !
storeRectOn: aStream indentString: indentString

	| isCentered nRect pRect |
	framingBlock isFramingParameters
		ifTrue: [framingBlock clientRect: self contentRect]
		ifFalse: [
			isCentered :=
				(framingBlock leftRatio = (1/2))
				| ((framingBlock leftRatio = 0) & (framingBlock leftInset = 0)).
			isCentered ifTrue: [
				(framingBlock := framingBlock wbCopy)
					leftRatio: 1/2;
					topRatio: 1/2;
					rightRatio: 1/2;
					bottomRatio: 1/2].
			nRect := self isDialog ifTrue: [self contentRect] ifFalse: [self frameRect].
			pRect := Display boundingBox.
			nRect :=
				(pRect leftTop rightAndDown: nRect origin - pRect origin)
					extentFromLeftTop: nRect extent.
			isCentered ifTrue: [pRect := nRect center extentFromCenter: Display boundingBox extent].
			framingBlock := framingBlock newFramerFromNewRect: nRect parentRect: pRect].
	super storeRectOn: aStream indentString: indentString.! !

!WBGeometryManager methods !   
children

    self layoutForm isNil ifTrue: [^#()].
    ^self layoutForm children! !

!WBToolBarEditor methods ! 
insert

	| index element |
	index := list selection.

	element := WBTool
		bitmap: WBToolPaneExampleSysBitmap
		selector: ''.
	element rectangle: (0@0 extent: thePane cellSize).

	index isNil ifTrue: [
		elements add: element.
		index := elements size.
	] ifFalse: [
		elements add: element afterIndex: index.
		index := index + 1.
	].
	list
		contents: (elements collect: [:each | each selector asString]);
		selection: index.

	(self paneNamed: 'bitmaps') selectItem: ''.
	(self paneNamed: 'selector') setContents: ''.
	(self paneNamed: 'rbSelector') setContents: ''.
	(self paneNamed: 'numSpaces') setContents: '0'.

	self updateButtons.! !

!WBManagedPValue methods !   
updateValue
	"First search for a matching key, if not found
		then search for a matching value, if not found
		then the user may have renamed the key
		and changed the value so search for the
		association."

	| newAssoc |
	key notNil ifTrue: [
		self pools do: [:eachPool |
			(newAssoc := eachPool associationAt: key ifAbsent: [nil])
				notNil ifTrue: [
					association := newAssoc.
					^value := newAssoc value]]].
	self pools do: [:eachPool |
		eachPool associationsDo: [:each |
			each value == value ifTrue: [
				association := each.
				key := each key.
				^value]]].
	self pools do: [:eachPool |
		eachPool associationsDo: [:each |
			each == association ifTrue: [
				key := each key.
				^value := each value]]].
	association := key := nil.
	^value! !

!WBInterfaceObject methods !  
postEdit: ignore

	^true! !

!WBAbstractCodeModule methods !  
defaultComment
		"Answer the default comment string."
	^'Private'! !

!WBMenuItemStub methods !   
defaultComment
		"Answer the default comment string."
    ^'Callback for the menu item titled ', self titleString, '.
		(Generated by WindowBuilder Pro)'.! !

!WBEditClassDialog methods !  
mostRecentList

    ^self class recentClasses collect: [:class | class name].! !

!BitEditor methods !
initialize
        "Private - Initialize the receiver."
	#osiHack.
    bitColor := 0 "ClrDefault".
    super initialize! !

!WBPropertyEditor methods ! 
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancelButton categoryLabel commentLabel label mainView 
	okButton propertyLabel revertButton useDefaultsButton xDU 
	yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	categoryList := ListBox new.
	comment := TextEdit new.
	propertyList := ListBox new.
	valueFalse := RadioButton new.
	valueString := EntryField new.
	valueTrue := RadioButton new.
	
		"Temporary Variables"
	cancelButton := Button new.
	categoryLabel := StaticText new.
	commentLabel := StaticText new.
	label := StaticText new.
	okButton := Button new.
	propertyLabel := StaticText new.
	revertButton := Button new.
	useDefaultsButton := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Property Editor';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -275/2 * xDU;
				topRatio: 1/2; topInset: -179/2 * yDU;
				rightRatio: 1/2; rightInset: -275/2 * xDU;
				bottomRatio: 1/2; bottomInset: -161/2 * yDU).
	self addView: mainView.
	
	categoryLabel "StaticText"
		owner: self;
		setName: 'categoryLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 2/123; leftInset: 0 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 59/123; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -12 * yDU);
		contents: 'Categories';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: categoryLabel.
	
	categoryList "ListBox"
		owner: self;
		setName: 'categoryList';
		when: #clicked: send: #selectCategory: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 2/123; leftInset: 0 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 59/123; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -52 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: categoryList;
		subPaneWithFocus: categoryList.
	
	propertyLabel "StaticText"
		owner: self;
		setName: 'propertyLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 2/123; leftInset: 0 * xDU;
				topRatio: 0; topInset: 54 * yDU;
				rightRatio: 59/123; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		contents: 'Properties';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: propertyLabel.
	
	propertyList "ListBox"
		owner: self;
		setName: 'propertyList';
		when: #clicked: send: #selectProperty: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 2/123; leftInset: 0 * xDU;
				topRatio: 0; topInset: 64 * yDU;
				rightRatio: 59/123; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 45/2 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: propertyList.
	
	label "StaticText"
		owner: self;
		setName: 'label';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 62/123; leftInset: 0 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 121/123; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -12 * yDU);
		contents: 'Property Value:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: label.
	
	valueTrue "RadioButton"
		owner: self;
		setName: 'valueTrue';
		when: #clicked: send: #valueBooleanChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 62/123; leftInset: 0 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 2/3; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		contents: 'True';
		startGroup;
		font: SysFont.
	mainView addSubpane: valueTrue.
	
	valueFalse "RadioButton"
		owner: self;
		setName: 'valueFalse';
		when: #clicked: send: #valueBooleanChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 2/3; leftInset: 0 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 34/41; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		contents: 'False';
		startGroup;
		font: SysFont.
	mainView addSubpane: valueFalse.
	
	valueString "EntryField"
		owner: self;
		setName: 'valueString';
		addClipsiblingsStyle;
		when: #textChanged: send: #valueStringChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 62/123; leftInset: 0 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: valueString.
	
	commentLabel "StaticText"
		owner: self;
		setName: 'commentLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 62/123; leftInset: 0 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 121/123; rightInset: 0 * xDU;
				bottomRatio: 0; bottomInset: -38 * yDU);
		contents: 'Property Description:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: commentLabel.
	
	comment "TextEdit"
		owner: self;
		setName: 'comment';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 62/123; leftInset: 0 * xDU;
				topRatio: 0; topInset: 38 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 45/2 * yDU);
		removeHorizontalScrollbarStyle;
		addVerticalScrollbarStyle;
		addBorderStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: comment.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 2/123; leftInset: 0 * xDU;
				topRatio: 1; topInset: -37/2 * yDU;
				rightRatio: 19/123; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 5/2 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: okButton.
	
	cancelButton "Button"
		owner: self;
		setName: 'cancelButton';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 7/41; leftInset: 0 * xDU;
				topRatio: 1; topInset: -37/2 * yDU;
				rightRatio: 38/123; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 5/2 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancelButton.
	
	revertButton "Button"
		owner: self;
		setName: 'revertButton';
		when: #clicked send: #revert to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 40/123; leftInset: 0 * xDU;
				topRatio: 1; topInset: -37/2 * yDU;
				rightRatio: 59/123; rightInset: 0 * xDU;
				bottomRatio: 1; bottomInset: 5/2 * yDU);
		contents: '&Revert';
		startGroup;
		font: SysFont.
	mainView addSubpane: revertButton.
	
	useDefaultsButton "Button"
		owner: self;
		setName: 'useDefaultsButton';
		when: #clicked send: #useDefaults to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 94/123; leftInset: 0 * xDU;
				topRatio: 1; topInset: -37/2 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 5/2 * yDU);
		contents: 'Use &Defaults';
		startGroup;
		font: SysFont.
	mainView addSubpane: useDefaultsButton! !

!WindowBuilder class methods !
lookPolicy

    ^self propertyAt: #LookPolicy! !

!Font methods ! 
nonPortableStoreOn: aStream indentString: indentString
	"Private - WBPro Development."

	#addedByOSI.
	aStream
		nextPutAll: indentString;
		nextPutAll: #Font;
		space;
		nextPutAll: #new;
		cr;
		nextPutAll: indentString;
		nextPutAll: (
			OperatingSystem isOS2
				ifTrue: [#fromBytes:]
				ifFalse: [#fromByteArray:]);
		space;
		nextPutArrayOfBytes: self logicalFont contents.! !

!PStaticText methods !
mutationExceptions

    ^#(#CPChildEntryField #Toggle)! !

!PListBox methods !
mutationExceptions

    ^#(#CPScrollingPane)! !

!WBLayoutForm methods !  
hideHandles: aCollectionOfHandles

    aCollectionOfHandles isNil ifTrue: [^self].
    aCollectionOfHandles do: [:aHandle |
        self invalidateRect: aHandle displayBox erase: false].! !

!WBModelObjectEditor methods !   
hasModelObjects

    ^self owner prototype modelObjects notEmpty! !

!WBCreateBitmap class methods !  
defaultBitmapHeight

	^32! !

!WBBitmapManagerWindow methods !
addEditorCompositePaneTo: aModel

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	
	(editorCompositePane := WBBitmapEditorCompositePane new)
		definedIn: #addEditorCompositePaneTo:;
		owner: aModel;
		setName: 'editorCompositePane';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 2 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 3 * yDU);
		startGroup.
	^editorCompositePane! !

!WBBitmapManagerWindow methods !
menuPoolFileIn: aPath
	"File in from the specified file."

	| stream |
	CursorManager execute changeFor: [
		stream := File pathName: aPath.
		[stream nextLine = self poolManager class tagBitmaps
			ifTrue: [
				stream position: 0.
				self menuPoolFileInBDT: stream]
			ifFalse: [
				stream position: 0.
				self poolManager fileInFrom: stream].
		] ensure: [stream close]].! !

!WBBitmapManagerWindow methods ! 
menuBitmapFileOutBitmapFile: aBitmap key: aKey

	| path |
	path := FileDialog new
		addFilter: '*.bmp' description: 'Bitmap Files (*.bmp)';
		defFilter: '*.bmp';
		saveTitle: 'File out bitmap...'
		fileName: (File safeFileName: aKey), '.BMP';
		file.
	path isNil ifTrue: [^self].
	[aBitmap wbOutputToFile: path]
		on: Error
		do: [:exception | ^self menuErrorHandler: exception].! !

!WindowBuilder methods !
menuOptionsAddInManager

	WBAddInManager new open! !

!WBXoteryXCodePolicy methods !  
basicRemoveSelector: aSelector fromClass: aClass
		"Remove aSelector from the specified class."
	aClass removeSelector: aSelector.! !

!WBMultiToolPalette methods !  
releaseBitmaps
        "Private - Release all bitmaps."

    self elements: nil.
    self pages do: [ :page |
        page do: [ :element | element releaseBitmaps ]
    ].
    self pages: nil.! !

!WBEventMessage methods !   
source: anObject
	"Set the receiver's source."

	source := anObject.! !

!WBGeometryManager methods !
distributeVertically
    "Distribute the selected widgets vertically"

    | first last start distance aWidget useGrid y gridY
    selections origins redoBlock |
    (selections := self selections copy) size > 2 ifFalse: [^self].
    (self isAltKeyDown and: [self isShiftKeyDown not])
        ifTrue: [selections := (selections asSortedCollection: [:a :b | a y <= b y]) asArray].
    first := selections first.
    last := selections last.
    origins := selections collect: [:widget | widget origin].
    distance := ((last y + (last height // 2)) - (start := first y + (first height // 2))) // (selections size - 1).
    useGrid := self useGrid.
    self undoManager
        add: 'Distribute Vertical'
        undo:
            [self hideHandles: (self handles reject: [:handle |
                handle owner == first or: [handle owner == last]]).
            2 to: selections size - 1 do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (origins at: i) x
                    y: (origins at: i) y;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandles: (self handles reject: [:handle |
                handle owner == first or: [handle owner == last]]).
            useGrid ifTrue: [gridY := self gridSize y].
            2 to: selections size - 1 do: [:i |
                aWidget := selections at: i.
                y := start + (i - 1 * distance) - (aWidget height // 2).
                useGrid ifTrue: [y := y roundTo: gridY].
                aWidget
                    moveWidget: aWidget x
                    y: y;
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!WBTreeNode methods !  
parent

    ^parent! !

!WBLayoutFrameEditor class methods !  
horizontalRatioStrings
	"Answer a dictionary mapping horizontal ratios to names."

	^horizontalRatioStrings ifNil: [
		horizontalRatioStrings := IdentityDictionary new
			at: 0 put: 'Window left';
			at: 1/2 put: 'Window center';
			at: 1 put: 'Window right';
			yourself]! !

!WBPropertyDescriptor methods !
default: anObject
    "Set the value of default."

    default := anObject! !

!PCompositePane methods ! 
usesFont

    ^false! !

!IndexedColor methods !  
basicStoreColorOn: aStream
		"Private - Store the color definition."
	#addedByOSI.
	aStream
		nextPut: $( ;
		nextPutAll: self class name;
		space;
		nextPutAll: #index: ;
		space;
		nextPutAll: self index printString;
		nextPut: $).! !

!Stream methods !   
skipWhitespace
        "Advance the receiver position beyond the next
         occurrence of whitespace, or if none, to the end of
         stream.  Answer true if whitespace occurred, else
         answer false."
	#addedByOSI.
    [self atEnd]
        whileFalse: [
            self peek isWhitespace ifFalse: [^true].
            self next].
    ^false! !

!WBMenuEditor methods !
loadKeyList: aPane

    aPane contents: (self wbEditorClass runtimeLessCode
        ifTrue: [#()]
        ifFalse: [self keyList])! !

!WindowBuilder methods ! 
popupPaneMenu: layoutPane

    | selection newSelection menu subMenu list |
    (newSelection := self selections) isEmpty
        ifTrue: [
            menu := WBMenu new
                    labels: #('Color' 'Menubar' 'Events' 'Window' 'Browse Class' 'Save As Default')
                    lines: #(4)
                    selectors: #(#setColor #setMenu #setEvents #setOther #menuEditBrowseClass #menuFileSaveAsDefault)]
        ifFalse: [
            self hasMultipleSelections
                ifTrue: [
                    menu := WBMenu new.
                    self selectionsHaveFontAttributes
                        ifTrue: [menu add: #setFont label: 'Font'].
                    self selectionsHaveColorAttributes
                        ifTrue: [menu add: #setColor label: 'Color'].
                    menu
                        add: #setFraming label: 'Framing';
                        add: #setEvents label: 'Events';
                        addLine;
                        add: #menuFileCreateComposite label: 'Create Composite';
                        addLine;
                        add: #alignLeft label: 'Align Left' for: geometryManager;
                        add: #alignCenterHorizontally label: 'Align Horizontal Center' for: geometryManager;
                        add: #alignRight label: 'Align Right' for: geometryManager;
                        add: #alignTop label: 'Align Top' for: geometryManager;
                        add: #alignCenterVertically label: 'Align Vertical Center' for: geometryManager;
                        add: #alignBottom label: 'Align Bottom' for: geometryManager;
                        yourself.
                    self has3orMoreSelections
                        ifTrue: [
                            menu
                                addLine;
                                add: #distributeHorizontally label: 'Distribute Horizontally' for: geometryManager;
                                add: #distributeVertically label: 'Distribute Vertically' for: geometryManager].
                    menu
                        addLine;
                        add: #menuEditBrowseWidgetClass label: 'Browse Classes';
                        add: #saveWidgetTemplate label: 'Save As Default';
                        addLine;
                        appendSubMenu:
                            (subMenu := WBMenu
                                new title: 'Morph';
                                owner: self owner).
                    (list := thePane mutationList) do: [:item |
                        subMenu add: item label: item].
                    list isEmpty
                        ifFalse: [subMenu addLine].
                    subMenu add: 'other' label: 'Other...']
                ifFalse: [
                    newSelection first isComposite
                        ifTrue: [
                            menu := WBMenu new
                                add: #setColor label: 'Color';
                                add: #setFraming label: 'Framing';
                                add: #setEvents label: 'Events';
                                add: #setOther label: 'Edit';
                                addLine;
                                add: #menuFileUngroupComposite label: 'Ungroup';
                                addLine;
                                add: #menuEditBrowseWidgetClass label: 'Browse Class';
                                add: #saveWidgetTemplate label: 'Save As Default';
                                addLine;
                                appendSubMenu:
                                    (subMenu := WBMenu
                                        new title: 'Morph';
                                        owner: self owner).
                            (list := thePane mutationList) do: [:item |
                                subMenu add: item label: item].
                            list isEmpty
                                ifFalse: [subMenu addLine].
                            subMenu add: 'other' label: 'Other...']
                        ifFalse: [
                            menu := WBMenu new
                                add: #setFont label: 'Font';
                                add: #setColor label: 'Color';
                                add: #setFraming label: 'Framing';
                                add: #setMenu label: 'Menu';
                                add: #setEvents label: 'Events';
                                add: #setOther label: 'Attributes';
                                addLine;
                                add: #menuEditBrowseWidgetClass label: 'Browse Class';
                                add: #saveWidgetTemplate label: 'Save As Default';
                                addLine;
                                appendSubMenu:
                                    (subMenu := WBMenu
                                        new title: 'Morph';
                                        owner: self owner).
                            (list := thePane mutationList) do: [:item |
                                    subMenu add: item label: item].
                            list isEmpty
                                ifFalse: [subMenu addLine].
                            subMenu add: 'other' label: 'Other...']]].
    self updateAttributePalette: menu for: thePane.
    "layoutPane setPopupMenu: menu."
    Notifier consumeInputUntil: [:e | e selector = #button2Up:].
    selection := menu popUpIn: layoutPane mainWindow.
    layoutPane setPopupMenu: nil.
    selection isMessage
        ifTrue: [selection perform]
        ifFalse: [
            selection isSymbol
                ifTrue: [self perform: selection]
                ifFalse: [
                    selection isString
                        ifTrue: [self sendInputEvent: #morphSelectionTo: with: selection asSymbol]]].! !

!WBApplicationCoordinatorModule methods !   
menuModuleClass
        "Answer the menu code module class."
    ^WBApplicationCoordinatorMenuModule! !

!PActionButton methods ! 
copySpecificsTo: aPane

    aPane
        action: self action.! !

!WindowFrameObject methods !  
iconFile: aString

    iconFile := aString.! !

!WBTreeListBox methods !  
shiftSelectionDown

    self performOnSelection: #moveDown
        selectionDelta: nil
        moveWithSelection: true.! !

!WBEventMessage methods !   
defaultArguments
	"Answer the default arguments for the receiver."

	^Array new: (self class numberOfArgumentsFor: self selector)! !

!WindowBuilder class methods ! 
register: extraName propertyAt: aSymbol put: anObject

	| slot |
	slot := self extras at: extraName ifAbsent: [OrderedCollection new].
	slot add:
		(Message new
			receiver: self wbEditorClass
			selector: #propertyAt:put:
			arguments: (Array with: aSymbol with: anObject)).
	self extras at: extraName put: slot.! !

!WBLayoutForm methods !  
selectionsInZorder
    "Answer a copy of the selected widgets in Z-order."

    ^((self selections
            asSortedCollection: [:a :b | (self children indexOf: a) <= (self children indexOf: b)])
            asOrderedCollection)! !

!WindowBuilder methods !   
menuEditClear

	self triggerAboutToChange.
	self geometryManager clearSelections.! !

!PButton methods ! 
otherButtonWithID: id

	self parent isNil ifTrue: [^nil].
	^self parent children 
		detect: [:child |	child isButton and: [child ~~ self and: [child specialId == id]]]
		ifNone: [nil]! !

!WBNLSPool methods !   
fileOutHeaderOn: aStream
	"File out the receiver's header."

	super fileOutHeaderOn: aStream.
	self stringDictionaryReaderClass
		fileOutPoolName: self poolName on: aStream;
		fileOutPoolFileName: self fileName on: aStream;
		fileOutPoolTableBeginOn: aStream.! !

!WBGeometryManager methods ! 
pasteSelections

    (self clipboard isNil or: [self layoutForm isNil]) ifTrue: [^self].
    self layoutForm loadedWidgets: self clipboard.! !

!PComboBox methods ! 
storeSpecificsOn: aStream indentString: indentString
    "Write out the list"
    self contents isNil
        ifFalse: [
            (self contents isArray and: [self contents notEmpty])
                ifTrue: [
                    aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'contents: #( '.
                    self contents do: [:item |
                        aStream nextPutAll: item asQuotedString; space].
                    aStream nextPut: $)]].! !

!WBEditClassDialog methods !   
mostFrequentSelect: selectedItem

    "Callback for the #clicked: event triggered in the WBComboBox named 'mostFrequent'.
     (Generated by WindowBuilder)"

    selectedClass := Smalltalk at: (selectedItem ifNil: [^nil]) asSymbol ifAbsent: [^nil].
    list clearSelection.
    self setWindowTitle.! !

!WBFontManagerWindow methods !
newCodeStream
	"Answer a new code stream for the receiver."

	^WBCodeStream new
		generatePortableFontCode: self poolManager generatePortableFontCode;
		generateByteArrayCode: false;			"<------ For compatability"
		yourself! !

!PActionButton methods !  
action

    ^action! !

!PEntryFieldGroup methods !   
children

	^children ifNil: [children := OrderedCollection new].! !

!WBGraphicObject methods !   
preferredExtent

    ^self suggestedSize ifNil: [self rect extent]! !

!WBLookPolicyOS2 methods ! 
draw3DBoxWith: aPen at: aRect

    aPen
        fill: (aRect insetBy: 1) color: Color gray;
        foreColor: Color darkGray;
        wbLineFrom: aRect leftTop to: (aRect rightTop left: 1);
        wbLineFrom: aRect leftTop to: (aRect leftBottom up: 1);
        foreColor: Color white;
        wbLineFrom: (aRect leftTop rightAndDown: 1) to: (aRect rightTop leftAndDown: 1);
        wbLineFrom: (aRect leftTop rightAndDown: 1) to: (aRect leftBottom rightAndUp: 1);
        foreColor: Color darkGray;
        wbLineFrom: (aRect leftBottom up: 1) to: (aRect rightBottom leftAndUp: 1);
        wbLineFrom: (aRect rightTop left: 1) to: (aRect rightBottom leftAndUp: 1);
        up; down.
    ^aRect insetBy: 1! !

!WBEditClassDialog methods !   
filterChoice

    ^filter selectedItem! !

!WBTabOrderEditor methods !
deletedGroup

	removeGroupButton disable.
	self setFirstStatus.! !

!Point methods ! 
extentFromRightTop: aPoint
        "Private - WBPro Development."
        "Added by OSI - Answer a Rectangle whose origin is the receiver
         at the top-right corner and extent is aPoint."
    #addedByOSI.
    ^Rectangle
        leftTop: ((self x left: aPoint x)@ (self y))
        rightBottom: ((self x) @ (self y down: aPoint y))! !

!ViewManager methods !  
modelObjects

    ^self propertyTableForEdit
        at: #modelObjects
        ifAbsentPut: [OrderedCollection new]! !

!Object methods !   
isInstVar

    ^(self propertyAt: #isInstVar) == true! !

!WBModelInstVar methods !   
okToGenerateSet

    ^self okToGenerateMethod: self methodNameForSet! !

!WindowBuilder methods ! 
minWindowSize

	| du |
	du := (SysFont width @ SysFont height) / (16@32).
	^((210 @ 180) / du) truncated! !

!WindowBuilder methods !   
setSizeAndPositionForWidgets: aCollectionOfWidgets

    aCollectionOfWidgets isRectangle
        ifTrue: [
            self
                updateSize: aCollectionOfWidgets;
                updatePosition: aCollectionOfWidgets origin]
        ifFalse: [
            self
                updateSize: thePane rect;
                updatePosition:
                    ((aCollectionOfWidgets notNil and: [aCollectionOfWidgets notEmpty])
                        ifTrue: [self shell contentLeftTop distanceRightAndDown: self layoutForm selectedRect topLeft]
                        ifFalse: [self shell rect origin])].! !

!PropertyAccessor methods !   
wbDefaultPoolKey

	#addedByOSI.
	^nil! !

!WBUndoRedoDialog methods !
redo

    redoList selectedItems isEmpty ifTrue: [^self].
    self undoManager redo: (redoList contents indexOf: redoList selectedItems last ifAbsent: [1]).
    self preInitWindow.! !

!WBCompositePaneTester methods !   
preInitWindow
	"Set up the test pane and framing blocks for the window."

	| testPane mainView width height |

	width := frame width + 5.
	height := frame height + 25.
	(mainView := self paneNamed: 'mainView')
		framingBlock: (
			LayoutFrame new
				leftRatio: 1/2 ;leftInset: (width // 2) negated;
				topRatio: 1/2 ;topInset: (height // 2) negated;
				rightRatio: 1/2 ;rightInset: (width - (width // 2)) negated;
				bottomRatio: 1/2 ;bottomInset: (height - (height // 2)) negated).

	(testPane := classToTest new)
		owner: self;
		setName: 'testPane';
		framingBlock: (
			LayoutFrame new
				leftRatio: 0 ;leftInset: 0;
				topRatio: 0 ;topInset: 0;
				rightRatio: 0 ;rightInset: frame width;
				bottomRatio: 0 ;bottomInset: frame height);
		startGroup.
	mainView addSubpane: testPane.! !

!WindowBuilder methods ! 
updateEvents: refresh

	| oldEvents theEvents triggeredEvents sel used unused |
	oldEvents := when contents.
	triggeredEvents := thePane eventsTriggered.
	theEvents := (Window class compiledMethodAt: #supportedEvents) notNil
		ifTrue: [thePane supportedEvents]
		ifFalse: [
			#obsoleteMethod.
			"If obsolete support is not loaded, then only show those
					old events for which an event is defined so that
					users can convert them to new triggered events."
			(thePane wbRealWidget handlersOrNil ifNil: [Dictionary new]) keys].
	used := OrderedCollection new.
	unused := OrderedCollection new.
	triggeredEvents do: [:event |
		(thePane eventHandlerSelectorAt: event) notEmpty
				ifTrue: [used add: '*' , event , self tagNewEvents]
				ifFalse: [unused add: event asString , self tagNewEvents]].
	theEvents do: [:event |
		(thePane oldEventHandlerSelectorAt: event) notEmpty
				ifTrue: [used add: '*' , event , self tagOldEvents]
				ifFalse: [unused add: event asString , self tagOldEvents]].
	theEvents := used
		addAll: unused;
		yourself.
	theEvents = oldEvents
		ifTrue: [^self].
	refresh
		ifTrue: [
			sel := when selectedItem.
			(sel notNil and: [sel notEmpty])
				ifTrue: [
					sel first = $*
						ifTrue: [sel := sel copyFrom: 2 to: sel size].
					perform contents notEmpty
						ifTrue: [sel := '*' , sel]].
			when
				contents: theEvents;
				selectItem: sel;
				invalidateRect: when rectangle]
		ifFalse: [when contents: theEvents].
	! !

!WBLayoutFrameEditor methods !   
groups

	^groups ifNil: [
		groups := Array
			with: (self paneNamed: 'attachGroup')
			with: (self paneNamed: 'exampleGroup')]! !

!WBTargetObject class methods !
for: anObject owner: anOwner
	"Answer a new initialize instance."

	^self new
		owner: anOwner;
		initializeFrom: anObject;
		yourself! !

!WBLayoutForm methods !
resizeBand: aPoint
    "Resize the band depending on the nib the user has selected.
        There is a minimum size restriction in place."

    | pt1 pt2 aRect |
    aRect := self bandRect.
    self currentNib = #topLeft
        ifTrue: [
            (aPoint y isBelow: (pt2 := aRect rightBottom y up: minSize y))
                ifTrue: [pt1 := aPoint x @ pt2]
                ifFalse: [
                    (aPoint y isAbove: (pt2 := aRect rightBottom y up: maxSize y))
                        ifTrue: [pt1 := aPoint x @ pt2]
                        ifFalse: [pt1 := aPoint]].
            (pt1 x isRightOf: (pt2 := aRect rightBottom x left: minSize x))
                ifTrue: [pt1 := pt2 @ pt1 y]
                ifFalse: [
                    (pt1 x isLeftOf: (pt2 := aRect rightBottom x left: maxSize x))
                        ifTrue: [pt1 := pt2 @ pt1 y]].

            ^self bandRect: (pt1 rightBottom: aRect rightBottom)].

    self currentNib = #bottomLeft
        ifTrue: [
            (aPoint y isAbove: (pt2 := aRect leftTop y down: minSize y))
                ifTrue: [pt1 := aPoint x @ pt2]
                ifFalse: [
                    (aPoint y isBelow: (pt2 := aRect leftTop y down: maxSize y))
                        ifTrue: [pt1 := aPoint x @ pt2]
                        ifFalse: [pt1 := aPoint]].
            (pt1 x isRightOf: (pt2 := aRect rightBottom x left: minSize x))
                ifTrue: [pt1 := pt2 @ pt1 y]
                ifFalse: [
                    (pt1 x isLeftOf: (pt2 := aRect rightBottom x left: maxSize x))
                        ifTrue: [pt1 := pt2 @ pt1 y]].

            ^self bandRect: (pt1 x  @ aRect leftTop y
                rightBottom: aRect rightBottom x @ (pt1 y))].

    self currentNib = #topRight
        ifTrue: [
            (aPoint y isBelow: (pt2 := aRect rightBottom y up: minSize y))
                ifTrue: [pt1 := aPoint x @ pt2]
                ifFalse: [
                    (aPoint y isAbove: (pt2 := aRect rightBottom y up: maxSize y))
                        ifTrue: [pt1 := aPoint x @ pt2]
                        ifFalse: [pt1 := aPoint]].
            (pt1 x isLeftOf: (pt2 := aRect leftTop x right: minSize x))
                ifTrue: [pt1 := pt2 @ pt1 y]
                ifFalse: [
                    (pt1 x isRightOf: (pt2 := aRect leftTop x right: maxSize x))
                        ifTrue: [pt1 := pt2 @ pt1 y]].

            ^self bandRect: (aRect leftTop x @ pt1 y
                rightBottom: (pt1 x @ aRect rightBottom y))].

    self currentNib = #bottomRight
        ifTrue: [
            (aPoint y isAbove: (pt2 := aRect leftTop y down: minSize y))
                ifTrue: [pt1 := aPoint x @ pt2]
                ifFalse: [
                    (aPoint y isBelow: (pt2 := aRect leftTop y down: maxSize y))
                        ifTrue: [pt1 := aPoint x @ pt2]
                        ifFalse: [pt1 := aPoint]].
            (pt1 x isLeftOf: (pt2 := aRect leftTop x right: minSize x))
                ifTrue: [pt1 := pt2 @ pt1 y]
                ifFalse: [
                    (pt1 x isRightOf: (pt2 := aRect leftTop x right: maxSize x))
                        ifTrue: [pt1 := pt2 @ pt1 y]].

            ^self bandRect: (bandRect leftTop rightBottom: pt1)].

    self currentNib = #wbBottomRightOffset
        ifTrue: [
            (aPoint y isAbove: (pt2 := aRect leftTop y down: minSize y))
                ifTrue: [pt1 := aPoint x @ pt2]
                ifFalse: [
                    (aPoint y isBelow: (pt2 := aRect leftTop y down: maxSize y))
                        ifTrue: [pt1 := aPoint x @ pt2]
                        ifFalse: [pt1 := aPoint]].
            (pt1 x isLeftOf: (pt2 := aRect leftTop x right: minSize x))
                ifTrue: [pt1 := pt2 @ pt1 y]
                ifFalse: [
                    (pt1 x isRightOf: (pt2 := aRect leftTop x right: maxSize x))
                        ifTrue: [pt1 := pt2 @ pt1 y]].

            ^self bandRect: (bandRect leftTop rightBottom: pt1)].! !

!WBInterfaceObject methods !
hitRect

    ^rect! !

!Menu methods !
asPMenuItem
   "Private - WBPro Development."

	| item pMenu subMenu accelArray |
	#addedByOSI.
	pMenu := WBPMenuItem new.
	pMenu title: ((title includes: Tab) ifTrue: [title upTo: Tab] ifFalse: [title]).
	(selector isMessage and: [
		selector receiver isKindOf: WBAction]) ifTrue: [
		selector receiver receiver: nil
	].
	pMenu selector: selector.

	1 to: self numberOfItems do: [:i |
		item := items at: i.
		item isSubmenu ifTrue: [
			subMenu := item submenu asPMenuItem.
		] ifFalse: [
			subMenu := WBPMenuItem new.
		].
		subMenu isSeparator: (item style = MfSeparator).
		item label notNil ifTrue: [
			subMenu title: ((item label includes: Tab) ifTrue: [item label upTo: Tab] ifFalse: [item label]).
		] ifFalse: [
			subMenu title: '--------'
		].
		(item selector isMessage and: [
			item selector receiver isKindOf: WBAction]) ifTrue: [
			item selector receiver receiver: nil
		].
		subMenu selector: item selector.

		accelArray := accel at: i.
		accelArray notNil ifTrue: [
			subMenu accelerator: (
				WBKeyAccel new
					accelArray: accelArray;
					yourself
			).
		].
		pMenu addChild: subMenu.
	].

	^pMenu! !

!WBLayoutForm methods !  
totalWidth

	self shell isNil 
		ifTrue: [^self margin * 2].
	^self shell margin * 2 + self shell frameExtent x! !

!WBAttributeEditor methods !
cancel

    thePane := nil.
    super close! !

!WBKeyAccel methods !
accelKey

    ^keyCode! !

!Object methods !  
wbIgnore: anObject

	#addedByOSI.! !

!WindowBuilder methods !
menuToolsBrowsePackages

    (Smalltalk at: #TeamVToolInterface ifAbsent: [^nil]) current browseSubsystem! !

!WBEventMessage methods !   
moveUp
	"Move the receiver's action up in the list."

	self moveToIndex: (self index - 1 max: 1).! !

!PropertyManager methods ! 
wbAddEvent: anEventDescription
	"Answer the event definition."

	#addedByOSI.
	^self wbEventsForEdit add: anEventDescription! !

!WindowBuilder methods !   
refresh

	self updateParent.
	self children do: [:child | child update].
	self layoutForm
		hideShellHandles;
		hideWindow;
		reframeAll;
		showWindow.! !

!WBLinkEditor methods ! 
viableClasses

    ^(ViewManager wbCreatedClasses collect: [ :aClass |
        aClass name ]) asSortedCollection asOrderedCollection.! !

!WBTreeListBox methods !   
moveDown

    self selectedItem moveDown.
    owningEditBox setFocus.! !

!PStatusPane methods ! 
configureWidget: x y: y width: width height: height borderWidth: borderWidth
	"Do nothing."! !

!WindowBuilder methods !   
defaultCodeModuleClasses
	"Private - Answer the default code module classes."

	| answer |
	(answer := OrderedCollection new)
		add: self class;
		add: WBVersionCodeModule.
	self class generatePartsMethods
		ifTrue: [answer add: (Smalltalk at: #WBPartsModule)].
	^answer! !

!WBCodePolicy methods ! 
removeScratchSelectorsFor: aWBClassDefinition
		"Remove all methods that have no source code."
	aWBClassDefinition isScratchWindow ifTrue: [
		self removeScratchSelectorsForClass: aWBClassDefinition targetClass.
		self removeScratchSelectorsForClass: aWBClassDefinition targetClass class ].! !

!WBPoolManagerWindow methods !   
selectedKeysChanged
	"Tthe collection of selected keys changed."

	self
		redrawCategories;
		updateEditor.! !

!WindowBuilder methods !   
menuViewSwitchTo

	| nameString |
	(nameString := WBListChooser new
		fromList: self viewList
		prompt: 'Which View?'
		selection: self shell paneName) isNil
		ifFalse: [
			self prototype switchToWindow: (self prototype windowAt: nameString).
			self reinitWindowBuilder].
	! !

!WBLookPolicyWin31 class methods !
downArrow

    ^Down ifNil: [Down := WBBitmapClass new fromSysID: ObmDnarrow]! !

!WBEventManagerWindow methods ! 
mustHaveOneHandlerSelected
	"Answer true if exactly one widget and exactly one event
		and exactly one handler is selected, else report an error
		to the user and return false."

	self mustHaveOneActionListSelected ifFalse: [^false].
	self handlerSelected isNil ifTrue: [
		MessageBox message:
			'You must have exactly one handler selected.'.
		^false].
	^true! !

!LayoutFrame methods !  
wbCopyTo: anObject
	"Copy of the receiver's instance variables to anObject."

	^(super wbCopyTo: anObject)
		wbLeftProportional: self wbLeftProportional;
		wbTopProportional: self wbTopProportional;
		wbRightProportional: self wbRightProportional;
		wbBottomProportional: self wbBottomProportional;
		wbRightAttachedToLeft: self wbRightAttachedToLeft;
		wbBottomAttachedToTop: self wbBottomAttachedToTop;
		yourself! !

!WBInterfaceObject methods !  
tabPosition

    ^tabPosition! !

!WBGeometryManager methods !
sendBackward: targets
    "Send the <targets> backward in the z-order"

    | zOrder zTarget children aLayoutForm |
    zOrder := (children := self children) copy.
    zTarget := ((self children indexOf: targets last) == self children size
        ifTrue: [^self] ifFalse: [self children after: targets last]).
    aLayoutForm := self layoutForm.
    (self undoManager
        add: 'Send Backward'
        undo:
            [zOrder reverseDo: [:child |
                child bringToFront.
                children
                    remove: child;
                    addFirst: child.
                child wbSetDirty].
            self owner updateOutboardZOrderChange: zOrder.
            self updateWidget: aLayoutForm]
        redo:
            [targets reverseDo: [:child |
                child sendToBackOf: zTarget.
                children
                    remove: child;
                    add: child after: zTarget.
                child wbSetDirty].
            self owner updateOutboardZOrderChange: targets.
            self updateWidget: aLayoutForm])
        redoAction value.! !

!WindowBuilder methods !  
getEditedCompositeClass

	^(WBChooseClassDialog new
		classList: (CompositePane wbCreatedClasses reject: [:class |
			class isWBInternalClass])) result! !

!DrawnButton methods !  
drawSelector
        "Private - WB Development"
	#addedByOSI.
    ^drawSelector! !

!WBENVYCodePolicy methods !  
basicCreateClassFor: aWBClassDefinition
		"Define and answer a new class.
		Answer nil if one could not be created."
	^aWBClassDefinition superclass
		subclass: aWBClassDefinition className asSymbol
		instanceVariableNames: aWBClassDefinition instVarNamesString
		classVariableNames: aWBClassDefinition classVarNamesString
		poolDictionaries: aWBClassDefinition poolNamesString.! !

!WindowBuilder methods !  
wbUnlinkPartMessages
    "Do Nothing"! !

!WBEditClassDialog class methods !   
clearFrequentClasses

    FrequentClasses := nil! !

!WBAbstractPrompter methods !
cancel

    "Callback for the #clicked event triggered in the Button named 'cancel'.
     (Generated by WindowBuilder)"

	result := nil.
	self close.! !

!WBVersionCodeModule methods !  
wbVersionString
	"Answer the version string."

	| aStream |
	aStream := WriteStream on: String new.
	self wbEditorClass versionNumber printOn: aStream decimalSeparator: '.'.
	^aStream contents! !

!WBTabOrderEditor methods !  
aboutToClose

	super aboutToClose.
    self cleanUpOk.! !

!WindowBuilder methods !  
menuToolsInspectChildren

    self children inspect! !

!PEntryField methods !
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	(#(#aboutToChangeTo: #changed: #entered: #textChanged:) includes: eventSymbol)
		ifTrue: [^#('aString')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!WBInterfaceObject methods !   
wbUnDestroyWidget

	self parent: ((self propertyAt: #oldParent) ifNil: [^nil]).
	self parent children add: self.! !

!WBTreeListBox methods !
flatList

    self drawIndex = self getTopIndex ifTrue: [
        cachedFlatList := list asFlatList.
    ].

    ^cachedFlatList! !

!WBTabOrderLayoutForm methods !  
fontFor: widget

	^widget tabPosition inGroup
		ifTrue: [smallFont]
		ifFalse: [largeFont].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBTeamVCodePolicy methods !   
wbScratchPackage
	"Answer the scratch package... create it if necessary."

	^(self currentSubsystem packageNamed: self wbScratchPackageName)
		ifNil: [self currentSubsystem createPackageNamed: self wbScratchPackageName]! !

!WBModelInstVar methods !   
hasEvent

    ^hasEvent! !

!WBInterfaceObject methods !  
preferredLabelOrientation

    ^nil! !

!WBLookPolicyOS2 methods !
titleJustification

    ^self class default leftJustification! !

!WBGeometryManager methods !
clipboard: aCollection

    self owner clipboard: (aCollection collect: [:aWidget |
        aWidget wbDuplicate])! !

!WBLayoutForm methods !
cursorOffset
    "Answer the value of cursorOffset."

    ^cursorOffset! !

!WBColorDialog class methods !   
isWBInternalClass

    ^true! !

!WBCreateClassDialog methods !   
isValidPackage: aPackage
    "Answer whether <aPackage> should appear in the package list"

    ^true! !

!WBLookPolicy methods !
iconExtent

    ^13@13! !

!WindowBuilder methods !   
selectionsHaveFontAttributes

	| selections |
	^(selections := self selections) notEmpty
		and: [(selections detect: [:widget | widget usesFont] ifNone: [nil]) notNil]! !

!ListBox class methods !
wbConstructPropertyManager
	"Construct the WindowBuilder property manager
		based on the Digitalk property manager."

	| answer |
	#addedByOSI.
	answer := super wbConstructPropertyManager
		wbAddEvent: (
			WBEventDescription new
				event: #drawItem: ;
				argumentNames: #('drawIndex'));
		wbAddEvent: (
			WBEventDescription new
				event: #clicked: ;
				argumentNames: #('selectedItem'));
		wbAddEvent: (
			WBEventDescription new
				event: #doubleClicked: ;
				argumentNames: #('selectedItem'));
		wbAddEvent: (
			WBEventDescription new
				event: #changed: ;
				argumentNames: #('selectedItem'));
		wbAddEvent: (
			WBEventDescription new
				event: #changedIndex: ;
				argumentNames: #('selectedIndex'));
		wbAddEvent: (
			WBEventDescription new
				event: #aboutToChange ;
				argumentNames: #( ));
		wbAddEvent: (
			WBEventDescription new
				event: #drawFocus: ;
				argumentNames: #('drawIndex'));
		wbAddEvent: (
			WBEventDescription new
				event: #drawSelection: ;
				argumentNames: #('drawIndex'));
		wbAddEvent: (
			WBEventDescription new
				event: #characterTyped: ;
				argumentNames: #('aCharacter'));
		wbAddEvent: (
			WBEventDescription new
				event: #measureItem: ;
				argumentNames: #('drawIndex'));
		yourself.

	#osiHack.
	"Don't depend upon the ColumnListBox being in the image
		because it is contained in the Header Sample code (VHDT31W.SLL)."
	self symbol = #ColumnListBox ifTrue: [
		answer
			add: (SelectorPropertyAccessor new name: 'Column Widths'; get: #columnWidths; set: #columnWidths:; format: 'Array');
			wbRemoveEventNamed: #drawItem: ;
			wbRemoveEventNamed: #drawFocus: ;
			wbRemoveEventNamed: #drawSelection: ;
			wbRemoveEventNamed: #measureItem: ].

	^answer! !

!PStatusPane methods !  
inset

    ^3! !

!WBAboutDialog methods !
thanks

    | user |
    user := self wbEditorClass userName.
    (user = '???') | (user = '')
        ifTrue: [user := '']
        ifFalse: [user := user , ',
'].
    MessageBox message: 'Special Thanks to:

Ken Cooper, Ted Peters, Dan Shafer,
Scott Herndon, Tom Murphy,
James Chan, Eric Clayberg,
Bob Yerex, Dina Fischer, Jim Howe,
Ron Jeffries, Darrow Kirkpatrick,
Ed Shirk, S. Sridhar, Dan Rubel,
Roxie Rochat, David Zeleznik,
Suman Goel, Max-Pieter Fraenkel,
Jeff Odell, Jasmin McCabe,
Ken Thompson, Robert Benson,
' , user , 'ParcPlace-Digitalk, Inc.
American Management Systems, Inc.
Knowledge Systems Corporation, Inc.
Object Technology International, Inc.'! !

!WBActionEditor methods !  
initWindow

    changed := false.
    action := thePane action.
    self updateList.! !

!WBLayoutForm methods !
layoutAsBitmap

	"Answer a bitmap that contains an image of the current window."
	| result extent margin drawingGrid |
	extent := self shell frameExtent.
	margin := self shell margin.
	drawingBitmap :=  WBBitmapClass screenExtent: extent + margin.
	drawingGrid := self model drawGrid.
	self model drawGrid: false.
	self display.
	self model drawGrid: drawingGrid.
	result := WBBitmapClass screenExtent: extent.
	result pen
		copyBitmap: drawingBitmap
		from: (margin @ margin extent: extent)
		at: 0@0.
	drawingBitmap release.
	drawingBitmap := nil.
	^result! !

!WindowBuilder class methods ! 
clearExtras
	"   WindowBuilder clearExtras    "

	Extras := Dictionary new.! !

!WBPMenuItem methods !   
copySpecificsTo: copy

    copy isSeparator: isDivider.
    copy accelerator: keyAccel.
    copy selector: selector.! !

!WBMenuEditor methods !
shiftDown

    menuItemsEditor shiftSelectionDown.! !

!WBEventManagerWindow class methods !  
widgetFilters: aDictionary
	"Set a dictionary mapping strings to filter selectors."
	"
	WBEventManagerWindow widgetFilters: nil.
	"

	widgetFilters := aDictionary.! !

!WBCallOutModule methods !
generateCreateViewsStub
        "Don't do this."! !

!WindowFrameObject methods !  
children: aCollection

    children := aCollection.! !

!GraphicsTool methods !   
rgbColorMode
	"Do nothing... for compatibility with OS/2"
! !

!WBCallOutEditor methods ! 
defaultSelectorFor: aPane

    | name suggested count |
    name := (aPane paneName isNil or: [aPane paneName isEmpty])
        ifTrue: [aPane realClass name]
        ifFalse: [aPane paneName asTempVarToken].
    name := name copy at: 1 put: name first asUppercase; yourself.
    suggested := 'add', name, 'To:'.
    count := 0.
    [self checkForDups: suggested] whileTrue:
        [count := count + 1.
        suggested := 'add', name, count asString, 'To:'].
    ^suggested! !

!WBLayoutForm methods !
nlsEnabled

    ^self model nlsEnabled! !

!WBCreateBitmap class methods !
lastBitmapType

	^lastBitmapType ifNil: [self defaultBitmapType]! !

!WBLookPolicyWin31 class methods !   
rightArrow

    ^Right ifNil: [Right := WBBitmapClass new  fromSysID: ObmRgarrow]! !

!WBTabOrderLayoutForm methods ! 
addGroupingPane
    "Add a grouping widget to the editor"

    self loadedWidgets: (OrderedCollection 
        with: (self groupPaneClass example)).! !

!PEnhancedEntryField methods ! 
field

    ^field! !

!String methods !   
asQuotedString
        "Private - WBPro Development."

	#addedByOSI.
	^self printString

	"######## OLD CODE ###########
    | stream |
    #addedByOSI.
    stream := WriteStream on: String new.
    self printOn: stream.
    ^stream contents
	##############################"! !

!PropertyAccessor methods !  
wbDefault: anObject
	"Set the default value for this property."

	#addedByOSI.
	^self propertyAt: #wbDefault put: anObject! !

!WBLookPolicy methods !  
scrollBarArrowHeight

    ^self class default scrollBarArrowHeight! !

!WBLayoutForm methods !
handles: aCollection
    "Set the value of handles."

    handles := aCollection.! !

!WBResizeBitmap methods !  
updateOk

	"Callback for the #textChanged: event in newWidthField [EnhancedEntryField].
		(Generated by WindowBuilder Pro)"

	(self newWidth > 0) & (self newHeight > 0)
		ifTrue: [okButton enable]
		ifFalse: [okButton disable].! !

!WBModelCodeModule methods ! 
generateBody

    | instVars events |
    events := self object propertyAt: #events.
    self targetClassDefinition
        instVarNames: (self instVars collect: [:instVar | instVar name]) asArray.
    self owner forceUpdate:
        (self targetClassDefinition instVarNames = self targetClass instVarNames) not.
    self initToBeRemoved.

    "#initialize method"
    ((instVars := self instVars select: [:instVar |
        instVar initialized & instVar lazy not]) notEmpty
        and: [instVars first okToGenerateInitialize])
        ifTrue: [
            self addModule: (WBModelInitializeModule new
                targetClass: self targetClass;
                object: instVars;
                messageSelector: #initialize;
                yourself)]
        ifFalse: [toBeRemoved add: #initialize].
    "#constructEventsTriggered method"
    (((instVars := self instVars select: [:instVar |
        instVar hasEvent]) notEmpty
        or: [events notEmpty])
        and: [instVars isEmpty
        or: [instVars first okToGenerateEventsTriggered]])
        ifTrue: [
            instVars := ((instVars collect: [:instVar | instVar eventName]), events)
                asSortedCollection asArray.
            self addModule: (WBModelEventsTriggeredModule new
                targetClass: self targetClass;
                object: instVars;
                messageSelector: #constructEventsTriggered;
                yourself)]
        ifFalse: [toBeRemoved add: #constructEventsTriggered].
    "Inst Var methods"
    self instVars do: [:instVar |
        instVar hasAccessors
            ifTrue: [
                "Get methods"
                instVar okToGenerateGet
                    ifTrue: [
                        self addModule: (WBModelGetModule new
                            targetClass: self targetClass;
                            object: instVar;
                            messageSelector: instVar methodNameForGet;
                            yourself)]
                    ifFalse: [toBeRemoved add: instVar methodNameForGet asSymbol].
                "Basic Set methods"
                instVar okToGenerateBasicSet
                    ifTrue: [
                        self addModule: (WBModelBasicSetModule new
                            targetClass: self targetClass;
                            object: instVar;
                            messageSelector: instVar methodNameForBasicSet;
                            yourself)]
                    ifFalse: [toBeRemoved add: instVar methodNameForBasicSet asSymbol].
                "Set methods"
                instVar okToGenerateSet
                    ifTrue: [
                        self addModule: (WBModelSetModule new
                            targetClass: self targetClass;
                            object: instVar;
                            messageSelector: instVar methodNameForSet;
                            yourself)]
                    ifFalse: [toBeRemoved add: instVar methodNameForSet asSymbol].
                "Trigger event methods"
                (instVar hasEvent
                    and: [instVar okToGenerateTriggerEvent])
                    ifTrue: [
                        self addModule: (WBModelTriggerEventModule new
                            targetClass: self targetClass;
                            object: instVar;
                            messageSelector: instVar methodNameForTriggeredEvent;
                            yourself)]
                    ifFalse: [toBeRemoved add: instVar methodNameForTriggeredEvent asSymbol]]
            ifFalse: [
                toBeRemoved
                    add: instVar methodNameForGet asSymbol;
                    add: instVar methodNameForBasicSet asSymbol;
                    add: instVar methodNameForSet asSymbol;
                    add: instVar methodNameForTriggeredEvent asSymbol]].
    self cleanup.! !

!WBVerticalScrollBar class methods !
isWBInternalClass

    ^true! !

!WBCreatePowerViewsModule methods !  
createViewModuleClass
		"Answer the code module used to generate the create view."
	^WBCreatePowerViewModule! !

!WBPrototype methods !   
widget: widget isInstVarIn: aWindow
		"Answer true if the child is an inst var in the view."
	1 to: aWindow class instSize do: [:index |
		(aWindow instVarAt: index) == widget 
			ifTrue: [
				(aWindow class allInstVarNames at: index) = widget paneName
					ifTrue: [^true]]].
	^false! !

!WBEditClassDialog class methods ! 
clearFilterList
    "WBEditClassDialog clearFilterList"
    FilterList := nil! !

!WBDialogEditor methods !   
ok

    | aSet |

    aSet := Set new.

    (self paneNamed: 'systemMenu') selection ifTrue: [
        aSet add: #sysmenu.
    ].

    (self paneNamed: 'titleBar') selection ifTrue: [
        aSet add: #titlebar.
    ].

    (self paneNamed: 'systemModal') selection ifTrue: [
        aSet add: #sysmodal.
    ].

    (self paneNamed: 'modal') selection ifTrue: [
        aSet add: #modal.
    ].

    thePane := thePane wbCopy.

    thePane style: aSet.

    super close.! !

!Object class methods !  
wbGenerateInstVars

	^true! !

!WBCreateBitmap class methods !
lastBitmapHeight: anInteger

	^lastBitmapHeight := anInteger! !

!PropertyAccessor methods !  
wbDuplicateValue: aValue for: anObject
	"Duplicate the property's value."

	#addedByOSI.
	^self setValue: aValue for: anObject! !

!WBFontManagerWindow methods !   
defaultExtension

	^'.FPL'! !

!WindowFrameObject methods !   
isDialog

    ^(self realClass inheritsFrom: WindowDialog)
        | (self realClass inheritsFrom: DialogCoordinator)! !

!WBNLSSubPool methods !
fileOutIncludeOn: aStream
	"File out a reference to the file containing the receiver's contents."

	self stringDictionaryReaderClass
		fileOutInclude: self fileName on: aStream.! !

!EnhancedEntryField class methods !   
okCharacterMethods
        "Answer a collection of character validation selectors."
    ^((self methodDictionary keys select: [ :selector |
        (selector at: 1) = $o and: [
        (selector at: 2) = $k and: [
        (selector occurrencesOf: $:) = 1]]])
            collect: [ :selector |
            selector asString copyFrom: 3 to: selector size - 1])  asSortedCollection! !

!WBSystemBitmapViewer class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBAbstractCodeModule methods !  
object
		"Answer the receiver's object."
	^object! !

!WBLayoutWizard methods !   
widgetMapFor: selectedItem

    | theClass widgetMap |
    theClass := selectedItem valueClass.
    widgetMap := self class widgetMap.
    [widgetMap includesKey: theClass]
        whileFalse: [theClass := theClass superclass].
    ^widgetMap at: theClass! !

!WBLookPolicyWin95 methods ! 
menuBarHeight

    ^menuBarHeight ifNil: [
        menuBarHeight := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCymenu" 15]
            ifFalse: [super menuBarHeight]]! !

!Window class methods ! 
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
		removeKey: 'Size window' ifAbsent: [ ];
		add: (
			SelectorPropertyAccessor new
				name: 'Old Event Table';
				get: #handlersOrNil ;
				set: #wbOldEventTable: ;
				wbDuplicate: #wbIgnore: ;
				wbStore: #nextPutProperty:oldEventTable:for: ;
				yourself);
        wbAddEvent: (
            WBEventDescription new
                event: #dragTargetDrawEmphasis: ;
                argumentNames: #('dragSession'));
        wbAddEvent: (
            WBEventDescription new
                event: #dragSourceNeedsObject: ;
                argumentNames: #('dragSession'));
        wbAddEvent: (
            WBEventDescription new
                event: #dragSourceNeedsCursors: ;
                argumentNames: #('anObject'));
        wbAddEvent: (
            WBEventDescription new
                event: #dragTargetLeave: ;
                argumentNames: #('dragSession'));
        wbAddEvent: (
            WBEventDescription new
                event: #dragTargetNeedsOperations: ;
                argumentNames: #('dragSession'));
        wbAddEvent: (
            WBEventDescription new
                event: #changed ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #dragTargetEnter: ;
                argumentNames: #('dragSession'));
        wbAddEvent: (
            WBEventDescription new
                event: #dragTargetEraseEmphasis: ;
                argumentNames: #('dragSession'));
        wbAddEvent: (
            WBEventDescription new
                event: #dragSourceCut: ;
                argumentNames: #('dragSession'));
        wbAddEvent: (
            WBEventDescription new
                event: #dragTargetOver: ;
                argumentNames: #('dragSession'));
        wbAddEvent: (
            WBEventDescription new
                event: #dragTargetDrop: ;
                argumentNames: #('dragSession'));
        yourself! !

!WBCreateViewModule methods !  
generateMenuMessage: aSymbol
		"Private - Generate all the menu definitions."
	self stream cr; cr;
		nextPutAll: #self;
		space.
	self
		generateMessagePattern: aSymbol
		arguments:
			(Array with: (self varNameFor: self view)),
			self messageArguments.
	self stream
		endExpression.! !

!WBTimerEditor methods !
ok

    thePane
        period: period contents asNumber asInteger.
    self close! !

!PCompositePane methods !
styleMap

    ^super styleMap
        at: #borders put: #(#addBorderStyle);
        at: #scrollbars put: #(#addBorderStyle #addHorizontalScrollbarStyle #addVerticalScrollbarStyle);
        at: #verticalScrollBar put: #(#addBorderStyle #addVerticalScrollbarStyle);
        yourself.! !

!WBOpenMethodModule methods !   
methodExists
    "Answer true if the receiver's method already exists."

    | cm |
    ^(cm := self policy existingMethodFor: self) notNil
        and: [(cm references: self generatedSymbol) not]! !

!Window methods ! 
isWBModel

	^false! !

!WBCreateClassDialog methods ! 
ok

    | className classSymbol superclass package packageName |
    className := (self paneNamed: 'className') text trimBlanks.
    className size > 0
        ifFalse: [^MessageBox messageNote: 'You must provide a class name.'].
    className first isUpperCase
        ifFalse: [^MessageBox messageNote: 'Class name must begin with an upper case letter.'].
    className do: [:c |
        ('~!!@#$%^&*( )_+=-|}{\][/?><.,''";: ' includes: c)
            ifTrue: [^MessageBox messageNote: 'Class name can only contain alpha numerics.']].
    classSymbol := className asSymbol.
    (Smalltalk includesKey: classSymbol)
        ifFalse: [
            self inTeamV
                ifTrue: [
                    packageName := (self paneNamed: 'packageName') selectedItem.
                    package := (Smalltalk at: #TeamVInterface) current packages
                        detect: [:pack | pack name = packageName].
                    superclass := (self paneNamed: 'superclassName') selectedItem asSymbol.
                    newClass := package
                        addClassNamed: classSymbol
                        superclassName: superclass
                        indexableType: 'none'
                        instanceVariableNames: #( )
                        classVariableNames: #( )
                        poolNames: (limitTo = 'EventManager'
                            ifTrue: [#( )] ifFalse: [#('ColorConstants' 'OperatingSystemConstants')])
                        classInstanceVariableNames: #( ).
                    newClass := Smalltalk at: newClass printString asSymbol]
                ifFalse: [
                    self inXoteryX
                        ifTrue: [
                            packageName := (self paneNamed: 'packageName') selectedItem.
                            superclass := Smalltalk at: (self paneNamed: 'superclassName') selectedItem asSymbol.
                            newClass := superclass
                                subclass: classSymbol
                                instanceVariableNames: ''
                                classVariableNames: ''
                                poolDictionaries: (limitTo = 'EventManager'
                                    ifTrue: [''] ifFalse: ['ColorConstants OperatingSystemConstants'])
                                category: packageName]
                        ifFalse: [
                            self inENVY
                                ifTrue: [
                                    (packageName := (self paneNamed: 'packageName') selectedItem) isNil
                                        ifTrue: [^MessageBox messageNote: 'You must select an application first'].
                                    package := Smalltalk at: packageName asSymbol ifAbsent: [^nil].
                                    package becomeDefault].
                            superclass := Smalltalk at: (self paneNamed: 'superclassName') selectedItem asSymbol.
                            newClass := superclass
                                subclass: classSymbol
                                instanceVariableNames: ''
                                classVariableNames: ''
                                poolDictionaries: (limitTo = 'EventManager'
                                    ifTrue: [''] ifFalse: ['ColorConstants OperatingSystemConstants'])]]]
        ifTrue: [
            newClass := Smalltalk at: className asSymbol.
            superclass := Smalltalk at: (self paneNamed: 'superclassName') selectedItem asSymbol.
            (#(#ViewManager #WindowDialog #CompositePane #ApplicationCoordinator #DialogCoordinator #EventManager) includes: classSymbol)
                ifTrue: [^MessageBox messageNote: 'You cannot save window definitions in the abstract class ' , newClass name , '.  Please choose a different name.'].
            newClass superclass == superclass
                ifFalse: [^MessageBox messageNote: 'The superclass of an existing class cannot be changed.'].
            (MessageBox confirm: 'The class ''' , newClass name , ''' exists.  Overwrite?')
                ifFalse: [^self]].
    WBEditClassDialog addToRecentList: newClass.
    self close.! !

!CompositePane class methods !  
defaultCodeModuleClass
        "Answer the default code module for the receiver."
    ^WBCompositePaneModule! !

!PRadioButtonGroup methods ! 
attributeEditor

    ^WBListEditor! !

!WBAboutDialog methods !   
getSerialNumber: aPane
	"Display the serial number."

	aPane contents: ('Registered to:\' , self wbEditorClass serialNumber) withCrs! !

!WBModelCodeModule methods !
targetObject

    ^self object! !

!WBTabOrderLayoutForm methods !
setByColumnMajorOrder

	| tabPosition |
	self removeGroupingPanes.
	self groups: Dictionary new.
	tabPosition := WBTabPosition fromTabPosition: 1.
	((self children select: [:widget | 
		widget isGrouper not 
		and: [widget usesFocus 
		and: [widget staysToBack not]]]) asSortedCollection: [:a :b |
			(a hitRect bottomRight x isLeftEqualOf: b hitRect topLeft x)
				or: [(a hitRect topLeft x isLeftEqualOf: b hitRect bottomRight x)
					and: [a hitRect bottomRight y isAboveEqual: b hitRect topLeft y]]]) do: [:widget |
			widget tabPosition: tabPosition.
			tabPosition := tabPosition nextTabPosition].
	self setSmartGroups.! !

!WBNLSSubPool methods !
fileOutFooterOn: aStream
	"File out the receiver's footer."

	self stringDictionaryReaderClass
		fileOutCategoryEndOn: aStream.
	super fileOutFooterOn: aStream.! !

!WBGeometryManager methods !  
hideHandlesExceptFor: aCollection

    self layoutForm hideHandlesExceptFor: aCollection! !

!WBAbstractAddInModule class methods !   
commonName

	^nil! !

!WindowBuilder methods !
selectionsHaveOtherAttributes

	| selections |
	self hasSelections ifFalse: [^self shell isCompositePane not].
	^(selections := self selections) notEmpty
		and: [(selections detect: [:widget | widget hasOtherEditor] ifNone: [nil]) notNil]! !

!WBLayoutFrameEditor methods !  
topAttachmentFor: aCollection
	"Answer the top attachment for the specified framing blocks."

	| ratio |
	aCollection do: [:each |
		ratio notNil
			ifTrue: [
				each wbTopProportional
					ifTrue: [ratio = self proportional ifFalse: [^'']]
					ifFalse: [ratio = each topRatio asRational ifFalse: [^'']]]
			ifFalse: [
				each wbTopProportional
					ifTrue: [ratio := self proportional]
					ifFalse: [ratio := each topRatio asRational]]].
	ratio ifNil: [^''].
	ratio isString ifTrue: [^ratio].
	^self class verticalRatioStrings at: ratio ifAbsent: [ratio printString]! !

!WBNLSPool methods !
fileOutFooterOn: aStream
	"File out the receiver's footer."

	self stringDictionaryReaderClass
		fileOutPoolTableEndOn: aStream.
	super fileOutFooterOn: aStream.! !

!PButtonListBox methods !
useImages

    ^self style == #defaultStyle
        or: [self style == #threeState].! !

!String methods !   
wbNameAndClass
    "Answer the receiver's name and class."

    ^self! !

!WBGraphicObject methods ! 
wbCopyTo: copy

	self fullCopy: copy.
	^copy! !

!Number methods !   
wbFullCopyReal: aDictionary
	"Answer a copy of the receiver which shares
		 the receiver instance variables.  Because
		 the receiver is unique (cannot be copied),
		 answer the receiver."

	#addedByOSI.
	^self! !

!WBBitmapManager methods !
editorClass
    "Answer a pool manager window class for the receiver."

    ^WBBitmapManagerWindow! !

!WBBitmapManagerWindow methods !  
menuKeyNew: aCollection pool: aPool

	aCollection do: [:each |
		self categories do: [:eachCategory |
			aPool
				at: each key
				in: eachCategory
				put: (
					self sameValueForAllCategories | each value isOperatingSystemBitmap
						ifTrue: [each value]
						ifFalse: [each value wbCopy])]].! !

!WBEnhancedEntryFieldEditor methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| autoTab cancel case caseLabel character characterLabel 
	field fieldLabel getFocus getFocusLabel justification 
	justText mainView ok size sizeLabel validationGroup xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	autoTab := CheckBox new.
	cancel := Button new.
	case := ListBox new.
	caseLabel := StaticText new.
	character := ListBox new.
	characterLabel := StaticText new.
	field := ListBox new.
	fieldLabel := StaticText new.
	getFocus := ListBox new.
	getFocusLabel := StaticText new.
	justification := ListBox new.
	justText := StaticText new.
	ok := Button new.
	size := WBEntryField new.
	sizeLabel := StaticText new.
	validationGroup := GroupBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'EnhancedEntryField Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -92 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -74 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -92 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -74 * yDU).
	self addView: mainView.
	
	field "ListBox"
		owner: self;
		setName: 'field';
		when: #needsContents send: #getField: to: self withArgument: field;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 94 * xDU;
				topRatio: 0; topInset: 131/2 * yDU;
				rightRatio: 0; rightInset: -174 * xDU;
				bottomRatio: 0; bottomInset: -126 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: field;
		subPaneWithFocus: field.
	
	characterLabel "StaticText"
		owner: self;
		setName: 'characterLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 17/2 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 0; rightInset: -90 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		contents: 'Character:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: characterLabel.
	
	fieldLabel "StaticText"
		owner: self;
		setName: 'fieldLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 94 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 0; rightInset: -174 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		contents: 'Field:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: fieldLabel.
	
	sizeLabel "StaticText"
		owner: self;
		setName: 'sizeLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 80 * xDU;
				topRatio: 0; topInset: 134 * yDU;
				rightRatio: 0; rightInset: -116 * xDU;
				bottomRatio: 0; bottomInset: -142 * yDU);
		rightJustified;
		contents: 'Max Size:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: sizeLabel.
	
	getFocusLabel "StaticText"
		owner: self;
		setName: 'getFocusLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 58 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -120 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Get Focus:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: getFocusLabel.
	
	justText "StaticText"
		owner: self;
		setName: 'justText';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -54 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Justification:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: justText.
	
	caseLabel "StaticText"
		owner: self;
		setName: 'caseLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 124 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -180 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Case:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: caseLabel.
	
	justification "ListBox"
		owner: self;
		setName: 'justification';
		when: #needsContents send: #getJustification: to: self withArgument: justification;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 10 * yDU;
				rightRatio: 0; rightInset: -54 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: justification.
	
	getFocus "ListBox"
		owner: self;
		setName: 'getFocus';
		when: #needsContents send: #getFocus: to: self withArgument: getFocus;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 58 * xDU;
				topRatio: 0; topInset: 10 * yDU;
				rightRatio: 0; rightInset: -120 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: getFocus.
	
	case "ListBox"
		owner: self;
		setName: 'case';
		when: #needsContents send: #getCase: to: self withArgument: case;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 124 * xDU;
				topRatio: 0; topInset: 10 * yDU;
				rightRatio: 0; rightInset: -180 * xDU;
				bottomRatio: 0; bottomInset: -46 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: case.
	
	character "ListBox"
		owner: self;
		setName: 'character';
		when: #needsContents send: #getCharacter: to: self withArgument: character;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 17/2 * xDU;
				topRatio: 0; topInset: 131/2 * yDU;
				rightRatio: 0; rightInset: -90 * xDU;
				bottomRatio: 0; bottomInset: -126 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: character.
	
	size "WBEntryField"
		owner: self;
		setName: 'size';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 118 * xDU;
				topRatio: 0; topInset: 132 * yDU;
				rightRatio: 0; rightInset: -140 * xDU;
				bottomRatio: 0; bottomInset: -144 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: size.
	
	autoTab "CheckBox"
		owner: self;
		setName: 'autoTab';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 142 * xDU;
				topRatio: 0; topInset: 132 * yDU;
				rightRatio: 0; rightInset: -180 * xDU;
				bottomRatio: 0; bottomInset: -144 * yDU);
		contents: 'Auto &Tab';
		startGroup;
		font: SysFont.
	mainView addSubpane: autoTab.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 132 * yDU;
				rightRatio: 0; rightInset: -40 * xDU;
				bottomRatio: 0; bottomInset: -146 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 42 * xDU;
				topRatio: 0; topInset: 132 * yDU;
				rightRatio: 0; rightInset: -78 * xDU;
				bottomRatio: 0; bottomInset: -146 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	validationGroup "GroupBox"
		owner: self;
		setName: 'validationGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 46 * yDU;
				rightRatio: 0; rightInset: -180 * xDU;
				bottomRatio: 0; bottomInset: -130 * yDU);
		contents: 'Validation';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: validationGroup! !

!WBCompositePaneScratchWindow class methods !   
isScratchWindow

    ^true! !

!WBStatusPaneEditor methods !  
setName: aString

	| box index |
	list selection isNil ifTrue: [^nil].
	box :=boxes at: list selection.
	box name: aString.

	index := list selection.
	list
		contents: (boxes collect: [:each | each name asString]);
		selection: index.! !

!WindowBuilder class methods !
versionNumber
	"Answer the window builder version."

	^self editorClass 
		propertyValueAt: #VersionNumber 
		category: self privateString.! !

!PDrawnButton methods !
storeContentsOn: aStream indentString: spaceString

	(self usesTitle and: [self contents notNil and: [self contents notEmpty]])
		ifTrue: [
			aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'cpContents: '.
			self contents printOn: aStream].! !

!PDrawnButton methods !   
importantEvents

    ^super importantEvents
        addFirst: #clicked;
        yourself! !

!ComboBox class methods !  
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbRemoveEventNamed: #changedIndex: ;
        wbRemoveEventNamed: #listVisible ;
        wbAddEvent: (
            WBEventDescription new
                event: #entered: ;
                argumentNames: #('aString'));
        wbAddEvent: (
            WBEventDescription new
                event: #textChanged: ;
                argumentNames: #('aString'));
        yourself! !

!WBModelInstVar methods !
methodNameForTriggeredEvent

    ^'trigger', self name asProperNoun, 'ChangedEvent'! !

!WindowBuilder methods !  
updateMenuAlign

	(self menuTitled: 'Align') updateEnabled.! !

!WBLookPolicy methods !   
drawFilledBoxWith: aPen at: aRect inset: inset backColor: backColor

    | innerRect |
    aPen
        fill: (innerRect := aRect insetBy: inset)
        color: backColor.
    ^innerRect! !

!WBLookPolicyOS2 methods ! 
drawMinimizeButtonWith: aPen at: aRect

    | innerRect |
    innerRect := self draw3DBoxWith: aPen at: aRect.
    aPen
        foreColor: Color black;
        drawRectangle: (innerRect insetBy: 6)! !

!WBClassDefinition methods !
poolNames
		"Answer the receiver's poolNames."
	^poolNames ifNil: [ poolNames := self basicPoolNames copy ].! !

!LayoutFrame methods !   
wbTopProportional
	"Answer true if the receiver is top proportional (inset = 0)."

	^(self propertyAt: #wbTopProportional) ifNil: [
		self wbTopProportional:
			(self topInset = 0) & (self topRatio ~= 0) & (self topRatio ~= 1)]! !

!WBEventManagerWindow methods !
widgetList

	^widgetList ifNil: [
		widgetList := Set new.
		self prototype children do: [:each | widgetList add: each wbRealWidget].
		self prototype modelObjects do: [:each | widgetList add: each wbRealWidget].
		self prototype targetInstVars do: [:each | widgetList add: each value wbRealWidget].
		widgetList
			remove: self targetObject ifAbsent: [];
			remove: self targetShell ifAbsent: [].
		widgetList := widgetList asArray collect: [:each | each wbNameAndClass => each].
		widgetList := (((widgetList select: [:each | each key first ~~ $<]) asSortedCollection asArray),
			((widgetList select: [:each | each key first == $<]) asSortedCollection asArray)) collect: [:each | each value].
		widgetList := (Array with: self targetObject), 
			((self targetObject == self targetShell)
				ifTrue: [#()] ifFalse: [Array with: self targetShell]),
			widgetList]! !

!PRadioButtonGroup methods !   
mutationExceptions

    ^#(#CPScrollingPane)! !

!WBTabPosition class methods !   
new

    ^super new initialize.! !

!WBAbstractCodeModule methods !   
category
		"Answer the category for the receiver."
	^category ifNil: [ self defaultCategory ]! !

!WBTreeNode methods !   
shiftRight

    children do: [ :c |
        c shiftRight.
    ].

    currentString := self indentString, currentString.! !

!WBPoolManagerWindow methods !   
menuErrorHandler: exception
	"Report the error to the user."

	MessageBox warning: (
		(WriteStream on: (String new: 100))
			nextPutAll: exception description;
			nextPut: $. ;
			cr;
			nextPutAll: 'Hold the ALT key down when clicking OK to see the full walkback.';
			contents).
	Notifier isAltKeyDown ifTrue: [exception pass].
	^nil! !

!WBOpenMethodModule methods !   
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self generateGeneratedSymbol.
        self stream
            cr; nextPutAll: #self; indentBy: 1;
            cr; nextPutAll: #createViews; nextPut: $;;
            cr; nextPutAll: '"preInitWindow;"';
            cr; nextPutAll: #openWindow; endExpression; indentBy: -1].! !

!WBUndoManager methods !   
hideHandles

    self owner layoutForm hideHandles.! !

!PGraphPane methods ! 
usesFocus

    ^false! !

!WBCreateMenuModule methods !   
defaultMessageArguments
		"Private - Answer the default message selector arguments."
	^Array
		with: self defaultPaneName! !

!WBOutboardWindow methods !
activated

	ownerChanged ifTrue: [self update].! !

!WBGeometryManager methods !  
bringToFront
    "Bring the selected widgets to the top of the z-order"

    self bringToFront:
        (self children select: [:child |
            self selections includes: child]).! !

!WindowBuilder class methods ! 
installedProducts

    | stream |
    stream := WriteStream on: (String new: 64).
    self osiProducts do: [:product |
        stream nextPutAll: product; cr].
    MessageBox new
        title: 'Installed Products';
        message: stream contents;
        iconInformation;
        ok;
        open.! !

!WBTabOrderEditor methods ! 
reverseOrder

	layoutForm reverseTabOrder.
	self setFirstStatus.! !

!WBModelInitializeModule methods !  
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self generateGeneratedSymbol.
        self stream cr; nextPutAll: 'super initialize.'.
        self object do: [:instVar |
            self stream cr; nextPutAll: instVar name; nextPutAll: ' := '.
            instVar initializeValue notNil
                ifTrue: [self stream nextPutAll: instVar initializeValue storeString; nextPut: $.]
                ifFalse: [self stream nextPutAll: instVar valueClass name; nextPutAll: ' new.']]].! !

!PMultipleSelectListBox methods !   
styles

    ^#(#defaultStyle #extendedSelect #ownerDrawFixed #ownerDrawVariable)! !

!WBEventManagerWindow methods !  
mustHaveOneActionListSelected
	"Answer true if exactly one widget and exactly one event
		is selected, else report an error to the user and return false."

	self widgetSelected isNil ifTrue: [
		MessageBox message:
			'You must have exactly one widget selected.'.
		^false].
	self eventSelected isNil ifTrue: [
		MessageBox message:
			'You must have exactly one event selected.'.
		^false].
	^true! !

!PEntryFieldGroup methods !  
contents: aCollection

	aCollection isNil ifTrue: [^self].
	super contents: (aCollection isDictionary
		ifTrue: [aCollection keys asOrderedCollection asArray]
		ifFalse: [aCollection asArray]).
	self addSubpanes.! !

!WBBitmapSubPool methods !   
fileOutBPL: aFileName keys: aCollection ids: idMap on: aStream
	"File out the receiver's contents."

	| assoc |
	self fileOutHeaderOn: aStream.
	aCollection asSortedCollection do: [:each |
		assoc := self associationAt: each ifAbsent: [nil].
		assoc notNil ifTrue: [
			self
				fileOutRef: assoc
				fileName: aFileName
				ids: idMap
				on: aStream]].
	self fileOutFooterOn: aStream.! !

!WBScrapbookRetrieve methods !  
getPage: selectedItem

    (self paneNamed: 'name') contents: (page := selectedItem).
    (self paneNamed: 'ok') enable.
    (self paneNamed: 'remove') enable.
    self displayImage: (self paneNamed: 'graphic').
    self updateScrollBar.! !

!WBLayoutForm methods ! 
directEditor: aWBDirectEditorManager
    "Set the value of directEditor."

    directEditor := aWBDirectEditorManager.! !

!WindowBuilder methods !  
updateCustomPanesMenu

	| index |
	index := customSubMenu numberOfItems + 1.
	self customPanes do: [:pane |
		customSubMenu
				insertItemDynamically: pane
				selector: pane
				atIndex: index.
		index := index + 1].! !

!WBScratchWindow class methods ! 
resetToDefault

    "self defaultClass selectors do: [:s |
        self createMethod: (self defaultClass sourceCodeAt: s).
    ]."! !

!PWBToolBar methods !
wbSuggestedTempName
        "Answer the suggested temporary variable name used in code generation."
    ^'ToolBar'! !

!WBMenuEditor methods !
pMenu

    ^menuItemsEditor contents withoutEmptyNodes! !

!WBLayoutForm methods !
defaultCursor

    ^self loadedWidgets notNil
        ifTrue: [CursorManager crossHair]
        ifFalse: [CursorManager arrow].! !

!WBFontManagerWindow class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBNLSManagerWindow methods !
defaultExtension

	^'.NPL'! !

!FrameObject methods ! 
drawFrameWith: aPen at: aPoint

	| theRect |
	theRect := aPoint extentFromLeftTop: rect extent.
	aPen 
		place: aPoint;
		box: theRect corner.! !

!WBMenu methods !  
addLine

    ^self appendSeparator! !

!WBOutboardWindow methods !
layoutForm

	^self owner layoutForm! !

!WBCodeStream methods !   
nextPutProperty: aWBProperty style: aBoolean for: anObject
	"Store the property in the receiver."

	aWBProperty wbDefault = aBoolean ifTrue: [^self].
	^self nextPutPropertyIgnoreDefault: aWBProperty style: aBoolean for: anObject! !

!WindowBuilder class methods ! 
supportsActionAndLinkButtons

    ^WBActionLinkAddInModule loaded! !

!WBEventManagerWindow class methods !   
defaultToFieldExtensions

	^Dictionary new
		at: 'Global...' put: #promptForGlobal;
		at: 'Window...' put: #promptForWindow;
		yourself! !

!WBBitmapManagerWindow methods !   
anySelectedBitmap
	"Answer any selected bitmap or nil."

	| aBitmap |
	self selectedKeysAndPools do: [:eachKeyAndPool |
		self selectedCategories do: [:eachCategory |
			(aBitmap := eachKeyAndPool value
				at: eachKeyAndPool key
				in: eachCategory
				ifAbsent: [nil]
			) isBitmap ifTrue: [^aBitmap]]].
	^nil! !

!WBLookPolicyOS2 methods !  
scrollBarHeight

	^scrollBarHeight ifNil: [
		scrollBarHeight := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCyhscroll" 23]
			ifFalse: [super scrollBarHeight]]! !

!WBAbstractCodeModule methods !  
generateTemporaries
        "Private - Generate the temporary variables."! !

!WBSubPool methods ! 
fileOutOn: aStream
	"File out the receiver's contents."

	self fileOutKeys: self keys on: aStream.! !

!WBBitmapEditorCompositePane methods !
editButton

	"Callback for the #clicked event in editButtonButton [Button].
		(Generated by WindowBuilder Pro)"

	self selectedValue isBitmap ifTrue: [ButtonEditor new openOn: self selectedValue].! !

!WBToolBarEditor methods !
up

    | element index |
    index := list selection.
    index isNil ifTrue: [ ^nil ].
    element := elements at: index.
    index == 1 ifTrue: [ ^nil ].
    elements removeIndex: index.
    elements add: element beforeIndex: index - 1.
    list invalidateRect: nil.
    list selection: index - 1.

    self updateButtons.! !

!WBListChooser methods !  
initWindowSize

    ^180@160! !

!WBEnhancedEntryFieldEditor methods !
getField: aPane

    | list |
    list := OrderedCollection new.
    list
        add: self noneString;
        addAll: thePane realClass okFieldMethods.
    aPane contents: list! !

!WBEditClassDialog methods !  
emptyString

    ^''! !

!WBPrototype methods !   
convertOSWidget: realWidget

    | widget theClass |
    theClass := realWidget class.
    theClass == WBGroupBox 
		ifTrue: [theClass := GroupBox].
    widget := theClass wbPseudoClass new.
    (theClass = WBHorizontalScrollBar) | (theClass = WBVerticalScrollBar)
		ifTrue: [theClass := ScrollBar].
    widget
		realClass: theClass;
		wbRealWidget: realWidget.
    realWidget framingBlock isRectangle 
		ifTrue: [
			realWidget framingBlock: realWidget framingBlock asLayout]
		ifFalse: [
			realWidget framingBlock isFramingParameters ifTrue: [
				realWidget framingBlock initialExtent: (realWidget propertyAt: #extent)]].
    widget
        contents: realWidget contents
        framingBlock: realWidget framingBlock;
        menu: realWidget getPopupMenu;
        paneName: realWidget paneName;
        style: (realWidget propertyAt:  #style).
    widget menu notNil 
		ifTrue: [widget menu: widget menu asWBPMenu].
    widget style isNil 
		ifTrue: [widget style: widget defaultStyle].
    realWidget font isNil 
		ifFalse: [widget font: realWidget font].

    ^widget! !

!WBModelSetModule methods !   
defaultMessageArguments

    ^Array with: (self object initializeValue isNil
        ifTrue: ['anObject']
        ifFalse: [
            self object valueClass name first isVowel
                ifTrue: ['an', self object valueClass name]
                ifFalse: ['a', self object valueClass name]]).! !

!WBInterfaceObject methods !   
sendToBack

    | widgets firstBackPane |
    (widgets := self siblings) remove: self ifAbsent: [].
    firstBackPane := widgets
        detect: [:widget | widget staysToBack]
        ifNone: [nil].
    (self staysToBack or: [firstBackPane isNil])
        ifTrue: [widgets addLast: self]
        ifFalse: [widgets add: self before: firstBackPane].
    self updateWidget.! !

!WBCreateBitmap methods !  
cancel

    self close.! !

!WindowBuilder class methods !
resetDefaults

    self allProperties do: [:property |
        property noDefault
            ifFalse: [property value: property default]].! !

!WBLayoutForm methods ! 
visibleFrameRect

    "Answer the client rectangle of the edited window
    that is currently visible in the scrolling pane (i.e.
    the client rectangle intersected with the visible region)"
	| visRect |
	visRect := (self rectangle leftTop + self scrollingForm topCorner) 
		extentFromLeftTop: self scrollingForm visibleExtent.
	^(self shell frameContentRect intersect: visRect).! !

!WBTemplateEditor methods !   
styleEditor

	^styleEditor! !

!Object methods !  
wbCopyTo: anObject
	"Copy of the receiver's instance variables to anObject."

	| size |
	#addedByOSI.
	size :=
		(self class isVariable ifTrue: [self basicSize] ifFalse: [0])
		+ self class instSize
	min:
		(anObject class isVariable ifTrue: [anObject basicSize] ifFalse: [0])
		+ anObject class instSize.
	self class isPointers & anObject class isPointers
		ifTrue: [
			1 to: size do: [:index |
				anObject instVarAt: index
					put: (self instVarAt: index)]].
	self class isPointers not & anObject class isPointers not
		ifTrue: [
			1 to: size do: [:index |
				anObject basicAt: index
					put: (self basicAt: index)]].
	^anObject! !

!WindowBuilder methods !  
currentEventIsTriggered
	"Answer true if the event is a new triggered event."

	^currentWhen notNil and: [
		(currentWhen copyFrom: (currentWhen size - self tagOldEvents size + 1 max: 1) to: currentWhen size) 
		~= self tagOldEvents]! !

!WBLayoutForm methods !  
select: aWidget

    | oldFirst |
    self targetIsFirst
        ifTrue: [self selections addLast: aWidget]
        ifFalse: [
            oldFirst := self selections isEmpty
                ifTrue: [nil] ifFalse: [self selections first].
            self selections addFirst: aWidget.
            oldFirst isNil
                ifFalse: [self hideHandles: (self handlesFor: oldFirst)]].
    self notifyModelOfSelectionChange.
    self showHandles: (self addHandlesFor: aWidget).! !

!WindowBuilder methods !
codeModulesFor: anObject
	"Private - Answer the code module."

	| codeModules |
	codeModules := self 
		propertyAt: #CodeModules 
		ifAbsent: [self defaultCodeModulesFor: anObject].
	self class addInModuleClass modulesModifyingCodeGeneration do: [:module |
		module modifyCodeGeneration: codeModules].
	codeModules do: [:each |
		each
			object: anObject;
			targetClass: anObject realClass].
	^codeModules! !

!WindowBuilder methods !
nlsMenu

	| menu |
	menu := (self menuTitled: 'Attributes') ifNil: [^nil].
	^(menu items at: (menu getIndex: 'NLS' ifAbsent: [^nil])) submenu! !

!WBTreeNode methods ! 
indentString

    ^'...'! !

!WBPrototype methods !   
children

	^shell children! !

!WBTemplateEditor methods !
postEdit

	^true! !

!WBGeometryManager methods ! 
moveByPixelLeft
    "Move the selected widgets left one pixel"

    | selections |
    (selections := self selections copy) isEmpty
        ifTrue: [^self owner setWindowPosition: (self shell x - 1 @ self shell y)].
    (self undoManager
        add: 'Move Pixel Left'
        undo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    moveWidget: (aWidget x right: 1)
                    y: aWidget y;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections]
        redo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    moveWidget: (aWidget x left: 1)
                    y: aWidget y;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections])
        redoAction value.
    self updateWidget.! !

!WBLayoutForm methods !  
clipRect

    ^0@0 extent: 10000@10000! !

!WBCodeStream methods !
addModule: aCodeModule
	"Add a code module to the list of code modules to be processed."

	self owner addModule: aCodeModule.! !

!WBMenuEditor methods !
warnOfAccelerators

    warnedAboutAccelerators isNil ifTrue: [
        MessageBox messageNote: 'Warning: Keyboard accelerators in popup menus are not supported in Smalltalk/V.   Those you add here will appear visually, but must be in a menubar to truly function.'.
        warnedAboutAccelerators := true.
    ].! !

!WBBitmapManagerWindow methods ! 
menuBitmapPasteIntoButtonUp

	| aBitmap selectedBitmap |
	selectedBitmap := self selectedValue ifNil: [^self].
	(aBitmap := Clipboard getBitmap) isBitmap
		ifTrue: [
			selectedBitmap wbButtonUp: aBitmap.
			self updateEditor]
		ifFalse: [
			MessageBox message:
				'The clipboard does not contain a bitmap'].! !

!WBAbstractPrompter methods !  
resultPrim

	^self implementedBySubclass! !

!WBPoolManagerWindow methods !   
valueAt: aKey in: aCategory pool: aPool
	"Answer the value to be displayed."

	aKey isNil | aCategory isNil | aPool isNil ifTrue: [^nil].
	^aPool at: aKey in: aCategory ifAbsent: [^'']! !

!PStatusPane methods ! 
generateTabStopsAndGroups

    ^true! !

!WBGraphicObject methods !   
extent: aPoint

    rect extent: aPoint! !

!WBPoolManagerWindow methods !
menuPoolDelete: aCollectionOfPools

	| aCollectionOfPoolNames |
	aCollectionOfPoolNames := aCollectionOfPools collect: [:each | each poolName].
	self menuPoolRemove: aCollectionOfPools.
	aCollectionOfPoolNames do: [:each |
		WBCodePolicy current removePoolNamed: each].! !

!WBNLSEditorCompositePane methods ! 
entered: aString

	"Callback for the #entered: event in valueEditField [EntryField].
		(Generated by WindowBuilder Pro)"

	Notifier isShiftKeyDown
		ifTrue: [self owner menuKeyPrevious]
		ifFalse: [self owner menuKeyNext].! !

!WBTabOrderLayoutForm methods !   
buttonReleasePlacing: aPoint
    "Process a button release event after placing a widget."

	| newGrouper size newGroupRect containedWidgets min |
	newGrouper := self loadedWidgets first.
	size := self cursorSelectPoint distanceRightAndDown: aPoint.

	newGroupRect := self cursorSelectPoint extentFromLeftTop: size.
	newGrouper rect: newGroupRect.
	self groups keysDo: [:group |
		(group rect intersects: newGroupRect)
			ifTrue: [
				self 
					loadedWidgets: nil;
					updateWidget.
				^MessageBox messageNote: 'Overlapping grouping is not allowed.'.]].
	
	(containedWidgets := self 
		widgetsFrom: self soloWidgets 
		containedIn: newGrouper) isEmpty
		ifTrue: [
			self
				loadedWidgets: nil;
				updateWidget.
			^MessageBox messageNote: 'A group must contain at least one groupable widget.'].
	min := WBTabPosition fromTabPosition: 10000.
	containedWidgets do: [:widget |
		(widget usesFocus 
		and: [widget tabPosition notNil 
		and: [widget tabPosition <= min]]) 
			ifTrue: [min := widget tabPosition]].
	newGroupRect := (self boundingBoxFor: containedWidgets) expandBy: 8.

	newGrouper
		tabPosition: min;
		parent: self shell;
		extent: newGroupRect extent.
	self children add: newGrouper.

	self
		placeNewWidgets: (Array with: newGrouper)
		at: newGroupRect leftTop;
		selections: #().

	self 
		resetGroups;
		moveGroupboxesToBack;
		normalizeTabOrder;
		loadedWidgets: nil;
		updateRect: self shell frameContentRect;
		triggerEvent: #setGroup.! !

!WindowBuilder methods ! 
hasMultipleSelections

    ^self selections size > 1! !

!WBCreateClassDialog class methods ! 
defaultType: aClassSymbol

    DefaultType := aClassSymbol! !

!WBGeometryManager methods !   
alignCenterVertically
    "Align the selected widgets along their vertical centers"

    | target selections origins aWidget redoBlock |
    (selections := self selections copy) size > 1 ifFalse: [^self].
    target := selections first.
    origins := selections collect: [:widget | widget origin].
    self undoManager
        add: 'Align Center Vertical'
        undo:
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (origins at: i) x
                    y: (origins at: i) y;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: aWidget x
                    y: (target y + ((target height - aWidget height) // 2));
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!WinDialogInfo methods !
style
        "Private - WBPro Development."
    #addedByOSI.
    ^self uLongAtOffset: 0! !

!WBDevelopmentWindow methods !  
updateMenuButton: palette for: currentWidget
	"Update the Menu button"

	(currentWidget notNil and: [currentWidget usesMenu])
		ifTrue: [palette enableItem: #setMenu]
		ifFalse: [palette disableItem: #setMenu].! !

!WindowBuilder methods !
canUseWin95Look

    ^OperatingSystem isOS2 not! !

!WBKeyEntryField methods !
setAugmentKeys

    accelerator isAlt: Notifier isAltKeyDown.
    accelerator isCtrl: Notifier isControlKeyDown.
    accelerator isShift: Notifier isShiftKeyDown.! !

!WBScrapbookStore methods !  
getName: aString

    aString isEmpty ifTrue: [
        (self paneNamed: 'ok') disable
    ] ifFalse: [
        (self paneNamed: 'chapters') selectedItems isEmpty ifTrue: [
            (self paneNamed: 'ok') disable
        ] ifFalse: [
            (self paneNamed: 'ok') enable
        ].
    ]! !

!WBEventMessage methods ! 
actionList: actions
	"Set the action list containing the receiver."

	self source setActionList: actions forEvent: self event.! !

!WBCreateBitmap methods ! 
windowTitle

	^'Create Bitmap'! !

!WBLayoutForm methods !
createUndoRedoForChangeSize: aWidget newBox: newBox oldBox: oldBox

    ^self undoManager
        add: 'Change Size'
        undo:
            [self hideHandles.
            aWidget
                configureWidget: oldBox left
                y: oldBox top
                width: oldBox width
                height: oldBox height
                borderWidth: aWidget borderWidth;
                wbUpdateConstraints.
            self children do: [:child |
                (aWidget ~~ child and: [
                    child wbHasWidgetAttachment])
                    ifTrue: [self wbLayOutChild: child]].
            self
                showHandles;
                notifyModelOfSizeOrPositionChange;
                updateAfterResize]
        redo:
            [self hideHandles.
            aWidget
                configureWidget: newBox left
                y: newBox top
                width: newBox width
                height: newBox height
                borderWidth: aWidget borderWidth;
                wbUpdateConstraints.
            self children do: [:child |
                (aWidget ~~ child and: [
                    child wbHasWidgetAttachment])
                    ifTrue: [self wbLayOutChild: child]].
            self
                showHandles;
                notifyModelOfSizeOrPositionChange;
                updateAfterResize].! !

!WBTargetObject methods !
invalidInstVars

	^invalidInstVars! !

!WBBitmapManager class methods !   
standardWBBitmapIDMap
	"Answer the standard window builder bitmap id map."

	^Dictionary new
		at: 'WBCalculatorBitmap' put: 101;
		at: 'WBCameraBitmap' put: 102;
		at: 'WBCheckBoxBitmap' put: 103;
		at: 'WBCheckBoxOnBitmap' put: 104;
		at: 'WBClearBitmap' put: 105;
		at: 'WBCopyBitmap' put: 106;
		at: 'WBCrayonsBitmap' put: 107;
		at: 'WBCutBitmap' put: 108;
		at: 'WBCutCopyPasteBitmap' put: 109;
		at: 'WBDateTimeBitmap' put: 110;
		at: 'WBDiscBitmap' put: 111;
		at: 'WBDivideBitmap' put: 112;
		at: 'WBGraphBitmap' put: 113;
		at: 'WBGreaterThan10Bitmap' put: 114;
		at: 'WBHandshakeBitmap' put: 115;
		at: 'WBLetterBitmap' put: 116;
		at: 'WBMinusBitmap' put: 117;
		at: 'WBMonaLisaBitmap' put: 118;
		at: 'WBMovieBitmap' put: 119;
		at: 'WBOpenNewBitmap' put: 120;
		at: 'WBOrgChartBitmap' put: 121;
		at: 'WBPasteBitmap' put: 122;
		at: 'WBPlusBitmap' put: 123;
		at: 'WBRadioButtonBitmap' put: 124;
		at: 'WBRadioButtonOnBitmap' put: 125;
		at: 'WBSaveBitmap' put: 126;
		at: 'WBTimesBitmap' put: 127;
		at: 'WBToolPaneExampleBitmap' put: 128;
		yourself.! !

!WBLinkEditor methods !  
select: selectedItem
    | typePane |
    ((Smalltalk at: selectedItem asSymbol) methodDictionary keys includes: #open) ifFalse: [
        (Smalltalk includesKey: #MDIChild) ifTrue: [
            (typePane := self paneNamed: 'types') contents: #('Independent' 'Child' 'Sibling' 'MDIChild')
        ] ifFalse: [
            (typePane := self paneNamed: 'types') contents: #('Independent' 'Child' 'Sibling')
        ].
    ] ifTrue: [
        (typePane := self paneNamed: 'types') contents: #('Independent')
    ].
    typePane selectItem: type asString.
    typePane selectedItem isNil ifTrue: [ typePane selectIndex: 1 ].
    self selectType: typePane selectedItem.! !

!WBAbstractCodeModule methods !  
defaultMessageSelector
		"Private - Answer the default message selector."
	^nil! !

!WBCodeGenerator methods !
generateCode
		"Private - Generate the code."
	[ modulesToProcess notEmpty
		] whileTrue: [
			modulesToProcess removeFirst
				generateCode ].! !

!PWBToolBar methods !  
vertical: aBoolean

    self propertyAt: #vertical put: aBoolean
! !

!PEntryFieldGroup methods !
mutationTypes

    ^#(#ListBox #CPScrollingPane #RadioButtonGroup #EntryFieldGroup)! !

!PDrawnButton methods !   
displayWith: aPen clipRect: clipRect

	| labelOrFileName bitmap |
	labelOrFileName := self contents.
	(self style == #invisible 
		or: [labelOrFileName isNil
		or: [labelOrFileName isEmpty]])
		ifTrue: [^self displayGenericWith: aPen clipRect: clipRect].
	(self fileExists: labelOrFileName)
		ifTrue: [bitmap := WBBitmapClass fromFile: labelOrFileName]
		ifFalse: [
			bitmap := WBBitmapClass
				screenWidth: self extent x
				height: self extent y.
			bitmap pen
				draw3DButton: (self justFileName: labelOrFileName)
				rect: bitmap boundingBox
				font: (self font isNil ifTrue: [self defaultFont] ifFalse: [self font])
				foreColor: self foreColor
				backColor: self realBackColor].
	(style == #fixedSize)
		ifTrue: [
			aPen
				copyBitmap: bitmap
					from: bitmap boundingBox
					at: rect origin]
		ifFalse: [
			aPen
				copyBitmap: bitmap
					from: bitmap boundingBox
					to: rect].
	bitmap release.! !

!WBCreateViewModule methods !
generateDefinitionFor: anObject instVar: aBoolean
		"Private - Generate the specified definition."

	| def |
	self targetObject class isWBInternalClass ifTrue: [
		anObject realClass == SmalltalkToolInterface current textPaneClass ifTrue: [
			def := 'SmalltalkToolInterface current textPaneClass new']].
	def isNil ifTrue: [def := anObject realClass name, ' ', #new].
	aBoolean  & self useInstVars not
		ifTrue: [self generateIndirectDefinition: def for: anObject]
		ifFalse: [self generateDefinition: def for: anObject].! !

!WBScratchWindow class methods !   
isScratchWindow

    ^true! !

!WBFontManager methods !   
codeKeyClass
	"Answer the named method class field, so that the
		code generator can generate expressions such as
		'Bitmap named: <aKey>'   or   'Font named: <aKey>'."

	^self == self class current
		ifTrue: [Font] ifFalse: [nil]! !

!WBStatusPaneEditor methods !  
preInitWindow

    boxes := thePane statusBoxes deepCopy.! !

!WBCreateBitmap methods !   
ok

    | type width height newBitmap |
	type := self class lastBitmapType: self bitmapType.
	width := self class lastBitmapWidth: self bitmapWidth.
	height := self class lastBitmapHeight: self bitmapHeight.
	newBitmap := WBBitmapClass
		perform: type
		withArguments: (Array with: width with: height).
	result := self bitmapKey => newBitmap.
    self close.! !

!WBTreeNode methods !  
isLeaf

    ^self hasChildren not! !

!WBLayoutForm methods ! 
shellHandles
    "Answer the value of shellHandles."

    ^shellHandles ifNil: [shellHandles := OrderedCollection new: 1].! !

!WBPMenuItem methods !
type

    (selector isNil or: [ (selector isMessage) not or: [ selector selector isNil ]]) ifTrue: [
        ^nil
    ] ifFalse: [
        selector receiver isWBAction ifTrue: [
            ^nil
        ] ifFalse: [selector selector == #openWithParent: ifTrue: [
            ^#Child
        ] ifFalse: [ selector selector == #openWithMyParent: ifTrue: [
            ^#Sibling
        ] ifFalse: [ selector selector == #openWithMDIParent: ifTrue: [
            ^#MDIChild
        ] ifFalse: [
            ^#Independent
        ]]]].
    ]! !

!WBFontEditorCompositePane methods !  
setFont

	"Callback for the #changed: event in nameField [WBComboBox].
		(Generated by WindowBuilder Pro)"

	| face size font selectedCategories |
	face := nameField selectedItem ifNil: [^self].
	size := sizeField text asInteger ifNil: [10].
	size < 1 ifTrue: [size := 10].
	selectedCategories := self selectedCategories.
	self selectedKeysAndPools do: [:eachKeyAndValue |
		selectedCategories do: [:eachCategory |
			font := Font
				face: face
				size: size
				fixedWidth: fixedWidthCheckBox selection
				attributes: 0.
			boldCheckBox selection ifTrue: [font bold: true].
			italicCheckBox selection ifTrue: [font italic: true].
			strikeOutCheckBox selection ifTrue: [font strikeOut: true].
			underscoreCheckBox selection ifTrue: [font underscore: true].
			eachKeyAndValue value
				at: eachKeyAndValue key
				in: eachCategory
				put: font]].! !

!Bitmap class methods !   
screenWidth4: w height: h
	"Answer a new screen Bitmap with width w and height h."

	#addedByOSI.
	^self new screenWidth4: w height: h! !

!PDrawnButton methods !  
changesSize

    ^true! !

!WBLayoutForm methods !
directEditor: aWBDirectEditorManager point: aPoint
    "Set the value of directEditor."

    aWBDirectEditorManager isNil ifTrue: [^self].
    self directEditor: aWBDirectEditorManager.
    aWBDirectEditorManager
        layoutForm: self point: aPoint;
        run.! !

!MenuWindow methods !  
asWBPMenuBar
        "Private - WBPro Development."
    | mw |
    #addedByOSI.
    mw := WBPMenubar new.
    menus do: [ :m |
        mw addChild: m asPMenuItem.
    ].

    mw updateListStrings.
    ^mw! !

!WBInterfaceObject methods ! 
moveWidgetPrim: x y: y

    self
        rect: (Rectangle
            leftTop: x @ y
            extent: self rect extent)! !

!WBTabOrderLayoutForm methods ! 
setTabPositionFor: aWidget

	| containingGroup widgetGroup |
	self groups do: [:group |
		(group includes: aWidget)
			ifTrue: [containingGroup := self groups keyAtValue: group]].
	containingGroup notNil
		ifTrue: [
			widgetGroup := self groups at: containingGroup.
			containingGroup tabPosition isNil
				ifTrue: [
					containingGroup tabPosition: (self nextTabPositionFromCollection: self soloWidgets).
					aWidget tabPosition: containingGroup tabPosition copy makeFirstInGroup]
				ifFalse: [
					(widgetGroup detect: [:widget | widget tabPosition notNil] ifNone: [nil]) isNil
						ifTrue: [aWidget tabPosition: containingGroup tabPosition copy makeFirstInGroup]
						ifFalse: [aWidget tabPosition: (self nextTabPositionFromCollection: widgetGroup)]]]
		ifFalse: [aWidget tabPosition: (self nextTabPositionFromCollection: self soloWidgets)].! !

!WBActionEditor methods !  
ok: ignore

    self ok! !

!WBMultiToolPalette methods ! 
switchTo: name
    | sel |
    self hideWindow.
    self elements: (self pageNamed: name).
    selection := self elementAtSelector: 'ArrowTool'.
    selection isNil ifTrue: [ selection := self defaultSelection ].
    self elements do: [ :element | element up ].
    sel := self elementAt: selection.
    sel isNil ifFalse: [ sel down ].
    self handle isValid ifTrue: [ self display ].
    self showWindow.! !

!WindowBuilder methods !  
abortClose
	"Abort the close operation. "

	self mainView abortClose.! !

!ThreeStateButton class methods !  
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #indeterminate ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #clicked: ;
                argumentNames: #('aBooleanOrNil'));
        yourself! !

!WBBitmapManager methods !  
updateSourceFor: aKey in: aPool value: aBitmap
	"If indicated, update the source for the specified pool/key."

	self updateSource ifFalse: [^self].
	aBitmap archive isArray ifFalse: [^self].
	(aPool pool associationAt: aKey) smalltalkLibraryName notNil ifTrue: [^self].
	WBCodePolicy current
		updateSourceFor: aKey
		inPoolNamed: aPool poolName
		sourceString: (
			(WriteStream on: (String new: 100))
				nextPutAll: #WBBitmapClass;
				cr;
				next: 4 put: $ ;
				nextPutAll: #fromModule: ;
				nextPut: $ ;
				nextPutAll: aBitmap archive first printString;
				cr;
				next: 4 put: $ ;
				nextPutAll: #id: ;
				nextPut: $ ;
				nextPutAll: aBitmap archive last printString;
				contents).! !

!WBEventManagerWindow methods !  
toFieldChanged: selectedItem pane: aPane

	"Callback for the #changed: event triggered in the WBComboBox named 'toField'.
	 (Generated by WindowBuilder)"

	| selector newSelection aHandler |
	newSelection := selectedItem.
	(selector := self toFieldExtensions at: selectedItem ifAbsent: [nil]) notNil ifTrue: [
		(newSelection := self perform: selector) notNil
			ifTrue: [
				aPane contents
					detect: [:each | each == newSelection]
					ifNone: [aPane contents: (Array with: newSelection), aPane contents].
				aPane selection: newSelection]
			ifFalse: [
				aPane selection: (newSelection := self targetObject)]].
	(aHandler := self handlerSelected) notNil ifTrue: [
		aHandler changeReceiver: newSelection.
		handlerListBox redraw.
		self owner setDirty].! !

!WBModelCodeModule methods !  
defaultComment
    "Answer the default comment string."

    ^'
        Remove the #generated tag before modifying this method.
        (Generated by WindowBuilder Pro)'! !

!WindowBuilder class methods !   
editorPropertyString

    ^#EditorProperties! !

!PComboBox methods ! 
generateAllStyles

    ^true! !

!WBHandle methods !  
owner: aFigure
        locator := locator copyOn: aFigure! !

!WBPoolManagerWindow methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| activeCategoryLabel categoryPathLabel mainView 
	menuCategoryAddSuggestedButton menuCategoryDeleteButton 
	menuCategoryNewButton menuKeyDeleteButton menuKeyNewButton 
	poolPathLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	activeCategoryField := WBComboBox new.
	categoryListBox := MultipleSelectListBox new.
	categoryPathField := EntryField new.
	keyListBox := MultipleSelectListBox new.
	poolListBox := MultipleSelectListBox new.
	poolPathField := EntryField new.
	
		"Temporary Variables"
	activeCategoryLabel := StaticText new.
	categoryPathLabel := StaticText new.
	menuCategoryAddSuggestedButton := Button new.
	menuCategoryDeleteButton := Button new.
	menuCategoryNewButton := Button new.
	menuKeyDeleteButton := Button new.
	menuKeyNewButton := Button new.
	poolPathLabel := StaticText new.
	
		"Call Outs"
	editorCompositePane := self addEditorCompositePaneTo: self.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Pool Manager';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -135 * xDU;
				topRatio: 1/2; topInset: -211/2 * yDU;
				rightRatio: 1/2; rightInset: -135 * xDU;
				bottomRatio: 1/2; bottomInset: -175/2 * yDU).
	self addView: mainView.
	
	poolListBox "MultipleSelectListBox"
		owner: self;
		setName: 'poolListBox';
		when: #changed: send: #poolListChanged:pane: to: self withArgument: poolListBox;
		when: #drawItem: send: #poolListDrawItem:pane: to: self withArgument: poolListBox;
		when: #needsContents send: #poolListNeedsContents: to: self withArgument: poolListBox;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3 * xDU;
				topRatio: 0; topInset: 7/2 * yDU;
				rightRatio: 1/2; rightInset: 3 * xDU;
				bottomRatio: 0; bottomInset: -53 * yDU);
		extendedSelect;
		startGroup;
		setPopupMenu: (
			Menu new
			    title: '';
			    owner: self;
			    appendItem: 'New...' selector: #menuPoolNew acceleratorString: '';
			    appendItem: 'Add existing...' selector: #menuPoolAddExisting acceleratorString: '';
			    appendItem: 'Update dependent classes...' selector: #menuPoolUpdateDependentClasses acceleratorString: '';
			    appendSeparator;
			    appendItem: 'File in...' selector: #menuPoolFileIn acceleratorString: '';
			    appendItem: 'File out...' selector: #menuPoolFileOut acceleratorString: '';
			    appendItem: 'File out separately...' selector: #menuPoolFileOutSeparately acceleratorString: '';
			    appendSeparator;
			    appendItem: 'Remove' selector: #menuPoolRemove acceleratorString: '';
			    appendItem: 'Delete' selector: #menuPoolDelete acceleratorString: ''
		);
		font: SysFont;
		contents: #( 'Pool 1' 'Pool 2' 'Pool 3' ).
	mainView
		addSubpane: poolListBox;
		subPaneWithFocus: poolListBox.
	
	poolPathField "EntryField"
		owner: self;
		setName: 'poolPathField';
		when: #needsContents send: #poolPathNeedsContents: to: self withArgument: poolPathField;
		when: #textChanged: send: #poolPathChanged:pane: to: self withArgument: poolPathField;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 25 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 1/2; rightInset: 3 * xDU;
				bottomRatio: 0; bottomInset: -135/2 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: poolPathField.
	
	menuCategoryNewButton "Button"
		owner: self;
		setName: 'menuCategoryNewButton';
		when: #clicked send: #menuCategoryNew to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 3/2 * xDU;
				topRatio: 0; topInset: 7/2 * yDU;
				rightRatio: 1/2; rightInset: -31 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		contents: 'New...';
		startGroup;
		font: SysFont.
	mainView addSubpane: menuCategoryNewButton.
	
	menuCategoryAddSuggestedButton "Button"
		owner: self;
		setName: 'menuCategoryAddSuggestedButton';
		when: #clicked send: #menuCategoryAddSuggested to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 34 * xDU;
				topRatio: 0; topInset: 7/2 * yDU;
				rightRatio: 1/2; rightInset: -62 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		contents: 'Add...';
		startGroup;
		font: SysFont.
	mainView addSubpane: menuCategoryAddSuggestedButton.
	
	menuCategoryDeleteButton "Button"
		owner: self;
		setName: 'menuCategoryDeleteButton';
		when: #clicked send: #menuCategoryDelete to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 131/2 * xDU;
				topRatio: 0; topInset: 7/2 * yDU;
				rightRatio: 1/2; rightInset: -193/2 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		contents: 'Delete';
		startGroup;
		font: SysFont.
	mainView addSubpane: menuCategoryDeleteButton.
	
	categoryListBox "MultipleSelectListBox"
		owner: self;
		setName: 'categoryListBox';
		when: #changed: send: #categoryListChanged:pane: to: self withArgument: categoryListBox;
		when: #drawItem: send: #categoryListDrawItem:pane: to: self withArgument: categoryListBox;
		when: #needsContents send: #categoryListNeedsContents: to: self withArgument: categoryListBox;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 3/2 * xDU;
				topRatio: 0; topInset: 67/2 * yDU;
				rightRatio: 1; rightInset: 3 * xDU;
				bottomRatio: 0; bottomInset: -53 * yDU);
		extendedSelect;
		startGroup;
		setPopupMenu: (
			Menu new
			    title: '';
			    owner: self;
			    appendItem: 'New...' selector: #menuCategoryNew acceleratorString: '';
			    appendItem: 'Rename...' selector: #menuCategoryRename acceleratorString: '';
			    appendItem: 'Add suggested...' selector: #menuCategoryAddSuggested acceleratorString: '';
			    appendSeparator;
			    appendItem: 'File out...' selector: #menuCategoryFileOut acceleratorString: '';
			    appendItem: 'File out separately...' selector: #menuCategoryFileOutSeparately acceleratorString: '';
			    appendSeparator;
			    appendItem: 'Delete' selector: #menuCategoryDelete acceleratorString: '';
			    appendSeparator;
			    appendItem: 'Show all' selector: #menuCategoryShowAll acceleratorString: '';
			    appendItem: 'Show selected' selector: #menuCategoryShowSelected acceleratorString: ''
		);
		font: SysFont;
		contents: #( 'category 1' 'category 2' 'category 3' ).
	mainView addSubpane: categoryListBox.
	
	activeCategoryField "WBComboBox"
		owner: self;
		setName: 'activeCategoryField';
		addClipsiblingsStyle;
		when: #changed: send: #activeCategoryFieldChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 25 * xDU;
				topRatio: 0; topInset: 39/2 * yDU;
				rightRatio: 1; rightInset: 3 * xDU;
				bottomRatio: 0; bottomInset: -119/2 * yDU);
		dropDownList;
		addDynamicListSizeStyle;
		startGroup;
		font: SysFont.
	mainView addSubpane: activeCategoryField.
	
	categoryPathField "EntryField"
		owner: self;
		setName: 'categoryPathField';
		addClipsiblingsStyle;
		when: #needsContents send: #categoryPathNeedsContents: to: self withArgument: categoryPathField;
		when: #textChanged: send: #categoryPathChanged:pane: to: self withArgument: categoryPathField;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 25 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 1; rightInset: 3 * xDU;
				bottomRatio: 0; bottomInset: -135/2 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: categoryPathField.
	
	keyListBox "MultipleSelectListBox"
		owner: self;
		setName: 'keyListBox';
		when: #changed: send: #keyListChanged:pane: to: self withArgument: keyListBox;
		when: #drawItem: send: #keyListDrawItem:pane: to: self withArgument: keyListBox;
		when: #needsContents send: #keyListNeedsContents: to: self withArgument: keyListBox;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3 * xDU;
				topRatio: 0; topInset: 141/2 * yDU;
				rightRatio: 1/2; rightInset: 3 * xDU;
				bottomRatio: 1; bottomInset: 39/2 * yDU);
		extendedSelect;
		startGroup;
		setPopupMenu: (
			Menu new
			    title: '';
			    owner: self;
			    appendItem: 'New...' selector: #menuKeyNew acceleratorString: '';
			    appendItem: 'Rename...' selector: #menuKeyRename acceleratorString: '';
			    appendItem: 'Move...' selector: #menuKeyMove acceleratorString: '';
			    appendItem: 'Browse references...' selector: #menuKeyBrowseReferences acceleratorString: '';
			    appendSeparator;
			    appendItem: 'Delete' selector: #menuKeyDelete acceleratorString: ''
		);
		font: SysFont;
		contents: #( 'key 1' 'key 2' 'key 3' ).
	mainView addSubpane: keyListBox.
	
	menuKeyNewButton "Button"
		owner: self;
		setName: 'menuKeyNewButton';
		when: #clicked send: #menuKeyNew to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3 * xDU;
				topRatio: 1; topInset: -16 * yDU;
				rightRatio: 0; rightInset: -65/2 * xDU;
				bottomRatio: 1; bottomInset: 7/2 * yDU);
		contents: 'New...';
		startGroup;
		font: SysFont.
	mainView addSubpane: menuKeyNewButton.
	
	menuKeyDeleteButton "Button"
		owner: self;
		setName: 'menuKeyDeleteButton';
		when: #clicked send: #menuKeyDelete to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 36 * xDU;
				topRatio: 1; topInset: -16 * yDU;
				rightRatio: 0; rightInset: -67 * xDU;
				bottomRatio: 1; bottomInset: 7/2 * yDU);
		contents: 'Delete';
		startGroup;
		font: SysFont.
	mainView addSubpane: menuKeyDeleteButton.
	
	mainView addSubpane: editorCompositePane.
	
	activeCategoryLabel "StaticText"
		owner: self;
		setName: 'activeCategoryLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 3/2 * xDU;
				topRatio: 0; topInset: 21 * yDU;
				rightRatio: 1/2; rightInset: -25 * xDU;
				bottomRatio: 0; bottomInset: -29 * yDU);
		contents: 'Active';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: activeCategoryLabel.
	
	categoryPathLabel "StaticText"
		owner: self;
		setName: 'categoryPathLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 3 * xDU;
				topRatio: 0; topInset: 115/2 * yDU;
				rightRatio: 1/2; rightInset: -22 * xDU;
				bottomRatio: 0; bottomInset: -131/2 * yDU);
		contents: 'Path';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: categoryPathLabel.
	
	poolPathLabel "StaticText"
		owner: self;
		setName: 'poolPathLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3 * xDU;
				topRatio: 0; topInset: 115/2 * yDU;
				rightRatio: 0; rightInset: -22 * xDU;
				bottomRatio: 0; bottomInset: -131/2 * yDU);
		contents: 'Path';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: poolPathLabel.
	
	self createMenus: mainView! !

!GraphPane class methods ! 
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #button1Moved ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #button2DoubleClicked ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #button1Down ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #button2Moved ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #doubleClicked ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #button2Down ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #button1UpShift ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #button1DownShift ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #clicked: ;
                argumentNames: #('aPoint'));
        yourself! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!Object methods !   
owner: owner

    owner modelObjects add: self! !

!WBLayoutWizard class methods !
standardButtons

    ^StandardButtons ifNil: [StandardButtons := self initializeStandardButtons]! !

!WBChoosePaneDialog methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel mainView ok xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	classListBox := ListBox new.
	
		"Temporary Variables"
	cancel := Button new.
	ok := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Choose a class:';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -68 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -65 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -68 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -65 * yDU).
	self addView: mainView.
	
	classListBox "ListBox"
		owner: self;
		setName: 'classListBox';
		when: #doubleClicked: send: #selectedClass: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -132 * xDU;
				bottomRatio: 0; bottomInset: -106 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: classListBox;
		subPaneWithFocus: classListBox.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 110 * yDU;
				rightRatio: 0; rightInset: -40 * xDU;
				bottomRatio: 0; bottomInset: -126 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 44 * xDU;
				topRatio: 0; topInset: 110 * yDU;
				rightRatio: 0; rightInset: -80 * xDU;
				bottomRatio: 0; bottomInset: -126 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel! !

!WBHandle class methods !   
new

    ^super new initialize.! !

!WBPoolManagerWindow methods !
suggestedCategoriesPrim
	"Answer a collection of suggested categories."

	^#( 'Standard' 'Large' 'Small' )! !

!WBGeometryManager methods !  
clearSelections

    | selections |
    self hasSelections
        ifTrue: [
            selections := self selections.
            self layoutForm destroySelectedWidgets.
            self owner
                setDirty;
                updateOutboardWidgetsDestroyed: selections]! !

!WBLookPolicyWin95 methods !  
drawGroupBox: aGroupBox with: aPen clipRect: clipRect

    | rect textRect borderRect |
    rect := aGroupBox rect.
    aPen font: aGroupBox font.
    textRect := (rect leftTop right: 7) extentFromLeftTop:
        (aGroupBox font wbStringWidth: aGroupBox contents) + 4 @ (aGroupBox font height + 2).
    borderRect := (rect leftTop down: aGroupBox font height // 2) rightBottom: rect rightBottom.
    aPen
        foreColor: Color darkGray;
        wbLineFrom: borderRect leftTop to: (borderRect rightTop left: 2);
        wbLineFrom: borderRect leftTop to: (borderRect leftBottom up: 2);
        wbLineFrom: (borderRect leftBottom up: 2) to: (borderRect rightBottom leftAndUp: 2);
        wbLineFrom: (borderRect rightTop left: 2) to: (borderRect rightBottom leftAndUp: 2@1);
        foreColor: Color white;
        wbLineFrom: (borderRect leftTop rightAndDown: 1) to: (borderRect rightTop leftAndDown: 2@1);
        wbLineFrom: (borderRect leftTop rightAndDown: 1) to: (borderRect leftBottom rightAndUp: 1@2);
        wbLineFrom: (borderRect leftBottom up: 1) to: (borderRect rightBottom leftAndUp: 1);
        wbLineFrom: (borderRect rightTop left: 1) to: (borderRect rightBottom left: 1);
        fill: textRect color: aGroupBox backColor;
        foreColor: aGroupBox foreColor;
        backColor: aGroupBox backColor;
        setTextAlign: WBDisplayContext defaultTextAlign;
        winDrawText: aGroupBox contents in: textRect format: self class default centerJustification.! !

!WBLayoutFrameEditor methods ! 
paneTop

	^'Pane top'! !

!LayoutFrame methods !  
wbRightProportional
	"Answer true if the receiver is right proportional (inset = 0)."

	^(self propertyAt: #wbRightProportional) ifNil: [
		self wbRightProportional:
			(self rightInset = 0) & (self rightRatio ~= 0) & (self rightRatio ~= 1)]! !

!WBPoolManagerWindow methods !   
redrawKeys
	"Redraw the list of keys."

	keyListBox redraw.! !

!WindowBuilder methods ! 
menuEditTestWindow

    self tryToSaveChanges notNil
        ifTrue: [
            self setDefaultFonts.
            [[self editedClass wbTestOpenIn: self shell rect]
                on: Error
                do: [:ex |
                    MessageBox warning:
                        'An error was detected while launching this window: [' , ex description ,
                        ']. Please try launching the window from the Transcript and correct the error. Hold the ALT key down when clicking OK to see the full walkback.'.
                    Notifier isAltKeyDown
                        ifTrue: [ex pass]
                        ifFalse: [self dumpErrorToTranscript: ex].
                    ^nil]] ensure: [self sendInputEvent: #resetFonts]].! !

!WBLayoutWizard methods !  
loadStandardButtons

    (self paneNamed: 'standardButtonsList')
        contents:
            (self class defaultButtons asArray),
            ((self class standardButtons reject: [:str |
                self class defaultButtons includes: str]) asArray);
        setValue: self class defaultButtons! !

!WindowBuilder methods !
menuSizeSetWindowSize
    "Prompt the user for a new window size"

    | answer |
    (answer := self
        getPointPrompting: 'New Window Size:'
        defaultPoint: self prototype shell extent) ifNil: [^nil].
    self setWindowSize: answer.! !

!WindowBuilder methods !   
menuScrapbookNew

	(MessageBox confirm: 'Are you sure that you want to throw out the old scrapbook and create another?')
		ifTrue: [
			self class scrapbook: nil.
			self updateQuickReferenceMenu]! !

!WBPoolManagerWindow methods !
showPath
	"Hide the category and pool path fields."

	| pane listBox |
	(listBox := self paneNamed: 'poolListBox') framingBlock
		bottomInset: poolListBoxFramingBlock bottomInset.
	listBox isHandleOk ifTrue: [listBox resize: self mainView rectangle].
	(self paneNamed: 'poolPathLabel') showWindow.
	(pane := self paneNamed: 'poolPathField') showWindow.
	
	(listBox := self paneNamed: 'categoryListBox') framingBlock
		bottomInset: categoryListBoxFramingBlock bottomInset.
	listBox isHandleOk ifTrue: [listBox resize: self mainView rectangle].
	(self paneNamed: 'categoryPathLabel') showWindow.
	(pane := self paneNamed: 'categoryPathField') showWindow.

	self optionMenu
		checkItem: #menuOptionShowPath.! !

!WBPoolManagerWindow methods !
menuCategoryFileOutSeparately: aDirectory
	"File out the selected pools and categories."

	| stream |
	CursorManager execute changeFor: [
		self selectedPools do: [:eachPool |
			self selectedCategories do: [:eachCategory |
				stream := File newFile: (eachPool fileNameFor: eachCategory) in: aDirectory.
				[eachPool fileOutCategories: (Array with: eachCategory) on: stream
				] ensure: [stream close]].
			stream := File newFile: eachPool fileName in: aDirectory.
			[eachPool fileOutCategoryFileNames: self selectedCategories on: stream
			] ensure: [stream close]]].! !

!WBInterfaceObject methods !   
framingBlock: framer

    framingBlock := framer! !

!WindowBuilder class methods !   
devBitmapFileName
	"Answer the name of the available development bitmap DLL."

	DevBitmapFileName isNil
		ifTrue: [
			DevBitmapFileName := self devBitmapFileNames
				detect: [:each | (File findFileName: each) notNil]
				ifNone: [self devBitmapFileNames first]].
	^DevBitmapFileName! !

!WBKeyEntryField class methods !   
supportedEvents
        "Answer the Set of events that EntryFields can notify
         their owners about."
    ^super supportedEvents
        add: #keyEntered;
        yourself! !

!WindowFrameObject methods ! 
addSubpane: aWidget
    "Windows import."
    children add: aWidget! !

!PAnimationPane methods ! 
styles

    ^#(#defaultStyle #noBorders)! !

!WBDevelopmentWindow class methods ! 
isWBInternalClass

    ^true! !

!WindowBuilder class methods !   
propertyAt: aSymbol

    | category |
    (category := self categoryWithProperty: aSymbol) ifNil: [^nil].
    ^category at: aSymbol ifAbsent: [nil]! !

!WBAttributeEditor methods !
stringFromBitmap: aStringOrBitmap

	^WBBitmaps 
		keyAtValue: aStringOrBitmap 
		ifAbsent: [aStringOrBitmap].! !

!WBLayoutWizard methods ! 
loadStandardMenus

    (self owner notNil and: [self owner shell isNonWindowParent])
        ifTrue: [
            (self paneNamed: 'standardMenusGroup') disable.
            (self paneNamed: 'standardMenusList') disable; backColor: Color gray.
            (self paneNamed: 'otherMenuButton') disable.
            (self paneNamed: 'setDefaultStandardMenusButton') disable]
        ifFalse: [
            (self paneNamed: 'standardMenusList')
                contents:
                    (self class defaultMenus asArray),
                    ((self class standardMenus reject: [:str |
                        self class defaultMenus includes: str]) asArray);
                setValue: self class defaultMenus]! !

!WBPoolManager methods !   
edit
    "Open a pool manager window on the receiver."

    self editorClass new openOn: self.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutFrameEditor methods !   
updateExample: aPane frameRect: aRectangle

	| multiplier frameRect paneRects leftTop extent rect |
	aRectangle isNil ifTrue: [^aPane paneRect: nil].
	multiplier := aPane extent / aRectangle extent.
	multiplier := multiplier x min: multiplier y.

	leftTop := aPane rectangle leftTop.
	extent :=  (aRectangle extent * multiplier) rounded.
	frameRect := leftTop extentFromLeftTop: extent.

	paneRects := self currentFramingBlocks collect: [:each |
		rect := each value: aRectangle.
		leftTop := aPane rectangle leftTop rightAndDown: (
			(aRectangle leftTop distanceRightAndDown: rect leftTop) * multiplier) rounded.
		extent := (rect extent * multiplier) rounded.
		leftTop extentFromLeftTop: extent].

	aPane
		frameRect: frameRect;
		paneRect: paneRects.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBAttributeWindow methods !   
checkUpdate
		"Check to see if the receiver needs updating."
	ownerChanged ifTrue: [
		ownerChanged := false.
		self update ].! !

!PEnhancedEntryField methods !   
case

    ^case! !

!WBTemplateEditor methods !   
textEditor

	^textEditor! !

!WBLookPolicy methods !  
displayWithRightScrollBar: aPen rect: aRect backColor: aColor

	| innerRect newInnerRect backColor |
	backColor := (self class isDefault not 
		and: [(self asRGBColor: aColor) = (self asRGBColor: self defaultOS2WidgetBackColor)])
		ifTrue: [self defaultWidgetBackColor]
		ifFalse: [aColor].
	innerRect := self displayWithBorder: aPen rect: aRect backColor: backColor.
	newInnerRect := innerRect leftTop rightBottom: (innerRect rightBottom left: self scrollBarWidth).
	self
		drawVScrollBarWith: aPen
		at: (newInnerRect rightTop
			rightBottom: (innerRect rightBottom)).
	^newInnerRect! !

!WBScrollBarEditor methods ! 
initWindow

    (self paneNamed: 'lineInc') contents: thePane lineIncrement asString.
    (self paneNamed: 'pageInc') contents: thePane pageIncrement asString.
    (self paneNamed: 'minimum') contents: thePane minimum asString.
    (self paneNamed: 'maximum') contents: thePane maximum asString.! !

!WBEditClassDialog methods !   
clearMostRecent

    "Callback for the #clicked event triggered in the Button named 'clearMostRecent'.
     (Generated by WindowBuilder)"

	Notifier isAltKeyDown
		ifTrue: [
			self class recentClasses remove: 
				(Smalltalk at: (mostRecent selectedItem ifNil: [^nil]) asSymbol ifAbsent: [^nil]).
			mostRecent text: '']
		ifFalse: [self class clearRecentClasses].
    self loadMostRecent.
	selectedClass := self mostRecentList isEmpty
		ifTrue: [nil]
		ifFalse: [Smalltalk at: (mostRecent selectedItem ifNil: [^nil]) asSymbol ifAbsent: [^nil]].
	self setWindowTitle.! !

!WBEventMessage methods !   
event
	"Answer the receiver's event."

	^event! !

!WBEventManagerWindow methods !   
eventSelected
    "Answer the currently selected event if exactly one is selected,
        else answer nil."

    ^self eventSelections size = 1
        ifTrue: [self eventSelections first]
        ifFalse: [nil]! !

!BitEditor methods ! 
save
    imageForm pen copyBitmap: copy
        from: copy boundingBox
        at: imageRect origin! !

!WBModelDefinitionEditor methods !   
disableFields

    name disable; backColor: Color gray; contents: self emptyString.
    (self paneNamed: 'nameLabel') foreColor: Color darkGray.
    myClass disable; backColor: Color gray; selectItem: 'Object'.
    (self paneNamed: 'classLabel') foreColor: Color darkGray.
    hasAccessors disable; selection: false.
    initialized disable; selection: false.
    lazy disable; selection: false.
    initializeValue disable; backColor: Color gray; contents: self emptyString.
    (self paneNamed: 'otherClassButton') disable.
    hasEvent disable; selection: false.! !

!WBChooseClassDialog class methods !   
isWBInternalClass

    ^true! !

!WBScrapbookRetrieve methods !   
remove

    chapter isNil ifFalse: [
        page isNil ifFalse: [
            (MessageBox confirm: 'Are you sure you want to remove the page: ''',page,'''?') ifTrue: [
                (scrapbook at: chapter) removeKey: page ifAbsent: [nil].
                chapter = 'Quick Reference' ifTrue: [ removedQuick := true ].
                self getChapter: (self paneNamed: 'chapters') selectedItem
            ].
        ] ifTrue: [
            (MessageBox confirm: 'Are you sure you want to remove the chapter: ''',chapter,'''?') ifTrue: [
                scrapbook removeKey: chapter ifAbsent: [nil].
                self loadChapters: (self paneNamed: 'chapters').
                self getChapter: (self paneNamed: 'chapters') selectedItem
            ].
        ].
    ]! !

!WBDevelopmentWindow methods !  
noTextString

	^'<No Text>'.! !

!BitEditor methods ! 
initImagePen: aPane
    imagePen := aPane pen! !

!WBPoolManagerWindow methods !   
keyMenu

	^self menuTitled: 'Key'! !

!WBTargetObject methods !   
handlers

	^oldHandlers ifNil: [
		oldHandlers := OrderedCollection new]! !

!WindowBuilder methods !
performTextLosingFocus: aPane

	(thePane notNil
		and: [self currentEventIsTriggered
		and: [aPane contents hasContent not
		and: [thePane removeFirstEventHandlerAt: self currentEvent]]])
	ifTrue: [
		aPane contents: (thePane eventHandlerSelectorAt: self currentEvent).
		self updateEvents: true.
		self layoutFormChanged].! !

!PStatusPane methods ! 
copySpecificsTo: aPane

    aPane statusBoxes: self statusBoxes.! !

!WBFramingEditor methods !   
initInstVars

    xCenteredCheckBox := (self paneNamed: 'xCenteredCheckBox').
    yCenteredCheckBox := (self paneNamed: 'yCenteredCheckBox').
    originXStyleFixed := (self paneNamed: 'originXStyleFixed').
    originXStyleScaled := (self paneNamed: 'originXStyleScaled').
    originXAnchor := (self paneNamed: 'originXAnchor').
    cornerXStyleFixed := (self paneNamed: 'cornerXStyleFixed').
    cornerXStyleScaled := (self paneNamed: 'cornerXStyleScaled').
    cornerXAnchor := (self paneNamed: 'cornerXAnchor').
    originYStyleFixed := (self paneNamed: 'originYStyleFixed').
    originYStyleScaled := (self paneNamed: 'originYStyleScaled').
    originYAnchor := (self paneNamed: 'originYAnchor').
    cornerYStyleFixed := (self paneNamed: 'cornerYStyleFixed').
    cornerYStyleScaled := (self paneNamed: 'cornerYStyleScaled').
    cornerYAnchor := (self paneNamed: 'cornerYAnchor').
    afterRect := (self paneNamed: 'afterRect').
    beforeRect := (self paneNamed: 'beforeRect').
    bottomRelative := (self paneNamed: 'bottomRelative').
    rightRelative := (self paneNamed: 'rightRelative').
    leftRelative := (self paneNamed: 'leftRelative').
    topRelative := (self paneNamed: 'topRelative').! !

!WBAbstractCreateViewsModule methods ! 
defaultMessageSelector
		"Private - Answer the default message selector."
	^#createViews! !

!Window methods !
nameForInstVar: sym
        "Private - WBPro Development."
    #addedByOSI.
    self paneName: sym! !

!WBPrototype methods !
primaryModel

    ^self targetObject primaryModel! !

!Window methods !   
wbFramingBlock
		"Private - Answer the framingBlock for the receiver; reimplemented
		in subclasses (TopPane, SubPane)."
	#addedByOSI.
	^self framingBlock! !

!PComboBox methods ! 
style: aStyle

    super style: aStyle.
    (self editor ifNil: [^nil]) layoutForm updateWidget.! !

!WBMenuItem methods !   
updateAttributes: attributesMask
        "Private - Send a message to the receiver to set its attributes."
    self window isNil ifTrue: [^self].
    attributesMask = (MfChecked | MfUnchecked)
        ifTrue: [
            ^UserLibrary
                checkMenuItem: self window handle
                item: self id
                flags: self attribute | MfBycommand].
    attributesMask = MfGrayed
        ifTrue: [
            ^UserLibrary
                enableMenuItem: self window handle
                item: self id
                flags: self attribute | MfBycommand].! !

!WindowBuilder class methods !  
openPrompt

    ^self openOn: (WBEditClassDialog new open selectedClass ifNil: [^nil]).! !

!WBMenuEditor methods !   
initWindow

	(self paneNamed: 'listEntryField') owningListBox: menuItemsEditor.
	self initializeOn: editedMenu.
	self wbEditorClass supportsActionAndLinkButtons
		ifFalse: [
			(self paneNamed: 'actionButton')
				hideWindow;
				disable.
			(self paneNamed: 'linkButton')
				hideWindow;
				disable].
	! !

!WBLayoutForm methods !
button1DoubleClick: aPoint
        "Private - button 1 has been double clicked."

    self triggerEvent: #editPane.
    ! !

!EntryField class methods !
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #entered: ;
                argumentNames: #('aString'));
        wbAddEvent: (
            WBEventDescription new
                event: #changed: ;
                argumentNames: #('aString'));
        wbAddEvent: (
            WBEventDescription new
                event: #textChanged: ;
                argumentNames: #('aString'));
        wbAddEvent: (
            WBEventDescription new
                event: #aboutToChangeTo: ;
                argumentNames: #('aString'));
        yourself! !

!WBCreateViewModule methods !  
useInstVars
		"Answer true if the receiver should generate instVar references."
	^super useInstVars and: [ self targetClass isScratchWindow not ]! !

!WBKeyEntryField methods !  
initialize

    super initialize.
    accelerator := WBKeyAccel new.! !

!WBCodeGenerator methods !  
generateCodeUsing: aCodeModuleOrCollection
    "Generate the code."

    (aCodeModuleOrCollection isCollection
        ifTrue: [aCodeModuleOrCollection]
        ifFalse: [Array with: aCodeModuleOrCollection])
            do: [:each | self addModule: each].
    self
        generateCode;
        cleanup;
        createClasses;
        createMethods.! !

!WBPMenu methods !
printOn: aStream

    aStream nextPutAll: 'a ', self class name.! !

!WBModelInstVar methods !
initializeValue

    ^initializeValue! !

!PEntryField methods !  
reframe: parentRect

	super reframe: parentRect.
	rect extent: ((rect extent max: self minSize) min: self maxSize)! !

!WindowBuilder methods !  
textChanged: aString

    | nlsString nlsKey nlsPool |
    thePane isNil ifTrue: [^nil].
    titleEditor setPopupMenu: nil.
    nlsString := aString.
    (aString notEmpty and: [aString first == $#])
        ifTrue: [
            nlsKey := aString copyFrom: 2 to: aString size.
            self shell nlsPools detect: [:sym |
                (nlsString := (nlsPool := Smalltalk at: sym)
                    at: nlsKey
                    ifAbsent: [nlsString := nlsPool
                        at: nlsKey asSymbol
                        ifAbsent: [aString]]) ~= aString]
                ifNone: []].
    thePane usesTitle & (thePane text == nlsString) not
        ifTrue: [
            thePane text: nlsString.
            self layoutForm updateTitle: thePane.
            self layoutFormChanged.
            self layoutForm checkMnemonicConflicts.
            (self autoSize and: [thePane changesSize and: [self selections size < 2]])
                ifTrue: [
                    self geometryManager autoSize.
                    self updateEvents: false]].
    ! !

!WBModelObjectEditor methods ! 
whenChanged: selectedObject

    self updateSend: self selectedObject! !

!WBEnhancedAttributeEditor methods !
initField: anAccessor pane: aPane
	"Initialize the contents of aPane."

	| value |
	anAccessor isNil | aPane isNil ifTrue: [^self].
	value := anAccessor wbGetValueFor: thePane wbRealWidget.
	aPane value: value.! !

!WindowBuilder class methods ! 
generatePortableFontCode

    ^self runtimeLessCode or: [
        self editorClass
            propertyValueAt: #GeneratePortableFontCode
            category: self codeGenerationPropertyString].! !

!SubPane class methods !   
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #help ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #mouseMoved: ;
                argumentNames: #('aPoint'));
        wbAddEvent: (
            WBEventDescription new
                event: #resized ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #gettingFocus ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #needsMenu ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #needsSelection ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #losingFocus ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #needsContents ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #rightClicked ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #backTabbed ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #display ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #tabbed ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #needsPopupMenu ;
                argumentNames: #( ));
        yourself! !

!WBTreeNode methods !   
nonHierarchicalPosition

    self isRoot ifTrue: [
        ^0
    ].

    ^parent nonHierarchicalPosition + self siblingPosition! !

!WBMenubarEditor methods !   
allowDividerFor: anItem

    ^(super allowDividerFor: anItem) & anItem parent isRoot not.! !

!WBUndoManager methods !
add: aWBUndoAction

    | maxUndoLevels |
    self owner isNil ifTrue: [^aWBUndoAction].
    current == undoList size
        ifFalse: [undoList := self undoableActions].
    undoList addLast: aWBUndoAction.
    current := current + 1.
    current > (maxUndoLevels := self class maxUndoLevels)
        ifTrue: [
            undoList := undoList removeFirst; yourself.
            current := maxUndoLevels].
    self
        setUndoLabel: self undoString, ' ', aWBUndoAction label;
        setUndoState: true;
        setCantRedo.
    ^aWBUndoAction! !

!Toggle class methods !
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbRemoveEventNamed: #clicked ;
        wbAddEvent: (
            WBEventDescription new
                event: #clicked: ;
                argumentNames: #('aBoolean'));
        yourself! !

!WBEditClassDialog class methods !  
addToFilterList: aClass

    self filterList add: aClass name before: self nonWBChoice! !

!WBLookPolicy methods !
drawTitleBarText: aFrameObject with: aPen in: aRect

    | titleRect |
    titleRect := aRect leftTop extentFromLeftTop: aRect width @ (self titleBarHeightFrom: aFrameObject).
    aFrameObject hasTitleBar
        ifTrue: [
            aPen
                fill: titleRect color: Color darkBlue;
                font: SysFont;
                foreColor: Color white;
                backColor: Color darkBlue;
                setTextAlign: TaTop;
                centerWinText: aFrameObject contents at: titleRect center].! !

!PRadioButton methods !   
displayWith: aPen clipRect: aRect

    self lookPolicy
        drawRadioButton: self
        with: aPen
        clipRect: aRect! !

!PEntryFieldGroup methods !
label: aString

	| gb |
	label := aString.
	self children isEmpty
		ifFalse: [
			gb := self children detect: [:child | child isKindOf: PGroupbox] ifNone: [nil].
			gb isNil ifFalse: [gb contents: aString]].! !

!WBCreateViewsModule methods !   
generateView: aView selector: aSymbol index: anInteger
        "Generate the code..."
	self addModule: (
		self createViewModuleClass new
			targetClass: self targetClass;
			messageSelector: aSymbol;
			object: self object;
			view: aView;
			viewIndex: anInteger;
			yourself ).! !

!WBToolBarEditor methods !
drawItem: drawIndex pane: aPane

    | element |

    element := elements at: drawIndex.
    element pen: nil.
    aPane pen
        fill: aPane drawBox color: Color white;
        copy: element pen
        from: element boundingBox
        to: ((aPane drawBox origin + 2) extent: element rectangle extent);
        setTextAlign: WBDisplayContext defaultTextAlign;
        font: SysFont;
        displayText: (element selector asString)
			at: aPane drawBox origin
				+ ((element rectangle width + 6)
					@ (3 * Rectangle leftTopUnit y + 2))! !

!WBCreateBitmap methods !   
setDefaultSize

	"Callback for the #clicked event in defaultSizeButton [Button].
		(Generated by WindowBuilder Pro)"

	self bitmapWidth: self class defaultBitmapWidth.
	self bitmapHeight: self class defaultBitmapHeight.! !

!WBTabOrderLayoutForm methods !   
handleColor

    ^Color red! !

!LayoutFrame methods !
asFramingBlockForDialogTopPaneFromWindow

	"The framingBlock for DialogTopPane and TopPane are passed 
		a rectangle in pixels.  DialogTopPane expects its framingBlock to
		return dialog units whereas TopPane expects its framingBlock to return pixels.
		Convert the insets from pixels to dialog units and skew the ratios
		so that when they are multiplied against the input (a rectangle in pixels),
		they will return a ratio *and* convert the pixels to dialog units."

	| xDU yDU |
	"xDU := (WindowDialog dialogUnit x / WindowDialog unitMultiplier x * 2) ceiling / 2."
	"xDU := WindowDialog dialogUnit x / WindowDialog unitMultiplier x."
	"yDU := WindowDialog dialogUnit y / WindowDialog unitMultiplier y."

	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.

			"The inset conversion is done during code generation"

	^self wbCopy
		leftRatio: self leftRatio / xDU;
		topRatio: self topRatio / yDU;
		rightRatio: self rightRatio / xDU;
		bottomRatio: self bottomRatio / yDU;
		yourself! !

!WBPrimaryModelModule methods !
targetClass
        "Answer the receiver's target class."
    ^super targetClass isMetaClass
        ifTrue: [super targetClass]
        ifFalse: [super targetClass class]! !

!WBTabPosition methods !
printOn: aStream

    aStream nextPutAll: basicTabPosition asString.
    groupPosition notNil ifTrue: [
        aStream nextPutAll: '.', groupPosition asString.
    ].! !

!WBLookPolicyWin95 class methods ! 
radioBitmap

    ^RadioBitmap ifNil: [RadioBitmap := WBBitmapClass new fromSysID: ObmCheckboxes]! !

!WBMultiToolPalette methods !
aboutToSaveImage

    self pages do: [ :page |
        page do: [ :tool | tool pen: nil ]
    ].! !

!WBModelInstVar methods !  
generatedSymbol

    ^#generated! !

!WindowBuilder methods ! 
openCompositePane

    self editedClass: WBCompositePaneScratchWindow.
    self open.! !

!WBGraphicObject methods ! 
lastRect: aRect

    lastRect := aRect! !

!String methods !  
wbManagedValueFor: anOwner
	"Answer a new value manager for the receiver."

	^WBManagedPNLSString for: anOwner value: self! !

!WBTemplateEditor methods !   
selections

	^Array with: template! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBNLSDictionaryReader class methods !
fileOutToken: aToken value: aString on: aStream
	"File out a token/value pair."

	^self fileOutToken: aToken value: aString indent: 0 on: aStream! !

!FrameObject methods ! 
editor: aWindowBuilder

	editor := aWindowBuilder! !

!PWBToolBar methods !   
attributeEditor

    ^WBToolBarEditor! !

!WBModelGetModule methods ! 
defaultComment
        "Answer the default comment string."
    ^'Answer the value of ', self object name, '.',
        super defaultComment! !

!WBUndoRedoDialog methods ! 
cancel

	self close! !

!WBLookPolicyWin95 methods !  
drawEntryField: anEntryField with: aPen clipRect: clipRect

	| innerRect contents region displayContents justification backColor |
	backColor := (self class isDefault not
		and: [(self asRGBColor: anEntryField backColor) = (self asRGBColor: anEntryField defaultBackColor)])
		ifTrue: [self defaultWidgetBackColor]
		ifFalse: [anEntryField backColor].
	innerRect := (self
		displayWithBorder: aPen
		rect: anEntryField rect
		backColor: backColor) insetBy: 1.
	"Draw the initialization text"
	(contents := anEntryField contents) isNil
		ifFalse: [
			displayContents := (anEntryField style == #password)
				ifTrue: [contents copy atAllPut: $*]
				ifFalse: [contents].
			justification := anEntryField justification == #left
				ifTrue: [self class default leftJustification]
				ifFalse: [
					anEntryField justification == #right
						ifTrue: [self class default rightJustification]
						ifFalse: [self class default centerJustification]].
			region := aPen setClipRect: innerRect.
			aPen
				font: anEntryField font;
				foreColor: anEntryField foreColor;
				backColor: anEntryField backColor;
				setTextAlign: WBDisplayContext defaultTextAlign;
				winDrawText: displayContents in: innerRect format: justification.
			aPen destroyRegion: region].! !

!WBManagedPValue methods !   
value: anObject

	value := anObject.
	self updateKey.! !

!WBAttributeWindow methods !   
ownerChanged
		"The receiver's owner has changed."
	ownerChanged ifFalse: [
		(Message receiver: self selector: #checkUpdate) performDeferred.
		ownerChanged := true ].! !

!WBClassDefinition methods !   
instVarNames
		"Answer a collection of instance variable names."
	^instVarNames ifNil: [ instVarNames := self basicInstVarNames ]! !

!WindowFrameObject methods !
wbCopyTo: copy

	super wbCopyTo: copy.
	copy paneName: self paneName.! !

!WindowBuilder methods !   
menuOptionsAutoUpdateOutboards

    self class togglePropertyValueAt: #AutoUpdateOutboards.
    self updateOptionsMenu.! !

!WBPropertyManager class methods !   
reinitialize
	"Reset a dictionary of managers mapping
		class name to attribute manager."

	"
	WBPropertyManager reinitialize.
	"

	managers := nil.! !

!PScrollBar methods !  
minimum: min

    minimum := min! !

!WindowBuilder class methods !   
recordCreatorInformation

    ^self editorClass
        propertyValueAt: #RecordCreatorInformation
        category: self codeGenerationPropertyString.! !

!WBAbstractCodeModule methods ! 
targetClass
		"Answer the receiver's target class."
	^targetClass! !

!WBModelInstVar methods !   
hasAccessors: aBoolean

    hasAccessors := aBoolean! !

!WBTabOrderEditor methods !  
result

	^result ifNil: [true].! !

!WBBitmapManagerWindow methods !  
menuBitmapFileOutBitmapFile4

	| aBitmap |
	(aBitmap := self selectedValue) isBitmap ifFalse: [^self].
	self menuBitmapFileOutBitmapFile: aBitmap wbCopy4 key: self selectedKey.! !

!WBLayoutFrameEditor methods ! 
attachRightTop

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: #(1 0 1 0).! !

!WBAddInManager methods !  
install

	| addIn |
	(addIn := WBAbstractAddInModule allSubclasses 
		detect: [:class | selection = class commonName]
		ifNone: [nil]) notNil
			ifTrue: [addIn loadAddIn]
			ifFalse: [
				self wbEditorClass
					perform:
						(self wbEditorClass listAddIns detect: [:sym |
							(self wbEditorClass perform: sym with: #name) = selection])
					with: nil].
	changed := true.
	self loadList! !

!WBUndoManager methods !  
owner

    ^owner! !

!WBLookPolicy methods ! 
drawVScrollBarWith: aPen at: aRect

    | thumbRect nonThumbRect upArrowRect downArrowRect arrowHeight |
    arrowHeight := self scrollBarArrowHeight.
    upArrowRect := (aRect leftTop rightBottom: aRect right @ (aRect top down: arrowHeight)).
    downArrowRect := (aRect left @ (aRect bottom up: arrowHeight) rightBottom: aRect rightBottom).
    thumbRect := aRect left @ (aRect top down: arrowHeight) rightBottom: aRect right @ (aRect top down: self scrollBarThumbHeight + arrowHeight).
    nonThumbRect := aRect left @ (aRect top down: arrowHeight + self scrollBarThumbHeight) rightBottom: aRect right @ (aRect bottom up: arrowHeight).
    self
        drawUpArrowWith: aPen at: upArrowRect;
        draw3DBoxWith: aPen at: thumbRect;
        drawDownArrowWith: aPen at: downArrowRect.
    aPen fill: nonThumbRect color: self scrollBarColor.
    ^nonThumbRect! !

!WindowBuilder class methods !  
openFontManager

    self runtimeLessPoolManagerWarning.
    (Notifier isControlKeyDown
        ifTrue: [WBFontManager system]
        ifFalse: [WBFontManager current]) edit.! !

!WBMenu methods !   
uncheckAll
        "Uncheck all items for the receiver."
    items do: [:mi | mi uncheck].! !

!PStatusPane methods ! 
usesFraming

    ^false! !

!WBCreateClassDialog methods !
result

    ^newClass! !

!PTextPane methods !
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	eventSymbol == #changed: ifTrue: [^#('aString')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!Object methods !   
wbFullCopy
	"Answer a full copy of the receiver."

	#addedByOSI.
	^self wbFullCopy: IdentityDictionary new! !

!WBEventManagerWindow methods !  
eventListUpdate

	eventListBox update.
	self handlerListUpdate.
	self zap.! !

!WindowBuilder class methods !   
gridSize: aPoint

    ^self editorClass
        propertyValueAt: #GridSize
        category: self gridPropertyString
        put: aPoint.! !

!WindowBuilder methods ! 
menuToolsInitializeExtras

    self class clearExtras.! !

!WBBitmapSubPool methods ! 
fileOutRef: anAssociation fileName: aFileName ids: idMap on: aStream
	"File out the specified key/value pair."

	aStream
		next: 4 put: $ ;
		nextPutAll: anAssociation key;
		next: (40 - anAssociation key size max: 1) put: $ ;
		nextPutAll: (
			anAssociation value isOperatingSystemBitmap
				ifTrue: ['*']
				ifFalse: [aFileName]);
		nextPut: $ ;
		nextPutAll: (idMap at: anAssociation key) printString;
		cr.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPoolManagerWindow methods !   
menuPoolRemove

    "Callback for the menu item titled 'Remove'.
     (Generated by WindowBuilder)"

	| msg |
	self selectedPools isEmpty ifTrue: [^self].
	msg := self selectedPools size = 1
		ifTrue: [ 'Remove the pool named ', self selectedPools first poolName, '?' ]
		ifFalse: [ 'Remove ', self selectedPools size printString, ' pools?' ].
	(MessageBox confirm: msg) ifFalse: [^self].
	[self menuPoolRemove: self selectedPools]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].! !

!WBUndoRedoDialog methods !  
initWindow

    super initWindow.
    levels contents: WBUndoManager maxUndoLevels asString.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLookPolicyOS2 methods ! 
scrollBarThumbHeight

	^scrollBarThumbHeight ifNil: [
		scrollBarThumbHeight := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCyvslider" 31]
			ifFalse: [super scrollBarThumbHeight]]! !

!PRealWidgetControl methods !
storeStyleOn: aStream indentString: spaceString
    "Do Nothing"! !

!WindowBuilder class methods !
openTemplateEditor

	WBTemplateEditor new open! !

!WBTeamVCodePolicy class methods ! 
defaultToolInterface
		"Answer the Team/V tool interface."
	^self teamInterface toolInterface! !

!WBTreeNode methods !   
fullCopyTo: copy  withParent: aParent

    | new |

    copy setChildren: (
        children collect: [ :c |
            new := c class new.
            c fullCopyTo: new withParent: copy.
            new
        ]
    ).

    copy setCurrentString: currentString.
    copy setListString: listString wbManagedValue.
    copy setParent: aParent.
    self copySpecificsTo: copy.! !

!WBAbstractCodeModule methods ! 
defaultMessageArguments
		"Private - Answer the default message selector arguments."
	^#( )! !

!WBInstVarSetModule methods ! 
defaultComment
		"Answer the default comment string."
	^'Set the value of ', self object, ' to <anObject>.
		(Generated by WindowBuilder Pro)'! !

!WBTreeListBox methods !  
exdent

    self selectedItem exdent.
    owningEditBox setFocus.! !

!WBMenu methods !  
insertItem: anObject
    selector: aSelector
    accelKey: aCharacter
    accelBits: afBits
    after: anInteger
        "Insert an item with label anObject and
         selector aSelector and accelerator described
         by aCharacter and afBits to the receiver menu
         after item anInteger.  aCharacter is the asciiValue
         of the accelerator key.  afBits is one or more of
         the following from the VirtualKeyConstants pool dictionary:
            AfAlt, AfChar, AfControl, AfHelp, AfLonekey, AfShift
            AfSyscommand, AfVirtualkey.
        anObject may be either a String, a Bitmap, or an Integer
        (a 32-bit value to associate with an owner-drawn item)."
    | mi style |
    style := anObject isInteger
        ifTrue: [MfOwnerdraw]
        ifFalse: [
            anObject isString
                ifTrue: [MfString]
                ifFalse: [MfBitmap]].
    (mi := self menuItemClass new)
        position: anInteger;
        style: style;
        attribute: 0;
        id: 0;
        selector: aSelector;
        label: (self fixUnderScoreChar: anObject);
        menu: self.
    items add: mi.
    accel add: (self accelArray: aCharacter accelBits: afBits).
    ^mi! !

!WBPoolManagerWindow methods ! 
updatePoolPath

	poolPathField update.
	self updateCategoryPath.! !

!WBGraphicObject class methods !
example

	| example |
	example := self new.
	example rect: (0@0 extent: 300@200).
	^example! !

!WBTabOrderLayoutForm methods !
allWidgetsContainedIn: grouper

	^self 
		widgetsFrom: (self children reject: [:widget | widget isGrouper])
		containedIn: grouper
		testBlock: [:widget | widget usesFocus & widget isGroupable].! !

!WBInterfaceObject methods !
oldEventHandlersDo: aBlock
	"Evaluate aBlock with each of the old event handlers of the receiver."

	(self wbRealWidget handlersOrNil ifNil: [^self]) associationsDo: aBlock.! !

!WBKeyAccel methods !  
isAlt: bool

    isAlt := bool! !

!WBLayoutForm methods !
selectedRect
    "Answer the rectangle encompassing all the selections."

    ^self boundingBoxFor: self selections! !

!PVideoPane methods !
usesFont

    ^false! !

!WBEditClassDialog methods ! 
envyApplicationList

    ^OrderedCollection new
        add: self class defaultChoice;
        addAll: self envyApplicationChoices;
        yourself.! !

!WBInterfaceObject methods ! 
updateWidget

    (self layoutForm ifNil: [^nil])
        updateRect: self hitRect! !

!PropertyManager methods !
wbEvents
	"Answer the event definitions."

	#addedByOSI.
	^(self propertyAt: #wbEvents) ifNil: [Dictionary new]! !

!WBOutboardAttributeWindow methods !
applyChange
	"Perform the action."
! !

!WBLookPolicy methods !   
drawRightArrowWith: aPen at: aRect

    | innerRect side |
    innerRect := self draw3DBoxWith: aPen at: aRect.
    side := (innerRect width min: innerRect height) // 7.
    aPen
        polygonFilled: (Array
            with: (innerRect center right: side)
            with: (innerRect center leftAndUp:  (side + 1) @ (side * 2 + 1))
            with: (innerRect center leftAndDown:  (side + 1) @ (side * 2 + 1))).! !

!WBTabOrderLayoutForm methods !
standardTestBlock

	^[:widget | 
		widget usesFocus 
		and: [widget staysToBack not 
		and: [widget isGroupable]]].! !

!WBGraphicObject methods ! 
initialize

    rect := 0@0 extent: 0@0! !

!GroupBox class methods ! 
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
		add: (
			SelectorPropertyAccessor new
				name: 'Label';
				get: #label ;
				set: #label: ;
				format: 'String' ;
				wbNLSAccessor: true;
				wbStore: nil );
		yourself! !

!WBLayoutForm methods ! 
updateWidget

	self isHandleOk 
		ifTrue: [
			self propertyAt: #hideHandles put: false.
			self invalidateRect: self shell frameContentRect erase: false].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PButton methods !
isGroupable

    ^true! !

!WBListEntryField class methods !  
isWBInternalClass

    ^true! !

!WBGeometryManager methods ! 
hasChildren

    ^self children notEmpty! !

!WindowBuilder methods ! 
menuOptionsLookPolicyWin95

    self class lookPolicy: WBLookPolicyWin95.
    self shell backColor asRGBColor = Color white asRGBColor
        ifTrue: [self shell backColor: Color gray].
    self updateLookPolicy! !

!CompositeFrameObject methods !   
wbBottomRightOffset

    ^self frameContentRect rightBottom rightAndDown: WBHandle handleSize // 2.! !

!WindowBuilder methods !  
cleanUp

    self outboards do: [:each | each close].
    geometryManager isNil ifFalse: [geometryManager owner: nil].
    undoManager isNil ifFalse: [undoManager owner: nil].
    prototype isNil
        ifFalse: [
            prototype shell editor: nil.
            prototype owner: nil; shell: nil].
    geometryManager := undoManager := prototype := nil.
    WBNLSManager current removeAllActionsWithReceiver: self.
    self mainView allChildren do: [:child |
        child
            framingBlock: nil;
            removeAllActionsWithReceiver: self;
            owner: nil].
    self mainView
        clearDependents;
        removeAllActionsWithReceiver: self;
        properties: nil;
        owner: nil.
    self menuWindow allMenus do: [:menu |
        menu allMenuItems do: [:item |
            item owner: nil; selector: nil].
        menu owner: nil].
    self
        releaseEventTable;
        propertyAt: #wbPartEvents put: nil;
        propertyAt: #wbPartMessages put: nil.
    SystemWeakRegistries current events ephemerons rehash.
    SystemWeakRegistries current externalResources ephemerons rehash.
    SystemWeakRegistries current finalizer ephemerons rehash.
    SystemWeakRegistries current notifier ephemerons rehash.
    SystemWeakRegistries current properties ephemerons rehash.! !

!PWBToolBar methods !   
styles

    ^#(#toggle #preAutomatic #postAutomatic #mdiToolBar)! !

!WBGraphicObject methods !   
x

	^self origin x! !

!PEntryFieldGroup methods !
isComposite

    ^true! !

!WBResizeBitmap methods !  
newWidth

    ^newWidthField contents asInteger! !

!PEntryField methods !
suggestedSize

    ^rect width @ (self font height + 8).! !

!Object methods !
wbNameAndClass
    "Answer the receiver's name and class."

    | answer |
    (answer := self paneName ifNil: ['']) isEmpty ifTrue: [
        Smalltalk associationsDo: [:each |
           each value == self
                ifTrue: [^each key, ' [Global]']].
        answer := '<Unnamed>'].
    self isWBPrimaryModel
        ifTrue: [answer := '*Primary Model*'].
    ^answer, ' [', self class name, ']'! !

!WBMultiToolPalette methods !
selectorAt: key on: name
    | element |
    ^(element := self elementAt: key on: name) isNil
        ifTrue: [ nil ]
        ifFalse: [ element selector ]! !

!WBInterfaceObject methods !
staysWayBack

    ^false! !

!WindowBuilder methods ! 
newWidgetType: selector

    CursorManager normal change.
    entries switchTo: selector.
    self setStatus: (self statusPaneHelp: selector).
    self geometryManager addWidgetOfClass: nil.! !

!WBLayoutWizard methods !   
defaultWidgetTypeFor: selectedItem

    ^(self widgetTypesFor: selectedItem) first! !

!WBActionEditor methods !  
cancel

    | answer |
    changed ifTrue: [
        answer := MessageBox yesNoCancelTitled: 'Please Confirm' text: 'Save action?'.
        answer isNil ifTrue: [
            ^nil
        ] ifFalse: [ answer == #yes ifTrue: [
            self add.
            changed := false.
        ]].
    ].
    super cancel! !

!WBCodePolicy methods !   
addPoolNamed: aSymbol
	"Add the specified pool to the system."

	Smalltalk at: aSymbol put: Dictionary new.! !

!WBCreateViewModule methods !
generatePanes
		"Private - Generate the pane definitions."
	self object targetObject eventTable isEmpty
		ifFalse: [
			self stream 	cr.
			self generatePaneHandlersOnly: self object targetObject].
	self stream cr.
	self
		generatePane: self view;
		generateAddPane: self view to: #target using: #addView: .
	(self children reject: [:child | child isWBInterfaceObject
		and: [child staysToBack]]) do: [:each |
		self stream cr.
		each creationMethodSelector isNil
			ifTrue: [self generatePane: each]
			ifFalse: [self generatePaneHandlersOnly: each].
		self generateAddPane: each to: self view using: #addSubpane:].
	((self children select: [:child | child isWBInterfaceObject
		and: [child staysToBack]]) 
		asSortedCollection: [:a :b |
			a extent <= b extent]) do: [:each |
		self stream cr.
		each creationMethodSelector isNil
			ifTrue: [self generatePane: each]
			ifFalse: [self generatePaneHandlersOnly: each].
		self generateAddPane: each to: self view using: #addSubpane:].! !

!WBGeometryManager methods !  
replicateHeight
    "Replicate the heights of the selected widgets"

    | target selections heights aWidget redoBlock |
    (selections := self selections copy) size > 1 ifFalse: [^self].
    target := selections first.
    heights := selections collect: [:widget | widget rect height].
    self undoManager
        add: 'Replicate Height'
        undo:
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    configureWidget: aWidget x
                    y: aWidget y
                    width: aWidget width
                    height: (heights at: i)
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    configureWidget: aWidget x
                    y: aWidget y
                    width: aWidget width
                    height: target rect height
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!WBPMenuItem methods !  
storeOn: aStream indentString: indentString

    | spaceString |

    spaceString := indentString.
    aStream nextPutAll: spaceString, 'Menu new'; cr.

    spaceString := spaceString, '    '.

    aStream nextPutAll: spaceString, 'title: '; nextPutStringConstant: self title.
    aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'owner: ',(aStream owner varNameFor: #owner).
    (self realSelector notNil and: [self realSelector isString]) ifTrue: [
        aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'selector: #'.
        self realSelector printOn: aStream.
    ].
    children do: [ :c |
        c isLeaf ifTrue: [
            c isSeparator ifTrue: [
                aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'appendSeparator'.
            ] ifFalse: [
                aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'appendItem: ';
					nextPutStringConstant: c fullTitle.
                "Support for link menus"
                c action notNil ifTrue: [
                    aStream nextPutAll:  ' action: #', c action
                ] ifFalse: [ c link isNil ifTrue: [
                    aStream nextPutAll:  ' selector: '.
                    (c realSelector notNil) ifTrue: [
                        aStream nextPut: $#.
                        #osiHack.
                        "In the future, spin off method stubs here...
                        aStream addModule: (
                            WBMenuItemStub new
                                messageSelector: c realSelector;
                                title: self fullTitle;
                                yourself )."
                    ].
                    c realSelector printOn: aStream.
                ] ifFalse: [
                    aStream nextPutAll:  ' link: #',c link,' type: #',c type
                ]].
                c accelerator notNil ifTrue: [
                    aStream nextPutAll: ' acceleratorString: '.
                    c accelerator printAccelOn: aStream.
                ].
            ].
        ] ifFalse: [
            aStream nextPutAll: ';'; cr; nextPutAll: spaceString, 'appendSubMenu: ('; cr.
            c storeOn: aStream indentString: spaceString, '    '.
            aStream cr; nextPutAll: spaceString,  ')'.
        ].
    ].! !

!WBInterfaceObject methods !
isInstVar: aBoolean
		"Set true if the receiver is referenced by an instance variable."
	isInstVar := aBoolean.! !

!WBLookPolicyWin31 methods !  
frameWidthBorder

    ^frameWidthBorder ifNil: [
        frameWidthBorder := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxborder" 5]
            ifFalse: [super frameWidthBorder]]! !

!WBClassDefinition class methods ! 
on: aClass
		"Answer a new initialized instance."
	^self new initialize: aClass instanceClass! !

!WBGeometryManager methods !
bringToFront: targets
    "Bring the <targets> to the top of the z-order"

    | zOrder children aLayoutForm |
    zOrder := (children := self children) copy.
    aLayoutForm := self layoutForm.
    (self undoManager
        add: 'Bring To Front'
        undo:
            [zOrder reverseDo: [:child |
                child bringToFront.
                children
                    remove: child;
                    addFirst: child.
                child wbSetDirty].
            self owner updateOutboardZOrderChange: zOrder.
            self updateWidget: aLayoutForm]
        redo:
            [targets reverseDo: [:child |
                child bringToFront.
                children
                    remove: child;
                    addFirst: child.
                child wbSetDirty].
            self owner updateOutboardZOrderChange: targets.
            self updateWidget: aLayoutForm])
        redoAction value.! !

!WBCompositePaneTester class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBAttributeEditor methods ! 
popupBitmapMenu: aPane
    | menu array answer |
    menu := Menu new
        owner: aPane;
        selector: #contents:;
        yourself.
	((array := WBBitmaps keys asSortedCollection asArray) 
		copyFrom: 1 to: (array size min: 24)) do: [:key |
			menu appendItem: key selector: key].
	array size > 24
		ifTrue: [
			menu appendSeparator;
				appendItem: 'Other...' action:
					(Message receiver: [
						(answer := WBListChooser fromList: array prompt: 'Select Bitmap') isNil
							ifFalse: [aPane contents: answer]] selector: #value)].
	menu checkItem: aPane contents.
    aPane setPopupMenu: menu.! !

!WBLayoutForm methods !  
deSelect: aWidget

    self selections remove: aWidget ifAbsent: [^nil].
    self notifyModelOfSelectionChange.
    self hideHandles: (self removeHandlesFor: aWidget).
    self showHandles.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutCodeModule methods !   
defaultShouldLogMethodSource
	"Answer true if the receiver's source should be logged."

	^super defaultShouldLogMethodSource 
		and: [self wbEditorClass licensed]! !

!WBModelObjectEditor methods !   
activated

	super activated.
	self updateLabel.! !

!WindowBuilder methods ! 
hasLayoutForm

    ^self layoutForm notNil! !

!WBLayoutForm methods !
shellHandles: aCollection
    "Set the value of shellHandles."

    shellHandles := aCollection.! !

!WindowBuilder class methods !  
definePrivateProperties
    "Define the private used in WindowBuilder Pro"

    ^(OrderedCollection new: 2)

        add: (WBPropertyDescriptor new
            name: #VersionNumber;
            commonName: 'Version Number';
            comment: 'Specifies the current version number';
            category: self privateString;
            default: self basicVersionNumber;
            yourself);

        add: (WBPropertyDescriptor new
            name: #Licensed;
            commonName: 'Licensed';
            comment: 'Is this a licensed copy of WindowBuilder Pro';
            category: self privateString;
            default: (self smalltalkLibraryName isNil 
					or: [(File findFileName: self smalltalkLibraryName fileName, '.SML') notNil]);
            yourself);

        yourself! !

!WBInterfaceObject methods !  
styles

    ^nil! !

!PListBox methods !  
attributeEditor

    ^WBListEditor! !

!PWBToolBar methods !  
importantEvents

    ^super importantEvents
        addFirst: #clicked:;
        add: #selecting:;
        add: #doubleClick:;
        add: #showHelp:;
        yourself! !

!WBModelDefinitionEditor methods !  
loadModels

    models contents: self modelClasses! !

!BlockClosure methods !
asLayout
	"Private - WindowBuilder Pro Development
		Answer a LayoutFrame based on the receiver."

	#addedByOSI.
	^(self value: (0 @ 0 extent: 80 @ 60)) asLayout! !

!WBLookPolicyWin31 methods ! 
titleJustification

    ^self class default centerJustification! !

!WBModelInstVar methods ! 
okToGenerateTriggerEvent

    ^self okToGenerateMethod: self methodNameForTriggeredEvent! !

!WBAttributeWindow methods ! 
ownerClosed

    "Callback for the #closed event from the owner.
     (Generated by WindowBuilder)"

	self close.! !

!WindowBuilder class methods !   
openEventTranslator

	(Smalltalk at: #WBEventTranslator
		ifAbsent: [^MessageBox message: 'Event Translator not installed.']) translate! !

!StaticText class methods !  
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
		add: (
			SelectorPropertyAccessor new
				name: 'Label';
				get: #contents ;
				set: #contents: ;
				format: 'String' ;
				wbNLSAccessor: true;
				wbStore: nil );
        wbAddEvent: (
            WBEventDescription new
                event: #mnemonicTyped ;
                argumentNames: #( ));
        yourself! !

!WBLayoutForm methods !  
maxSize
    "Answer the value of maxSize."

    ^maxSize! !

!PropertyManager methods !  
wbDuplicateFrom: anObject to: copyObject
	"Duplicate anObject's properties in copyObject."

	| propMgr |
	#addedByOSI.
	propMgr := copyObject wbPropertyManager.
	self associationsDo: [:each | each wbDuplicateFrom: anObject to: copyObject using: propMgr].
	^copyObject! !

!WBLookPolicy class methods !
isWin32s

    ^OperatingSystem isWin32s! !

!WindowBuilder methods !  
paneNameIsInstVar: aBoolean
	"Set thePane to have an inst var name."

	instVar perform: 
		(aBoolean = true
			ifTrue: [#check]
			ifFalse: [#uncheck]).
	(self paneNamed: 'nameText')	contents:
		(aBoolean = true
			ifTrue: ['I-Var:']
			ifFalse: ['Name:']).
	thePane notNil
		ifTrue: [thePane isInstVar: aBoolean].
	! !

!WBPoolManagerWindow methods !
isPathVisible

	^(self paneNamed: 'categoryListBox') framingBlock bottomInset
		= categoryListBoxFramingBlock bottomInset! !

!MenuWindow class methods !
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #aboutToDisplayMenu ;
                argumentNames: #( ));
        yourself! !

!WBActionEditor class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!Object methods !
pt
	"Print the receiver to the Transcript"	
	#addedByOSI.
	Transcript cr; show: self asString! !

!WBHandle methods !
origin
        ^locator value leftAndUp: (HandleSize // 2) rounded! !

!WBNLSManager methods ! 
defaultIndirectCodeGenerationStyle
	"Answer the code generation style.
		Answer #key to generate code that references the pool key directly.
		Answer #pool to generate code that is '(<pool> at: <key>)'.
		Answer #manager to generate code that is
			'(<valueClass> named: <key>)'  or  '(<managerClass> system at: <key>)'."

	^#pool! !

!WBDefaultCompositePaneScratchWindow methods !
addSubpanes

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| xDU yDU |

	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	
	self
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -40 * xDU;
				topRatio: 1/2; topInset: -25 * yDU;
				rightRatio: 1/2; rightInset: -40 * xDU;
				bottomRatio: 1/2; bottomInset: -25 * yDU)! !

!WBEventManagerWindow methods !
updateLabel

	self labelWithoutPrefix: 
		'Event Manager: [' , 
		(self owner classNameFor: self owner editedClass) , ']'! !

!WBPropertyEditor methods !   
revertPrim

    | property |
    self clearChanges.
    (property := self selectedProperty) isNil ifTrue: [^nil].
    self setValue: property value.
    (self paneNamed: 'revertButton') disable.
    self updateItems.! !

!PEntryFieldGroup methods ! 
displayWith: aPen clipRect: inRect
	| region aRect clipRect |
	aRect := inRect.
	aPen fill: self rect color: self backColor.
	self style == #verticalScrollBar 
		ifTrue: [
			self displayWithLeftScrollBar: aPen.
			aRect := inRect insetBy: 1.
			aRect := Rectangle
				leftTop: aRect leftTop
				extent: ((aRect extent x - self lookPolicy scrollBarWidth + 1) @ (aRect extent y)).
			aRect := aRect intersect: inRect].
	self children do: [:child |
		child reframe: self rect.
		(aRect intersects: child rect) 
			ifTrue: [
				region := aPen setClipRect: (clipRect := aRect intersect: child rect).
				child resetPen: aPen.
				child displayWith: aPen clipRect: clipRect.
				aPen destroyRegion: region]	].! !

!WindowBuilder methods !   
updateNlsCategories

	| menu count |
	menu := self nlsMenu ifNil: [^self].
	(count := menu propertyAt: #wbNlsItemCount) ifNil: [
		count := menu items size.
		menu propertyAt: #wbNlsItemCount put: count].
	[menu items size > count] whileTrue: [
		menu removeItemDynamically: menu items size].
	WBNLSManager current categories asSortedCollection do: [:each |
		menu
			appendItemDynamically: each
			selector: (
				Message
					receiver: self
					selector: #menuNlsActiveCategory:
					arguments: (Array with: each))].
	self updateNlsActiveCategory: WBNLSManager current activeCategory.! !

!WBStyleEditor class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBInterfaceObject methods ! 
usesMenu

    ^true! !

!WBLayoutForm methods !   
isOS2

    ^Smalltalk platformIsOS2! !

!WBScrapbookStore methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel chapters chaptersLabel mainView name nameLabel 
	newChapter ok xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	chapters := MultipleSelectListBox new.
	chaptersLabel := StaticText new.
	name := WBEntryField new.
	nameLabel := StaticText new.
	newChapter := Button new.
	ok := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Store in Scrapbook';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -169/2 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -52 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -169/2 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -52 * yDU).
	self addView: mainView.
	
	name "WBEntryField"
		owner: self;
		setName: 'name';
		when: #textChanged: send: #getName: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -166 * xDU;
				bottomRatio: 0; bottomInset: -14 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: name;
		subPaneWithFocus: name.
	
	chapters "MultipleSelectListBox"
		owner: self;
		setName: 'chapters';
		when: #changed: send: #getChapter: to: self;
		when: #needsContents send: #loadChapters: to: self withArgument: chapters;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 26 * yDU;
				rightRatio: 0; rightInset: -166 * xDU;
				bottomRatio: 0; bottomInset: -84 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: chapters.
	
	newChapter "Button"
		owner: self;
		setName: 'newChapter';
		when: #clicked send: #newChapter to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 114 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 0; rightInset: -166 * xDU;
				bottomRatio: 0; bottomInset: -102 * yDU);
		contents: '&New Chapter';
		startGroup;
		font: SysFont.
	mainView addSubpane: newChapter.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 0; rightInset: -81/2 * xDU;
				bottomRatio: 0; bottomInset: -102 * yDU);
		defaultPushButton;
		contents: '&Store';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 44 * xDU;
				topRatio: 0; topInset: 88 * yDU;
				rightRatio: 0; rightInset: -161/2 * xDU;
				bottomRatio: 0; bottomInset: -102 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	chaptersLabel "StaticText"
		owner: self;
		setName: 'chaptersLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 16 * yDU;
				rightRatio: 0; rightInset: -38 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		contents: 'Chapters:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: chaptersLabel.
	
	nameLabel "StaticText"
		owner: self;
		setName: 'nameLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -44 * xDU;
				bottomRatio: 0; bottomInset: -12 * yDU);
		rightJustified;
		contents: 'Page Name:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: nameLabel! !

!WBAbstractCreateViewsModule methods !  
generateCode
        "Generate the code..."
	super generateCode.
	self messageArgumentCount > 0
		ifTrue: [
			self generateCreateViewsStub ].! !

!WBLayoutForm methods ! 
nlsStringFor: aString

    ^self model nlsStringFor: aString! !

!WBMenu methods !
add: aSelector label: aLabelString accelerator: aString

    ^self
        add: aSelector
        label: aLabelString
        mnemonic: nil
        enable: nil
        toggle: nil
        for: nil
        accelerator: aString.! !

!WBXoteryXCodePolicy methods !  
basicLogMethodFor: aCodeModule
		"Private - Log the specified method source."
	SourceManager current
		logSource: aCodeModule sourceString
		forSelector: aCodeModule messageSelector
		inClass: aCodeModule targetClass.! !

!WBPrototype methods !   
wbPartMessages
		"Answer the wbPartMessages for the receiver."
	^(self propertyAt: #WBPartMessages) ifNil: [super wbPartsMessages]! !

!LayoutFrame methods ! 
asFramingBlockForDialogSubPaneFromWindow

	"The framingBlock for subpanes in a dialog are passed the dialog units
		of the parent and expected to return dialog units for the subpane.
		The framingBlock for subpanes in a window are passed pixels
		of the parent and expected to return pixels for the subpane.
		Convert the insets from pixels to dialog units."

	"The conversion is done during code generation..."

	^self! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBInterfaceObject methods ! 
usesFraming

    ^true! !

!WBPoolManagerWindow methods ! 
defaultExtension

	^'.*'! !

!WindowBuilder class methods !   
newCompositeWindowBuilder

	self wbEditorClass preOpen.
	self wbEditorClass new openCompositePane.! !

!WindowFrameObject methods !  
frameRectExtent: aPoint

    self extent:
        (self isDialog
            ifTrue: [aPoint - (2 * self borderWidth) - (0 @ (self titleHeight + self menuHeight))]
            ifFalse: [aPoint]).! !

!WBLayoutForm methods !
setupResizing
    "Setup for the resizing state."

    self releaseState: #buttonReleaseResizing:.
    self motionState: #button1MotionResizing:.
    self minSize: self selections first wbMinSize.
    self maxSize: self selections first wbMaxSize.
    self bandRect: self selectedRect.
    self cursorOffset: self initialCursorOffset.
    self drawBand.
    self setCursor: self currentNib.! !

!WBResizeBitmap methods !  
ok

    "Callback for the #clicked event in okButton [Button].
        (Generated by WindowBuilder Pro)"

    newExtent := self newWidth @ self newHeight.
    isButtonBitmap := (self paneNamed: 'buttonBitmap') selection.
    isButtonBitmap ifTrue: [newExtent := newExtent x * 2 @ newExtent y].
    isResizeAll := (self paneNamed: 'allRadioButton') selection.
    isScaled := (self paneNamed: 'scaledButton') selection.
    self close.! !

!WBInterfaceObject methods !   
colorElements

    | colorElements |
    colorElements := Dictionary new.
    self usesColor
        ifTrue: [
            self usesForeColor
                ifTrue: [colorElements at: 'Fore Color' put: self foreColor].
            self usesBackColor
                ifTrue: [colorElements at: 'Back Color' put: self backColor]].
    ^colorElements! !

!WBLayoutWizard methods !
activated

    (self mainView propertyAt: #defining) == true
        ifTrue: [self loadAttributes].
    self mainView propertyAt: #defining put: false! !

!WBInterfaceObject methods ! 
storeRectOn: aStream indentString: spaceString

	self framingBlock: (self wbEditorClass useLayoutFrame
		ifTrue: [self framingBlock asLayout]
		ifFalse: [self framingBlock asFramingParameters: self rect]).
	framingBlock isFramingParameters
		ifTrue: [framingBlock initialExtent: self extent].
	aStream
		cr; nextPutAll: spaceString; nextPutAll: #framingBlock: ;
		space; 	indentBy: 1; cr; nextPut: $(.
	self storeFramingBlockOn: aStream indentString: spaceString.
	aStream 
		nextPut: $);
		indentBy: -1.! !

!WBLayoutFrameEditor methods !
proportional

	^'Proportional'! !

!WBKeyEntryField methods ! 
accelerator: newAccel

    accelerator := newAccel.
    (accelerator isNil) ifTrue: [
        self contents: ''.
        accelerator := WBKeyAccel new.
    ] ifFalse: [
        self contents: accelerator keyName.
    ].! !

!WBFontSelectionWindow methods !
openOn: aWindowBuilder

    owner := aWindowBuilder.
    ((Notifier isControlKeyDown xor: self atleastOneKey)
        and: [self wbEditorClass runtimeLessCode not])
        ifTrue: [super openOn: aWindowBuilder]
        ifFalse: [self openFontDialogOn: aWindowBuilder].! !

!WBLayoutForm methods ! 
createUndoRedoForNewWidgets: newWidgets oldWidgets: oldWidgets named: aString
    "Create the Undo/Redo blocks for adding new widgets."

    | childList sel theModel |
    childList := self children copy.
    sel := self selections.
    theModel := self model.
    ^self undoManager
        add: aString
        undo:
            [self hideHandles.
            newWidgets isEmpty
                ifFalse: [
                    newWidgets do: [:aWidget |
                        [aWidget isDestroyed ifFalse: [aWidget wbDestroyWidget]] on: Error do: []]].
            oldWidgets isEmpty
                ifFalse: [
                    oldWidgets do: [:aWidget |
                        aWidget wbUnDestroyWidget].
                    childList reverseDo: [:child |
                        (self children includes: child)
                            ifTrue: [
                                child bringToFront.
                                self children
                                    remove: child;
                                    addFirst: child.
                                child wbSetDirty]].
                    oldWidgets do: [:aWidget |
                        aWidget manageChild]].
            self updateWidget.
            self isCurrentLayoutForm
                ifTrue: [
                    self selections: sel; drawOrderSymbols.
                    self model updateOutboardZOrderChange: self children]]
        redo:
            [self hideHandles.
            oldWidgets isEmpty
                ifFalse: [
                    oldWidgets do: [:aWidget |
                        [aWidget isDestroyed ifFalse: [aWidget wbDestroyWidget]] on: Error do: []]].
            newWidgets isEmpty
                ifFalse: [
                    newWidgets do: [:aWidget |
                        aWidget wbUnDestroyWidget].
                    childList reverseDo: [:child |
                        (self children includes: child)
                            ifTrue: [
                                child bringToFront.
                                self children
                                    remove: child;
                                    addFirst: child.
                                child wbSetDirty]].
                    newWidgets do: [:aWidget |
                        aWidget manageChild]].
            self model: theModel.
            self updateWidget.
            self isCurrentLayoutForm
                ifTrue: [
                    self selections: newWidgets; drawOrderSymbols.
                    self model updateOutboardZOrderChange: self children]].! !

!WindowBuilder methods !   
aboutToClose
	"Detect that Smalltalk is shutting down. Prevent our
	 Save Changes query from coming up at shutdown. "

	#osiHack. "Is there a better way to detect shutdown?"
	Transcript isNil ifTrue: [^self].
	self confirmSaveChanges
		ifFalse: [^self abortClose].
	self triggerEvent: #aboutToClose.
	#osiHack.
	"What should happen in OS/2?"
	Smalltalk platformIsWin32
		ifTrue: [
			self mainView parent isNil
				ifFalse: [
					self mainView parent isMDIClient
						ifFalse: [self mainView parent mainView bringToTop]]].
	self cleanUp.! !

!WBActionEditor methods !  
fileIn

    | dialog file |
    dialog := FileDialog new.
    dialog title: 'File In Actions';
        defFilter: '*.ACT';
        addFilter: '*.ACT' description: 'Action Lists';
        hideReadonly;
        open.

    file := dialog file.
    file isNil ifTrue: [^self].
    file := File pathNameReadOnly: file.
    CursorManager execute change.
    file fileIn.
    CursorManager normal change.
    file close.

    self updateList! !

!WindowBuilder methods !   
hasCustomPanes

	^self customPanes notEmpty! !

!WBPropertyDescriptor methods !   
noDefault

    ^self hasFlag: self noDefaultFlag! !

!WBAbstractPrompter class methods !  
prompt: promptString list: aCollection default: defaultObject
	"Prompt for an entry in a list."

	^self
		prompt: promptString
		title: self defaultTitle
		list: aCollection
		default: defaultObject! !

!PStaticGraphic methods ! 
usesFocus

    ^false! !

!Object class methods ! 
wbConstructPropertyManager
	"Construct the WindowBuilder property manager
		based on the Digitalk property manager."

	^PropertyManager new
		add: (
			SelectorPropertyAccessor new
				name: 'Event Table';
				get: #eventTable ;
				set: #wbEventTable: ;
				wbDuplicate: #wbIgnore: ;
				wbStore: #nextPutProperty:eventTable:for: ;
				yourself);
		yourself

	"***********************************************************
	Use this script to automatically generate methods like these.
	************************************************************

    | classCollection stream
        pWidget superPWidget
        events eventsInherited eventsAdded eventsRemoved |

    classCollection := Window withAllSubclasses
        reject: [:each | (each name copyFrom: 1 to: (5 min: each name size)) = 'PARTS'].

    stream := WBCodeStream new.
    classCollection do: [:eachClass |
        pWidget := eachClass wbPseudoClass basicNew.
        superPWidget :=
            eachClass superclass == Object
                ifTrue: [nil]
                ifFalse: [eachClass superclass wbPseudoClass basicNew].
        events := eachClass eventsTriggered.
        eventsInherited := eachClass superclass eventsTriggered.
        eventsAdded := Dictionary new.
        events do: [:each |
            ((eventsInherited includes: each) and: [
                superPWidget notNil and: [
                    (pWidget eventHandlerArgNamesFor: each)
                    = (superPWidget eventHandlerArgNamesFor: each)]])
                        ifFalse: [
                            eventsAdded at: each put: (
                                pWidget eventHandlerArgNamesFor: each)]].
        eventsRemoved := eventsInherited reject: [:each | events includes: each].
        eventsAdded notEmpty | eventsRemoved notEmpty ifTrue: [
            stream nextPutAll: '!!', eachClass name, ' class methods!!
wbConstructPropertyManager
    ', (String with: 34 asCharacter), 'Construct the WindowBuilder property manager
        based on the Digitalk property manager.', (String with: 34 asCharacter), '

    #addedByOSI.
    ^super wbConstructPropertyManager';
                indentBy: 2.
            eventsRemoved do: [:each |
                stream cr; nextPutAll: 'wbRemoveEventNamed: ', each storeString, ' ;'].
            eventsAdded associationsDo: [:each |
                stream
                    cr; nextPutAll: 'wbAddEvent: ('; indentBy: 1;
                    cr; nextPutAll: 'WBEventDescription new'; indentBy: 1;
                    cr; nextPutAll: 'event: ', each key storeString, ' ;';
                    cr; nextPutAll: 'argumentNames: #('.
                each value do: [:eachArgName |
                    stream nextPutAll: eachArgName storeString].
                each value isEmpty ifTrue: [stream space].
                stream
                    nextPutAll: '));'; indentBy: -2].
            stream cr;
                nextPutAll: 'yourself!! !!';
                indentBy: -2;
                cr; cr]].
    stream contents edit.
	"! !

!PThreeStateButton methods ! 
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	eventSymbol == #clicked: ifTrue: [^#('aBooleanOrNil')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!WBCreateBitmap class methods !   
lastBitmapWidth

	^lastBitmapWidth ifNil: [self defaultBitmapWidth]! !

!WBLookPolicyWin95 methods !  
drawComboBox: aComboBox with: aPen clipRect: clipRect

    | style rect topRect bottomRect buttonRect innerRect
     buttonWidth list region newPoint |
    style := aComboBox style.
    rect := aComboBox rect.
    topRect := rect leftTop extentFromLeftTop: rect width @ (aComboBox font height + 8).
    innerRect := self
        displayWithMinorBorder: aPen
        rect: topRect
        backColor: aComboBox backColor.
    aPen fill: innerRect color: aComboBox backColor.
    buttonWidth := self scrollBarWidth.
    buttonRect := (innerRect rightTop left: buttonWidth)
        extentFromLeftTop: (buttonWidth @ innerRect height).
    style == #simpleList
        ifTrue: [
            bottomRect := topRect leftBottom rightBottom: rect rightBottom.
            "Must be an increment of font height"
            bottomRect := bottomRect leftTop extentFromLeftTop:
                (bottomRect width @ ((bottomRect height - 4 truncateTo: aPen font height)+4)).
            innerRect := self
                displayWithMinorBorder: aPen
                rect: bottomRect
                backColor: aComboBox backColor.
            aPen fill: innerRect color: aComboBox backColor.
            (list := aComboBox contents) isNil
                ifFalse: [
                    aPen
                        foreColor: aComboBox foreColor;
                        backColor: aComboBox backColor;
                        font: aComboBox font.
                    region := aPen setClipRect: (innerRect intersect: clipRect).
                    newPoint := innerRect leftTop right: 2.
                    1 to: list size do: [:i |
                        aPen displayText: (list at: i) at: newPoint.
                        newPoint := newPoint down: aPen font height].
                    aPen destroyRegion: region]]
        ifFalse: [self drawDownArrowWith: aPen at: buttonRect].! !

!WBPoolManagerWindow methods !
menuPoolFileOutSeparately

    "Callback for the menu item titled 'File out separately...'.
     (Generated by WindowBuilder)"! !

!WBPoolManagerWindow methods !
poolPath
	"Answer the current pool path, or nil if none."

	^(self selectedPool ifNil: [^nil]) fileName! !

!WBAbstractPrompter methods !
promptField

	^self paneNamed: 'prompt'! !

!WBResizeBitmap methods ! 
isButtonBitmap

	^isButtonBitmap ifNil: [
		self defaultButtonExtents includes: oldExtent]! !

!WBTabPosition methods !  
>= aTabPosition

    (aTabPosition basicTabPosition < basicTabPosition) ifTrue: [
        ^true
    ].

    (aTabPosition basicTabPosition = basicTabPosition) &
    (aTabPosition groupPosition notNil & groupPosition notNil and: [
        aTabPosition groupPosition < groupPosition
    ]) ifTrue: [
        ^true
    ].

    ^false! !

!WBAbstractCodeModule methods ! 
sourceString
		"Private - Answer the method source."
	^self stream contents! !

!WindowBuilder class methods !
codeGenerationHook

	^self propertyAt: #CodeGenerationHook! !

!WBCodeGenerator methods ! 
propertyAt: key 
        "Answer the value associated with key
        in the properties dictionary."
    properties isNil ifTrue: [ ^nil ].
    ^properties at: key ifAbsent: [ nil ]! !

!WindowBuilder methods ! 
isShellDialog

	^self shell isDialog! !

!PStatusPane methods !   
defaultBackColor

    ^Color buttonFace! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder methods ! 
newSizeOrPosition: aCollectionOfWidgets

    self setSizeAndPositionForWidgets: aCollectionOfWidgets.! !

!WBLayoutForm methods ! 
placeNewWidget: aWidget at: aPoint
	"Place the new widget <aWidget> at <aPoint>"

	| width height gridSize |
	width := aWidget rect width.
	height := aWidget rect height.
	self useGrid
		ifTrue: [
			gridSize := self gridSize.
			width := (width roundTo: gridSize x) max: gridSize x.
			height := (height roundTo: gridSize y) max: gridSize y].
	[aWidget
		configureWidget: aPoint x
		y: aPoint y
		width: width
		height: height
		borderWidth: aWidget borderWidth;
		wbUpdateConstraints;
		manageChild;
		sendToBack.
	self children
		remove: aWidget;
		addLast: aWidget]
		on: Error do: [
			self wbHalt.
			^aWidget isDestroyed
				ifFalse: [aWidget wbDestroyWidget]].
	self model isNil
		ifFalse: [self model setDirty].! !

!UndefinedObject methods ! 
wbCopyUsing: aDictionary

	^self! !

!WBLayoutForm methods !  
handleColor

    ^self colorBlack! !

!WBEventMessage methods !   
arguments: anArray
	"Set the arguments for the receiver."

	super arguments: (
		anArray = self defaultArguments
			ifTrue: [nil]
			ifFalse: [anArray]).! !

!PropertyManager methods !  
wbFullCopy: aDictionary from: anObject to: copyObject
	"Perform a full copy on the property."

	#addedByOSI.
	self associationsDo: [:each | each wbFullCopy: aDictionary from: anObject to: copyObject].! !

!WBResizeBitmap methods !  
newWidth: anInteger

	newWidthField contents: anInteger asString.! !

!PStaticText methods !  
usesMenu

    ^false! !

!WindowBuilder methods ! 
classNameFor: aClass

    ^(aClass isNil or: [aClass isScratchWindow])
        ifTrue: ['Untitled']
        ifFalse: [aClass name]! !

!WindowBuilder methods ! 
useFence

    ^self class useFence! !

!WBCreateViewModule methods !  
generateDefinitions
		"Generate a definition for each of the view's elements."
	self
		generateDefinition: #self, ' ', #topPaneClass, ' ', #new
		for: self view;
		generateChildDefinitions;
		generateFontDefinitions.! !

!WBLayoutForm methods !  
aboutToSaveImage

    graphicsTool release.
    super aboutToSaveImage.! !

!WBPoolManagerWindow methods !   
poolMenu

	^self menuTitled: 'Pool'! !

!WBHandle methods !   
handles
        ^Array new! !

!WBActionEditor methods !   
loadList: aPane

    aPane contents: WBAction listActions! !

!WBLayoutForm methods ! 
reframeAll

    self children do: [:widget |
        widget reframe: self shell frameContentRect].! !

!WindowBuilder class methods !
openMethodType

	^self propertyAt: #OpenMethodType! !

!WBTreeNode methods !  
canExdent

    ^self isRoot not and:  [ parent isRoot not ].! !

!WBInterfaceObject methods ! 
moveWidget: x y: y

    self
        moveWidgetPrim: x y: y;
        updateWidgetMoved.! !

!WBModelSetModule methods ! 
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self generateGeneratedSymbol.
        self object hasEvent
            ifTrue: [
                self stream
                    cr; nextPutAll: self object name; nextPutAll: ' = '; nextPutAll: self messageArguments first;
                    indentBy: 1; cr; nextPutAll: 'ifFalse: [';
                    indentBy: 1; cr; nextPutAll: #self;
                    indentBy: 1; cr; nextPutAll: self object methodNameForBasicSet;
                    space; nextPutAll: self messageArguments first; nextPut: $;;
                    cr; nextPutAll: #changed; nextPut: $;;
                    cr; nextPutAll: self object methodNameForTriggeredEvent; nextPut: $];
                    indentBy: -3]
            ifFalse: [
                self stream
                    cr; nextPutAll: #self;
                    space; nextPutAll: self object methodNameForBasicSet;
                    space; nextPutAll: self messageArguments first]].! !

!WBLookPolicy methods ! 
isDefault

    ^self class isDefault! !

!WBLookPolicyWin95 methods ! 
minimizeButtonSize

    ^16 @14! !

!WindowBuilder methods !  
menuFileExportToResFile

	| fName |
	fName := (FileDialog new saveFile:
		(File
			fileName: self editedClass name
			extension: (String with: $r with: $e with: $s))) file.
	fName notNil
		ifTrue: [self prototype exportToResFile: fName].
	! !

!WindowBuilder class methods ! 
register: extraName menu: anArray before: aString

	| slot |
	slot := self extras at: extraName ifAbsent: [OrderedCollection new].
	slot add:
		(Message new
			receiver: self wbEditorClass
			selector: #insertMenu:before:
			arguments: (Array with: anArray with: aString)).
	self extras at: extraName put: slot.! !

!WBPMenuItem methods ! 
selector

    ^selector! !

!WBLayoutForm methods !   
wbLayOutChild: child
    "Private - Layout the children of the receiver
     based on the height and width of the receiver."! !

!WBGeometryManager methods ! 
hasMultipleSelections

    ^self selections size > 1! !

!WBKeyAccel methods !
isShift

    ^isShift ifNil: [false]! !

!ApplicationCoordinator methods !
modelObjects

    ^self propertyTableForEdit
        at: #modelObjects
        ifAbsentPut: [OrderedCollection new]! !

!Object methods !   
wbFontsUsed
	"Answer all fonts used in the receiver."

	^#( )! !

!WBUserInfoDialog class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!PEntryFieldGroup methods !  
copySpecificsTo: aPane

    aPane
        label: self label;
        contents: self contents.! !

!WBInterfaceObject methods !  
preEdit: ignore

    ^true! !

!WBLayoutForm methods !
findChildFor: aPoint

    ^(self children reject: [:widget | widget staysToBack])
            detect: [:widget | widget boundingBox containsPoint: aPoint]
            ifNone: [
                (self children select: [:widget | widget staysToBack])
                    detect: [:widget | widget boundingBox containsPoint: aPoint]
                    ifNone: [nil]].! !

!WBCreateMenuModule methods !   
menu
		"Answer the receiver's menu definition."
	^menu! !

!WBLayoutCodeModule methods !  
generatePaneClipStyle: aPane
        "Private - Generate the clipsiblings style if necessary."
    (aPane == self view or: [aPane isWBInterfaceObject not]) ifFalse: [
        frames isNil ifTrue: [ frames := OrderedCollection new ].
        self generatePaneClipStyle: aPane frames: frames ].! !

!WBMenuItem methods !  
enableSelector: aSymbol
        "Private - Set the enable selector of the menu item."
    enableSelector := aSymbol! !

!WindowFrameObject methods !  
supportedEvents

     ^self realClass basicNew topPaneClass supportedEvents asSortedCollection! !

!WBPoolManagerWindow methods ! 
selectedKeyAndPool
	"Answer the selected key/pool if exactly one is selected,
		else answer nil."

	^self selectedKeysAndPools size = 1
		ifTrue: [self selectedKeysAndPools first]
		ifFalse: [nil]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!Object methods !   
wbPropertyManager
    "Answer the window builder property manager for the receiver."

    ^self class wbPropertyManager! !

!WindowBuilder methods ! 
createUndoRedoForNewWindowSize: newSize oldSize: oldSize

    | shifted |
    shifted := Notifier isControlKeyDown.
    ^self undoManager
        add: 'Change Window Size'
        undo: [self setWindowSizePrim: oldSize shifted: shifted]
        redo: [self setWindowSizePrim: newSize shifted: shifted].! !

!WBKeyAccel methods ! 
keyCode: code

    keyCode := code.
    keyCode isCharacter ifFalse: [
        text := self constantsDict at: code ifAbsent: [ ^text := '' ].
        text := text copyFrom: 3 to: text size.
    ] ifTrue: [
        text := CharacterConstants keyAtValue: code ifAbsent: [ String with: code asUpperCase ].
    ].! !

!WBCodeGenBase methods !  
owner
		"Answer the receiver's owner."
	^owner! !

!WBLayoutForm methods !
addWidgetCentered
    "Place the loaded widget in the center of the screen."

    | newWidgets point |
	[newWidgets := self loadedWidgets collect: [:aWidget |
        aWidget wbCloneWithParent: self shell]]
        on: Error do: [:ex |
			"Report an error only if..."
			self wbHalt.
            newWidgets isNil
                ifFalse: [
                    newWidgets do: [:widget |
                        widget isDestroyed ifFalse: [widget wbDestroyWidget]]].
            self loadedWidgets: nil.
            ^self].
    point := self shell frameContentRect center
        leftAndUp: (self boundingBoxFor: newWidgets) extent // 2.
    self
        placeNewWidgets: newWidgets
        at: point;
        createUndoRedoForNewWidgets: newWidgets
            oldWidgets: #()
            named: (newWidgets size == 1
                ifTrue: ['Add New Widget']
                ifFalse: ['Add New Widgets']);
        selections: newWidgets";
        redraw".

    self loadedWidgets: nil.! !

!WBInterfaceObject methods !
printOn: aStream

    aStream nextPutAll: self wbNameAndClass! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBBitmapManager methods ! 
codeKeyClass
	"Answer the named method class field, so that the
		code generator can generate expressions such as
		'Bitmap named: <aKey>'   or   'Font named: <aKey>'."

	^self == self class current
		ifTrue: [Bitmap] ifFalse: [nil]! !

!WBInterfaceObject methods ! 
winClassStyle

    ^0! !

!WindowFrameObject class methods !  
styleFrom: winStyle

	| set |
	set := Set new.
	(winStyle bitIsOn: WsSysmenu)
		ifTrue: [set add: #sysmenu].
	(winStyle bitIsOn: WsCaption)
		ifTrue: [set add: #titlebar].
	(winStyle bitIsOn: DsModalframe)
		ifTrue: [set add: #modal].
	(winStyle bitIsOn: DsSysmodal)
		ifTrue: [set add: #sysmodal].
	^set! !

!WBLayoutWizard methods !  
checkedAttribute: index

    (attributesList contents at: index) object
        propertyAt: #inLayout put: true! !

!WBPowerViewAddInModule class methods !  
modifiesProperties
    "Does this add-in modify properties?"

    ^true! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PStatusPane methods !  
readSpecificsFrom: aWidget

	self statusBoxes: aWidget contents.
	aWidget isResizable
		ifTrue: [self style: (aWidget justified, 'Justified') asSymbol]
		ifFalse: [self style: (aWidget justified, 'JustifiedFixed') asSymbol].
	self updateBoxes.! !

!WBLayoutForm methods !   
numChildren
    "Answer number of children in the receiver."

    ^self children size! !

!WBEventMessage methods !  
replace: anEventMessage
	"Replace <anEventMessage> in the event table."

	| actions index |
	index := anEventMessage index ifNil: [^self add].
	anEventMessage remove.
	actions := self actionList.
	index := (index min: actions size + 1) max: 1.
	self actionList: (
		(actions copyFrom: 1 to: index - 1),
		(self asActionSequence),
		(actions copyFrom: index to: actions size)).! !

!ClassHierarchyBrowser methods !
wbFindClass: aClassName
        "Private - WBPro Development.
			Position at that point in the hierarchy."

	| className class supers blanks |
	#addedByOSI.
    self textModified ifTrue: [^self].
    className := aClassName asSymbol.
    class := Smalltalk at: className.
    CursorManager execute changeFor: [
        supers := (Array with: class), class allSuperclasses.
        blanks := 0.
        1 to: supers size do: [ :i |
            (originalClasses includes: (supers at: i))
               ifTrue: [ blanks := i ]].
        blanks = 0 ifTrue: [
            ^MessageBox message: 'Class "', className,
                            '" not found in this browser.' ].
        supers do: [ :cl |
            hiddenClasses remove: cl ifAbsent: []].
        self update: originalClasses.
        methodSelectedLast := false.
        selectedMethod := nil.
        selectedInstVar := nil.
        selectedClass := class.
        self changed: #hierarchy:
            with: #restoreSelected:
            with: (((String new: ((blanks - 1 max: 0) * 2)) atAllPut: $ ),
                class name).
        self enableClassesMenu.
        self disableMethodsMenu.
        self
            changed: #instanceVars: ;
            changed: #selectors: ;
            changed: #text: ]! !

!PGroupbox methods ! 
contents

    ^super contents ifNil: ['']! !

!WBPool methods !   
fileOutFooterOn: aStream
	"File out the receiver's footer."! !

!WBTeamVCodePolicy methods !   
removePoolNamed: aSymbol
    "Remove the specified pool from the system."

    (self currentSubsystem
        definitionOfPoolNamed: aSymbol)
            removeFromSystem.! !

!Object methods !  
creationMethodSelector: creationMethodSelector

    self propertyAt: #creationMethodSelector put: creationMethodSelector.! !

!WBCodeStream methods ! 
nextPutCommentNoWrap: aString
        "Append a comment with quotes to the receiver's stream."
    | commentStream oldWrap |
    oldWrap := self maxLineSize.
    self maxLineSize: nil.
    self nextPut: $".
    commentStream := ReadStream on: aString.
    [    self nextPutAll: commentStream nextLine trimBlanks.
        commentStream atEnd] whileFalse: [self cr].
    self nextPut: $".
    self maxLineSize: oldWrap.! !

!Window methods !   
tabPosition: ignore
        "Private - WBPro Development."
    #addedByOSI.! !

!WBModelDefinitionEditor methods !
setHasAccessors: aBoolean

    | selectedItem |
    selectedItem := attributes selectedItem ifNil: [^nil].
    selectedItem hasAccessors == aBoolean ifTrue: [^self].
    selectedItem hasAccessors: aBoolean.
    aBoolean
        ifTrue: [
            hasEvent selection: true; enable.
            selectedItem hasEvent: true.
            initialized selection
                ifTrue: [
                    lazy selection: true; enable.
                    selectedItem lazy: true].
            self setClass: myClass selectedItem]
        ifFalse: [
            hasEvent selection: false; disable.
            selectedItem hasEvent: false.
            lazy selection: false; disable.
            selectedItem lazy: false].
    self setDirty.! !

!Font methods !
wbEquals: aFont
	"Private - WBPro Development."

	#addedByOSI.
	^self == aFont or: [
		self faceName = aFont faceName and: [
		self pointSize = aFont pointSize and: [
		self fixedWidth = aFont fixedWidth and: [
		self bold = aFont bold and: [
		self italic = aFont italic and: [
		self strikeOut = aFont strikeOut and: [
		self underscore = aFont underscore]]]]]]]! !

!WBLookPolicyOS2 methods !  
titleBarHeight

	^titleBarHeight ifNil: [
		titleBarHeight := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCyminmaxbutton" 34]
			ifFalse: [super titleBarHeight]]! !

!CompositeFrameObject methods ! 
isNonWindowParent

    ^true! !

!WBActionEditor methods !
getAuthor: aPane

     aPane setContents: (Smalltalk at: #WindowBuilderUser ifAbsent: [ nil ])! !

!WBFontSelectionWindow methods !   
update
    "The receiver has been activated and the
        owner has changed, so update the receiver's content's
        to reflect the change in the owner."

	self updateContents.
	super update.
	(self paneNamed: 'poolList') update.
	(self paneNamed: 'fontList') update.! !

!WindowBuilder methods !   
resetFocus

	titleEditor
		setFocus;
		selectAll;
		setPopupMenu: nil.! !

!WBModelDefinitionEditor methods !  
select: selectedItem

    selectedItem isNil ifTrue: [^self].
    (self isDirty and: [selectedModel notNil])
        ifTrue: [
            (MessageBox confirm: 'Save Changes to ', selectedModel name,'?')
                ifTrue: [
                    self updateModel
                        ifFalse: [^models selectItem: selectedModel]]].
    selectedModel := selectedItem.
    self loadAttributesForClass: selectedModel.
    myClass contents: ((self standardClasses, self modelClasses)
        collect: [:cls | cls name]) asSortedCollection asArray.
    self
        enableModelFields;
        disableFields;
        clearDirty! !

!WBGeometryManager methods !   
clipboard

    ^self owner clipboard! !

!WBCodeStream methods !  
closeParenthesis
	"Append a ')' to the code stream."

	parenthesis removeLast ifTrue: [stream nextPut: $)].
	noParenthesis := false.
	self indentBy: -1.! !

!WBModelInstVar methods ! 
name: aString

    name := aString! !

!WBAbstractCodeModule methods !
cleanup
        "Private - Do special cleanup before storing the code."! !

!PButtonListBox methods !  
styles

    ^#(#defaultStyle #threeState #noImages #threeStateNoImages)! !

!WBLayoutForm methods !   
button1MotionMovingWidget: aPoint
    "Process a motion event while moving a widget."

    | x y currentSelections ctrl gridX gridY useGrid contentRect |
    (self checkAllowMove: aPoint) ifFalse: [^self].
    currentSelections := self selections.

    "Control drag creates a copy"
    ctrl := Notifier isControlKeyDown.
    (ctrl and: [currentSelections ~= self duplicateWidgets])
        ifTrue: [
            self
                cloneWidgets: self duplicatableWidgets
                at: self selectedRect topLeft.
            self duplicateWidgets: (currentSelections := self selections)].

    (useGrid := self useGrid)
        ifTrue: [
            gridX := self gridSize x max: 1.
            gridY := self gridSize y max: 1].
    contentRect := self shell frameContentRect.
    1 to: currentSelections size do: [:index |
        x := aPoint x left: (self cursorOffset at: index) x.
        y := aPoint y up: (self cursorOffset at: index) y.
        useGrid
            ifTrue: [
                x := contentRect left distanceRight: x.
                y := contentRect top distanceDown: y.
                x := contentRect left right: (x roundTo: gridX).
                y := contentRect top down: (y roundTo: gridY)].
        self useFence
            ifTrue: [
                x := (x rightMost: contentRect left) leftMost: (contentRect right left: (currentSelections at: index) width).
                y := (y lowerOf: contentRect top) higherOf: (contentRect bottom up: (currentSelections at: index) height)].
        (currentSelections at: index)
            moveWidget: x
            y: y;
            wbUpdateConstraints].

    self children do: [:child |
        ((currentSelections includes: child) not and: [
            child wbHasWidgetAttachment])
            ifTrue: [self wbLayOutChild: child]].

    self model isNil
        ifFalse: [
            self model setDirty.
            self notifyModelOfSizeOrPositionChange].! !

!PWBHorizontalScrollBar methods !  
displayWith: aPen clipRect: clipRect

    self lookPolicy
        drawHorizontalScrollBar: self
        with: aPen
        clipRect: clipRect! !

!WBScrollingPane class methods ! 
isWBInternalClass

    ^true! !

!WindowBuilder methods ! 
clipboard: aCollection

    WBClipboard := aCollection! !

!WBInterfaceObject methods !   
getFont: aWindowBuilder

    ^FontDialog new
        sampleFont: self font;
        open;
        chosen! !

!WBLayoutForm methods !   
setupShellResizing
    "Setup for the resizing state."

    self releaseState: #buttonReleaseResizingShell:.
    self motionState: #button1MotionResizingShell:.
    self minSize: self wbMinSize.
    self maxSize: self wbMaxSize.
    self bandRect: self shell frameContentRect.
    self cursorOffset: (Array with: 8@8) "initialCursorOffset".
    self updateWidget.
    self drawBand.
    self setCursor: self currentNib.! !

!Object methods !
wbCopy
   "Answer a copy of the receiver which shares
		 the receiver instance variables."

	#addedByOSI.
	^self wbCopyTo: (
		self class isVariable
			ifTrue: [self class new: self basicSize]
			ifFalse: [self class new])! !

!PVideoPane methods !
hasBorder

    ^self style == #defaultStyle or: [self style == #stretch]! !

!WindowBuilder methods ! 
updateOptionsMenu

	(self menuTitled: 'Options') updateToggled.! !

!WBLookPolicyWin31 methods !  
drawDownArrowWith: aPen at: aRect

    | innerRect side |
    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class downArrow
                from: self class downArrow boundingBox
                to: aRect]
        ifFalse: [
            innerRect := self draw3DBoxWith: aPen at: aRect.
            side := (innerRect width min: innerRect height) // 7.
            aPen
                polygonFilled: (Array
                    with: (innerRect center down: side + 2)
                    with: (innerRect center rightAndUp: (side * 2 + 1) @ (side - 1))
                    with: (innerRect center leftAndUp: (side * 2 + 1) @ (side - 1)));
                fill: ((innerRect center leftAndUp: side @ (side*2 - 2 + Rectangle leftTopUnit y))
                    extentFromLeftBottom: (side*2+1) @ (side*2+1)) color: Color black].! !

!PScrollBar methods ! 
initialize

    super initialize.
    self
        minimum: 0;
        maximum: 100;
        lineIncrement: 1;
        pageIncrement: 24.! !

!WBCodeStream methods !
initialize
		"Private - Initialize the receiver."
	stream := WriteStream on: (String new: 1000).
	indent := lineStartPos := 0.
	parenthesis := OrderedCollection new.
	noParenthesis := false.! !

!PDrawnButton methods ! 
defaultForeColor

    ^Color buttonText! !

!WBTreeNode methods ! 
setChildren: aList

    children := aList! !

!WBLookPolicy methods ! 
displayWithRightBottomScrollBars: aPen rect: aRect backColor: aColor

	| innerRect newInnerRect backColor |
	backColor := (self class isDefault not 
		and: [(self asRGBColor: aColor) = (self asRGBColor: self defaultOS2WidgetBackColor)])
		ifTrue: [self defaultWidgetBackColor]
		ifFalse: [aColor].
	innerRect := self displayWithBorder: aPen rect: aRect backColor: backColor.
	newInnerRect := innerRect leftTop
		rightBottom: (innerRect rightBottom leftAndUp: (self scrollBarWidth @ self scrollBarHeight)).
	self
		drawVScrollBarWith: aPen
		at: (newInnerRect rightTop
			rightBottom: (innerRect rightBottom up: self scrollBarHeight));
		drawHScrollBarWith: aPen
		at: (newInnerRect leftBottom
			rightBottom: (innerRect rightBottom left: self scrollBarWidth)).
	aPen
		fill: (newInnerRect rightBottom rightBottom: innerRect rightBottom)
		color: Color gray.
	^newInnerRect! !

!WindowBuilder methods !   
newCompositePaneFrom: aWindowBuilder

    self editedClass: WBCompositePaneScratchWindow.
    self openWithParent: aWindowBuilder.
    self mainView propertyAt: #parentWB put: aWindowBuilder.
    self layoutForm initializeCompositePane.
    self mainView propertyAt: #creatingNewComposite put: true.
    self sendInputEvent: #setDirty.! !

!WBBitmapManagerWindow methods ! 
menuKeyNew

    "Callback for the menu item titled 'New...'.
     (Generated by WindowBuilder)"

	| newAssoc newKey newBitmap |
	newAssoc := WBCreateBitmap new
		openOn: self defaultNewKey;
		result.
	newAssoc isNil ifTrue: [^self].
	newKey := self checkNewKey: newAssoc key.
	newKey isNil ifTrue: [^self].
	newBitmap := newAssoc value.
	self menuKeyNew: (Array with: newKey => newBitmap).! !

!WBCreateViewModule methods !
withChildren
		"Answer the child panes."
	^(Array with: self view), self children! !

!WBLayoutForm methods ! 
drawOrderSymbols
    "Draw the order symbols"

    self isCurrentLayoutForm
        ifFalse: [^self].
    ^self drawOrderSymbolsFor: self children! !

!WBLayoutForm methods ! 
showHandles: aCollectionOfHandles color: aColor

    | target region |
    self selections isEmpty ifTrue: [^self].
    target := self selections first.
    region := self pen setClipRect: self shell frameContentRect.
    aCollectionOfHandles do: [:aHandle |
        aHandle owner == target
            ifTrue: [
                self directEditor isNil
                    ifTrue: [aHandle displayOn: self pen color: aColor]
                    ifFalse: [aHandle displayOn: self pen color: Color green]]
            ifFalse: [aHandle displayHollowOn: self pen color: aColor]].
    self pen destroyRegion: region.! !

!PScrollBar methods ! 
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	eventSymbol == #changed: ifTrue: [^#('position')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!WindowBuilder class methods ! 
initTranscriptMenuDelayed
	"Prompt the user to initialize the transcript menu."

	WBAboutDialog initTranscriptAfterClose: false.
	self resetTranscript! !

!WBLayoutForm methods !  
button1Move: aPoint
    "Private - button 1 is down and the mouse has been moved."

    self motionState notNil
        ifTrue: [self perform: self motionState with: aPoint].! !

!WBBitmapManagerWindow methods ! 
menuKeyFromClipboard

    "Callback for the menu item titled 'New...'.
     (Generated by WindowBuilder)"

	| newKey newBitmap |
	newBitmap := Clipboard getBitmap.
	newBitmap isBitmap ifFalse: [
		^MessageBox message:
			'The clipboard does not contain a bitmap.'].
	newBitmap := newBitmap wbCopy.
	newKey := Prompter prompt: 'Enter new key' default: self defaultNewKey.
	newKey isNil ifTrue: [^self].
	newKey := self checkNewKey: newKey.
	newKey isNil ifTrue: [^self].
	self menuKeyNew: (Array with: newKey => newBitmap).! !

!WindowBuilder methods !  
menuOptionsSetGridSize

	| gridSize |
	gridSize := self 
		getPointPrompting: 'Grid Size:' 
		defaultPoint: self gridSize.
	gridSize isNil 	ifTrue: [^self].
	((gridSize x < 3) | (gridSize y < 3)) & self drawGrid
		ifTrue: [
			(MessageBox confirm: 'This grid size is rather fine, and will take some time to display.   Are you sure you wish to display it?')
				ifFalse: [
					self drawGrid: false.
					self updateOptionsMenu]].
	self gridSize: gridSize.! !

!WindowBuilder methods !   
menuFileImportFromResFile

    | resFile |
    resFile := FileDialog
        new title: 'Import Resource File:';
        fileSpec: '*.res';
        hideReadonly;
        addFilter: '*.res' description: 'Resource file (*.RES)';
        defFilter: '*.res';
        open;
        file.
    resFile isNil
        ifFalse: [
            (self prototype: (WBPrototype importFromResFile: resFile owner: self)) notNil
                ifTrue: [
                    self setDirty.
                    self generateApplicationCode.
                    self editClass: self editedClass]].! !

!WBPoolManagerWindow methods !
selectedCategory
	"Answer the selected category if exactly one is selected,
		else answer nil."

	^self selectedCategories size = 1
		ifTrue: [self selectedCategories first]
		ifFalse: [nil]! !

!WBScratchWindow methods ! 
perform: selector with: arg
    "Scratch windows should not perform any events"
    ^self perform: selector! !

!StylePropertyAccessor methods !  
wbDefaultPoolKey

	^self style! !

!WBClassDefinition methods !   
classField
		"Answer the class that the receiver describes."
	^classField! !

!WBGeometryManager methods !
has3orMoreSelections

    ^self selections size > 2! !

!WindowBuilder methods !  
popupInstVarMenu: paneNamePane
	"Set the pop up menu for the inst var (pane name) pane."! !

!WBTreeNode methods ! 
owner
	"Answer the receiver's owner."

	^owner ifNil: [(parent ifNil: [^nil]) owner]! !

!Object class methods ! 
wbModelClass
    "Private - Answer the model class used by the receiver"
    ^nil! !

!PButtonListBox methods !   
storeStyleOn: aStream indentString: spaceString
    "Do Nothing"! !

!WBDescriptor methods !   
isFontAttribute

    ^self hasFlag: self fontFlag
! !

!WBInterfaceObject methods !  
isWBInterfaceObject

    ^true! !

!WBDescriptor methods !
isFontAttribute: aBoolean

    aBoolean
        ifTrue: [self addFlag: self fontFlag]
        ifFalse: [self removeFlag: self fontFlag]
! !

!WBAttributeEditor class methods !
wbBasicVersion
		"Private - Answer the window builder version."
	^2.0! !

!WBCreateViewsModule methods !  
objectHasMultipleViews
		"Private - Answer true if there are multiple views."
	^self object windows size > 1! !

!WBBitmapManagerWindow methods ! 
menuKeyDuplicate

	"Callback for the menu item titled 'New...'.
	 (Generated by WindowBuilder)"

	| newBitmap newKey |
	newBitmap := self selectedValue ifNil: [^self].
	newBitmap isOperatingSystemBitmap ifFalse: [newBitmap := newBitmap wbCopy].
	newKey := Prompter prompt: 'Enter new key' default: self defaultNewKey.
	(newKey isNil or: [newKey isEmpty]) ifTrue: [^self].
	(newKey first isUppercase and: [newKey first isLetter])
		ifFalse: [^MessageBox message: 'Key names must be valid pool names (e.g., first letter must be an upper case letter)'].
	newKey := self checkNewKey: newKey.
	newKey isNil ifTrue: [^self].
	self menuKeyNew: (Array with: newKey => newBitmap).! !

!WBPool methods ! 
fileOutOn: aStream
	"File out the receiver's contents."

	self fileOutCategories: self categories on: aStream.! !

!WBBasicCodeModule methods !  
owner
		"Answer the receiver's owner."
	^owner ifNil: [owner := WBCodeGenerator new]! !

!WBStatusPaneEditor methods !
setWidth: aString

    | box |
    list selection isNil ifTrue: [ ^nil ].
    box :=boxes at: list selection.
    box width: aString asInteger.! !

!WBLookPolicy methods !
borderWidthFrom: aFrameObject

    ^1! !

!WBDescriptor methods ! 
addFlag: aSymbol

    flags isNil ifTrue: [flags := Array new].
    flags := (flags asOrderedCollection add: aSymbol; yourself) asArray! !

!WindowBuilder methods ! 
updateOutboardZOrderChange: aCollectionOfWidgets
	"Update all of the outboard windows with the new z-order"

	self outboards do: [:window |
		window zOrderChanged: aCollectionOfWidgets].! !

!PWBVerticalScrollBar methods !  
suggestedSize

    ^17 @ self extent y! !

!PGroupbox methods !   
usesMenu

    ^false! !

!PScrollBar methods !
pageIncrement

    ^pageIncrement! !

!WBModelObjectEditor methods !  
enableFields

    name enable.
    instVar enable.
    when enable.
    send enable.! !

!WindowBuilder methods !  
inspectSelection

    self hasSelections
        ifFalse: [self shell inspect]
        ifTrue: [
            self selections size == 1
                ifTrue: [self selections first inspect]
                ifFalse: [self selections inspect]].
    ! !

!WBPoolManagerWindow methods ! 
categories
	"Answer a collection of all categories in the selected pools."

	^categoryListBox contents! !

!PCheckBox methods !  
winUserStyle

	style == #checkBox
		ifTrue: [^BsCheckbox].
	^BsAutocheckbox! !

!WBLookPolicyWin95 methods !
drawTitleBar: aFrameObject with: aPen in: aRect

    | titleRect titleTextRect |
    aFrameObject hasTitleBar ifFalse: [^self].
    titleRect := aRect leftTop extentFromLeftTop: aRect width @ self titleBarHeight.
    aFrameObject hasTitleBar
        ifTrue: [
            aPen fill: titleRect color: Color activeTitleBar.
             self
                drawTitleBarText: aFrameObject
                with: aPen
                in: (titleTextRect := self titleRectFrom: aFrameObject)].
    (aFrameObject style includes: #sysmenu)
        ifTrue: [
            aFrameObject isDialog
                ifFalse: [
                    self
                        drawSystemMenuWith: aPen
                        at: (titleRect leftTop extentFromLeftTop: self systemMenuWidth @ self titleBarHeight)].
            self
                drawCloseButtonWith: aPen
                at: ((titleRect rightTop leftAndDown: self closeButtonSize x + 2 @ 2)
                    extentFromLeftTop: self closeButtonSize).
            ((aFrameObject style includes: #minimize)
                or: [aFrameObject style includes: #maximize])
                ifTrue: [
                    (aFrameObject style includes: #minimize)
                        ifTrue: [
                            self
                                drawMinimizeButtonWith: aPen
                                at: ((titleRect rightTop leftAndDown:
                                    self minimizeButtonSize x + self maximizeButtonSize x + self closeButtonSize x + 4 @ 2)
                                    extentFromLeftTop: self minimizeButtonSize)]
                        ifFalse: [
                            self
                                drawMinimizeButtonDisabledWith: aPen
                                at: ((titleRect rightTop leftAndDown:
                                    self minimizeButtonSize x + self maximizeButtonSize x + self closeButtonSize x + 4 @ 2)
                                    extentFromLeftTop: self minimizeButtonSize)].
                    (aFrameObject style includes: #maximize)
                        ifTrue: [
                            self
                                drawMaximizeButtonWith: aPen
                                at: ((titleRect rightTop leftAndDown:
                                    self maximizeButtonSize x + self closeButtonSize x + 4 @ 2)
                                    extentFromLeftTop: self maximizeButtonSize)]
                        ifFalse: [
                            self
                                drawMaximizeButtonDisabledWith: aPen
                                at: ((titleRect rightTop leftAndDown:
                                    self maximizeButtonSize x + self closeButtonSize x + 4 @ 2)
                                    extentFromLeftTop: self maximizeButtonSize)]]].! !

!WBCodeStream methods !
nextPutStringConstant: aString
	"Look up the receiver in the NLS Pools to find a match.
		If found, then include the NLS variable in the code
		and answer true, else include a quoted string constant,
		and answer false."

	| pool |
	self owner targetClassDefinition nlsPools do: [:eachPool |
		eachPool associationsDo: [:eachAssoc |
			aString == eachAssoc value ifTrue: [
				(pool := WBNLSManager poolFor: eachPool) notNil ifTrue: [
					self
						nextPutValue: aString
						key: eachAssoc key
						pool: pool
						manager: pool manager.
					^true]]]].
	self nextPutAll: aString asQuotedString.
	^false! !

!WindowBuilder class methods !  
codeGenerationPropertyString

    ^#CodeGenerationProperties
! !

!WBResizeBitmap methods !  
newExtent

	^newExtent! !

!StylePropertyAccessor methods !   
wbFrameStyle
    "Private - Answer the style constant."

    ^self propertyAt: #wbFrameStyle! !

!Point methods !
extentFromCenter: aPoint
        "Private - WBPro Development."
        "Added by OSI - Answer a Rectangle whose center point is
         the receiver and extent is aPoint."
    #addedByOSI.
    ^Rectangle
        leftTop: (self leftAndUp: aPoint // 2)
        rightBottom: (self rightAndDown: aPoint - (aPoint // 2))! !

!PTextEdit methods !   
styleMap

    ^super styleMap
        at: #scrollBars put: #(#addHorizontalScrollbarStyle #addVerticalScrollbarStyle);
        at: #noScrollBars put: #(#removeHorizontalScrollbarStyle #removeVerticalScrollbarStyle #addBorderStyle);
        at: #noBorders put: #(#removeHorizontalScrollbarStyle #removeVerticalScrollbarStyle #removeBorderStyle);
        at: #wordWrap put: #(#removeHorizontalScrollbarStyle #addVerticalScrollbarStyle #addBorderStyle);
        yourself.! !

!WindowBuilder class methods !  
initMenu

	! !

!WBCreateViewModule methods ! 
initFontDefinitions
	"Add temporaries for all fonts used in the view."

	| name |
	self panesWithFonts do: [:eachPane |
		eachPane wbFontsUsed do: [:eachFont |
			(eachFont wbEquals: SysFont) ifFalse: [
				self varNameForFont: eachFont ifAbsentPut: [
					name := self constructVarNameForFont: eachFont.
					self temporaries add: name.
					name]]]].! !

!WBTemplateEditor methods !  
add

	"Callback for the #clicked event triggered in the Button named 'addButton'.
     (Generated by WindowBuilder)"

	| newTemplateClass |
	(newTemplateClass := (WBChoosePaneDialog new classList:
		(SubPane allSubclasses reject: [:c |
			(c symbol beginsWith: ' ') | c isWBInternalClass])) result) isNil ifTrue: [^self].
	(self templateAt: newTemplateClass name) isNil
		ifFalse: [
			(MessageBox confirm: 
				'A template already exists for ', newTemplateClass name, 
				'. Do you want to replace it?') ifFalse: [^self]].
	self 
		templateAt: newTemplateClass name asSymbol
		put: (newTemplateClass wbPseudoClass 
			exampleFrom: newTemplateClass name).

	self loadList.
	templateList selectItem: newTemplateClass name asSymbol.
	self templateSelected: templateList selectedItem.! !

!WBGeometryManager methods !
alignBottom
    "Align the selected widgets along their bottom sides"

    | target selections origins aWidget redoBlock |
    (selections := self selections copy) size > 1 ifFalse: [^self].
    target := selections first.
    origins := selections collect: [:widget | widget origin].
    self undoManager
        add: 'Align Bottom'
        undo:
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (origins at: i) x
                    y: (origins at: i) y;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: aWidget x
                    y: (target y + target height - aWidget height);
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!WindowBuilder class methods !  
drawGrid: aBoolean

    ^self editorClass
        propertyValueAt: #DrawGrid
        category: self gridPropertyString
        put: aBoolean! !

!WBPoolManagerWindow methods !
existingPoolsToAdd
	"Answer a collection of pool names."

	| answer |
	answer := SortedCollection new.
	Smalltalk associationsDo: [:eachAssoc |
		self poolManager class managers
			detect: [:eachMgr | (eachMgr poolFor: eachAssoc) notNil]
			ifNone: [
				(self poolManager isValidPool: eachAssoc value) ifTrue: [
					answer add: eachAssoc key]]].
	^answer! !

!WBEventManagerWindow methods ! 
sendFieldShowAll: aBoolean

	(sendFieldShowAll := aBoolean)
		ifTrue: [
			self optionMenu
				checkItem: #menuOptionSendFieldShowAll]
		ifFalse: [
			self optionMenu
				uncheckItem: #menuOptionSendFieldShowAll].
	self sendFieldUpdate.! !

!WindowBuilder class methods !
copyrightAfterBody

    ^self editorClass
        propertyValueAt: #CopyrightAfterBody
        category: self codeGenerationPropertyString.! !

!WBCodeStream methods ! 
nextPutBitmapNamed: aBitmapName inPoolNamed: aPoolName
	"Store the reference to the bitmap."

	WBCodeGenerator generateDirectBitmapRefs
		ifTrue: [
			self
				nextPutPoolKey: aBitmapName
				in: aPoolName]
		ifFalse: [
			self
				nextPutPool: aPoolName
				atKey: aBitmapName]! !

!WBCompositePaneModule methods !  
defaultMessageSelector
		"Private - Answer the default message selector."
	^#addSubpanes! !

!WBAbstractCreateViewsModule methods !   
generateCreateViewsStub
        "Generate the code..."
	self addModule: (
		WBCreateViewsStubModule new
			targetClass: self targetClass;
			object: self object;
			yourself ).! !

!WBScrapbookRetrieve methods !   
getScrollImage: position
    | pageList |
    (pageList := self paneNamed: 'pages') selectIndex: position.
    self getPage: pageList selectedItem.! !

!WBGraphicObject methods !   
bottomLeft

	^rect bottomLeft! !

!WindowFrameObject methods !
frameExtent

    ^self frameRect extent! !

!WBCreateClassDialog methods !
teamPackageChoices
    "Compute the list of packages in which the user could save the window"
	^(((Smalltalk at: #TeamVInterface) current packages
		select: [:pack | self isValidPackage: pack])
		collect: [:pack | pack name]) asSortedCollection asArray! !

!WBUndoManager methods !   
setRedoLabel: aString

    redoMenu
        changeItem: #redo
        label: aString replaceEscapeCharacters , (String with: Tab) , 'Ctrl+Shift+Z'! !

!WBLayoutFrameEditor methods !   
updateFramingBlocks

    | newFramingBlocks windowRect |
    newFramingBlocks := OrderedCollection new.
    self currentWidgets
        with: self currentFramingBlocks
        do: [:eachWidget :eachFramingBlock |
            windowRect := eachWidget parent isNil
                ifTrue: [
                    self mainView
                        propertyAt: #frameRect
                        ifAbsentPut: [self owner shellFrameContentRect]]
                ifFalse: [eachWidget parent frameContentRect].
            newFramingBlocks add: (
                eachFramingBlock
                    newFramerFromNewRect: (windowRect localizeRect: eachWidget rect)
                    parentRect: (0 @ 0 extent: windowRect extent))].
    currentFramingBlocks := newFramingBlocks.! !

!WBInterfaceObject class methods !  
classFrom: class and: style

	| theClass styleList winClass |
	winClass := class.
	winClass isString
		ifTrue: [winClass := (#('BUTTON' 'EDIT' 'STATIC' 'LISTBOX' 'SCROLLBAR' 'COMBOBOX') indexOf: winClass) + 127].
	theClass := self classAndStyleDict at: winClass ifAbsent: [PGenericSubpane].
	theClass isClass 
		ifFalse: [
			styleList := theClass.
			(styleList at: 1) isClass
				ifTrue: [
					theClass := styleList at: 1.
					styleList := styleList copyFrom: 2 to: styleList size].
			styleList do: [:a |
				(style bitAnd: (a at: 1)) = (a at: 2)
					ifTrue: [theClass := a at: 3]]].
	^theClass! !

!Bitmap class methods !   
wbSysModuleName
	"Answer the wb system bitmap module name."

	^self wbEditorClass devBitmapFileName! !

!WBTeamVCodePolicy class methods !   
annotationManager
		"Answer the annotation manager."
	^WBAnnotationManager ifNil: [
		WBAnnotationManager := Smalltalk at: #AnnotationManager ]! !

!WBEventDescription methods !
argumentNames

	^self arguments collect: [:each | each key]! !

!WindowFrameObject methods !  
attributeEditor

	^self isDialog 
		ifTrue: [WBDialogEditor]
		ifFalse: [WBWindowEditor].! !

!WBTeamVCodePolicy methods !  
wbScratchPackageName

	^'** WindowBuilder Pro Scratch **'! !

!WBScrollingPane methods !  
updateVerticalSlider

     self getScrollRanges.
    self updateVerticalSliderTo: topCorner y! !

!WBLayoutForm methods !
dropLocation
		"Answer the drag drop location."
	#osiHack.
	"For parts drag/drop support in wbpro development."
	^self propertyAt: #partsDragDropLocation! !

!WBFontSelectionWindow methods !  
applyChange
	"Set the font attributes for the current widget"

	| selections fonts boxes font widget redoBlock |
	(selections := self currentWidgets) isEmpty ifTrue: [^self].
	fonts := selections collect: [:eachWidget | eachWidget font].
	boxes := selections collect: [:eachWidget | eachWidget boundingBox].
	font := self selectedFont.
	self undoManager
		add: 'Set Font'
		undo: [
			self layoutForm hideHandles.
			1 to: selections size do: [:i |
				(widget := selections at: i) 
					font: (fonts at: i);
					configureWidget: widget x
					y: widget y
					width: (boxes at: i) width
					height: (boxes at: i) height
					borderWidth: widget borderWidth;
					wbUpdateConstraints]]
		redo: (redoBlock :=[
			self layoutForm hideHandles.
			1 to: selections size do: [:i |
				(selections at: i) font: font].
			self owner postEditUpdate]).
	redoBlock value.! !

!WBPoolManagerWindow methods !
initWindow

	self showAllCategoriesPrim: true.! !

!PStatusPane methods ! 
height

	^self font isNil
		ifTrue: [(UserLibrary getSystemMetrics: SmCycaption) - 1]
		ifFalse: [self font height + 8].! !

!WindowBuilder methods !   
paneNameIsValidInstVar: aString
	"Determine if aString is a valid inst var name, and enable/disable the i-var check box."

	instVar perform:
		((self editedClass wbGenerateInstVars 
			and: [(self editedClass wbReservedInstVarNames includes: aString) not 
			and: [aString = aString asInstVarToken]])
			ifTrue: [#enable]
			ifFalse: [#disable]).
	! !

!WindowBuilder class methods !
removeProperty: aSymbol

	((self propertiesAtCategory: self privateString) ifNil: [^nil])
		removeKey: aSymbol ifAbsent: [nil].! !

!WBListChooser class methods !   
promptForGlobal

    | globals selection |
    globals := SortedCollection new: Smalltalk size.
    Smalltalk associationsDo: [:each |
        each value wbCreated ifFalse: [
            globals add: each key]].
    selection := self
        fromList: globals
        prompt: 'Select a global...'.
    ^Smalltalk at: selection ifAbsent: [nil]! !

!Object methods !  
wbConvertEventTable: aDictionary
	"Convert the receiver's event table."

	self eventTable do: [:each |
		each asActionSequence do: [:eachAction |
			eachAction receiver: (
				aDictionary
					at: eachAction receiver
					ifAbsent: [eachAction receiver])]].! !

!WBAbstractAddInModule class methods !
loadAddIn
    "Load the receiver and perform any initializations."

    self loaded: true.
    self initializeOnLoad.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PEntryField methods !   
winClassStyle

    ^EsAutohscroll | EsNohidesel | WsBorder! !

!WBLayoutWizard methods !  
updateSourceButtons

    sourceInstance isNil
        ifTrue: [
            (self paneNamed: 'inspectButton') disable.
            (self paneNamed: 'browseClassButton') disable.
            (self paneNamed: 'defineButton') disable.
            (self paneNamed: 'generateButton') disable]
        ifFalse: [
            (self paneNamed: 'inspectButton') enable.
            (self paneNamed: 'browseClassButton') enable.
            (modelList contents includes: sourceInstance class)
                ifTrue: [(self paneNamed: 'defineButton') enable]
                ifFalse: [(self paneNamed: 'defineButton') disable].
            self owner isNil
                ifTrue: [(self paneNamed: 'generateButton') disable]
                ifFalse: [(self paneNamed: 'generateButton') enable]]! !

!WindowBuilder methods !  
menuToolsInspectSystemColorConstants

    SystemColorConstants inspect! !

!PDrawnButton methods !
backColor

	^(self parent notNil and: [
		self parent isNonWindowParent | 
		(self parent backColor = self parent defaultBackColor)])
		ifTrue: [self realBackColor]
		ifFalse: [super backColor].! !

!PWBHorizontalScrollBar methods !  
suggestedSize

    ^self extent x @ 17! !

!WBLayoutWizard methods !  
uncheckedAttribute: index

    (attributesList contents at: index) object
        propertyAt: #inLayout put: false! !

!WBMenuEditor methods !   
newAccelerator: text

    | accel |

    self warnOfAccelerators.

    self checkKeyAccels.

    (accel := WBKeyAccel new keyName: text) notNil ifTrue: [
		keyShortCutEditor text = accel keyName ifFalse: [
	        keyShortCutEditor text: accel keyName ].
    ] ifFalse: [
        isAlt selection: false.
        isCtrl selection: false.
        isShift selection: false.
    ].

    hasAccelCheckBox selection:  accel notNil.! !

!WBDevelopmentWindow methods !  
updateText: currentWidget
    "Update the text setting"

    (currentWidget notNil and: [currentWidget usesTitle])
        ifTrue: [
            self textEditor
                setContents: (self nlsKeyFor: currentWidget text);
                setPopupMenu: nil;
                enable.
            self textLabel enable]
        ifFalse: [
            self textEditor
                setContents: self noTextString;
                disable.
            self textLabel disable].! !

!WBTabOrderLayoutForm methods !
initialize
    "Private - Initialize the reciever"

    super initialize.
    showOrder := true.
    targetIsFirst := true.
    useDirectSelect := false.
    self initializeFonts.! !

!WindowBuilder methods ! 
gridSize: newSize

    | gridSize |
    "Store into GridSize property of WindowBuilder"
    gridSize := (newSize x max: 1) @ (newSize y max: 1).
    self class gridSize: gridSize.
    self drawGrid
        ifTrue: [self menuOptionsRedraw].
    ! !

!WBLayoutWizard class methods !
labelJustification: aSymbol

    LabelJustification := aSymbol! !

!WBPoolManagerWindow methods ! 
redrawCategories
	"Redraw the category list."

	categoryListBox redraw.! !

!ScrollBar class methods !   
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #changed: ;
                argumentNames: #('position'));
        yourself! !

!WBTabPosition methods !
withinGroup

    ^self inGroup & self firstInGroup not! !

!WBEventManagerWindow methods !
sendFieldNeedsContentsDeferred: aPane

	aPane
		disableRedraw;
		contents: self sendFieldList;
		enableRedraw.
	self zap.! !

!WBDevelopmentObject methods !  
isAltKeyDown

	^Notifier isAltKeyDown! !

!WBCodeStream methods ! 
crNoNewLine
		"Write the line terminating character (carriage-line-feed)
			to the receiver stream, then indent."
	self checkEnd.
	lineStartPos := stream position.
	stream next: indent put: Tab.! !

!WBPrototype methods !  
targetObject

	^targetObject! !

!PStaticBox methods !
suggestedSize

    ^100@100! !

!WBTabOrderLayoutForm methods !   
soloWidgets: aCollection

	soloWidgets := aCollection! !

!WindowBuilder class methods !  
codeModuleClassFor: aClass
	"Private - Answer the code module class."

	| objClass cmClass |
	objClass := aClass.
	[objClass notNil and: [
		(cmClass := self 
			propertyAt: (objClass name , 'CodeModule') asExistingSymbolOrNil 
			ifAbsent: [objClass defaultCodeModuleClass]) notNil
				ifTrue: [^cmClass].
		true]] whileTrue: [objClass := objClass superclass].
	^self error: 'no code generator module defined for this class'! !

!WBLayoutWizard methods !  
primaryModel

    ^self prototype primaryModel! !

!WBPoolEditorCompositePane methods !   
selectedKey

	^self owner selectedKey! !

!PRadioButtonGroup methods !
initialize

	super initialize.
	self numColumns: 1.! !

!WBScrapbookRetrieve class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowFrameObject methods ! 
contentRect

    | contentRect |
    self isDialog ifTrue: [^rect].
    contentRect := rect left @ (rect top down: self titleHeight + self menuHeight)
        rightBottom: rect right @ rect bottom.
    ^contentRect insetBy: self borderWidth! !

!WBColorDialog methods ! 
initWindow

	| c |

	colors := Color wbDefaultColors keys asSortedCollection asOrderedCollection.
	colors addFirst: #default.
	foreColor = thePane defaultForeColor
		ifTrue: [c := #default]
		ifFalse: [c := foreColor wbColorSelector ifNil: [#default]].

	(thePane usesForeColor) ifTrue: [
		(self paneNamed: 'foreColorList')
			contents: colors;
			selection: c.
	] ifFalse: [
		(self paneNamed: 'foreColorList')
			contents: #(#default);
			selection: #default;
			disable
	].

	backColor = thePane defaultBackColor
		ifTrue: [c := #default]
		ifFalse: [c := backColor wbColorSelector ifNil: [#default]].

	(self paneNamed: 'backColorList')
		contents: colors;
		selection: c.! !

!WBAttributeEditor methods !   
bitmapFromString: aStringOrBitmap

	^WBBitmaps 
		at: aStringOrBitmap 
		ifAbsent: [aStringOrBitmap]! !

!WBToolBar class methods ! 
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #showHelp: ;
                argumentNames: #('selector'));
        wbAddEvent: (
            WBEventDescription new
                event: #doubleClick: ;
                argumentNames: #('selector'));
        wbAddEvent: (
            WBEventDescription new
                event: #selecting: ;
                argumentNames: #('selector'));
        wbAddEvent: (
            WBEventDescription new
                event: #clicked: ;
                argumentNames: #('selector'));
        yourself! !

!ViewManager methods !  
modelNamed: modelName
    "Added by OSI"
    #addedByOSI.
    ^self modelObjects
        detect: [:modelObject | modelObject paneName = modelName]
        ifNone: [nil]! !

!WBLayoutForm methods !   
buttonReleaseSelecting: aPoint
    "Process a button release event after drag selecting."

    | shifted |
    self drawBand.

    shifted := Notifier isShiftKeyDown.

    self selections: (shifted
        ifFalse: [
            self children select: [:widget |
                self bandRect intersects: widget boundingBox]]
        ifTrue: [
            self children select: [:widget |
                (self bandRect containsPoint: widget boundingBox topLeft) and: [
                self bandRect containsPoint: widget boundingBox bottomRight]]]).

    self showHandles.! !

!WBPrimaryModelModule methods !   
defaultComment
        "Answer the default comment string."
    ^'Private - Answer the model class used by this window'! !

!WBTargetObject methods ! 
modelObjects

	^modelObjects ifNil: [
		modelObjects := OrderedCollection new]! !

!WBCallOutModule methods !
panesWithFonts
	"Answer a collection of panes with fonts."

	^Array with: self object! !

!WBBasicCodeModule methods !   
sourceString: aString
	"Set the source string."

	sourceString := aString.! !

!WBAbstractAddInModule class methods !
modifiesPalette
    "Does this add-in modify the palette?"

    ^false! !

!WindowBuilder class methods !
wbSystemBitmapNames
		"Answer the development system bitmap names."

	^#(
		'ActionButtonSysBitmap'
		'ButtonSysBitmap'
		'CheckBoxGroupSysBitmap'
		'CheckBoxSysBitmap'
		'ComboBoxSysBitmap'
		'CP3DCheckBoxSysBitmap'
		'CP3DFrameSysBitmap'
		'CP3DRadioButtonSysBitmap'
		'CPBitmapButtonSysBitmap'
		'CPBitmapPaneSysBitmap'
		'CPBitmapToggleSysBitmap'
		'CPCircularGaugeSysBitmap'
		'CPColumnarListBoxSysBitmap'
		'CPDateEditorSysBitmap'
		'CPHierarchicalListBoxSysBitmap'
		'CPHorizontalBarGaugeSysBitmap'
		'CPHorizontalSliderSysBitmap'
		'CPNumericEditorSysBitmap'
		'CPSpinButtonSysBitmap'
		'CPTableEditorSysBitmap'
		'CPTimeEditorSysBitmap'
		'CPValueSetSysBitmap'
		'CPVerticalBarGaugeSysBitmap'
		'CPVerticalSliderSysBitmap'
		'DrawnButtonSysBitmap'
		'EnhancedEntryFieldSysBitmap'
		'EntryFieldGroupSysBitmap'
		'EntryFieldSysBitmap'
		'GraphPaneSysBitmap'
		'GroupBoxSysBitmap'
		'LinkButtonSysBitmap'
		'ListBoxSysBitmap'
		'ListPaneSysBitmap'
		'MultipleSelectListBoxSysBitmap'
		'RadioButtonGroupSysBitmap'
		'RadioButtonSysBitmap'
		'SexPaneSysBitmap'
		'StaticBoxSysBitmap'
		'StaticGraphicSysBitmap'
		'StaticTextSysBitmap'
		'StatusPaneSysBitmap'
		'TextEditSysBitmap'
		'TextPaneSysBitmap'
		'TextSysBitmap'
		'ThreeStateButtonSysBitmap'
		'WB3DButtonSysBitmap'
		'WBAddressEditorPaneSysBitmap'
		'WBAddressPaneSysBitmap'
		'WBAddressSysBitmap'
		'WBAlignBottomSysBitmap'
		'WBAlignCenterHorizontalSysBitmap'
		'WBAlignCenterVerticalSysBitmap'
		'WBAlignDistributeHorizontalSysBitmap'
		'WBAlignDistributeVerticalSysBitmap'
		'WBAlignLeftSysBitmap'
		'WBAlignRightSysBitmap'
		'WBAlignTopSysBitmap'
		'WBAnimationPaneSysBitmap'
		'WBArrowToolSysBitmap'
		'WBAutosizeSysBitmap'
		'WBBitmapManagerToolbarSysBitmap'
		'WBBringToFrontSysBitmap'
		'WBCheckBoxOnSysBitmap'
		'WBCheckBoxSysBitmap'
		'WBClearSysBitmap'
		'WBCompositeSysBitmap'
		'WBCopySysBitmap'
		'WBCPStaticGraphicSysBitmap'
		'WBCreateNewDialogSysBitmap'
		'WBCreateNewSysBitmap'
		'WBCutSysBitmap'
		'WBDictionaryEditorPaneSysBitmap'
		'WBDuplicateSysBitmap'
		'WBEditAppCodeSysBitmap'
		'WBEditTabbingSysBitmap'
		'WBGroupSysBitmap'
		'WBHorizontalScrollBarSysBitmap'
		'WBListEditorPaneSysBitmap'
		'WBListSysBitmap'
		'WBLittleDownArrowSysBitmap'
		'WBLittleUpArrowSysBitmap'
		'WBMiscSysBitmap'
		'WBNamePaneSysBitmap'
		'WBOkCancelPaneSysBitmap'
		'WBOpenNewSysBitmap'
		'WBOsilogoSysBitmap'
		'WBOtherSysBitmap'
		'WBPasteSysBitmap'
		'WBPersonPaneSysBitmap'
		'WBPositionSysBitmap'
		'WBRadioButtonOnSysBitmap'
		'WBRadioButtonSysBitmap'
		'WBReplicateHeightSysBitmap'
		'WBReplicateWidthSysBitmap'
		'WBSaveSysBitmap'
		'WBSendToBackSysBitmap'
		'WBSetColorSysBitmap'
		'WBSetDrawGridSysBitmap'
		'WBSetFontSysBitmap'
		'WBSetFramingSysBitmap'
		'WBSetMenuSysBitmap'
		'WBSizeSysBitmap'
		'WBSteelPatternSysBitmap'
		'WBTestWindowSysBitmap'
		'WBToolBarSysBitmap'
		'WBToolPaneExampleSysBitmap'
		'WBValuatorSysBitmap'
		'WBVerticalScrollBarSysBitmap'
		'WBWbproSysBitmap'
		'WBWindowBuilderToolbarBitmapSysBitmap'
		'WBWindowSysBitmap'
	)! !

!WBActionLinkAddInModule class methods !   
comment

	^'WARNING!!  Using ActionButtons 
and LinkButtons for other than 
prototyping is discouraged 
and may not be supported 
in future releases'! !

!WBAbstractAddInModule class methods !  
module

    ^nil! !

!WBApplicationCoordinatorModule methods !
generateDefinitions
        "Generate a definition for each of the view's elements."
    self
		generateChildDefinitions;
		generateFontDefinitions.! !

!WBInterfaceObject class methods ! 
templateRemove: aClassName

	^self templates 
		removeKey: aClassName asSymbol 
		ifAbsent: [nil].! !

!PButton methods !   
mutationTypes

    ^#(#Button #CPBitmapButton #CPBitmapPane)! !

!PTextEdit methods ! 
mutationTypes

    ^#(#EntryField #StaticText #Toggle #CPSpinEditor)! !

!Array methods ! 
asOrderedCollectionRecursively
	"Private - WBPro Development."

	#addedByOSI.
	^(self collect: [:element |
			element isArray
				ifTrue: [element asOrderedCollectionRecursively]
				ifFalse: [
					element == #nil
						ifTrue: [nil]
						ifFalse: [element]]]) asOrderedCollection.! !

!PLinkButton methods !
attributeEditor

    ^Notifier isAltKeyDown
        ifTrue: [super attributeEditor]
        ifFalse: [WBLinkEditor].! !

!WBCodeStream methods !
indentBy: anInteger
		"Indent the receiver."
	indent := indent + anInteger.! !

!WBLayoutForm methods !   
removeHandlesFor: aWidget

    | removed |
    removed := self handles select: [:aHandle | aHandle isFor: aWidget].
    self handles: (self handles reject: [:aHandle | aHandle isFor: aWidget]).
    ^removed! !

!WBCreateViewModule methods !   
generateChildDefinitions
        "Generate a definition for each of the view's elements."
    | sortedChildren eachChild first callOuts primaryModelModule |

    "Define the children in order sorted by var name."
    self primaryModel isNil
        ifFalse: [
            self addModule: (WBPrimaryModelModule new
                targetClass: self targetClass;
                object: self object;
                yourself).
            (primaryModelModule := WBPrimaryModelOpenOnModule new
                targetClass: self targetClass;
                object: self object;
                yourself) okToGenerate
                ifTrue: [self addModule: primaryModelModule].
            (primaryModelModule := WBPrimaryModelInitializeModule new
                targetClass: self targetClass;
                object: self object;
                yourself) okToGenerate
                ifTrue: [self addModule: primaryModelModule]].
    sortedChildren :=
        ((self children asOrderedCollection
                reject: [:each | each isWBPrimaryModel])
            collect: [:each | Association key: (self varNameFor: each) value: each])
                asSortedCollection.
    callOuts := sortedChildren select: [:eachAssoc | eachAssoc value creationMethodSelector notNil].
    sortedChildren := sortedChildren select: [:eachAssoc | eachAssoc value creationMethodSelector isNil].

    "First define the inst vars."
    first := true.
    sortedChildren do: [:eachAssoc |
        (self isInstVar: eachAssoc key) ifTrue: [
            first ifTrue: [
                self stream cr; indentBy: 1 during: [
                    self stream cr; nextPutComment: 'Instance Variables'].
                first := false].
            eachChild := eachAssoc value.
            self generateDefinitionFor: eachChild instVar: true & self useInstVars not]].

    "Then define the temp vars."
    first := true.
    sortedChildren do: [:eachAssoc |
        (self isInstVar: eachAssoc key) ifFalse: [
            first ifTrue: [
                self stream cr; indentBy: 1 during: [
                    self stream cr; nextPutComment: 'Temporary Variables'].
                first := false].
            eachChild := eachAssoc value.
            self generateDefinitionFor: eachChild]].

    "Then define the callouts"
    first := true.
    callOuts do: [:eachAssoc |
        first ifTrue: [
            self stream cr; indentBy: 1 during: [
                self stream cr; nextPutComment: 'Call Outs'].
            first := false].
        self generateCallOutFor: eachAssoc value instVar: (self isInstVar: eachAssoc key) & self useInstVars not].! !

!WindowBuilder methods !   
updateNlsActiveCategory: aCategory

	self nlsMenu
		uncheckAll;
		checkItem: aCategory.! !

!PComboBox methods !
importantEvents

    ^super importantEvents
        addFirst: #textChanged:;
        addFirst: #clicked:;
        addFirst: #changed:;
        yourself! !

!WBLayoutForm methods !   
targetIsFirst: aBoolean
    "Set the value of targetIsFirst."

    targetIsFirst := aBoolean! !

!WindowBuilder methods !
menuToolsInitializeAttributes

	WBPropertyManager current reinitialize.! !

!WBPoolManagerWindow methods !
poolPathChanged: aString pane: aPane

    "Callback for the #textChanged: event triggered in the EntryField named 'poolPathField'.
     (Generated by WindowBuilder)"

	self poolPath: aString.! !

!WBWindowEditor methods !  
ok

    | aSet anArray |

    aSet := Set new.
    (self paneNamed: 'systemMenu') selection ifTrue: [
        aSet add: #sysmenu.
    ].

    (self paneNamed: 'maximizeBox') selection ifTrue: [
        aSet add: #maximize.
    ].

    (self paneNamed: 'minimizeBox') selection ifTrue: [
        aSet add: #minimize.
    ].

    (self paneNamed: 'sizingFrame') selection ifTrue: [
        aSet add: #sizable.
    ].

    (self paneNamed: 'titleBar') selection ifTrue: [
        aSet add: #titlebar.
    ].

    "Support for MainView children"
    (self paneNamed: 'mainViewChild') selection ifTrue: [
        aSet add: #mainViewChild.
    ].

    iconEditor notNil ifTrue: [
        iconEditor fileName notNil ifTrue: [
            iconFile := ((anArray := File splitPath: iconEditor fileName in: Disk) at: 2),'\',(anArray at: 3).
        ]
    ].

    thePane := thePane wbCopy.

    thePane
        style: aSet;
        iconFile: iconFile.

    super close.! !

!WBClassDefinition methods !   
hasInstVarsChanged
		"Answer true if the receiver's inst vars are different."
	(instVarNames ifNil: [ ^false ])
		do: [ :eachInstVarName |
			(self classField instVarNames includes: eachInstVarName
				) ifFalse: [ ^true ] ].
	^false! !

!PDrawnButton methods ! 
styles

    ^self wbEditorClass runtimeLessCode
        ifTrue: [#(#fixedSize #stretchToFit)]
        ifFalse: [#(#fixedSize #stretchToFit #invisible)]! !

!PWBToolBar methods !   
usesFraming

    ^self style ~~ #mdiToolBar! !

!WBTreeNode methods ! 
childBefore: aChild

    ^children before: aChild ifNone: [ nil ]! !

!BitEditor methods !
close
    super close.
    copy release! !

!WBLookPolicyOS2 methods !
frameWidthBorder

	^frameWidthBorder ifNil: [
		frameWidthBorder := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCxborder" 26]
			ifFalse: [super frameWidthBorder]]! !

!WindowBuilder methods !  
updateLayoutProperties

    self layoutForm
        dragOutline: self dragOutline;
        showOrder: self showZOrder;
        targetIsFirst: self targetIsFirst;
        useFence: self useFence;        
        useDirectSelect: self useDirectSelect;
        yourself.! !

!WindowBuilder class methods !  
aboutWB

    WBAboutDialog new open! !

!PButton methods !
specialId: anObject

    specialId := anObject! !

!WBBitmapManagerWindow methods !   
sameValueForAllCategories
	"Answer true if the same bitmap should be used
		for all categories."

	^SameValueForAllCategories ifNil: [false]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder methods !  
prepareAppWindowsForSave: windowList

	"Scan through the panes, looking for methods and instance
	 variables to predeclare."

	| allSelectors menuPanes methodsToDeclare methodNames panesToScan
	 poolDictionaries sharedPools sharedVariableString generateClassDef index |

	CursorManager execute change.

	"Since we don't log source, recompiling the class will fail
	  when trying to compile the open method.  To avoid this, we
	  remove the old method first"

	(self editedClass isScratchWindow and: [self inENVY not])
		ifTrue: [
			self class openMethodType isNil
				ifTrue: [self editedClass removeSelector: #open]
				ifFalse: [self editedClass removeSelector: self class openMethodType]].

	poolDictionaries := Set new.
	methodsToDeclare := Dictionary new.
	methodNames := self editedClass selectors asOrderedCollection.

	self editedClass allSuperclasses do: [:aClass |
		methodNames addAll: aClass selectors].

	panesToScan := OrderedCollection new.
	windowList do: [:view |
		poolDictionaries addAll: view nlsPools.
		panesToScan addAll: view children copy].
	panesToScan addAll: self children.

	menuPanes := OrderedCollection new.

	windowList do: [:view |
		view menu notNil
			ifTrue: [
				(allSelectors := view menu allSelectors) keysDo: [:aSelector |
					(aSelector isSymbol) & (methodNames includes: aSelector) not
						ifTrue: [
							methodsToDeclare
								at: aSelector
								put: (self commentForMenu: (allSelectors at: aSelector))]]].

		view oldEventHandlersDo: [:assoc |
			(assoc value isSymbol) & (methodNames includes: assoc value) not
				ifTrue: [
					methodsToDeclare
						at: assoc value
						put: (self commentForTopPane: view event: assoc key)]].

		"These method stubs are now automatically generated by WBCodeModule>>nextPutEventTable:for:
		view eventHandlersDo: [:assoc |
			msg := assoc value.
			(selector := msg selector) isString ifTrue: [selector := selector asSymbol].
			((selector isSymbol) & (methodNames includes: selector) not and: [
				msg receiver == self prototype targetObject])
					ifTrue: [
						methodsToDeclare
							at: selector
							put: (Array
								with: view
								with: assoc key
								with: (self commentForTopPane: view event: assoc key))]]"  ].

	panesToScan do: [:widget |
		widget menu notNil
			ifTrue: [
				(allSelectors := widget menu allSelectors) keysDo: [:aSelector |
					(aSelector isSymbol) & (methodNames includes: aSelector) not
						ifTrue: [
							methodsToDeclare
								at: aSelector
								put: (self commentForMenu: (allSelectors at: aSelector))]]].

		widget oldEventHandlersDo: [:assoc |
			(assoc value isSymbol) & (methodNames includes: assoc value) not
				ifTrue: [
					methodsToDeclare
						at: assoc value
						put: (self commentForWidget: widget event: assoc key)]].

		"These method stubs are now automatically generated by WBCodeModule>>nextPutEventTable:for:
		widget eventHandlersDo: [:assoc |
			msg := assoc value.
			(selector := msg selector) isString ifTrue: [selector := selector asSymbol].
			((selector isSymbol) & (methodNames includes: selector) not and: [
				msg receiver == self prototype targetObject])
					ifTrue: [
						methodsToDeclare
							at: selector
							put: (Array
								with: widget
								with: assoc key
								with: (self commentForEvent: widget event: assoc key selector: selector))]]."

		widget extraHandlers do: [:aSelector |
			(aSelector isSymbol) & (methodNames includes: aSelector) not
				ifTrue: [methodsToDeclare at: aSelector put: (self commentForExtra: widget)]].

		poolDictionaries addAll: widget requiredPoolDictionaries].

	(methodsToDeclare notEmpty) & (self editedClass isScratchWindow)
		ifTrue: [
		"Do not generate any methods for a scratch window"
		methodsToDeclare := Dictionary new].

	methodsToDeclare keysDo: [:aMethod |
		self declareMethod: aMethod commentString: (methodsToDeclare at: aMethod)].

	"Make sure it has the local Constants pool dictionary"
	sharedPools := self editedClass sharedPools.
	self editedClass isScratchWindow
		ifTrue: [
			poolDictionaries add: #OperatingSystemConstants; add: #ColorConstants.
			self editedClass setSharedPools: poolDictionaries asArray]
		ifFalse: [
			sharedVariableString := self editedClass sharedVariableString.
			generateClassDef := false.
			
			"Remove the old pools..."
			#(#WBConstants #WinConstants #PMConstants) do: [:dict |
				(index := sharedVariableString indexOfString: dict) > 0 ifTrue: [
					generateClassDef := true.
					sharedVariableString :=
						(sharedVariableString
							copyFrom: 1
							to: index - 1),
						(sharedVariableString
							copyFrom: index + dict size + 1
							to: sharedVariableString size)]].
			poolDictionaries
				remove: #WBConstants ifAbsent: [ ];
				remove: #WinConstants ifAbsent: [ ];
				remove: #PMConstants ifAbsent: [ ].

			"Add the new pools..."
			poolDictionaries add: #ColorConstants.
			(sharedPools includes: #OperatingSystemConstants)
				ifFalse: [poolDictionaries add: #OperatingSystemConstants].

			poolDictionaries do: [:dict |
				(sharedPools includes: dict)
					ifFalse: [
						sharedVariableString := sharedVariableString,' ',dict asString.
						generateClassDef := true]].
			generateClassDef
				ifTrue: [
					self editedClass superclass
						subclass: self editedClass name asSymbol
						instanceVariableNames: self editedClass instanceVariableString
						classVariableNames: self editedClass classVariableString
						poolDictionaries: sharedVariableString]].

	CursorManager normal change.! !

!WBCreateViewModule methods ! 
generatePaneName: aPane
        "Private - Generate the pane name definition."
    | name |
    (name := aPane paneName ifNil: [ '' ]
        ) notEmpty ifTrue: [
            name := name isSymbol
                ifTrue: [ '#', name ]
                ifFalse: [ name asQuotedString ].
            self stream
                cr;
                nextPutAll: #setName: ;
                space;
                nextPutAll: name;
                endMessage ].! !

!WBAddInManager class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBModelObjectEditor class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBLayoutForm methods !  
clearHandles

    self handles: self emptyCollection.! !

!PButton methods !  
autoRecognizeOkCancel

    "By default, OK and Cancel buttons are automatically
     recognized and assigned the ID_OK and ID_CANCEL
     styles. Whenever the 'Enter' key is pressed, the #clicked
     event handler of the OK button is executed. Whenever
     the 'Esc' key is pressed, the #clicked event handler of
     the Cancel button is executed."

    ^self class autoRecognizeOkCancel! !

!WBTeamVCodePolicy class methods !  
teamInterface
		"Answer the Team/V interface."
	^WBTeamVInterface ifNil: [
		WBTeamVInterface := self defaultTeamInterface ]! !

!WBScrapbookRetrieve methods !  
getChapter: selectedItem
    | pageList |
    (chapter := selectedItem) isNil ifFalse: [
        self loadPages: (pageList := self paneNamed: 'pages').
        self pages isEmpty ifFalse: [
            page := self pages first.
            pageList selectItem: page.
            self getPage: page.
        ] ifTrue: [
            self displayImage: (self paneNamed: 'graphic').
             (self paneNamed: 'name') contents: ''.
            self updateScrollBar.
        ].
    ].
    chapter = 'Quick Reference' ifTrue: [
        (self paneNamed: 'remove') disable
    ] ifFalse: [
        (self paneNamed: 'remove') enable
    ].! !

!WBScrollingPane methods !  
scrollVertical: anInteger

    self scrollTopCorner: 0 @ anInteger! !

!WindowBuilder methods !   
dragOutline

    ^self class dragOutlines! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!Bitmap methods ! 
wbButtonDownBox
    "Private - Answer the up button contents box."

    | box |
    box := self wbButtonUpBox.
    box := (box leftTop right: self width // 2) extentFromLeftTop: box extent.
    ^box rightAndDown: 2! !

!WindowBuilder methods !   
codePolicy
	"Private - Answer the code policy."

	^self 
		propertyAt: #CodePolicy 
		ifAbsent: [self defaultCodePolicy]! !

!WBLayoutFrameEditor methods !
leftAttachmentFor: aCollection
	"Answer the left attachment for the specified framing blocks."

	| ratio |
	aCollection do: [:each |
		ratio notNil
			ifTrue: [
				each wbLeftProportional
					ifTrue: [ratio = self proportional ifFalse: [^'']]
					ifFalse: [ratio = each leftRatio asRational ifFalse: [^'']]]
			ifFalse: [
				each wbLeftProportional
					ifTrue: [ratio := self proportional]
					ifFalse: [ratio := each leftRatio asRational]]].
	ratio ifNil: [^''].
	ratio isString ifTrue: [^ratio].
	^self class horizontalRatioStrings at: ratio ifAbsent: [ratio printString]! !

!WBEventManagerWindow methods ! 
menuMethodSave

    "Callback for the menu item titled 'Save'.
     (Generated by WindowBuilder)"

	self methodTextSaved: methodTextEdit.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PScrollBar methods !   
realClassName

    ^'ScrollBar'! !

!WBPoolManagerWindow methods !
showAllCategories: aBoolean
	"Set true if all categories should be shown."

	showAllCategories = (aBoolean ~= false) ifFalse: [
		self showAllCategoriesPrim: (aBoolean ~= false).
		self updateCategories].! !

!WBRGBColorDialog methods !   
elementSelected: selectedItem

    "Callback for the #clicked: event triggered in the WBListBox named 'elementsList'.
     (Generated by WindowBuilder)"

    self updateColorList: selectedItem.

    self sendInputEvent: #updateRGBField: with: (elements at: selectedItem)! !

!PRadioButtonGroup methods !  
storeContentsOn: aStream indentString: spaceString! !

!WindowBuilder class methods !   
insertMenu: anArray before: menuNameString

	| menus target oc aString |
	menus := self wbMenus.
	aString := menuNameString replaceEscapeCharacters stripMnemonic.
	oc := anArray asOrderedCollectionRecursively.
	target := menus detect: [:m | 	(m at: 1) stripMnemonic = aString] ifNone: [nil].
	target isNil ifFalse: [^menus add: oc before: target].
	menus do: [:menu |
		(menu at: 3) do: [:mi |
			mi isSymbol
				ifFalse: [
					(mi at: 1) stripMnemonic = aString
						ifTrue: [^(menu at: 3) add: oc before: mi].
					(mi at: 3) isString
						ifFalse: [
							(mi at: 3) do: [:msi |
								msi isSymbol
									ifFalse: [
										(msi at: 1) stripMnemonic = aString
											ifTrue: [^(mi at: 3) add: oc before: msi]]]]]]].! !

!WindowBuilder class methods ! 
useDirectSelect

    ^self editorClass
        propertyValueAt: #UseDirectSelect
        category: self editorPropertyString! !

!WindowFrameObject methods !   
titleRectFrom: aPoint

    ^self lookPolicy titleRectFrom: self! !

!WBTreeNode class methods !   
new

    ^super new initialize! !

!WBLayoutForm methods !
useFence: aBoolean
    "Set the value of useFence."

    useFence := aBoolean! !

!WBPoolManagerWindow methods ! 
categoryListNeedsContents: aPane

    "Callback for the #needsContents event triggered in the MultipleSelectListBox named 'categoryListBox'.
     (Generated by WindowBuilder)"

	| all oldSelection newContents newSelection |
	all := self allCategories.
	oldSelection := self selectedCategories.
	self showAllCategories
		ifTrue: [newContents := all]
		ifFalse: [
			newContents := Set new.
			self selectedPools do: [:each | newContents addAll: each categories].
			newContents := newContents asSortedCollection].
	newSelection := oldSelection select: [:each | newContents includes: each].
	aPane contents: newContents.
	self selectedCategories: newSelection.

	activeCategoryField
		contents: all;
		selection: self poolManager activeCategory.! !

!PButton methods !  
usesColor

    ^Smalltalk platformIsOS2! !

!WBPoolManagerWindow methods !
updateValue: anObject at: aKey in: aCategory pool: aPool

	self selectedCategory = aCategory
		ifTrue: [
			self redrawKeys.
			self selectedKey = aKey ifTrue: [
				self redrawCategories.
				editorCompositePane updateEditorValue]]
		ifFalse: [
			self selectedKey = aKey ifTrue: [
				self redrawCategories]].! !

!WindowBuilder methods !  
shell

	^self prototype shell! !

!WindowBuilder methods !
menuToolsInspectAllInstances

    | collection |
    (collection := self prototype realClass allInstances) size == 1
        ifTrue: [collection first inspect]
        ifFalse: [
            collection isEmpty
                ifTrue: [MessageBox message: 'No Instances']
                ifFalse: [collection inspect]].! !

!PEntryFieldGroup methods !  
usesTitle

    ^true! !

!WBAbstractCodeModule methods !  
indentSuccessiveCommentLines

	^false! !

!WBEventManagerWindow methods ! 
activated

	super activated.
	self updateLabel.! !

!WBCallOutModule methods !   
defaultMessageArguments
        "Private - Answer the default message selector arguments."
    ^Array with: self defaultOwnerName! !

!WindowBuilder methods !
sizeLabel

	^sizePane! !

!WBInterfaceObject methods !
defaultStyle

	| styles |
	^(styles := self styles) isNil 
		ifTrue: [nil]
		ifFalse: [styles first]! !

!WBListEditor methods !   
delete

	Notifier isAltKeyDown
		ifTrue: [list := OrderedCollection new]
		ifFalse: [
			listBox selection isNil ifTrue: [^nil].
			list removeIndex: listBox selection].
	listBox contents: list.
	item contents: ''.
	self disable.! !

!WBGeometryManager methods ! 
selectionsInZorder

    self layoutForm isNil ifTrue: [^#()].
    ^self layoutForm selectionsInZorder! !

!WBLookPolicy methods !
frameWidthSizable

    ^4! !

!PStaticText methods !  
mutationTypes

    ^#(#EntryField #StaticText #Toggle)! !

!PropertyAccessor methods !
wbDuplicateFrom: anObject to: copyObject using: aPropertyManager
	"Duplicate the property."

	#addedByOSI.
	(aPropertyManager getAccessor: self name ifAbsent: [^self])
		wbDuplicateValue: (self getValueFor: anObject)
		for: copyObject.
	^copyObject! !

!WBUndoManager methods !
setRedoState: aBoolean

    aBoolean
        ifTrue: [redoMenu enableItem: #redo]
        ifFalse: [redoMenu disableItem: #redo]! !

!WindowBuilder methods !   
updateMenuEdit

	(self menuTitled: 'Edit') updateEnabled.! !

!WBPropertyEditor methods ! 
useDefaults

    (MessageBox confirm: 'Set all properties to default values?') ifFalse: [^self].
    WindowBuilder resetDefaults.
    self revertPrim.! !

!WBGraphicObject methods !   
y

	^self origin y! !

!WBTreeNode methods !  
updateListStrings

    children do: [ :c |
        c listString: c title.
        c updateListStrings.
    ].! !

!Color methods ! 
storeColorOn: aStream
		"Store the color definition."
	| key |
	#addedByOSI.
	key := self wbColorSelector ifNil: [^self basicStoreColorOn: aStream].
	aStream
		nextPutAll: #Color ;
		space;
		nextPutAll: key.! !

!PEntryFieldGroup methods !
mutateSpecificsFrom: aPane
	| list |
	((list := aPane contents) notNil and: [list isArray | list isDictionary])
		ifTrue: [self contents: list deepCopy].
	(aPane respondsTo: #label)
		ifTrue: [self label: aPane label].! !

!WBResizeBitmap methods !   
newHeight: anInteger

	newHeightField contents: anInteger asString.! !

!WBActionEditor methods ! 
help

    MessageBox notify: 'Action Attributes Help' withText:
'Enter the text for your action in the ''Method
Text'' box. The window may be referred to as
''self window''. The button or menuItem can be
refered to as ''self button'' or ''self menuItem''.

To remove an action, delete the method named
"action<ActionName>" from the class WBAction.'! !

!Object methods ! 
wbBecome: anObject
	"Change all references that point to the receiver
		to point to anObject instead."

	self become: anObject.

	"If the receiver was in the SystemWeakRegistries current
		then it must be rehashed because it is based on #basicHash
		and anObject has a different #basicHash than the receiver."
	SystemWeakRegistries current events ephemerons rehash.
	SystemWeakRegistries current externalResources ephemerons rehash.
	SystemWeakRegistries current finalizer ephemerons rehash.
	SystemWeakRegistries current notifier ephemerons rehash.
	SystemWeakRegistries current properties ephemerons rehash.! !

!WindowBuilder methods ! 
menuOptionsProperties

	WBPropertyEditor new open! !

!WBCreateClassDialog methods !  
setDefault
    "Callback for the #clicked event triggered in the Button named 'setDefault'.
     (Generated by WindowBuilder)"

    | defaultType |
    self class
        defaultType:
            (defaultType := (self paneNamed: 'setViewManager') selection
            ifTrue: [#ViewManager]
            ifFalse: [#ApplicationCoordinator]).
    self class
        defaultSuperClassFor: (limitTo = 'CompositePane'
            ifTrue: [#CompositePane]
            ifFalse: [
                limitTo = 'EventManager'
                    ifTrue: [#EventManager]
                    ifFalse: [
                        limitTo = 'Window'
                            ifTrue: [
                                defaultType == #ViewManager
                                    ifTrue: [#ViewManager]
                                    ifFalse: [#ApplicationCoordinator]]
                            ifFalse: [
                                defaultType == #ViewManager
                                    ifTrue: [#WindowDialog]
                                    ifFalse: [#DialogCoordinator]]]])
        put: (Smalltalk at: (self paneNamed: 'superclassName') selectedItem asSymbol).
    self class defaultPackage: (self paneNamed: 'packageName') selectedItem! !

!WBCodePolicy methods ! 
basicCompileMethodFor: aCodeModule
		"Private - Compile and store the method.
			Answer an association with key = selector and value = compiled method
			if sucessful, else answer nil."
	self implementedBySubclass.! !

!WindowBuilder methods ! 
selections

    ^self layoutForm selections! !

!ApplicationCoordinator class methods !   
defaultCodeModuleClass
        "Answer the default code module for the receiver."
    ^WBApplicationCoordinatorModule! !

!WBAbstractAddInModule class methods !  
initializeOnLoad
    "Perform initializations of loading"! !

!WBLayoutForm methods !  
redisplaySelection

    self updateRect: (self boundingBoxFor: self selections).! !

!WindowBuilder methods ! 
menuScrapbookMerge

	| fileName scrapbook mergeScrapbook overWrite |
	(Smalltalk includesKey: #ObjectFiler)
		ifFalse: [^MessageBox message: 'Merging a Scrapbook requires the ObjectFiler. Install ''\EXTRAS\OBJFILER\VOF*.SLL''.'].
	fileName := (FileDialog new
			openTitle: 'Merge Scrapbook'
			fileSpec: '*.SBK'
			showFileInButton: false) file.
	fileName isNil
		ifFalse: [
			mergeScrapbook := (Smalltalk at: #ObjectFiler) loadFromPathName: fileName.
			scrapbook := self class scrapbook.
			overWrite := nil.
			mergeScrapbook keysDo: [:chapter |
				(scrapbook includesKey: chapter)
					ifFalse: [scrapbook at: chapter put: (mergeScrapbook at: chapter)]
					ifTrue: [
						(mergeScrapbook at: chapter) keysDo: [:page |
							(overWrite isNil and: [(scrapbook at: chapter) includesKey: page])
								ifTrue: [overWrite := MessageBox confirm: 'Overwrite existing pages with the same names?'].
							(overWrite == false and: [((scrapbook at: chapter) includesKey: page)])
								ifTrue: [(scrapbook at: chapter) at: (page , '.2') put: ((mergeScrapbook at: chapter) at: page)]
								ifFalse: [(scrapbook at: chapter) at: page put: ((mergeScrapbook at: chapter) at: page)]]].
				self updateQuickReferenceMenu]].! !

!WBInterfaceObject methods !   
storeColorOn: aStream indentString: indentString

	self foreColor notNil 
		ifTrue: [
			(self asRGBColor: self foreColor) ~= (self asRGBColor: self defaultForeColor)
				ifTrue: [
					aStream nextPutAll: ';'; cr;
						nextPutAll: indentString;
						nextPutAll: #foreColor: ;
						space;
						nextPutColor: self foreColor]].
	self realBackColor notNil
		ifTrue: [
			(self asRGBColor: self realBackColor) ~= (self asRGBColor: self defaultBackColor)
				ifTrue: [
					aStream nextPutAll: ';'; cr;
						nextPutAll: indentString ;
						nextPutAll: #backColor: ;
						space;
						nextPutColor: self realBackColor]].! !

!WBTabOrderLayoutForm methods !
buttonReleaseMovingTabPosition: aPoint
    "Process a button release event after moving a tab position."

	| targetWidget delta |
	(targetWidget := self findChildFor: aPoint) ifNil: [^nil].
	(targetWidget tabPosition isNil
		or: [(targetWidget tabPosition inGroup or: [self dragWidget tabPosition inGroup])
		and: [targetWidget tabPosition basicTabPosition ~= self dragWidget tabPosition basicTabPosition]])
		ifTrue: [^Terminal bell].
	delta := self dragWidget tabPosition <= targetWidget tabPosition
		ifTrue: [0.5]
		ifFalse: [-0.5].
	Notifier isControlKeyDown
		ifTrue: [self dragWidget tabPosition: targetWidget tabPosition copy]
		ifFalse: [targetWidget tabPosition: self dragWidget tabPosition copy].
	self dragWidget tabPosition inGroup
		ifTrue: [self dragWidget tabPosition groupPosition: self dragWidget tabPosition groupPosition + delta]
		ifFalse: [self dragWidget tabPosition basicTabPosition: self dragWidget tabPosition basicTabPosition + delta].
	self 
		dragWidget: nil;
		resetGroups;
		normalizeTabOrder;
		updateRect: self shell frameContentRect;
		triggerEvent: #setTabPosition.! !

!WindowBuilder class methods !  
wbDefaultFont

	| defaultFont |
	defaultFont := self propertyAt: #WBDefaultFont.
	defaultFont isNil
		ifTrue: [
			defaultFont := Font fromStockFont: SystemFont.
			self propertyAt: #WBDefaultFont put: defaultFont].
	^defaultFont! !

!WBStandardCodePolicy methods !   
basicCompileMethodFor: aCodeModule
		"Private - Compile and store the method.
			Answer an association with key = selector and value = compiled method
			if sucessful, else answer nil."
	^aCodeModule targetClass compile: aCodeModule sourceString! !

!PThreeStateButton methods !  
winUserStyle

	style == #threeState
		ifTrue: [^Bs3state].
	^BsAuto3state! !

!WBPropertyEditor methods !   
clearChanges

    changes := IdentityDictionary new.! !

!WBGeometryManager methods ! 
gridSize

    ^self owner gridSize! !

!PCompositePane methods !  
defaultBackColor

	^self parent isCompositePane
		ifTrue: [self parent defaultBackColor]
		ifFalse: [
			defaultBackColor isNil
				ifTrue: [super defaultBackColor]
				ifFalse: [defaultBackColor]].! !

!WBLayoutForm methods !   
buildWindow: parentWindow

    WBLookPolicy purgeCache.
    super buildWindow: parentWindow! !

!WBTreeListBox methods ! 
indentSelection

    self performOnSelection: #indent
        selectionDelta: nil
        moveWithSelection: false.
    self setEditBox.
    self event: #select! !

!WindowBuilder class methods !   
partsSupportIsInstalled
	"Answer true if parts support is installed."

	^Smalltalk includesKey: #WBPARTSInterfaceEditor! !

!WindowBuilder class methods !   
osiProductRegistry
    "Answer the OSI Product registry"

    | answer |
    ^ServiceRegistry globalRegistry
        serviceNamed: #OSIProducts
        ifNone: [
            ServiceRegistry globalRegistry
                    register: (answer := ServiceRegistry new)
                    withName: #OSIProducts
                    version: Smalltalk version.
            answer]! !

!WBLayoutForm methods !
handleAt: aPoint

    ^self handles detect: [:aHandle |
        aHandle containsPoint: aPoint] ifNone: [nil]! !

!WBTreeNode methods !   
canMoveUp

    ^self previousSibling notNil |
        (self isRoot not and: [ parent previousSibling notNil ]).! !

!WBMenu methods !
enableItem: item
        "Enable an item.  item can be the label or the selector."
    (self isThere: item) ifFalse: [^self].
    (self getMenuItem: item) enable.! !

!WBAbstractCodeModule methods !   
canInheritMethod
		"Answer true if the method can be inherited from the superclass."
	^true! !

!WBTreeNode methods ! 
canIndent

    ^self previousSibling notNil! !

!TextPane class methods ! 
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #saved ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #changed: ;
                argumentNames: #('aString'));
        wbAddEvent: (
            WBEventDescription new
                event: #controlTabbed ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #aboutToSave ;
                argumentNames: #( ));
        yourself! !

!Font methods !   
wbSuggestedName
	"Answer a suggestive name for the receiver."

	| stream |
	stream := WriteStream on: (String new: 20).
	stream nextPutAll: self faceName.
	stream nextPutAll: self pointSize printString.
	self bold ifTrue: [stream nextPutAll: 'Bold'].
	self italic ifTrue: [stream nextPutAll: 'Italic'].
	self strikeOut ifTrue: [stream nextPutAll: 'StrikeOut'].
	self underscore ifTrue: [stream nextPutAll: 'Underscore'].
	^stream contents! !

!WindowBuilder class methods !
addWindowBuilderMenuHelpItems

	(Smalltalk includesKey: #HelpStatusPane) ifFalse: [^self].
	(Smalltalk at: #HelpStatusPane)
		at: 'WindowBuilder' put: 'Launch WindowBuilder.';
		at: 'newWindowBuilder' put: 'Open WindowBuilder on a scratch ViewManager.';
		at: 'newDialogWindowBuilder' put: 'Open WindowBuilder on a scratch WindowDialog.';
		at: 'editWindow' put: 'Open WindowBuilder on an existing ViewManager or WindowDialog.';
		at: 'launchBitmapManager' put: 'Open the CPBitmapManager.';
		at: 'aboutWB' put: 'Display version information on WindowBuilder.'! !

!WBModelDefinitionEditor methods ! 
setEvents

	events propertyAt: #listEditorLabel put: 'Edit Extra Event List'.
	events := ((WBListEditor new openOn: events) result ifNil: [^self])
		asSortedCollection asArray.
	self setDirty.! !

!WBLayoutFrameEditor methods !
updateExample

    | beforeRect afterRect parent |
    self currentWidgets notEmpty ifTrue: [
        beforeRect := (parent := self currentWidgets first parent) isNil
            ifTrue: [
                self mainView
                    propertyAt: #frameRect
                    ifAbsentPut: [self owner shellFrameContentRect]]
            ifFalse: [parent contentRect].
        afterRect := beforeRect origin extent: (
            beforeRect extent * exampleAfter extent / exampleBefore extent) rounded].
    self
        updateExample: exampleBefore frameRect: beforeRect;
        updateExample: exampleAfter frameRect: afterRect.! !

!Class methods !  
wbNameAndClass
    "Answer the receiver's name and class."

    ^self name, (
		self wbCreated
			ifTrue: [' [Window]']
			ifFalse: [' [Class]']).! !

!WBDevelopmentWindow methods ! 
templateAt: aSymbol

	^WBInterfaceObject templateAt: aSymbol! !

!WBLookPolicyWin31 methods ! 
centerJustification

    ^"SsCenter" 1! !

!WBAbstractCodeModule methods !
defaultTargetObject
		"Answer the receiver's default target object."
	^(self object ifNil: [^nil]) targetObject! !

!WBPrototype methods !
removeWindow: aName

	windows size > 1
		ifFalse: [^MessageBox messageNote: 'You cannot remove the last view.'].
	windows := windows reject: [:window |
		window paneName = aName].
	shell paneName = aName
		ifTrue: [self switchToWindow: windows first].! !

!WBInterfaceObject methods ! 
wbRealWidget

	realWidget isNil
		ifTrue: [self wbRealWidget: self wbRealWidgetDefault].
	^realWidget! !

!WBLayoutForm methods !   
checkMnemonicConflicts

	| mnemonic |
	self selections size = 1 ifFalse: [^self].
	(mnemonic := self selections first contents) isString ifFalse: [^self].
	(mnemonic := mnemonic mnemonicChar) isNil ifTrue: [^self].
	self children do: [:widget |
		widget contents notNil 
			ifTrue: [
				((widget ~= self selections first) 
				and: [widget contents isString 
				and: [widget contents mnemonicChar = mnemonic]]) ifTrue: [
					^MessageBox messageNote: 
							'The ', widget realClass name, ' with contents ', widget contents asQuotedString stripMnemonic, 
							' already has the mnemonic &', (String with: mnemonic), '.  Please choose another.']]].
	self shell menu notNil 
		ifTrue: [
			self shell menu children do: [:aMenu |
				aMenu listString mnemonicChar = mnemonic 
					ifTrue: [
						^MessageBox messageNote: 
								'The menu ', aMenu listString asQuotedString stripMnemonic, 
								' already has the mnemonic ~', mnemonic asString, '.  Please choose another.']]].! !

!WBLayoutForm methods !   
wbMaxSize

    ^self wbEditorClass maxWindowSize! !

!WBModelCodeModule methods ! 
defaultCategory
        "Answer the default category for the receiver."
    ^'private'! !

!WBLayoutWizard methods !  
updateUpDownButtons

    | selectedItem |
    selectedItem := attributesList selectedItem.
    selectedItem == attributesList contents first
        ifTrue: [(self paneNamed: 'upButton') disable]
        ifFalse: [(self paneNamed: 'upButton') enable].
    selectedItem == attributesList contents last
        ifTrue: [(self paneNamed: 'downButton') disable]
        ifFalse: [(self paneNamed: 'downButton') enable].! !

!GraphicsTool methods !
wbLineFrom: p1 to: p2

    "Added by OSI"
    #addedByOSI.
    self place: p1;
        line: p2.! !

!WBPMenuItem methods !
title: aTitle

    self listString: aTitle.! !

!PDrawnButton methods !   
minSize

	^((style == #fixedSize) and: [self fileExists: self contents])
		ifTrue: [self bitmapExtent]
		ifFalse: [16@16]! !

!WBEditClassDialog methods !  
updateListContents

    self loadClassList.
	list hideWindow; showWindow.! !

!WindowBuilder methods !   
selectionsHaveColorAttributes

	| selections |
	self hasSelections ifFalse: [^true].
	^(selections := self selections) notEmpty
		and: [(selections detect: [:widget | widget usesColor] ifNone: [nil]) notNil]! !

!WBInterfaceObject methods !   
borderWidth

	^nil! !

!WBPrimaryModelOpenOnModule methods !  
defaultMessageSelector
        "Private - Answer the default message selector."
    ^#openOn:! !

!WBScrapbookStore methods ! 
newChapter

	| name |
	name := Prompter prompt: 'Enter name for new chapter.' default: ''.
	(name notNil and: [name notEmpty])
		ifTrue: [
			(self wbEditorClass scrapbook includesKey: name)
				ifTrue: [^MessageBox notify: 'Already Exists' withText: '''' , name , ''' alread exists!!'].
			self wbEditorClass scrapbook at: name asString put: Dictionary new].
	self loadChapters: (self paneNamed: 'chapters').
	! !

!PListBox methods !   
styles

    ^#(#defaultStyle #ownerDrawFixed #ownerDrawVariable)! !

!WBLookPolicyWin31 methods ! 
scrollBarHeight

    ^scrollBarHeight ifNil: [
        scrollBarHeight := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCyhscroll" 3]
            ifFalse: [super scrollBarHeight]]! !

!WBInterfaceObject methods !  
winStyle

	| theStyle |
	theStyle :=
		WsChild   |
		WsVisible |
		WsClipsiblings |
		self winClassStyle |
		self winUserStyle.
	(self tabPosition isNil or: [self tabPosition firstInGroup])
		ifTrue: [
			theStyle := theStyle | WsGroup.
			(self usesFocus & self tabPosition notNil)
				ifTrue: [theStyle := theStyle | WsTabstop]].
	^theStyle! !

!WBMenuTester methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| mainView xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Testing Menubar...';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -175/2 * xDU;
				topRatio: 1/2; topInset: -61/2 * yDU;
				rightRatio: 1/2; rightInset: -175/2 * xDU;
				bottomRatio: 1/2; bottomInset: -43/2 * yDU).
	self addView: mainView! !

!WBEventHandlerStubModule methods !   
source

	^source! !

!WBPoolManagerWindow methods !   
updateCategories

	categoryListBox update.
	self updateActiveCategoryMenu.! !

!WBToolBarEditor methods !
paste

    | index |
    index := list selection.
    index isNil ifTrue: [
        elements add: clipboard deepCopy.
        index := elements size.
    ] ifFalse: [
        elements add: clipboard deepCopy beforeIndex: index
    ].
    list
        contents: (elements collect: [ :element | element selector asString ]);
        selection: index.

    self updateButtons.! !

!WindowBuilder class methods !  
buyACopyMessage
	"Answer the demo message string."

	^'This is a demonstration copy.  To purchase
WindowBuilder Pro please contact: 

' , self osiMessage! !

!WBLayoutForm methods ! 
cursors
    "Create all of the cursors that the widget might need"

    ^cursors ifNil: [
        cursors := IdentityDictionary new
            at: #topLeft put: CursorManager sizeLeftTop;
            at: #topRight put: CursorManager sizeRightTop;
            at: #bottomLeft put: CursorManager sizeRightTop;
            at: #bottomRight put: CursorManager sizeLeftTop;
            at: #move put: CursorManager dragDropMove;
            at: #cross put: CursorManager crossHair;
            at: #wbBottomRightOffset put: CursorManager sizeLeftTop;
            yourself].! !

!PDrawnButton methods !   
isGroupable

    ^true! !

!WBMenuEditor methods !
initializeOn: aPMenu

    (aPMenu hasChildren) ifFalse: [
        aPMenu addChild: WBPMenuItem new.
    ].

	aPMenu asFlatList do: [:each |
		each title: (self nlsKeyFor: each title)].
    aPMenu updateListStrings.
    menuItemsEditor contents: aPMenu.
    (self paneNamed: 'listEntryField')
        contents: aPMenu firstChild title;
        selectAll.
    menuItemsEditor selectIndex: 1.

    self fillInCurrentItem.! !

!WBTabOrderEditor methods !   
setIncludeOuter

	self class includeOuter
		ifTrue: [self groupsMenu checkItem: #includeOuter]
		ifFalse: [self groupsMenu uncheckItem: #includeOuter]! !

!WBTeamVCodePolicy methods ! 
versionLabel
		"Answer the version label."
	^self annotationManager versionLabel! !

!WBCreateClassDialog class methods ! 
defaultPackage: aPackageName

    DefaultPackage := aPackageName! !

!WBLayoutForm methods !  
updateWidget: aCollectionOfWidgets

    self isHandleOk
        ifTrue: [
            self propertyAt: #hideHandles put: false.
            self updateRect: (self boundingBoxWithLastFor: aCollectionOfWidgets)].! !

!WBPropertyDescriptor methods ! 
category: aString
    "Set the value of category."

    category := aString! !

!PStatusPane methods !   
style: aStyle

    super style: aStyle.
    self updateBoxes! !

!WBInterfaceObject methods !
styleMap

    ^IdentityDictionary new! !

!StaticText methods !   
wbGrayDisable
	"Private - WBPro Development."

	#addedByOSI.
	OperatingSystem isWindows95
		ifTrue: [self disable]
		ifFalse: [self foreColor: Color darkGray].! !

!WindowFrameObject methods !  
frameRect

	| answer |
	self isDialog ifFalse: [^rect].
	answer := rect left @ (rect top up: self titleHeight + self menuHeight) 
		rightBottom: rect right @ rect bottom.
	^answer expandBy: self borderWidth! !

!WBTreeNode methods !  
moveDown

    | nextSibling parentSibling |

    self isRoot ifTrue: [
        ^self
    ].

    (nextSibling := self nextSibling) notNil ifTrue: [
        parent removeChild: self.
        parent addChild: self afterNode: nextSibling.
    ] ifFalse: [
        parentSibling := parent nextSibling.
        (parentSibling notNil) ifTrue: [
            parent removeChild: self.
            (nextSibling := parentSibling firstChild) notNil ifTrue: [
                parentSibling addChild: self beforeNode: nextSibling.
            ] ifFalse: [
                parentSibling addChild: self.
            ].
        ].
    ].! !

!WBFontSelectionWindow methods ! 
currentWidgets: aCollection
	"Update the receiver's contents to reflect
		the new widget."

	super currentWidgets: (aCollection select: [:each | each usesFont]).! !

!WBAbstractAddInModule class methods !
modulesModifyingCodeGeneration
    "Answer a collection of all of the Add-In Module classes
     that modify the code generation"

    ^self loadedModules select: [:module |
        module modifiesCodeGeneration]! !

!WBInterfaceObject class methods !
styleFrom: aStyle

    ^nil! !

!PComboBox methods !  
mutateSpecificsFrom: aPane
	| list |
	((list := aPane contents) notNil and: [list isArray])
		ifTrue: [self contents: list deepCopy].! !

!WBInterfaceObject methods !   
parent

    ^parentWindow! !

!WBInterfaceObject methods !
lookPolicy

    ^(self parent ifNil: [^WBLookPolicy current]) lookPolicy! !

!WBPoolManagerWindow methods !   
menuKeyBrowseReferences: aCollection

	| refs count all |
	count := 0.
	all := Notifier isShiftKeyDown.
	aCollection do: [:each |
		refs := (each value associationAt: each key) allReferences.
		refs := refs select: [:eachMth | eachMth isCompiledMethod].
		refs notEmpty
			ifTrue: [
				MethodBrowser new
					label: 'References to ', each key printString;
					literal: each key;
					openOn: refs.
				all ifFalse: [(count := count + 1) >= 10 ifTrue: [^self]]]
			ifFalse: [
				aCollection size = 1
					ifTrue: [
						MessageBox message: 'No references to ', each key printString]
					ifFalse: [
						Transcript cr; show: 'No references to ', each key printString]]]! !

!WBMethodStubModule methods ! 
owner
		"Answer the receiver's owner."
	^owner ifNil: [owner := WBCodeGenerator new]! !

!WBTreeListBox methods ! 
itemType

    ^WBPMenuItem! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBDialogScratchWindow class methods !
resetToDefault

    "self defaultClass selectors do: [:s |
        self createMethod: (self defaultClass sourceCodeAt: s).
    ]."! !

!WBPoolManagerWindow methods !   
isActiveCategoryVisible

	^(self paneNamed: 'categoryListBox') framingBlock topInset
		= categoryListBoxFramingBlock topInset! !

!WBScrollingPane methods ! 
totalWidth

   self hasChildren  ifTrue: [
        ^self firstChild totalWidth
    ] ifFalse: [
        ^0
    ].! !

!WBSubPool methods !
fileOutIncludeOn: aStream
	"File out a reference to the file containing the receiver's contents."! !

!WBPrototype methods !   
newWindow: aName

	| xDU yDU newShell |
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	(newShell := WindowFrameObject newForClass: WBScratchWindow defaultClass)
		realClass: windows first realClass;
		wbRealWidget: windows first wbRealWidget wbCopy;
		paneName: aName;
        framingBlock:
			(LayoutFrame new
	            leftRatio: 1/2; leftInset: -374/5 * xDU;
    	        topRatio: 1/2; topInset: -60 * yDU;
        	    rightRatio: 1/2; rightInset: -376/5 * xDU;
            	bottomRatio: 1/2; bottomInset: -60 * yDU);
		backColor: windows first backColor;
		rect: self windows first rect deepCopy;
		editor: self owner;
		"style: #(sysmenu sizable minimize maximize titlebar);"
		"extent: (shell framingBlock value: Display boundingBox) extent;"
		contents: 'Untitled View #', (windows size + 1) asString.

	windows add: (shell := newShell).
	self switchToWindow: shell.! !

!WBLayoutForm methods ! 
handles
    "Answer the value of handles."

    ^handles! !

!WBResourceDescriptor class methods !   
name: aString commonName: aString2 comment: aString3

    ^self new
            name: aString;
            commonName: aString2;
            comment: aString3;
            deriveValue! !

!WBPrototype methods !
targetInstVarNames

	^self targetObject wbInstVarMap keys asSortedCollection! !

!WBLayoutWizard methods !
offset

    ^self owner gridSize! !

!WBDevelopmentWindow methods !   
shellFrameContentRect

	^self shell frameContentRect! !

!WindowBuilder class methods !   
openNlsManager

    self runtimeLessPoolManagerWarning.
    (Notifier isControlKeyDown
        ifTrue: [WBNLSManager system]
        ifFalse: [WBNLSManager current]) edit.! !

!WBCodeStream methods !
nextPutTemporaries: aCollection
	"Append a sequence of temporaries to the receiver."

	self
		cr;
		nextPut: $|;
		space.
	aCollection asSortedCollection do: [:each |
		self
			nextPutAll: each;
			space].
	self nextPut: $|.! !

!WBInterfaceObject methods !
defaultBackColor

    ^Color windowBackground! !

!WBLookPolicyWin31 methods !
systemMenuWidth

    ^systemMenuWidth ifNil: [
        systemMenuWidth := (self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxsize" 30]
            ifFalse: [super systemMenuWidth]) + 1]! !

!PEnhancedEntryField methods !
copySpecificsTo: aPane

    aPane
        autoTab: self autoTab;
        maximumSize: self maximumSize;
        getFocus: self getFocus;
        case: self case;
        justification: self justification;
        character: self character;
        field: self field.! !

!WBInterfaceObject methods !
wbMorphWithParent: aParent to: newClass

    ^(aParent children add: ((self mutateTo: newClass) ifNil: [^nil]))
        parent: aParent;
        yourself.! !

!WBModelBasicSetModule methods ! 
defaultMessageArguments

    ^Array with: (self object initializeValue isNil
        ifTrue: ['anObject']
        ifFalse: [
            self object valueClass name first isVowel
                ifTrue: ['an', self object valueClass name]
                ifFalse: ['a', self object valueClass name]]).! !

!WBEventManagerWindow methods !
handlerSelected: aHandler
    "Set the currently selected handler."

    self handlerSelections: (OrderedCollection with: aHandler).! !

!WBFileSelectorEditor methods ! 
open

    | file contents |

    contents := thePane contents.
    ((contents includes: $*) not and: [ File exists: contents ])
        ifTrue: [ contents := (File splitPath: contents in: Disk) at: 3 ]
        ifFalse: [ contents := filters first ].
    fileDialog := FileDialog new.
    fileDialog
            title: title;
            fileSpec: contents;
            hideReadonly.
    1 to: filters size do: [ :i |
        fileDialog addFilter: (filters at: i) description: (descriptions at: i) ].

    fileDialog open.

    file := fileDialog file.
    file isNil
        ifFalse: [ thePane contents: file ].! !

!PEntryField class methods !
exampleFrom: aClass

	| example |
	example := super exampleFrom: aClass.
	example contents: ''.
	^example! !

!WBMenu methods !
enableAll
        "Enable all items for the receiver."
    items do: [:mi | mi enable].! !

!WindowBuilder methods !  
inXoteryX

    ^self class xoteryxIsInstalled! !

!WindowBuilder class methods !  
propertyAt: aSymbol category: categorySymbol

    | category |
    (category := self propertiesAtCategory: categorySymbol asSymbol) ifNil: [^nil].
    ^category at: aSymbol ifAbsent: [nil]! !

!WBTreeListBox class methods ! 
new

    ^super new initialize.! !

!WBLayoutForm methods !   
emptyCollection

    ^OrderedCollection new! !

!WBModelInstVar methods ! 
properties
        "Private - Answer the properties Dictionary."
    ^properties! !

!WindowBuilder methods ! 
menuScrapbookSave

	| fileName |
	(Smalltalk includesKey: #ObjectFiler)
		ifFalse: [^MessageBox message: 'Saving a Scrapbook requires the ObjectFiler. File in ''\EXTRAS\OBJFILER\VWOBJFLR.ST''.'].
	fileName := (FileDialog new saveTitle: 'Save Scrapbook' fileName: 'SCRAP.SBK') file.
	fileName isNil
		ifTrue: [^nil].
	(Smalltalk at: #ObjectFiler) dump: self class scrapbook newFile: fileName.! !

!WBApplicationCoordinatorMenuModule methods !   
defaultOwnerName
        "Answer the default owner name."
    ^'aModel'! !

!WindowBuilder class methods !
defineUserProperties: collection
    "Define the user properties used in WindowBuilder Pro"

    collection

        add: (WBPropertyDescriptor new
            name: #UserName;
            commonName: 'User Name';
            comment: 'Specifies the user''s name.';
            category: self userPropertyString;
            default: '';
            noDefault: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #CompanyName;
            commonName: 'Company Name';
            comment: 'Specifies the user''s company name.';
            category: self userPropertyString;
            default: '';
            noDefault: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #SerialNumber;
            commonName: 'Serial Number';
            comment: 'Specifies the user''s serial number.';
            category: self userPropertyString;
            default: '';
            noDefault: true;
            yourself);

        yourself! !

!WBInterfaceObject methods ! 
getColors: aWindowBuilder

    ^WBRGBColorDialog new
        elements: self colorElements
        defaults: self colorDefaults
        paneEdited: self! !

!WBInterfaceObject methods !   
usesColor

    ^true! !

!WBTabPosition methods ! 
firstInGroup

    ^groupPosition isNil | (groupPosition = 1)! !

!PropertyAccessor methods !  
wbDefault
	"Answer the default value for this property."

	#addedByOSI.
	^self propertyAt: #wbDefault! !

!Symbol methods ! 
asPresentableString
        "Private - WBPro Development."

    "Take a smalltalk style symbol, separate its capital-letter-delimited tokens
     into words separated by spaces, capitalize the first word, and return a string."

    | inStream outStream nextChar |
    #addedByOSI.
    inStream := ReadStream on: self asString.
    outStream := WriteStream on: (String new: self asString size).

    nextChar := inStream next.
    outStream nextPut: nextChar asUpperCase.

    [ inStream atEnd ] whileFalse: [
        nextChar := inStream next.
        (nextChar isUpperCase) ifTrue: [
            outStream nextPut: $ .
        ].
        outStream nextPut: nextChar.
    ].

    ^outStream contents! !

!WBCodePolicy methods !   
removeSelector: aSelector fromClass: aClass
		"Remove aSelector from the specified class."
	^self basicRemoveSelector: aSelector fromClass: aClass! !

!WBDefaultScratchWindow class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBPrototype methods !   
convertWidgetsToRes: dialogTitle

	| dU answer rect text |
	dU := self realDialogUnit.
	answer := OrderedCollection new.
	self childen reverseDo: [:widget |
		rect := widget framingBlock value: self shell contentRect.
		rect := (rect left // dU x) @ (rect top // dU y) rightBottom: (rect right // dU x) @ (rect bottom // dU y).
		text := ''.
		widget contents isString
			ifTrue: [text := widget contents].
		answer
			add:
				(WinDialogInfo
					itemTemplateStyle: widget winStyle
					x: rect left
					y: rect top
					cx: rect extent x
					cy: rect extent y
					id: (self children indexOf: widget)
					className: widget windowClass
					text: text)].
	^answer! !

!WBPoolManagerWindow methods !
menuKeyNext

	| index |
	(index := self keysAndPools
		indexOf: self selectedKeyAndPool
		ifAbsent: [0]
	) < self keysAndPools size ifTrue: [
		self selectedKeyAndPool: (self keysAndPools at: index + 1)].! !

!WBInstVarGetModule methods !   
defaultCategory
		"Answer the default category for the receiver."
	^'accessing'! !

!BitEditor methods !  
initBitPen: aPane
    bitPen := aPane pen! !

!PWBToolBar methods !
readSpecificsFrom: aPane

    self
        cellSize: aPane creationCellSize;
        vertical: aPane isVertical;
        useSystem: aPane useSystem;
        style: aPane tpStyle;
        elements: aPane elements.
    "Make sure all tools have defined rectangles."
    elements isEmpty ifFalse: [
        elements first rectangle:
            (Rectangle
                origin: (self vertical
                    ifTrue: [0 @ (elements first numSpaces - 1
                        + (Rectangle leftTopUnit y *
                            ((elements size - 1) * self cellSize y)))]
                    ifFalse: [elements first numSpaces @ 0])
                extent: self cellSize)].
    2 to: elements size do: [:index | aPane rectForKey: index].! !

!SpinButton class methods !  
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        "add: (SelectorPropertyAccessor new name: 'Minimum'; get: #minimum; set: #minimum: ; format: 'Integer');
        add: (SelectorPropertyAccessor new name: 'Maximum'; get: #maximum; set: #maximum: ; format: 'Integer');"
        add: (SelectorPropertyAccessor new name: 'Contents'; get: #contents; set: #contents: ; format: 'Array');
        add:
            (StylePropertyAccessor new
                name: 'Centered';
                style: 'EsCenter';
                pool: OperatingSystemConstants;
                wbAddStyle: #centered);
        add:
            (StylePropertyAccessor new
                name: 'Right Justified';
                style: 'EsRight';
                pool: OperatingSystemConstants;
                wbAddStyle: #rightJustified);
        wbRemoveEventNamed: #drawItem: ;
        wbRemoveEventNamed: #clicked: ;
        wbRemoveEventNamed: #doubleClicked: ;
        wbRemoveEventNamed: #aboutToChange ;
        wbRemoveEventNamed: #drawFocus: ;
        wbRemoveEventNamed: #drawSelection: ;
        wbRemoveEventNamed: #characterTyped: ;
        wbRemoveEventNamed: #measureItem: ;
        wbAddEvent: (
            WBEventDescription new
                event: #previousLine ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #spinnedAround: ;
                argumentNames: #('anInteger'));
        wbAddEvent: (
            WBEventDescription new
                event: #up ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #changingIndex: ;
                argumentNames: #('anIndex'));
        wbAddEvent: (
            WBEventDescription new
                event: #nextLine ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #down ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #changing: ;
                argumentNames: #('selectedItem'));
        yourself! !

!WBLookPolicyWin31 methods !
drawButton: aButton with: aPen clipRect: clipRect

    | region bottom right innerRect clip |
    innerRect := aButton rect.
    aButton style == #defaultPushButton
        ifTrue: [aPen drawRectangle: (innerRect := innerRect insetBy: 1)].
    bottom := aButton rect bottom up: 1.
    right := aButton rect right left: 1.
    aPen
        wbLineFrom: aButton rect left @ (aButton rect top down: 1) to: aButton rect left @ bottom;
        wbLineFrom: right @ (aButton rect top down: 1) to: right @ bottom;
        wbLineFrom: (aButton rect left right: 1) @ aButton rect top to: right @ aButton rect top;
        wbLineFrom: (aButton rect left right: 1) @ bottom to: right @ bottom;
        fill: (innerRect insetBy: 3) color: aButton defaultBackColor.
    OperatingSystem isOS2
        ifTrue: [aPen draw3DButtonRect: ((innerRect leftTop down: 1) rightBottom: (innerRect rightBottom down: 1))]
        ifFalse: [aPen draw3DButtonRect: innerRect].
    clip := ((innerRect insetBy: 3) intersect: clipRect).
    (clip left isRightOf: clip right) | (clip top isBelow: clip bottom)
        ifFalse: [
            region := aPen setClipRect: clip.
            aPen
                setBackgroundModeTransparent;
                foreColor: aButton foreColor;
                font: aButton font;
                setTextAlign: WBDisplayContext defaultTextAlign;
                centerWinText: aButton contents at: innerRect center;
                setBackgroundModeOpaque;
                destroyRegion: region].! !

!PButton methods !
usesTitle

    ^true! !

!WBLookPolicyOS2 methods !   
drawUpArrowWith: aPen at: aRect

    | innerRect side point |
    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class upArrow
                from: self class upArrow boundingBox
                to: aRect]
        ifFalse: [
            innerRect := self draw3DBoxWith: aPen at: aRect.
            side := (innerRect width min: innerRect height) // 7.
            point := innerRect center up: side.
            aPen
                foreColor: Color black;
                wbLineFrom: (point left: 1) to: ((point left: 1) leftAndDown: side * 2 + 1);
                wbLineFrom: point to: (point leftAndDown: side * 2 + 1);
                wbLineFrom: (point right: 1) to: ((point right: 1) leftAndDown: side * 2 + 1);
                wbLineFrom: point to: (point rightAndDown: side * 2 + 1);
                wbLineFrom: (point right: 1) to: ((point right: 1) rightAndDown: side * 2 + 1);
                wbLineFrom: (point left: 1) to: ((point left: 1) rightAndDown: side * 2 + 1)]! !

!WBTabPosition methods !   
basicTabPosition: anObject

    basicTabPosition := anObject! !

!WBScrapbookStore methods !  
openOn: aPane

    layoutPane := aPane.
    self open! !

!WBTabOrderEditor methods !
preInitWindow

	super preInitWindow.
    (self paneNamed: 'scrollingForm') addSubpane: self createLayoutForm.
    layoutForm setWidgets: self children copy.! !

!WBPoolManager methods !   
codeGenerationStyle
	"Answer the code generation style.
		Answer #key to generate code that references the pool key directly.
		Answer #pool to generate code that is '(<pool> at: <key>)'.
		Answer #manager to generate code that is
			'(<valueClass> named: <key>)'  or  '(<managerClass> system at: <key>)'."

	^(self propertyAt: #codeGenerationStyle) ifNil: [self defaultCodeGenerationStyle]! !

!WBApplicationCoordinatorModule methods ! 
initVarNames
		"Private - Initialize the variable names."
	self varNameFor: self view ifAbsentPut: [self defaultViewName].
	super initVarNames.
	self varNameFor: self targetObject put: self defaultOwnerName.! !

!WBLookPolicyWin31 methods !
maximizeButtonSize

    ^self titleBarHeight asPoint! !

!PWBToolBar methods !
elements: aCollectionOfWBTools

    elements := aCollectionOfWBTools! !

!WBRGBColorDialog class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBMultiToolPalette methods !
initialize

    super initialize.
    self pages: Dictionary new.! !

!WBInterfaceObject methods !   
isFrameObject

    ^false! !

!WBCodeModule methods ! 
constructTempNameFrom: aString
		"Answer a valid temporary variable name that is not
			an instance variable or existing temporary variable name."
	| answer index base |
	base := aString asSuggestedTempVarToken.
	answer := base, '1'.
	index := 1.
	[ (self isVarName: answer) | (self isInstVar: answer)
		] whileTrue: [
			answer := base, (index := index + 1) asString ].
	^answer
! !

!WBMenuEditor methods ! 
nlsPools

	^[(Smalltalk platformIsOS2
		ifTrue: [self mainView pmOwner]
		ifFalse: [self mainView parent]) 
		owner prototype shell nlsPools asArray]
		on: Error do: [#()].! !

!WBLayoutForm methods !  
windowClass
        "Private - Answer the window class of WBLayoutForm."
   | className wndClass address answer |
    className := 'WBLayout'.
    wndClass := WinWindowClass new.
    answer := UserLibrary getClassInfo: OperatingSystem hInstanceExe
        className: className asParameter
        wndClass: wndClass asParameter.
    answer ifTrue: [^className].
    UserLibrary getClassInfo: OperatingSystem hInstanceExe
        className: Window windowClass asParameter
        wndClass: wndClass asParameter.
    address := ExternalAddress copyToNonSmalltalkMemoryZ: className.
    wndClass style: CsOwndc | CsDblclks | CsVredraw | CsHredraw;
        className: address asParameter;
        hIcon: 0;
        hBrush: 0.
    (UserLibrary registerClass: wndClass asParameter) = 0
        ifTrue: [^self osError].
    address free.
    ^className! !

!WBLookPolicyWin31 methods !  
leftJustificationWordWrap

    ^"SsLeft" 0! !

!StylePropertyAccessor methods !   
wbFrameStyle: styleConstant
    "Private - Set the style constant."

    self style: styleConstant.
    self propertyAt: #wbFrameStyle put: styleConstant.! !

!WBDevelopmentWindow methods !   
setFraming
	"Set the framing attributes for the current widget"

	| newFrameCollection framingBlock rects editor |
	editor := Set new.
	self selections do: [:widget | editor add: (widget framingBlock wbFramingEditor ifNil: [#nil])].
	editor size > 1 ifTrue: [
		MessageBox message:
			'Cannot edit FramingParameters and LayoutUnits together.'.
		^nil].
	editor := editor asArray first.
	framingBlock := self selections first framingBlock.
	editor = #nil ifTrue: [
		MessageBox message:
			'Editor for ', framingBlock class name, ' not implemented.'.
		^nil].
	rects := self selections collect: [:widget |
		self shellFrameContentRect localizeRect: widget rect].
	newFrameCollection := (editor new
		openOnFramer: framingBlock
		rects: rects
		parentRect: (0 @ 0 extent: self shellFrameContentRect extent)
		owner: self) result.
	newFrameCollection notNil
		ifTrue: [
			1 to: self selections size do: [:i |
				(self selections at: i) framingBlock: (newFrameCollection at: i)]].
	^newFrameCollection.! !

!WBTreeListBox methods !
shiftSelectionUp

    self performOnSelection: #moveUp
        selectionDelta: nil
        moveWithSelection: true.! !

!WBPrototype methods !  
framingParametersFor: aFramingBlock inWindow: aWindow
	"In case we're reading in an existing window, make life
	 a little easier on them by performing a simple conversion of
	framing blocks into framing parameters.  Nothing fancy;  just
	getting the coordinates right."

	| baseRect viewContentRect |
	viewContentRect := 0 @ 0 extent: aWindow contentRect extent.
	baseRect := aFramingBlock value: viewContentRect.
	aWindow isDialog
		ifTrue: [
			baseRect := (baseRect origin // WindowDialog dialogUnit) 
				extent: (baseRect extent // WindowDialog dialogUnit)].
	^LayoutFrame new
		leftInset: (viewContentRect left distanceRight: baseRect left);
		topInset: (viewContentRect top distanceDown: baseRect top);
		rightInset: (viewContentRect left distanceLeft: baseRect right);
		bottomInset: (viewContentRect top distanceUp: baseRect bottom);
		yourself! !

!WBListChooser class methods !  
fromList: aList prompt: questionString

    ^super new fromList: aList prompt: questionString! !

!WBColorDialog methods !
cancel

    self close.! !

!WBKeyAccel methods ! 
keyName: aString

    (text := aString) isEmpty ifTrue: [^nil].
    (keyCode := self constantsDict
        keyAtValue: 'Vk', text
        ifAbsent: [nil]) isNil ifFalse: [^self].
    (keyCode := CharacterConstants
        at: text
        ifAbsent: [nil]) isNil ifFalse: [^self].
   keyCode := (text := aString asUppercase) first.
! !

!PWBVerticalScrollBar methods !   
displayWith: aPen clipRect: clipRect

    self lookPolicy
        drawVerticalScrollBar: self
        with: aPen
        clipRect: clipRect! !

!PWBToolBar methods !  
maxSize

	^self vertical
		ifTrue: [self suggestedSize x @ 32000]
		ifFalse: [32000 @ self suggestedSize y]
! !

!WBRGBColorDialog methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| backColorLabel blue blueLabel cancel chooseRGBColor color 
	colorList elementsLabel elementsList green greenLabel 
	mainView ok red redLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	backColorLabel := StaticText new.
	blue := WBEntryField new.
	blueLabel := StaticText new.
	cancel := Button new.
	chooseRGBColor := Button new.
	color := StaticText new.
	colorList := WBListBox new.
	elementsLabel := StaticText new.
	elementsList := WBListBox new.
	green := WBEntryField new.
	greenLabel := StaticText new.
	ok := Button new.
	red := WBEntryField new.
	redLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Set Widget Colors';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -187/2 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -117/2 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -187/2 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -117/2 * yDU).
	self addView: mainView.
	
	elementsList "WBListBox"
		owner: self;
		setName: 'elementsList';
		when: #clicked: send: #elementSelected: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -92 * xDU;
				bottomRatio: 0; bottomInset: -54 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: elementsList;
		subPaneWithFocus: elementsList.
	
	colorList "WBListBox"
		owner: self;
		setName: 'colorList';
		when: #clicked: send: #colorSelected: to: self;
		when: #drawItem: send: #drawItem:pane: to: self withArgument: colorList;
		when: #drawSelection: send: #highlightItem:pane: to: self withArgument: colorList;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 96 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -184 * xDU;
				bottomRatio: 0; bottomInset: -96 * yDU);
		ownerDrawFixed;
		startGroup;
		font: SysFont.
	mainView addSubpane: colorList.
	
	red "WBEntryField"
		owner: self;
		setName: 'red';
		when: #textChanged: send: #rgbChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 30 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 0; rightInset: -54 * xDU;
				bottomRatio: 0; bottomInset: -68 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: red.
	
	green "WBEntryField"
		owner: self;
		setName: 'green';
		when: #textChanged: send: #rgbChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 30 * xDU;
				topRatio: 0; topInset: 70 * yDU;
				rightRatio: 0; rightInset: -54 * xDU;
				bottomRatio: 0; bottomInset: -82 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: green.
	
	blue "WBEntryField"
		owner: self;
		setName: 'blue';
		when: #textChanged: send: #rgbChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 30 * xDU;
				topRatio: 0; topInset: 84 * yDU;
				rightRatio: 0; rightInset: -54 * xDU;
				bottomRatio: 0; bottomInset: -96 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: blue.
	
	chooseRGBColor "Button"
		owner: self;
		setName: 'chooseRGBColor';
		when: #clicked send: #chooseRGBColor to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 98 * yDU;
				rightRatio: 0; rightInset: -92 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		contents: 'Choose RGB Color...';
		startGroup;
		font: SysFont.
	mainView addSubpane: chooseRGBColor.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 96 * xDU;
				topRatio: 0; topInset: 98 * yDU;
				rightRatio: 0; rightInset: -138 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 142 * xDU;
				topRatio: 0; topInset: 98 * yDU;
				rightRatio: 0; rightInset: -184 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	color "StaticText"
		owner: self;
		setName: 'color';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 58 * xDU;
				topRatio: 0; topInset: 56 * yDU;
				rightRatio: 0; rightInset: -92 * xDU;
				bottomRatio: 0; bottomInset: -96 * yDU);
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: color.
	
	blueLabel "StaticText"
		owner: self;
		setName: 'blueLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 86 * yDU;
				rightRatio: 0; rightInset: -28 * xDU;
				bottomRatio: 0; bottomInset: -94 * yDU);
		rightJustified;
		contents: 'Blue:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: blueLabel.
	
	greenLabel "StaticText"
		owner: self;
		setName: 'greenLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 72 * yDU;
				rightRatio: 0; rightInset: -28 * xDU;
				bottomRatio: 0; bottomInset: -80 * yDU);
		rightJustified;
		contents: 'Green:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: greenLabel.
	
	redLabel "StaticText"
		owner: self;
		setName: 'redLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 58 * yDU;
				rightRatio: 0; rightInset: -28 * xDU;
				bottomRatio: 0; bottomInset: -66 * yDU);
		rightJustified;
		contents: 'Red:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: redLabel.
	
	elementsLabel "StaticText"
		owner: self;
		setName: 'elementsLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -92 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Elements:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: elementsLabel.
	
	backColorLabel "StaticText"
		owner: self;
		setName: 'backColorLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 96 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -182 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Color:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: backColorLabel! !

!ListPane class methods !
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #doubleClicked: ;
                argumentNames: #('selectedItem'));
        wbAddEvent: (
            WBEventDescription new
                event: #changed: ;
                argumentNames: #('selectedItem'));
        wbAddEvent: (
            WBEventDescription new
                event: #changedIndex: ;
                argumentNames: #('selectedIndex'));
        wbAddEvent: (
            WBEventDescription new
                event: #aboutToChange ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #characterTyped: ;
                argumentNames: #('aCharacter'));
        wbAddEvent: (
            WBEventDescription new
                event: #clicked: ;
                argumentNames: #('selectedItem'));
        yourself! !

!WBPoolManagerWindow methods !  
activeCategoryMenu

	^self menuTitled: 'Active'! !

!WBLayoutWizard methods ! 
selectModel: selectedItem

    selectedItem ifNil: [^nil].
    sourceInstance := selectedItem new.
    (self paneNamed: 'modelButton') selection: true.
    self
        updateSourceButtons;
        disableFields;
        loadAttributes! !

!WBLayoutWizard class methods ! 
clearCache
    " WBLayoutWizard clearCache "
    DefaultButtons := StandardButtons := DefaultMenus :=
    StandardMenus := WidgetMap := MenuDefinitions := nil! !

!WindowFrameObject methods !  
initialize

    super initialize.

    style := nil.
    children := OrderedCollection new.! !

!WBAbstractAddInModule class methods ! 
modifyMenus: aMenuCollection
    "Modify the menus"! !

!WBModelInstVar methods !  
methodNameForGet

    ^self name! !

!WBGraphicObject methods !   
wbMaxSize

	^self maxSize! !

!WBFontSelectionWindow methods !
selectedPool
	"Answer the currently selected pool."

	^selectedPool ifNil: [
		self poolManager pools isEmpty ifTrue: [^nil].
		selectedPool := self poolManager pools
			detect: [:each |
				(each pool
					detect: [:eachFont | eachFont == self selectedFont]
					ifNone: [nil]) notNil]
			ifNone: [
				(self poolManager pools asSortedCollection: [:a :b | a poolName < b poolName])
					detect: [:each | each pool notEmpty]
					ifNone: [
						(self poolManager pools asSortedCollection: [:a :b | a poolName < b poolName])
							first]]]! !

!PEntryField methods !  
importantEvents

    ^super importantEvents
        addFirst: #changed:;
        addFirst: #textChanged:;
        yourself! !

!WBBitmapManagerWindow methods !
preInitMenus

	| index |
	self categoryMenu removeItemDynamically: 'File out separately...'.
	categoryListBox getPopupMenu removeItemDynamically: 'File out separately...'.
	index := self keyMenu getIndex: #menuKeyNew.
	self keyMenu
		insertItem: 'New Button...' selector: #menuKeyNewButton accelKey: nil accelBits: nil after: index;
		appendSeparator;
		appendItem: 'Duplicate' selector: #menuKeyDuplicate acceleratorString: '';
		appendItem: 'From Clipboard...' selector: #menuKeyFromClipboard acceleratorString: '';
		appendItem: 'From Screen...' selector: #menuKeyFromScreen acceleratorString: '';
		appendSeparator;
		appendItem: 'File in Bitmap File...' selector: #menuKeyFileInBitmapFile acceleratorString: '';
		appendItem: 'File out BDT File...' selector: #menuKeyFileOutBDTFile acceleratorString: '';
		appendItem: 'File out RC and supporting files...' selector: #menuKeyFileOutRCFile acceleratorString: '';
		appendItem: 'File out RC and 4 bit supporting files...' selector: #menuKeyFileOutRCFile4 acceleratorString: '';
		appendItem: 'File out RC and 8 bit supporting files...' selector: #menuKeyFileOutRCFile8 acceleratorString: '';
		appendSeparator;
		appendItem: 'Resize...' selector: #menuKeyResize acceleratorString: '';
		appendItem: 'Resize Button...' selector: #menuKeyResizeButton acceleratorString: ''.
	self optionMenu
		appendSeparator;
		appendItem: 'Same bitmap all categories' selector: #menuOptionSameValueForAllCategories acceleratorString: '';
		appendItem: 'Show dimensions' selector: #menuOptionShowDimensions acceleratorString: '';
		appendItem: 'Update source' selector: #menuOptionUpdateSource acceleratorString: ''.
	self mainView menuWindow
	    addMenu: self bitmapMenu.
	super preInitMenus.! !

!Object methods ! 
wbSuggestedTempName
        "Answer the suggested temporary variable name used in code generation."
    ^self class name! !

!WBPoolManagerWindow methods !   
preInitWindow

	super preInitWindow.
	self preInitMenus.
	poolListBoxFramingBlock := poolListBox framingBlock copy.
	categoryListBoxFramingBlock := categoryListBox framingBlock copy.
	self hidePath; hideActiveCategory.
	self mainView labelWithoutPrefix: self windowTitle.
	poolListBox
		ownerDrawFixed;
		printSelector: #poolName.
	categoryListBox ownerDrawFixed.
	keyListBox ownerDrawFixed.! !

!WBScrollingPane methods !  
amountToScrollLeft

    ^10! !

!WBLayoutForm methods !   
updateTitle: widget

	widget == self shell 
		ifTrue: [
			^widget 
				drawTitleTextWith: self pen
				in: (widget titleRectFrom: self shell frameLeftTop)].
	self
		hideHandles;
		updateRect: widget rect;
		showHandles.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBFontSelectionWindow methods !
fontNeedsContents: aPane

	"Callback for the #needsContents event in fontList [ListBox].
		(Generated by WindowBuilder Pro)"

	| newContents |
	self selectedPool notNil
		ifTrue: [
			newContents := SortedCollection new.
			self selectedPool pool associationsDo: [:each | newContents add: each].
			aPane
				printSelector: #key;
				contents: newContents;
				selection: (newContents detect: [:each | each value == self selectedFont] ifNone: [nil])]
		ifFalse: [aPane contents: #( )]! !

!WindowBuilder methods ! 
primaryModel

    ^self prototype primaryModel! !

!WBPoolManagerWindow methods ! 
selectedCategories: aCollection
	"Set the selected categories."

	categoryListBox selection: aCollection.
	self selectedCategoriesChanged.! !

!WBEnhancedEntryFieldEditor class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBCreateBitmap methods !
initWindow

	self mainView labelWithoutPrefix: self windowTitle.
	self bitmapType: self class lastBitmapType.
	self bitmapWidth: self class lastBitmapWidth.
	self bitmapHeight: self class lastBitmapHeight.
	initialKey isString ifTrue: [self bitmapKey: initialKey].
	self updateOk.! !

!PStatusPane methods !  
defaultForeColor

    ^Color buttonText! !

!WBLayoutForm methods !   
notifyModelOfSelectionChange

    self triggerEvent: #selectionChanged: with: self selections.! !

!WBLookPolicyOS2 methods ! 
maximizeButtonSize

    ^self titleBarHeight asPoint! !

!WBEventManagerWindow methods !  
handlerShowAll
    "Answer true if the handler should show all hanlders at once."

    ^handlerShowAll ifNil: [false]! !

!WBLayoutForm methods !
checkAllowMove: aPoint

    "If the user has moved the mouse sufficiently then allow the widget to be moved."

    self allowMove ifTrue: [^true].
    ((aPoint x - self cursorSelectPoint x) abs > self moveTolerance
        or: [(aPoint y - self cursorSelectPoint y) abs > self moveTolerance])
        ifTrue: [
            self dragOutline ifTrue: [self drawBand].
            self allowMove: true.
            self hideOrderSymbols.
            ^true].
    ^false! !

!DrawnButton class methods !   
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #drawItem ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #drawFocus ;
                argumentNames: #( ));
        wbAddEvent: (
            WBEventDescription new
                event: #drawSelection ;
                argumentNames: #( ));
        yourself! !

!WBInstVarObject methods ! 
name: aString

	name := aString.! !

!WBMethodStubModule methods !
wrapComment
	"Answer true if the comment should be wrapped."

	^false! !

!PColumnListBox methods !  
displayWith: aPen clipRect: clipRect

    self lookPolicy
        displayWithRightScrollBar: aPen
        rect: self rect
        backColor: self backColor! !

!Object methods !  
modifiedByOSI
    "Added by OSI. Execute the following to get a list
     of all base class methods modified by WindowBuilder.

        Smalltalk sendersOf: #modifiedByOSI.

    "
    #addedByOSI.! !

!WindowBuilder class methods !  
initializeProperties
    "Initialize the Property dictionary"
    " WindowBuilder initializeProperties "

    | propertyCollection categories cached |

    cached := Properties isNil
        ifTrue: [Dictionary new]
        ifFalse: [cached := self cacheSpecialProperties].

    Properties := IdentityDictionary new.
    categories := Set new.

    (propertyCollection := self defineProperties) do: [:property |
        categories add: property category].

    categories do: [:category |
        Properties at: category put: IdentityDictionary new].

    propertyCollection do: [:property |
        property value: property default.
        (Properties at: property category)
            at: property name
            put: property].

    self 
        initializePrivateProperties;
        initializePropertiesAddIns.

    cached isNil
        ifFalse: [
            cached associationsDo: [:assoc |
                self propertyValueAt: assoc key put: assoc value]].! !

!WBTeamVCodePolicy methods !   
basicLogMethodFor: aCodeModule
		"Private - Log the specified method source."
	"Don't log methods because they are logged as part of basicCompileMethod..."! !

!PropertyAccessor methods !   
wbStore: anAction

	self propertyAt: #wbStoreAction put: anAction.! !

!WBMenuEditor class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowBuilder methods ! 
resetFonts

	| fonts |
	(fonts := self propertyAt: #StoredFonts) isNil ifTrue: [^self].
	self propertyAt: #StoredFonts put: nil.
	ListFont := fonts at: 1.
	TextFont := fonts at: 2.
	ButtonFont := fonts at: 3.
	SysFont := fonts at: 4.
	! !

!WBColorDialog methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| backColorLabel backColorList cancel foreColorLabel 
	foreColorList mainView ok xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	backColorLabel := StaticText new.
	backColorList := WBListBox new.
	cancel := Button new.
	foreColorLabel := StaticText new.
	foreColorList := WBListBox new.
	ok := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Set Pane Colors';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -93 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -56 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -93 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -56 * yDU).
	self addView: mainView.
	
	foreColorList "WBListBox"
		owner: self;
		setName: 'foreColorList';
		when: #drawItem: send: #drawItemFore:pane: to: self withArgument: foreColorList;
		when: #drawSelection: send: #highlightItem:pane: to: self withArgument: foreColorList;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -92 * xDU;
				bottomRatio: 0; bottomInset: -94 * yDU);
		ownerDrawFixed;
		startGroup;
		font: SysFont.
	mainView
		addSubpane: foreColorList;
		subPaneWithFocus: foreColorList.
	
	backColorList "WBListBox"
		owner: self;
		setName: 'backColorList';
		when: #drawItem: send: #drawItemBack:pane: to: self withArgument: backColorList;
		when: #drawSelection: send: #highlightItem:pane: to: self withArgument: backColorList;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 96 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -182 * xDU;
				bottomRatio: 0; bottomInset: -94 * yDU);
		ownerDrawFixed;
		startGroup;
		font: SysFont.
	mainView addSubpane: backColorList.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 96 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -110 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 50 * xDU;
				topRatio: 0; topInset: 96 * yDU;
				rightRatio: 0; rightInset: -92 * xDU;
				bottomRatio: 0; bottomInset: -110 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	foreColorLabel "StaticText"
		owner: self;
		setName: 'foreColorLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -45 * xDU;
				bottomRatio: 0; bottomInset: -12 * yDU);
		contents: 'Forecolor:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: foreColorLabel.
	
	backColorLabel "StaticText"
		owner: self;
		setName: 'backColorLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 96 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -139 * xDU;
				bottomRatio: 0; bottomInset: -12 * yDU);
		contents: 'Backcolor:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: backColorLabel! !

!WBInstVarSetModule methods !
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self generateGeneratedSymbol.
        self stream
            cr; nextPutAll: self object;
            nextPutAll: ' := '; nextPutAll: self messageArguments first;
            endExpression].! !

!WBLayoutWizard methods !   
generateLayout

    self owner ifNil: [^self].
    (self owner hasChildren
        and: [Notifier isAltKeyDown not])
        ifTrue: [
            (MessageBox confirm: 'All of the existing widgets will be lost. Do you wish to continue?')
                ifTrue: [
                    self owner geometryManager selectAll.
                    self owner menuEditClear]
                ifFalse: [^self]].
    self
        generateModel;
        generateMenus;
        generateWidgets.
    self owner layoutForm redraw.
    Notifier isAltKeyDown ifFalse: [self close].! !

!WindowBuilder methods !  
menuToolsInspectGraphicsConstants

    GraphicsConstants inspect! !

!WBLocator methods ! 
copyOn: anObject
        ^self species on: anObject at: selector withArguments: arguments! !

!WBLayoutWizard class methods !  
standardMenus

    ^StandardMenus ifNil: [StandardMenus := self initializeStandardMenus]! !

!WBPoolManagerWindow methods !   
closed
	"The receiver has been closed."

	super closed.
	self poolManager removeAllActionsWithReceiver: self.! !

!Bitmap class methods !   
buttonWidth4: w height: h
	"Private - WBPro Development.
		Create a new tool bar button bitmap template"

	#addedByOSI.
	^(self screenWidth4: w * 2 height: h) wbInitButton! !

!PCheckBox methods !   
styles

    ^#(#autoCheckBox #checkBox)! !

!WBCodeGenerator class methods !  
generateDirectBitmapRefs
		"Answer true if the receiver is to generate direct bitmap references (pool vars)."
	^GenerateDirectBitmapRefs ifNil: [ true ]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPoolManagerWindow methods !  
menuPoolAddExisting

    "Callback for the menu item titled 'Add existing...'.
     (Generated by WindowBuilder)"

	| existingPools poolsToAdd |
	(existingPools := self existingPoolsToAdd) isEmpty ifTrue: [
		^MessageBox message: 'There are no existing pools to add.'].
	poolsToAdd := WBMultiListChooser
		fromList: existingPools
		prompt: 'Select existing pools to add'.
	poolsToAdd isNil ifTrue: [^self].
	poolsToAdd isEmpty ifTrue: [^self].
	[self menuPoolAddExisting: poolsToAdd]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].! !

!TopPane methods ! 
modelObjects

    ^self owner modelObjects! !

!Bitmap methods !  
wbScaleButton: newExtent
    "Answer a new bitmap containing the contents of the receiver."

    | newBitmap |
    #addedByOSI.
    newBitmap := WBBitmapClass
        width: newExtent x
        height: newExtent y
        planes: self planes
        bitCount: self bitCount.
    newBitmap wbInitButton.
    newBitmap pen
        copyBitmap: self
        from: self wbButtonUpBox
        to: newBitmap wbButtonUpBox.
    newBitmap pen
        copyBitmap: self
        from: self wbButtonDownBox
        to: newBitmap wbButtonDownBox.
    ^newBitmap! !

!WBApplicationCoordinatorModule methods !
defaultMessageSelector
        "Private - Answer the default message selector."
    ^#buildView:forModel:! !

!WBCodeStream methods ! 
maxLineSize
        "Answer the maximum number of characters per line.
            Nil indicates no maximum."
    ^maxLineSize! !

!WBCompositeMenuModule class methods !
defaultMessageSelector
		"Private - Answer the default message selector."
	^#addSubpaneMenus:! !

!WBMenuEditor methods ! 
ok

	self updateItem: menuItemsEditor selection.
	menuItemsEditor listAttribute asFlatList do: [:each |
		each title: (self nlsStringFor: each title)].
	result := self pMenu.
	result update.
	super close! !

!WBLayoutForm methods !  
selectAll
    "Select all of the widgets."

    self
        selections: self children copy;
        showHandles! !

!WBInterfaceObject methods !  
windowClass

    ^self realClass basicNew windowClass! !

!WBBitmapManagerWindow methods !
bitmapMenu

	^Menu new
		title: 'Bitmap';
		owner: self;
		appendItem: 'Copy' selector: #menuBitmapCopy acceleratorString: 'Ctrl+C';
		appendItem: 'Paste' selector: #menuBitmapPaste acceleratorString: 'Ctrl+V';
		appendItem: 'Paste into button' selector: #menuBitmapPasteIntoButton acceleratorString: '';
		appendItem: 'Paste into button up' selector: #menuBitmapPasteIntoButtonUp acceleratorString: '';
		appendItem: 'Paste into button down' selector: #menuBitmapPasteIntoButtonDown acceleratorString: '';
		appendSeparator;
		appendItem: 'From Screen...' selector: #menuBitmapFromScreen acceleratorString: '';
		appendItem: 'From Screen into button...' selector: #menuBitmapFromScreenIntoButton acceleratorString: '';
		appendItem: 'From Screen into button up...' selector: #menuBitmapFromScreenIntoButtonUp acceleratorString: '';
		appendItem: 'From Screen into button down...' selector: #menuBitmapFromScreenIntoButtonDown acceleratorString: '';
		appendSeparator;
		appendItem: 'File in Bitmap File...' selector: #menuBitmapFileInBitmapFile acceleratorString: '';
		appendItem: 'File out Bitmap File...' selector: #menuBitmapFileOutBitmapFile acceleratorString: '';
		appendItem: 'File out 4 bit Bitmap File...' selector: #menuBitmapFileOutBitmapFile4 acceleratorString: '';
		appendItem: 'File out 8 bit Bitmap File...' selector: #menuBitmapFileOutBitmapFile8 acceleratorString: '';
		yourself! !

!WBModelDefinitionEditor methods !  
disableModelFields

    (self paneNamed: 'attributesLabel') foreColor: Color darkGray.
    attributes contents: #(); disable.
    (self paneNamed: 'addButton') disable.
    (self paneNamed: 'removeButton') disable.
    (self paneNamed: 'updateButton') disable.
    (self paneNamed: 'renameButton') disable.
    (self paneNamed: 'editButton') disable.
    (self paneNamed: 'upButton') disable.
    (self paneNamed: 'downButton') disable.
    (self paneNamed: 'eventsButton') disable.! !

!WBBitmapManagerWindow methods !  
menuBitmapFromScreen

	| aBitmap aKeyAndPool aCategory |
	aKeyAndPool := self selectedKeyAndPool ifNil: [^self].
	aCategory := self selectedCategory ifNil: [^self].
	aBitmap := WBBitmapClass fromUser ifNil: [^self].
	aKeyAndPool value
		at: aKeyAndPool key
		in: aCategory
		put: aBitmap.! !

!WBFramingEditor class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowBuilder methods ! 
opened
	"Connect the receiver to the NLS manager."

	self updateNlsCategories.
	self updateNlsMenu.
	WBNLSManager current
		when: #activeCategoryChanged: send: #updateNlsActiveCategory: to: self;
		when: #categoryAdded:pool: send: #updateNlsCategories to: self;
		when: #categoryRemoved:pool: send: #updateNlsCategories to: self.! !

!WBToolBarEditor methods !
copy

    | index |
    index := list selection.
    index isNil ifTrue: [ ^nil ].
    clipboard := elements at: index .
    (self paneNamed: 'paste') enable.! !

!WBPropertyManager class methods ! 
cacheManagers
	"Answer true if the managers should be cached."

	^cacheManagers ifNil: [false]! !

!WBScrollingPane methods !
scrollHorizontal: anInteger

    self scrollTopCorner: anInteger  @ 0! !

!WBListChooser methods !
fromList: aList prompt: questionString selection: s

    sel := s.
    ^self fromList: aList prompt: questionString! !

!String methods !
hasContent
        "Private - WBPro Development."
    (self isEmpty) ifTrue: [
        #addedByOSI.
        ^false
    ].
    self do: [ :aChar |
        (aChar == $ ) not ifTrue: [
            ^true
        ].
    ].
    ^false! !

!WBAbstractCodeModule methods ! 
wrapComment
	"Answer true if the comment should be wrapped."

	^true! !

!WBClassDefinition methods !
policy
		"Answer the receiver's code policy."
	^self owner policy
! !

!WBLookPolicyOS2 class methods !  
purgeCache
    " WBLookPolicyOS2 purgeCache "

    Down notNil ifTrue: [Down release].
    Up notNil ifTrue: [Up release].
    Right notNil ifTrue: [Right release].
    Left notNil ifTrue: [Left release].
    RadioBitmap notNil ifTrue: [RadioBitmap release].
    Down := Up := Right := Left := RadioBitmap := nil.! !

!WBMultiToolPalette methods ! 
disable: key on: name
    | element |
    (element := self elementAt: key on: name) isNil
            ifFalse: [
                element disabled.
                (self handle isValid and: [ elements == (self pageNamed: name)])
                    ifTrue: [ self display: key ]]! !

!PRadioButton class methods !  
styleFrom: style

	^(style bitIsOn: BsAutoradiobutton)
		ifFalse: [#radioButton]
		ifTrue: [#autoRadioButton].! !

!WBUndoAction methods !  
redoAction

    ^redoAction! !

!WindowBuilder methods !  
setWindowSizePrim: aPoint shifted: shifted

    | newExtent |
    self layoutForm
        triggerEvent: #changed;
        hideHandles.
    newExtent := aPoint +
		(self shell isDialog
			ifTrue: [
				(0 @ (self shell titleHeight + self shell menuHeight))
					+ (self shell borderWidth * 2)]
			ifFalse: [0]).
    self shell frameRectExtent: newExtent.
    self scrollingForm windowHasSized.
    shifted
        ifFalse: [
            self children do: [:widget |
                widget reframe: self shell frameContentRect]]
        ifTrue: [
            self children do: [:widget |
                widget wbUpdateConstraints]].
	self layoutForm pen fill: Color white.
    self layoutForm
		redraw;
		showHandles.
    self newWindowSize: aPoint.! !

!WBLookPolicy methods !   
displayWithBorder: aPen rect: aRect backColor: backColor

    aPen drawRectangle: aRect.
    ^self
        drawFilledBoxWith: aPen
        at: aRect
        inset: 1
        backColor: backColor! !

!WindowBuilder methods !  
initMdiWindowSize

	| extent origin du |
	du := (SysFont width @ SysFont height) / (16@32).
	extent := ((240 @ 230) / du) truncated.
	origin := (self frame mdiChildren size - 1) * (16 @ 16).
	^origin extentFromLeftTop: extent.! !

!WBLayoutForm methods !
model
    "Answer the value of model."

    ^owner! !

!WBEventManagerWindow methods !   
sendFieldText
    "Answer the sendField selection, either string or compiled method."

    ^sendField text! !

!WBUndoAction methods !   
label

    ^label! !

!WBInterfaceObject methods !
isGrouper

    ^false! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBDescriptor methods !
printOn: aStream indent: indentString

    flags isNil
        ifTrue: [
            aStream
                nextPutAll: self class name;
                cr; tab; nextPutAll: indentString; nextPutAll: 'name: '; nextPutAll: name printString;
                cr; tab; nextPutAll: indentString; nextPutAll: 'commonName: '; nextPutAll: commonName printString;
                cr; tab; nextPutAll: indentString; nextPutAll: 'comment: '; nextPutAll: comment printString.]
        ifFalse: [
            aStream
                nextPutAll: self class name;
                cr; tab; nextPutAll: indentString; nextPutAll: 'name: '; nextPutAll: name printString;
                cr; tab; nextPutAll: indentString; nextPutAll: 'commonName: '; nextPutAll: commonName printString;
                cr; tab; nextPutAll: indentString; nextPutAll: 'comment: '; nextPutAll: comment printString;
                cr; tab; nextPutAll: indentString; nextPutAll: 'flags: #'; nextPutAll: flags printString.]
! !

!WindowBuilder methods !   
hasChildren

    ^self children notEmpty! !

!WBModelInstVar methods !
hasEvent: aBoolean

    hasEvent := aBoolean! !

!WBLayoutWizard methods !
buttonsToGenerate

    ^(self paneNamed: 'standardButtonsList') value! !

!WBLookPolicyWin31 methods !
frameWidthDialog

    ^frameWidthDialog ifNil: [
        frameWidthDialog := (self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxdlgframe" 7]
            ifFalse: [super frameWidthDialog]) + 1]! !

!WBGraphicObject methods ! 
width
        "Answer the receiver's width."
    ^self rect width! !

!WBLayoutForm methods ! 
toggleSelect: aWidget

    (self selections includes: aWidget)
        ifTrue: [self deSelect: aWidget]
        ifFalse: [self select: aWidget]! !

!PRadioButtonGroup methods !
readSpecificsFrom: aWidget

    self
        label: aWidget label;
        numColumns: aWidget numColumns;
        contents: aWidget contents.! !

!WBTreeNode methods !   
children

    ^children! !

!WBFramingEditor methods !
originXStyleChanged: styleRadio

    (styleRadio contents = 'Scaled') & (styleRadio selection)
        ifTrue:
            [originXAnchor selection: 'Window left'.
            originXAnchor disable.
            leftRelative disable.
            ]
        ifFalse:
            [leftRelative enable.
            originXAnchor enable.
            ].
    self setExampleRects.! !

!WBCodeModule methods !
generateTemporaries
        "Private - Generate the temporary variables."
	self stream wrapDuring: [
		self stream indentBy: 1 during: [
			self generateTemporaries: self temporaries ] ].! !

!WindowBuilder class methods !  
openPropertyEditor

	WBPropertyEditor new open! !

!WBTabOrderLayoutForm methods !
drawToBitmap

	^false! !

!WBDevelopmentWindow methods !  
compilerEvaluate: aString

	| transcript result |
	transcript := Transcript.
	Transcript := ReadWriteStream on: String new.
	[result := [Compiler evaluate: aString] on: Error do: [nil]] 
		ensure: [Transcript := transcript].
	^result! !

!WBOpenMethodModule methods !  
defaultComment
    "Answer the default comment string."

    ^'Build and open a window for a new instance of the receiver.
        Remove the #generated tag before modifying this method.
        Remove the comment delimiters below to enable #preInitWindow support.
        Use the TopPane #validated event to simulate #initWindow support.
        (Generated by WindowBuilder Pro)'! !

!PRadioButtonGroup methods !
isComposite

    ^true! !

!WBNLSDictionaryReader class methods ! 
commentEndString

	^' */'! !

!WBScrollingPane methods !  
windowHasSized

    self scrollTopCorner: self topCorner.
    self setScrollRanges: true.
    self scrollIfNecessaryRedraw: true.
    self updateSliders.! !

!WBPrimaryModelOpenOnModule methods !
generateComment
        "Private - Generate the comment."

    super generateComment.
    self stream cr.! !

!WBUndoManager methods !  
reset

    self bindToOwner! !

!WBWindowEditor class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBLookPolicyOS2 methods !   
leftJustificationWordWrap

    ^"DtLeft" 0! !

!PEntryField methods ! 
maxSize

    ^32000 @ self suggestedSize y! !

!Symbol methods !  
asCUAPresentableString
        "Private - WBPro Development."

    "Take a smalltalk style symbol, separate its capital-letter-delimited tokens
     into words separated by spaces and return a string."

    | inStream outStream nextChar |
    #addedByOSI.
    inStream := ReadStream on: self asString.
    outStream := WriteStream on: (String new: self asString size).

    nextChar := inStream next.
    outStream nextPut: nextChar.

    [ inStream atEnd ] whileFalse: [
        nextChar := inStream next.
        (nextChar isUpperCase) ifTrue: [
            outStream nextPut: $ .
        ].
        outStream nextPut: nextChar asLowerCase.
    ].

    ^outStream contents! !

!WBTabOrderLayoutForm class methods !  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #setTabPosition;
        add: #setGroup;
        add: #deletedGroup;
        add: #clicked:;
        yourself! !

!WindowBuilder methods !   
updateOutboards: aCollectionOfWidgets
	"Update all of the outboard windows with the new selections"

	self outboards do: [:window |
			window selectionChanged: aCollectionOfWidgets].! !

!WBLayoutForm methods !  
useGrid

    ^self model isNil
        ifTrue: [true]
        ifFalse: [self model useGrid]! !

!WindowBuilder methods !
updateMenuAll

	self
		updateMenuFile;
		updateMenuEdit;
		updateMenuAttributes;
		updateMenuAlign;
		updateMenuSize;
		updateMenuOptions;
		updateMenuAdd.! !

!WBLookPolicy class methods !  
purgeCache

    self current: nil.
    self default: nil.
    self allSubclasses do: [:cls |
        cls purgeCache].! !

!WBLayoutWizard methods !
usesModel

    ^(self attributesToGenerate detect: [:attribute |
        (attribute propertyAt: #modelUpdatesWidget) == true
            or: [(attribute propertyAt: #widgetUpdatesModel) == true]]
        ifNone: [nil]) notNil! !

!WBNLSManager methods !  
editorClass
    "Answer a pool manager window class for the receiver."

    ^WBNLSManagerWindow! !

!WBOutboardWindow methods !  
selectionChanged: aCollectionOfWidgets
	"The owner's current selection changed."

	self update.! !

!WBPropertyDescriptor methods !  
category
    "Answer the value of category."

    ^category! !

!WBPrimaryModelModule methods !  
defaultMessageSelector
        "Private - Answer the default message selector."
    ^#wbModelClass! !

!WBLookPolicy methods !
menuFont

    ^SysFont! !

!WBScrapbookRetrieve methods ! 
chapters

    ^scrapbook keys asSortedCollection! !

!WindowFrameObject methods ! 
menuHeight

    ^self lookPolicy menuBarHeightFrom: self! !

!WindowBuilder methods ! 
addWidgetCentered: ignored
    "Happens on doubleclick in palette.  Assumes select
     happened first"

    self layoutForm addWidgetCentered.! !

!WBPoolEditorCompositePane methods !
updateEditor

	self
		updateCategory;
		updateKey;
		updateValue.! !

!WBGeometryManager methods ! 
useFence

    ^self owner useFence! !

!Object methods !  
wbIsPValueManager
	"Answer true if the receiver is a value manager."

	^false! !

!WBAbstractAddInModule class methods ! 
loadedModules
    "Answer a collection of all of the Add-In Module classes
     that are currently loaded"

    ^self allSubclasses select: [:module |
        module loaded]! !

!WBFontSubPool methods ! 
fileOutHeaderOn: aStream
	"File out the receiver's header."

	aStream cr.! !

!WindowBuilder methods !   
menuOptionsDrawGrid

    self drawGrid
        ifFalse: [
            ((self gridSize x < 3) | (self gridSize y < 3))
                ifTrue: [
                    (MessageBox confirm: 'Your grid is rather small, and will take some time to display.   Are you sure you wish to do this?')
                        ifFalse: [^self]]].
    self class togglePropertyValueAt: #DrawGrid.
    self updateOptionsMenu.
    self layoutForm isNil
        ifFalse: [self menuOptionsRedraw].! !

!WBHandle methods ! 
owner
        ^locator object! !

!WindowBuilder methods ! 
menuToolsInspectLayoutForm

    self layoutForm inspect! !

!WBScrollingPane methods !
scrollIfNecessaryRedraw: redraw

    | childSize visibleExtent newTopCorner |

    self hasChildren ifFalse: [
        ^false
    ].

    childSize       := self childSize.
    visibleExtent := self visibleExtent.


    newTopCorner := topCorner deepCopy.

    (childSize x < (visibleExtent x + topCorner x)) ifTrue: [
        newTopCorner x: (childSize x - visibleExtent x max: 0).
    ].

    (childSize y < (visibleExtent y + topCorner y)) ifTrue: [
        newTopCorner y: (childSize y - visibleExtent y max: 0).
    ].

    (newTopCorner ~= topCorner) ifTrue: [
        self scrollTopCorner: topCorner - newTopCorner unlimited: false.
        topCorner := newTopCorner.
        ^true
     ] ifFalse: [
        topCorner := newTopCorner.
        ^false
    ].! !

!WBListEntryField methods !
wmGetdlgcode: wParam with: lParam

    ^DlgcWantallkeys! !

!WindowBuilder class methods !
codeGeneratorClass
	"Private - Answer the code generator class."

	^self 
		propertyAt: #CodeGeneratorClass 
		ifAbsent: [WBCodeGenerator]! !

!WindowBuilder class methods !  
generatePartsMethods
	"Answer true if parts methods should be generated."

	^self partsSupportEnabled! !

!WBTabOrderLayoutForm methods !
children
    "Answer a collection of the children of the receiver."

    ^widgets
! !

!WBBitmapEditorCompositePane methods !   
preInitWindow

	super preInitWindow.
	self owner mainView
		when: #activated send: #update to: bitmapPane.
	sizeButton
		contents: (WBSizeSysBitmap handle; yourself).
	sizePane
		font: self wbEditorClass editorFont.! !

!WBDescriptor methods ! 
commonName: aString
    "Set the value of commonName."

    commonName := aString! !

!WBNLSDictionaryReader class methods ! 
fileOutComment: aString on: aStream
	"File out a token/value pair inside a comment."

	aStream
		cr;
		nextPutAll: self commentStartString;
		nextPutAll: aString;
		nextPutAll: self commentEndString.! !

!PScrollBar methods !
mutationTypes

    ^#(#CPValuator #ScrollBar)! !

!PStaticBox methods !   
usesColor

    ^false! !

!WBLayoutForm methods ! 
shellHandleAt: aPoint

    ^self shellHandles detect: [:aHandle |
        aHandle containsPoint: aPoint] ifNone: [nil]! !

!WBLayoutForm methods !   
hideShellHandles

    self shellHandles do: [:aHandle |
        aHandle displayOn: self pen color: Color white].! !

!WindowBuilder methods !
currentEvent
		"Answer the currently selected event symbol."
	| event |
	event := currentWhen.
	event isNil ifTrue: [^nil].
	(event at: 1) = $* ifTrue: [
		event := event copyFrom: 2 to: event size].
	event := self currentEventIsTriggered
		ifTrue: [
			event
				copyFrom: 1
				to: event size - self tagNewEvents size]
		ifFalse: [
			event
				copyFrom: 1
				to: event size - self tagOldEvents size].
	^event asSymbol! !

!WBFontPool methods ! 
fileOutHeaderOn: aStream
	"File out the receiver's header."

	aStream openParenthesis.
	self manager fileOutRefOn: aStream.
	aStream
		space;
		nextPutAll: #poolNamed: ;
		space;
		nextPutAll: self poolName storeString;
		closeParenthesis;
		indentBy: 1.! !

!WBPoolManagerWindow methods !
menuPoolFileIn: aPath
	"File in from the specified file."

	| stream |
	CursorManager execute changeFor: [
		stream := File pathName: aPath.
		[self poolManager fileInFrom: stream]
			ensure: [stream close]].! !

!WBTeamVCodePolicy methods !
removeKey: aKey inPoolNamed: aSymbol
	"Remove the specified key from a pool in the system."

	(self currentSubsystem unpackagedPackage subsystem 
		definitionOfPoolNamed: aSymbol asSymbol) isNil
		ifTrue: [super removeKey: aKey inPoolNamed: aSymbol]
		ifFalse: [
			((self currentSubsystem
				definitionOfPoolNamed: aSymbol)
					definitionOfPoolVariableNamed: aKey)
						removeFromSystem].! !

!WindowBuilder class methods !   
wbCreateClassDialog

	^self propertyAt: #WBCreateClassDialog! !

!PCompositePane methods !
usesForeColor

    ^false! !

!WBPoolManagerWindow methods !  
selectedPoolsChanged
	"Tthe collection of selected pools changed."

	self
		updatePoolPath;
		updateCategories;
		updateKeys.! !

!CompositeFrameObject methods ! 
hasOtherEditor

    ^false! !

!WBNLSManagerWindow methods !  
menuPoolExtractStrings
	"Use a custom translator to extract strings from windows."

	| translatorClass poolList targetPool |
	(poolList := self selectedPools) isEmpty ifTrue: [
		^MessageBox message:
			'Select one or more pools to use during string extraction'].
	poolList size > 1 ifTrue: [
		targetPool := WBListChooser
			fromList: (poolList collect: [:each | each poolName])
			prompt: 'Select a pool to receive strings'.
		targetPool isNil ifTrue: [^self].
		targetPool := poolList detect: [:each | each poolName = targetPool].
		poolList := (Array with: targetPool), (poolList copyWithout: targetPool)].
	self selectedCategory isNil ifTrue: [
		^MessageBox message:
			'Select exactly one category into which the extracted strings will be placed'].
	(translatorClass := Smalltalk at: #WBNLSExtractionTranslator ifAbsent: [nil]) isNil ifTrue: [
		^MessageBox message:
			'Please install the translators first.'].
	translatorClass
		translateFor: self poolManager
		pools: poolList
		category: self selectedCategory.! !

!WBCallOutEditor class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBCallOutEditor methods !   
selectorChanged: aString

    "Callback for the #textChanged: event triggered in the EntryField named 'selector'.
     (Generated by WindowBuilder)"

    (callOutMap at: callOutList selectedItem ifAbsent: [^self]) = aString ifTrue: [^self].
    (self checkForDups: aString)
        ifTrue: [MessageBox warning: 'Duplicate call out selectors are not allowed']
        ifFalse: [
            callOutMap
                at: callOutList selectedItem
                put: (aString asSuggestedUnarySelectorToken, ':')]! !

!PGroupbox methods !
usesTitle

    ^true! !

!WBEditClassDialog class methods !   
defaultFilterList

    ^#(
        '<Any>'
        'ViewManager'
        'WindowDialog'
        'ApplicationCoordinator'
        'DialogCoordinator'
        'CompositePane'
        '<Non WB>'
        ) asOrderedCollection! !

!WBToolBarEditor methods !  
setNumSpaces: aString

    (elements at: list selection) numSpaces: aString asInteger.! !

!WBMenu methods !  
disableAll
        "Disable all items for the receiver."
    items do: [:mi | mi disable].! !

!WBLookPolicyOS2 methods ! 
drawCheckBox: aCheckBox with: aPen clipRect: clipRect

    | iconExtent aPoint iconRect |
	iconExtent := OperatingSystem isOS2
		ifTrue: [self class radioBitmap extent]
		ifFalse: [self iconExtent + 1].
    self
        drawToggle: aCheckBox
        with: aPen
        clipRect: clipRect.
    aPoint := aCheckBox rect left @ (aCheckBox rect center y up: iconExtent y // 2).
    self
       draw3DBoxWith: aPen
        at: (iconRect := aPoint extentFromLeftTop: iconExtent).
    aPen
        foreColor: Color darkGray;
        wbLineFrom: (iconRect leftBottom rightAndUp: 2)
            to: (iconRect rightBottom leftAndUp: 1@2);
        wbLineFrom: (iconRect rightTop leftAndDown: 2)
            to: (iconRect rightBottom leftAndUp: 2)! !

!WBLayoutWizard class methods !  
widgetMap

    ^WidgetMap ifNil: [WidgetMap := self initializeWidgetMap]! !

!WBInterfaceObject methods ! 
listEditorLabel

    ^nil! !

!WBInterfaceObject methods !
wbRealWidgetDefault

	^(self realClass inheritsFrom: Window)
		ifTrue: [self realClass new]
		ifFalse: [self realClass basicNew topPaneClass new]! !

!PStaticText methods !
changesSize

    ^true! !

!WBCreateBitmap class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowBuilder methods ! 
activated

    self mainView isHandleOk ifFalse: [^self].
    self prototype shell update.
    self
        updateText: thePane;
        updateLayoutProperties;
        updatePasteButton;
        updateMenuOptions;
        updateNlsMenu.! !

!WBMultiToolPalette methods !
on: name add: aSelector

    ^self add: nil selector: aSelector on: name! !

!WBLayoutForm methods !  
updateWidgetAttachments: currentSelections

    self children do: [:child |
        ((currentSelections includes: child) not and: [
            child wbHasWidgetAttachment])
            ifTrue: [self wbLayOutChild: child]].! !

!WBLayoutFrameEditor class methods !   
verticalRatioStrings
	"Answer a dictionary mapping vertical ratios to names."

	^verticalRatioStrings ifNil: [
		verticalRatioStrings := IdentityDictionary new
			at: 0 put: 'Window top';
			at: 1/2 put: 'Window center';
			at: 1 put: 'Window bottom';
			yourself]! !

!PCompositePane methods !  
suggestedSize

	^self initialFraming isNil
		ifTrue: [100@100]
		ifFalse: [(self initialFraming value: Display boundingBox) extent].! !

!WBApplicationCoordinatorModule methods !  
generateCreateViewsStub
        "Don't do this."! !

!WBTreeListBox methods !  
selectedItem

    ( self selection ) isNil   ifTrue: [
        ^nil
    ]  ifFalse: [
        ^list asFlatList at: value
    ]! !

!WBMultiToolPalette methods !  
add: aSelector on: name

    ^self add: nil selector: aSelector on: name! !

!WBToolBarEditor methods !   
down

    | element index |
    index := list selection.
    index isNil ifTrue: [ ^nil ].
    element := elements at: index.
    index == elements size ifTrue: [ ^nil ].
    elements removeIndex: index.
    elements add: element afterIndex: index.
    list invalidateRect: nil.
    list selection: index + 1.

    self updateButtons.! !

!PGraphPane methods !
readSpecificsFrom: aPane

    self style: (aPane hasBorderStyle 
		ifFalse: [#noBorders]
		ifTrue: [
			aPane hasHorizontalScrollBarStyle
				ifFalse: [#noScrollBars]
				ifTrue: [#defaultStyle]])! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCodePolicy methods !
inBaseImage: aClass
	"Answer true if aClass is part of the base image."

	^aClass smalltalkLibraryOrdinal = 1 or: [
		(aClass smalltalkLibraryName ifNil: [^false]) asLowercase beginsWith: 'v']! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PComboBox methods ! 
preferredLabelOrientation

    ^#left! !

!WBEditClassDialog methods !
anyPackage

    "Callback for the #clicked event triggered in the Button named 'anyPackage'.
     (Generated by WindowBuilder)"

    package selectItem: self class defaultChoice.
    self class packageChoice: self class defaultChoice.
    self updateListContents.! !

!WBPMenuItem methods !   
fullTitle

    | fullTitle |

    fullTitle := self title.

    (keyAccel notNil and: [ keyAccel keyName notNil ]) ifTrue: [
        fullTitle := fullTitle, (String with: Tab), keyAccel fullKeyName.
    ].

    ^fullTitle! !

!WBToolBarEditor methods !  
getBitmaps: aPane

	| keys aPoint |

	aPoint := self cellSize.
	aPane
		printSelector: #key;
		contents: (keys := useSystem
			ifTrue: [
				self
					validBitmapsFrom: WBBitmapManager system
					withSize: aPoint]
			ifFalse: [
				self
					validBitmapsFrom: WBBitmapManager current
					withSize: aPoint]).
	keys isEmpty ifFalse: [aPane selection: keys first].! !

!WBManagedPValue methods !  
owner

	^owner! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPoolManagerWindow methods !
menuPoolFileIn

    "Callback for the menu item titled 'File in...'.
     (Generated by WindowBuilder)"

	| path |
	path := self promptForExistingFileName: 'File in pools...'.
	path isNil ifTrue: [^self].
	[self menuPoolFileIn: path]
		on: Error
		do: [:exception | ^self menuErrorHandler: exception].! !

!ReadWriteStream methods !  
nextTwoBytes
        "Private - WBPro Development.
         Answer the next two bytes from a byte array."
    #addedByOSI.
    ^self next + (self next * 256)! !

!WindowBuilder class methods !
allViewManagerClasses

	| teamClass |
	WBClasses notNil
		ifTrue: [^WBClasses].
	"Exclude all WindowBuilder subclasses"
	WBClasses := WindowBuilder withAllSubclasses asOrderedCollection.
	ViewManager allSubclasses do: [:aClass |
		aClass isWBInternalClass
			ifTrue: [WBClasses add: aClass]].
	(teamClass := Smalltalk at: #TeamApplication ifAbsent: [nil]) isNil
		ifFalse: [WBClasses addAll: teamClass withAllSubclasses].
	(teamClass := Smalltalk at: #TeamDialog ifAbsent: [nil]) isNil
		ifFalse: [WBClasses addAll: teamClass withAllSubclasses].
	^WBClasses! !

!WBInterfaceObject methods !
oldEventHandlerSelectorAt: aSymbol put: aString
	"Answer the first event handler at aSymbol as a string
		or an empty string if there is no handler defined."

	aString = '' | aString isNil
		ifTrue: [
			(self wbRealWidget handlersOrNil ifNil: [^self])
				removeKey: aSymbol asSymbol ifAbsent: [^self]]
		ifFalse: [
			self wbRealWidget handlers
				at: aSymbol asSymbol put: aString].! !

!PGroupbox methods !   
winClassStyle

    ^BsGroupbox! !

!WBBitmapManagerWindow methods !   
menuOptionUpdateSource

	self poolManager updateSource: self poolManager updateSource not.
	self updateOptionMenu.! !

!WBXoteryXCodePolicy methods !
basicCreateClassFor: aWBClassDefinition
		"Define and answer a new class.
		Answer nil if one could not be created."
	^aWBClassDefinition superclass
		subclass: aWBClassDefinition className asSymbol
		instanceVariableNames: aWBClassDefinition instVarNamesString
		classVariableNames: aWBClassDefinition classVarNamesString
		poolDictionaries: aWBClassDefinition poolNamesString
		"category: ???".! !

!WBFontSelectionWindow methods !   
selectedFont
	"Answer the currently selected font."

	^selectedFont ifNil: [SysFont]! !

!WBManagedPValue methods !  
wbManagedValue
	"Answer the value being managed."

	^self value! !

!WBEventMessage methods !
changeReceiver: anObject
	"Set the message selector."

	| index |
	index := self index.
	self receiver: anObject.
	index notNil ifTrue: [(self actionList at: index) receiver: self receiver].! !

!Rectangle methods !   
unLocalizeRect: aRect
        "Private - WBPro Development.
            Answer a rectangle that is the same coordinates as self.
            The rectangle passed in is assumed in self's coordinates."
    #addedByOSI.
    ^(aRect leftTop + self origin) extentFromLeftTop: aRect extent! !

!WBPropertyDescriptor methods !
hasResourcesFor: ignore

    ^self hasResources! !

!WBMenuEditor methods !   
selectorEditorChanged: aString

    (selectorEditor contents size ~= 0) & (self allowAttributesFor: menuItemsEditor selectedItem) not ifTrue: [
        MessageBox message: 'Cannot set attributes for top level menus.  Press Cr to insert an item, then promote it with Promote item to add menu items to a menu.'.
        selectorEditor setContents: ''.
        menuItemsEditor
            sendInputEvent: #setFocus.
    ].! !

!Stream methods !
upToWhitespace
		"Answer the contents from the current position
			to the next white space."
	#addedByOSI.
    ^self
        copyFrom: self position + 1
        to: (self skipToWhitespace
	            ifTrue: [self position - 1]
	            ifFalse: [self position])! !

!PActionButton methods !
attributeEditor

    ^Notifier isAltKeyDown
        ifTrue: [super attributeEditor]
        ifFalse: [WBActionEditor].! !

!WindowBuilder methods ! 
menuEditEventSummary

    WBTextEditWindow new
        labelWithoutPrefix: 'Event Summary [' , (self classNameFor: self editedClass) , ']';
        openOn: self prototype eventsSummaryString.! !

!PButton methods !  
isButton

    ^true! !

!WBLookPolicy methods !   
drawFrameBorder: aFrameObject with: aPen in: aRect

    aPen
        foreColor: Color black;
        drawRectangle: aRect.! !

!WindowBuilder methods ! 
menuSizeSetWindowPosition
    "Prompt the user for a new window position"

    | answer |
    Notifier isAltKeyDown
        ifTrue: [
            self layoutForm captureMouseInput.
            answer := Display
                wbPointFromUser: (0 @ 0 extent: self shell rect extent)
                offset: (self shell rect extent // 2)
                executing: [:loc | self updatePosition: loc].
            self layoutForm clearMouseCapture]
        ifFalse: [
            (answer := self
                getPointPrompting: 'New Window Position:'
                defaultPoint: self shell rect origin) ifNil: [^nil]].
    self setWindowPosition: answer.
    self setDirty.! !

!WBPrototype methods ! 
shell

	^shell ifNil: [shell := WindowFrameObject new]! !

!WBTargetObject methods !  
isWBModel

	^false! !

!WBTopPane methods !   
wmMouseactivate: wParam with: lParam
        "Private - If mouse has been clicked on an inactive
         window, select it."
    self mainWindow mdiSelected: true.
    ^MaActivate! !

!WBCallOutModule methods ! 
generateBody
	"Private - Generate the method body."

	self stream indentBy: 1 during: [
		self
			generateGeneratedSymbol;
			generateLayoutTemporaries;
			generateFontDefinitions;
			generatePane].! !

!WBCreateViewModule methods !
generateMenu: aMenu selector: aSymbol
		"Private - Generate all the menu definitions."
	self addModule: (
		self menuModuleClass new
			owner: self;
			object: self object;
			targetClass: self targetClass;
			messageSelector: aSymbol;
			menu: aMenu;
			yourself ).! !

!WBLayoutWizard methods !   
modelClasses

    ^(EventManager wbCreatedClasses
        asSortedCollection: [:a :b | a name <= b name]) asArray! !

!WindowFrameObject methods !   
modifiedBy

    ^modifiedBy! !

!WBCreateBitmap class methods !   
lastBitmapHeight

	^lastBitmapHeight ifNil: [self defaultBitmapHeight]! !

!PTextEdit methods !   
displayWith: aPen clipRect: clipRect

    style == #noBorders
        ifTrue: [^self displayWithNoBorder: aPen].
    (style == #scrollBars or: [style == #defaultStyle])
        ifTrue: [
            ^self lookPolicy
                displayWithRightBottomScrollBars: aPen
                rect: self rect
                backColor: self backColor].
    style == #wordWrap
        ifTrue: [
            ^self lookPolicy
                displayWithRightScrollBar: aPen
                rect: self rect
                backColor: self backColor].
    self lookPolicy
        displayWithBorder: aPen
        rect: self rect
        backColor: self backColor! !

!WBInterfaceObject methods !  
resetPen: aPen

    aPen
        up;
        down;
        font: SysFont;
        backColor: Color windowBackground;
        foreColor: Color windowBorder;
        setTextAlign: WBDisplayContext defaultTextAlign.! !

!PropertyAccessor methods !
wbRemoveStyleAction

	#addedByOSI.
	^(self propertyAt: #wbRemoveStyleAction) ifNil: [self wbDefaultRemoveStyleAction]! !

!WBModelCodeModule methods !   
generateComment
        "Private - Generate the comment."

    super generateComment.
    self stream cr.! !

!WindowBuilder methods !  
updateMenuAttributes

	(self menuTitled: 'Attributes') updateEnabled.! !

!TextEdit class methods !   
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbRemoveEventNamed: #entered: ;
        wbAddEvent: (
            WBEventDescription new
                event: #changed: ;
                argumentNames: #('anObject'));
        wbAddEvent: (
            WBEventDescription new
                event: #textChanged: ;
                argumentNames: #('anObject'));
        wbAddEvent: (
            WBEventDescription new
                event: #aboutToChangeTo: ;
                argumentNames: #('anObject'));
        yourself! !

!PCompositePane methods !
initialFraming: aFramingParameter

    initialFraming := aFramingParameter! !

!WBTreeNode methods !  
firstChild

    children isEmpty ifTrue: [ ^nil ].

    ^children first! !

!WBMultiViewAddInModule class methods ! 
modifyMenus: aMenu
	"Modify the menus"

	#osiHack.
	"the 'hasLayoutForm' should be a nil but nil does not work"

	self
			insertMenu: #('\uView' nil 
				#(#('\uSwitch To...' #menuViewSwitchTo '' #hasMultipleViews nil nil) 
				#('\uCreate...' #menuViewCreate '' #hasLayoutForm "<-- hack" nil nil) 
				#('\uRemove...' #menuViewRemove '' #hasMultipleViews nil nil)))
			in: aMenu
			after: 'Edit'.! !

!PComboBox methods !  
usesForeColor

    ^self isWindows95 or: [style == #dropDownList]! !

!WindowBuilder methods !
targetIsFirst

    ^self class targetIsFirst! !

!WindowFrameObject methods ! 
modifiedBy: aString

    modifiedBy := aString! !

!WBActionLinkAddInModule class methods !   
modifiesPalette
    "Does this add-in modify the palette?"

    ^true! !

!WBAbstractAddInModule class methods ! 
modifiesCodeGeneration
    "Does this add-in modify code generation?"

    ^false! !

!Button class methods !
wbConstructPropertyManager
	"Construct the WindowBuilder property manager
		based on the Digitalk property manager."

	#addedByOSI.
	^super wbConstructPropertyManager
		add: (
			SelectorPropertyAccessor new
				name: 'Label';
				get: #contents ;
				set: #contents: ;
				format: 'String' ;
				wbNLSAccessor: true;
				wbStore: nil );
		wbAddEvent: (
			WBEventDescription new
				event: #clicked ;
				argumentNames: #( ));
		yourself! !

!WBLookPolicyWin95 methods !   
systemMenuWidth

    ^systemMenuWidth ifNil: [
        systemMenuWidth := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxsize" 30]
            ifFalse: [super systemMenuWidth]]! !

!WBCreateViewModule methods !   
view
		"Answer the reciever's view."
	^view ifNil: [ view := self defaultView ].! !

!WindowBuilder class methods !   
defineCodeGenerationProperties: collection
    "Define the code generation properties used in WindowBuilder Pro"

    collection

        add: (WBPropertyDescriptor new
            name: #Copyright;
            commonName: 'Copyright';
            comment: 'Specifies the copyright string to use in generated code. Automatic word substitution is supported: "%Y" is replaced by the current calendar year. "%C" is replaced by the company name. "%U" is replaced by user name. "%D" is replaced by the current date. "T" is replaced by the current time.';
            category: self codeGenerationPropertyString;
            default: '(c) Copyright %C, %Y. All Rights Reserved.';
            yourself);

        add: (WBPropertyDescriptor new
            name: #GenerateCopyright;
            commonName: 'Generate Copyright';
            comment: 'Specifies whether each generated method should include a copyright string.';
            category: self codeGenerationPropertyString;
            default: false;
            yourself);

        add: (WBPropertyDescriptor new
            name: #CopyrightAfterBody;
            commonName: 'Copyright After Body';
            comment: 'Specifies whether the copyright string should appear after the method body. When this property is false, the copyright text is generated before the method body right after the method comment. This is only applicable when "Generate Copyright" is set to true.';
            category: self codeGenerationPropertyString;
            default: false;
            yourself);

        add: (WBPropertyDescriptor new
            name: #LineBeforeComment;
            commonName: 'Line Before Comment';
            comment: 'Specifies whether there should be a blank line between the message pattern and the method comment.';
            category: self codeGenerationPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #GeneratePortableFontCode;
            commonName: 'Generate Portable Font Code';
            comment: 'Specifies whether font definitions should be generated using portable font APIs. Non-portable font generation is more accurate on the current platform.';
            category: self codeGenerationPropertyString;
            default: false;
            yourself);

        add: (WBPropertyDescriptor new
            name: #RecordCreatorInformation;
            commonName: 'Record Creator Information';
            comment: 'Specifies whether creator information should be generated.';
            category: self codeGenerationPropertyString;
            default: false;
            yourself);

        add: (WBPropertyDescriptor new
            name: #IndirectBitmapReferences;
            commonName: 'Indirect Bitmap References';
            comment: 'Specifies whether references to bitmaps managed by the WBBitmapManager should be generated as

indirect references
    Bitmap named: <key>

or direct references
    <key>';
            category: self codeGenerationPropertyString;
            changeBlock: [:aBoolean | WBBitmapManager current isIndirectCodeGenerationStyle: aBoolean];
            default: WBBitmapManager current isIndirectCodeGenerationStyle;
            yourself);

        add: (WBPropertyDescriptor new
            name: #IndirectFontReferences;
            commonName: 'Indirect Font References';
            comment: 'Specifies whether references to fonts managed by the WBFontManager should be generated as

indirect references
    Font named: <key>

or direct references
    <key>';
            category: self codeGenerationPropertyString;
            changeBlock: [:aBoolean | WBFontManager current isIndirectCodeGenerationStyle: aBoolean];
            default: WBFontManager current isIndirectCodeGenerationStyle;
            yourself);

        add: (WBPropertyDescriptor new
            name: #IndirectNLSReferences;
            commonName: 'Indirect NLS References';
            comment: 'Specifies whether references to strings managed by the WBNLSManager should be generated as

indirect references
    <NLS-pool> at: <key>

or direct references
    <key>';
            category: self codeGenerationPropertyString;
            changeBlock: [:aBoolean | WBNLSManager current isIndirectCodeGenerationStyle: aBoolean];
            default: WBNLSManager current isIndirectCodeGenerationStyle;
            yourself);

        add: (WBPropertyDescriptor new
            name: #AutoRecognizeOkCancel;
            commonName: 'Auto Recognize OK and Cancel';
            comment: 'Specifies whether Buttons with labels ''OK'' or ''Cancel'' should automatically be given the defaultPushButton or cancelPushButton style during code generation.';
            category: self codeGenerationPropertyString;
            changeBlock: [:aBoolean | PButton autoRecognizeOkCancel: aBoolean];
            default: PButton autoRecognizeOkCancel;
            yourself);

        add: (WBPropertyDescriptor new
            name: #GenerateByteArrayCode;
            commonName: 'Generate Byte Array Code';
            comment: 'Specifies whether byte arrays should be generated using the new language specification.  If true, then ByteArrays will be generated as

    #[ ]

rather than

    #( ) asByteArray.';
            category: self codeGenerationPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #UseLayoutFrame;
            commonName: 'Use LayoutFrame';
            comment: 'Specifies whether LayoutFrame or FramingParameters should be used during code generation.';
            category: self codeGenerationPropertyString;
            default: true;
            yourself);

        add: (WBPropertyDescriptor new
            name: #RuntimeLessCode;
            commonName: 'Runtime less code';
            comment: 'Specifies whether generated code should not have any dependencies on WindowBuilder Pro runtime libraries.';
            category: self codeGenerationPropertyString;
            default: false;
            yourself);

        add: (WBPropertyDescriptor new
            name: #LogScratch;
            commonName: 'Log scratch window code';
            comment: 'Specifies whether code generated for the WindowBuilder scratch windows should be logged.';
            category: self codeGenerationPropertyString;
            default: false;
            yourself);

        yourself! !

!WBApplicationCoordinatorModule methods !  
useInstVars
		"Answer true if the receiver should generate instVar references."
	^false! !

!WBFramerExample methods !
backColor

	^Color gray! !

!WindowBuilder methods !  
editedClass: realClass

	self prototype realClass: realClass! !

!WBModelDefinitionEditor methods !   
updateInitializeValue: selectedItem

    (selectedItem initialized
        and: [(selectedItem valueClass inheritsFrom: String)
        or: [(selectedItem valueClass inheritsFrom: Number)
        or: [selectedItem valueClass inheritsFrom: Boolean]]])
        ifTrue: [
            initializeValue contents: selectedItem initializeValue storeString.
            selectedItem myClass == selectedModel
                ifTrue: [
                    initializeValue
                        enable;
                        backColor: Color white]
                ifFalse: [
                    initializeValue
                        disable;
                        backColor: Color gray]]
        ifFalse: [
            initializeValue
                contents: self emptyString;
                disable;
                backColor: Color gray].! !

!PEnhancedEntryField methods !
maximumSize: anInteger

    maxSize := anInteger! !

!WindowBuilder methods ! 
updateOutboardWidgetsDestroyed: aCollectionOfWidgets
	"Update all of the outboard windows when a widget is destroyed"

	self outboards do: [:window |
		window widgetsDestoyed: aCollectionOfWidgets].
	! !

!WBLayoutForm methods !   
usesFocus

    ^true! !

!WBCreateButton class methods !  
defaultBitmapHeight

	^22! !

!WBRGBColorDialog methods ! 
drawItem: index pane: aPane

    | color string |

    (string := tempColors at: index) = #default
        ifTrue: [ color :=  defaults at: self selectedElement ifAbsent: [ Color black ] ]
        ifFalse: [ color := Color perform: string ].

    aPane pen
        fill: aPane drawBox color: Color white;
        fill: (
			(aPane drawBox leftTop extentFromLeftTop:
				self colorBarWidth @ aPane drawBox height
					) insetBy: 1) color: color;
        setTextAlign: WBDisplayContext defaultTextAlign;
        font: ListFont;
        displayText: string at: (
			aPane drawBox leftTop rightAndDown: (
				(self colorBarWidth + 5)
					@ ((aPane drawBox height - 2) * Rectangle leftTopUnit y) ) )! !

!PRadioButtonGroup methods ! 
copySpecificsTo: aPane

    aPane
        label: self label;
        contents: self contents.! !

!WBClassDefinition methods !  
basicCreateClass
		"Private - Create/modify the class if necessary."
	self policy createClassFor: self.! !

!WBEnhancedAttributeEditor methods !  
thePropertyManager

	^thePropertyManager ifNil: [
		thePropertyManager := thePane wbRealWidget wbPropertyManager]! !

!WBLookPolicyWin31 class methods ! 
purgeCache
    " WBLookPolicyWin31 purgeCache "

    Down notNil ifTrue: [Down release].
    Up notNil ifTrue: [Up release].
    Right notNil ifTrue: [Right release].
    Left notNil ifTrue: [Left release].
    Down := Up := Right := Left := nil.! !

!WBLookPolicy methods !   
drawFrame: aFrameObject with: aPen

    | aPoint aRect region |
    aPoint := aFrameObject frameLeftTop.
    region := aPen setClipRect: (aRect := aPoint extentFromLeftTop: aFrameObject frameRect extent).
    self drawFrameBorder: aFrameObject with: aPen in: aRect.
    aPen destroyRegion: region.
    aRect extent > ((self borderWidthFrom: aFrameObject) asPoint * 2)
        ifTrue: [
            region := aPen setClipRect: (aRect := aRect insetBy: (self borderWidthFrom: aFrameObject)).
            self
                drawTitleBar: aFrameObject with: aPen in: aRect;
                drawMenuBar: aFrameObject with: aPen in: aRect.
            aPen destroyRegion: region].! !

!WindowBuilder class methods !
wbSystemBitmapFileName
	"Answer the system bitmap file name."

	^'wb20sysw'! !

!WBUndoAction methods !  
undoAction

    ^undoAction! !

!WindowBuilder class methods !
scrapbook: aScrapbook

	Scrapbook := aScrapbook! !

!WBLayoutFrameEditor methods !
attachRightTopBottom

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: #(1 0 1 1).! !

!Object class methods !  
supportedEvents
        "Obsolete - initialize the set of events that instances of the receiver class generate."
		"Added by OSI to return empty set if Digitalk obsoletes are not loaded."
	#addedByOSI.
    self obsoleteMethod.
    ^Set new! !

!WBPMenubar methods !  
storeOn: aStream indentString: indentString

    children do: [ :m |
        aStream nextPutAll: ';'; cr; nextPutAll: indentString, '    addMenu: ('; cr.
        m storeOn: aStream indentString: indentString, '        '.
        aStream cr; nextPutAll: indentString, '    )'.
    ].! !

!WBPrototype methods ! 
initializeInstVarsFor: aViewObject

    | names wbInstVarMap modelClass |
    names := aViewObject class allInstVarNames.
    targetObject := aViewObject.
    (wbInstVarMap := aViewObject wbInstVarMap) keys do: [:each |
        aViewObject
            instVarAt: (names indexOf: each)
            put: (
                WBInstVarObject new
                    owner: aViewObject;
                    name: each;
                    yourself)].
    ((modelClass := aViewObject class wbModelClass) notNil
        and: [wbInstVarMap includesKey: 'model'])
        ifTrue: [
            aViewObject
                instVarAt: (names indexOf: 'model')
                put: (((wbInstVarMap at: 'model')
                    ifNil: [modelClass new])
                    propertyAt: #primaryModel put: true;
                    setName: 'model';
                    isInstVar: true;
                    owner: aViewObject)].! !

!WBTimerEditor methods ! 
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancelButton mainView okButton periodLabel xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	period := EntryField new.
	
		"Temporary Variables"
	cancelButton := Button new.
	okButton := Button new.
	periodLabel := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Timer Editor';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -44 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -20 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -44 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -20 * yDU).
	self addView: mainView.
	
	period "EntryField"
		owner: self;
		setName: 'period';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 52 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -82 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: period;
		subPaneWithFocus: period.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -40 * xDU;
				bottomRatio: 0; bottomInset: -36 * yDU);
		defaultPushButton;
		contents: 'OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: okButton.
	
	cancelButton "Button"
		owner: self;
		setName: 'cancelButton';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 46 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -82 * xDU;
				bottomRatio: 0; bottomInset: -36 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancelButton.
	
	periodLabel "StaticText"
		owner: self;
		setName: 'periodLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 6 * yDU;
				rightRatio: 0; rightInset: -48 * xDU;
				bottomRatio: 0; bottomInset: -14 * yDU);
		rightJustified;
		contents: 'Period (ms):';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: periodLabel! !

!WBOpenMethodModule methods ! 
defaultMessageSelector
        "Private - Answer the default message selector."
    ^#open! !

!WBPoolManagerWindow methods ! 
selectedCategory: aCategory
	"Select the category."

	self selectedCategories: (OrderedCollection with: aCategory).! !

!PropertyAccessor methods !  
wbAddStyle: aSymbol

	#addedByOSI.
	self propertyAt: #wbAddStyleAction put: aSymbol.! !

!PLinkButton methods !  
copySpecificsTo: aPane

    aPane
        link: self link;
        type: self type.! !

!WBEntryListPrompter methods !  
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel list mainView ok prompt xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	list := WBComboBox new.
	ok := Button new.
	prompt := StaticText new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'Query';
		noSmalltalkMenuBar;
		backColor: Color gray;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -77 * xDU;
				topRatio: 1/2; topInset: -79 * yDU;
				rightRatio: 1/2; rightInset: -77 * xDU;
				bottomRatio: 1/2; bottomInset: -70 * yDU).
	self addView: mainView.
	
	list "WBComboBox"
		owner: self;
		setName: 'list';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3 * xDU;
				topRatio: 0; topInset: 16 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 1; bottomInset: 19 * yDU);
		simpleList;
		startGroup;
		font: SysFont.
	mainView
		addSubpane: list;
		subPaneWithFocus: list.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -71 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 1; rightInset: 81/2 * xDU;
				bottomRatio: 1; bottomInset: 7/2 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1; leftInset: -36 * xDU;
				topRatio: 1; topInset: -19 * yDU;
				rightRatio: 1; rightInset: 9/2 * xDU;
				bottomRatio: 1; bottomInset: 7/2 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	prompt "StaticText"
		owner: self;
		setName: 'prompt';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3 * xDU;
				topRatio: 0; topInset: 5 * yDU;
				rightRatio: 1; rightInset: 4 * xDU;
				bottomRatio: 0; bottomInset: -13 * yDU);
		contents: 'StaticText';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: prompt! !

!WBNLSManagerWindow methods ! 
defaultPoolManager
	"Answer the current NLS pool manager."

	^WBNLSManager current! !

!WBOutboardWindow methods !   
setDirty

	^self owner setDirty! !

!WBColorDialog methods !  
highlightItem: index pane: aPane

    aPane pen 
		reverse: 
			(Rectangle 
				leftTop: (aPane drawBox leftTop + ((self colorBarWidth + 2) @ 0))
				rightBottom: aPane drawBox rightBottom)! !

!WBCodeStream methods ! 
noParenthesis
	"Suppress the next generation of parenthesis.
		WARNING!!  Use this only if you are *sure*
		that parenthesis can be suppressed."

	noParenthesis := true.! !

!WBEventManagerWindow class methods !
defaultWarningClasses

	^Array with: Window! !

!WBCodeStream methods !   
openBracket
	"Append a '[' to the code stream."

	stream nextPut: $[.
	self indentBy: 1.! !

!WBBitmapEditorCompositePane class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBListChooser methods !
listClass

    ^ListBox! !

!WBPrototype methods !
importFromResFile: resFile

	| newClass template hFile idDict symName hName |
	(newClass := (self wbEditorClass wbCreateClassDialog new forWindowType: 'Dialog') result) isNil
		ifTrue: [^nil].
	shell := WindowFrameObject new.
	shell realClass: newClass.
	windows := OrderedCollection with: shell.
	template := WinDialogInfo new readFrom: resFile.
	self children: OrderedCollection new.
	idDict := Dictionary new.
	hName := (resFile copyFrom: 1 to: resFile size - 3) , 'H'.
	(File exists: hName) ifTrue: [
		hFile := File pathName: hName.
		[	[hFile atEnd not and: [(hFile nextString: 'define') notNil]]
				whileTrue: [
					symName := hFile nextWord.
					idDict at: hFile nextWord asInteger put: symName].
		] ensure: [hFile close]].
	shell
		rect: (template origin extent: (template extent * self realDialogUnit) rounded);
		contents: template text.
	shell style: (WindowFrameObject styleFrom: template style).
	shell extent: shell extent + (self shellFrameRect extent - self shellContentRect extent).
	template items do: [:p |
		p rect: ((self shellContentRect origin + (p rect origin * self realDialogUnit) rounded) extent: (p rect extent * self realDialogUnit) rounded).
		p wbUpdateConstraints.
		p paneName: (idDict at: p resID ifAbsent: [nil]).
		self children add: p].
	"self children: self children reversed."
	^newClass! !

!WindowBuilder methods !  
statusDescriptionFor: aWidget

	| nameString |
	aWidget paneName isNil
		ifTrue: [
			nameString := 'an unnamed ' , aWidget realClass name.
			aWidget contents isString
				ifTrue: [nameString := nameString , ' (contents is ' , aWidget contents asQuotedString , ')']]
		ifFalse: [nameString := 'the ' , aWidget realClass name , ' named ' , aWidget paneName asQuotedString].
	^nameString! !

!PCompositePane methods !   
backColor

	^self parent isCompositePane
		ifTrue: [super backColor]
		ifFalse: [
			backColor = super defaultBackColor
				ifTrue: [super backColor]
				ifFalse: [backColor]].! !

!WindowBuilder class methods !  
codePolicyClass
	"Private - Answer the code policy class."

	^self 
		propertyAt: #CodePolicyClass 
		ifAbsent: [nil]! !

!WBLayoutForm methods !  
duplicate
    "Duplicate the selected widgets"

    self hideHandles.
    self
        cloneWidgets: self duplicatableWidgets
        at: (self selectedRect topLeft rightAndDown: self duplicateOffset).
    self duplicateWidgets: self selections.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder methods !  
menuSizeSetWidgetPosition
    "Prompt the user for a new widget position"

    | answer |
    self hasSelections ifFalse: [^self menuSizeSetWindowPosition].
    (answer := self
        getPointPrompting: 'New Widget Position:'
        defaultPoint: (self shell contentLeftTop distanceRightAndDown: self layoutForm selectedRect topLeft)) ifNil: [^nil].
    self geometryManager repositionSelectedWidgets: (self shell contentLeftTop rightAndDown: answer).! !

!WindowBuilder methods !  
popupTargetMenu: sendPane

    | menu panesMenu objectMenu iVarMenu eventHandlerTarget
    global checkItem array answer |

    self currentEventIsTriggered
        ifFalse: [^sendPane setPopupMenu: nil].

    menu := Menu new
        owner: self;
        selector: #popupEventTarget:;
        appendItem: (
            self editedClass isScratchWindow
                ifTrue: ['Self'] ifFalse: ['Self [', self editedClass name, ']'])
            selector: "#self" self prototype targetObject;
        yourself.
    self shell isCompositePane
        ifFalse: [menu appendItem: 'Top Pane' selector: self shell wbRealWidget].
    thePane == self shell
        ifFalse: [menu appendItem: 'Widget' selector: thePane wbRealWidget].
    (self hasChildren or: [self prototype targetInstVarNames notEmpty])
        ifTrue: [menu appendSeparator].
    self hasChildren
        ifTrue: [
            menu appendSubMenu:
                (panesMenu := Menu new
                    title: 'Widgets';
                    owner: self;
                    selector: #popupEventTarget:;
                    yourself).
            ((array := self children asArray) copyFrom: 1 to: (array size min: 24)) do: [:pane |
                panesMenu appendItem: pane wbNameAndClass selector: pane wbRealWidget].
            array size > 24
                ifTrue: [
                    panesMenu appendSeparator;
                        appendItem: 'Other Widget...' action:
                            (Message receiver: [
                                (answer := WBListChooser
                                    fromList: (array collect: [:pane | pane wbRealWidget])
                                    prompt: 'Select Pane') isNil
                                    ifFalse: [self popupEventTarget: answer]] selector: #value)]].
    self prototype modelObjects notEmpty
        ifTrue: [
            menu appendSubMenu:
                (objectMenu := Menu new
                    title: 'Model Objects';
                    owner: self;
                    selector: #popupEventTarget:;
                    yourself).
            ((array := self prototype modelObjects asArray) copyFrom: 1 to: (array size min: 24)) do: [:object |
                objectMenu appendItem: object wbNameAndClass selector: object].
            array size > 24
                ifTrue: [
                    objectMenu appendSeparator;
                        appendItem: 'Other Model Object...' action:
                            (Message receiver: [
                                (answer := WBListChooser
                                    fromList: array
                                    prompt: 'Select Model Object') isNil
                                    ifFalse: [self popupEventTarget: answer]] selector: #value)]].
    self prototype targetInstVarNames notEmpty
        ifTrue: [
            menu appendSubMenu:
                    (iVarMenu := Menu new
                        title: 'Inst Vars';
                        owner: self;
                        selector: #popupEventTarget:;
                        yourself).
            ((array := self prototype targetInstVars asSortedCollection asArray)
                copyFrom: 1 to: (array size min: 24)) do: [:iVarAssoc |
                iVarMenu appendItem: iVarAssoc key asString selector: iVarAssoc value].
            array size > 24
                ifTrue: [
                    iVarMenu appendSeparator;
                        appendItem: 'Other I-Var...' action:
                            (Message receiver: [
                                (answer := WBListChooser
                                    fromList: (array collect: [:each | each key])
                                    prompt: 'Select I-Var') isNil
                                    ifFalse: [self popupEventTarget: (array detect: [:each | each key = answer]) value]] selector: #value)]].
    eventHandlerTarget :=
        ((thePane wbRealWidget eventHandlerTargetAt: self currentEvent asExistingSymbolOrNil)
            ifNil: [self prototype targetObject]) wbRealWidget.

    Smalltalk associationsDo: [:each |
        each value == eventHandlerTarget ifTrue: [
            global := each]].
    menu
        appendSeparator;
        appendItem:     'Window',
            ((global notNil and: [global value wbCreated])
                ifTrue: [checkItem := #window:. ' [',global key,']'] ifFalse: ['']),'...' selector: #window:;
        appendItem:     'Global',
            ((global notNil and: [global value wbCreated not])
                ifTrue: [checkItem := #global:. ' [',global key,']'] ifFalse: ['']),'...' selector: #global:.

    checkItem isNil
        ifTrue: [
            menu checkItem: eventHandlerTarget.
            panesMenu isNil ifFalse: [panesMenu checkItem: eventHandlerTarget].
            objectMenu isNil ifFalse: [objectMenu checkItem: eventHandlerTarget].
            iVarMenu isNil ifFalse: [iVarMenu checkItem: eventHandlerTarget]]
        ifFalse: [menu checkItem: checkItem].

    sendPane setPopupMenu: menu.! !

!PToggle methods !  
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	eventSymbol == #clicked: ifTrue: [^#('aBoolean')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!WBCreateMenuModule methods !  
defaultPaneName
		"Answer the default owner name."
	^'aPane'! !

!WBLayoutForm methods !  
button1MotionMovingOutline: aPoint
    "Process a motion while moving an outline of the widget."

    | x y ctrl contentRect |
    (self checkAllowMove: aPoint) ifFalse: [^self].

    "Control drag creates a copy"
    ctrl := Notifier isControlKeyDown.
    (ctrl and: [self selections ~= self duplicateWidgets])
        ifTrue: [
            self
                cloneWidgets: self duplicatableWidgets
                at: self selectedRect topLeft.
            self duplicateWidgets: self selections].

    contentRect := self shell frameContentRect.
    x := aPoint x left: self cursorOffset last x.
    y := aPoint y up: self cursorOffset last y.
    self useGrid
        ifTrue: [
            x := contentRect left distanceRight: x.
            y := contentRect top distanceDown: y.
            x := contentRect left right: (x roundTo: (self gridSize x max: 1)).
            y := contentRect top down: (y roundTo: (self gridSize y max: 1))].
    self useFence
        ifTrue: [
            x := (x rightMost: contentRect left) leftMost: (contentRect right left: bandRect width).
            y := (y lowerOf: contentRect top) higherOf: (contentRect bottom up: bandRect height)].

    "See if the widget has moved first, must check using the offset of the drawn box."
    self
        drawBand;
        moveBand: x @ y;
        drawBand.

    self notifyModelOfSizeOrPositionChange: bandRect.! !

!PEnhancedEntryField methods ! 
attributeEditor

    ^WBEnhancedEntryFieldEditor! !

!PStatusPane methods !   
updateBoxesRightJustifiedFixed

	| xPos aRect |
	xPos := rect right - self height.
	self statusBoxes reverseDo: [:box |
		xPos := xPos left: box width + 6.
		aRect := Rectangle leftTop: xPos @ rect top rightBottom: (xPos + box width + 6) @ (rect bottom down: 2).
		aRect := aRect insetBy: (0 @ self inset).
		box rectangle: aRect.
		xPos := xPos left: box space].
	^xPos! !

!WindowBuilder class methods ! 
osiProducts

	| osiProducts |
	^(osiProducts := self osiProductRegistry) registeredServices
		collect: [:serviceName |
			(osiProducts serviceNamed: serviceName) , 
			' v' , (osiProducts versionOf: serviceName)].! !

!WBGraphicObject methods !  
fullCopy: copy

	self == copy 
		ifFalse: [
			properties notNil 
				ifTrue: [
					properties keysAndValuesDo: [:eachKey :eachValue |
						copy propertyAt: eachKey put: eachValue]]].! !

!WBCodePolicy methods !
removePoolNamed: aSymbol
    "Remove the specified pool from the system."

    Smalltalk removeKey: aSymbol ifAbsent: [ ].! !

!WBCreateClassDialog class methods !  
defaultSuperClassFor: aType

    ^self defaultSuperClass at: aType ifAbsent: [aType]! !

!WindowBuilder methods ! 
openOn: appWindowClass

	self editedClass: appWindowClass.
	self open.! !

!WBLayoutForm methods !   
dragOutline: aBoolean
    "Set the value of dragOutline."

    dragOutline := aBoolean.! !

!WBDialogEditor class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBToolBarEditor methods !   
toggleDefault: selection

    selection ifTrue: [
        (self paneNamed: 'cellSize')
            contents: '25 @ 22';
            disable
    ] ifFalse: [
        (self paneNamed: 'cellSize') enable
    ].! !

!WBEditClassDialog methods !
packageChoices

    ^(Smalltalk at: #TeamVInterface) current packages select: [:pack |
            self isValidPackage: pack].! !

!BitEditor methods !  
isInGrid: aPoint
        "Private - Answer true if aPoint is in the grid."
    | gridRectangle |
    gridRectangle := 0 @ 0 extent: (copy extent * scale).
    (gridRectangle containsPoint: aPoint)
        ifTrue: [^true]
        ifFalse: [^false]! !

!WBEventManagerWindow methods !
eventSelections: aCollection
    "Answer the currently selected events."

    eventListBox selection: aCollection.
	self handlerListUpdate.! !

!WBEditClassDialog methods !
inXoteryX

    ^self wbEditorClass xoteryxIsInstalled! !

!Behavior methods ! 
wbPseudoClass
	"Answer the appropriate pseudo class for the receiver"
	| className superclass pSym |
	className := self name.
	pSym := ('P', className) asSymbol.
	(Smalltalk includesKey: pSym) 
		ifTrue: [^Smalltalk at: pSym].
	superclass := (Smalltalk at: className asSymbol) superclass name.
	[superclass = 'Object'] whileFalse: [
		pSym := ('P', superclass) asSymbol.
		(Smalltalk includesKey: pSym)
			ifTrue: [^Smalltalk at: pSym].
		superclass := (Smalltalk at: superclass asSymbol) superclass name].
	^PGenericSubpane! !

!WBModelObjectEditor methods !
styleEditor

    ^style! !

!WBTemplateEditor methods !   
updateSizeButton: currentWidget

	currentWidget isNil
		ifTrue: [sizeButton disable]
		ifFalse: [sizeButton enable].! !

!WBLayoutForm methods !
duplicateWidgets
    "Answer the value of duplicateWidgets."

    ^duplicateWidgets! !

!WBEventHandlerStubModule methods !  
event

	^event! !

!WindowBuilder methods !   
updateMenuAdd

	(self menuTitled: 'Add') updateEnabled.! !

!WBTabOrderEditor methods !   
clicked: aWidget

	(aWidget isNil or: [aWidget isGrouper not])
		ifTrue: [removeGroupButton disable]
		ifFalse: [
			removeGroupButton enable.
			self setStatus: 'Use "Remove Group" to remove the tabbing group.']! !

!WBLayoutForm methods !  
isWBLayoutForm
    "Answer whether the receiver is an instance of WBLayoutForm"

    ^true! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBToolMenuAddInModule class methods !   
modifiesMenus
    "Does this add-in modify the menus?"

    ^true! !

!WBMenuEditor methods !
result

    ^result! !

!WindowFrameObject methods !  
isCompositePane

    ^self realClass inheritsFrom: CompositePane.! !

!WBBitmapManagerWindow methods !
menuBitmapFromScreenIntoButton

	| aBitmap selectedBitmap |
	selectedBitmap := self selectedValue ifNil: [^self].
	aBitmap := WBBitmapClass fromUser ifNil: [^self].
	selectedBitmap wbInitButton: aBitmap.
	self updateEditor.! !

!PRadioButtonGroup methods !  
usesTitle

    ^true! !

!RadioButtonGroup class methods !
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #changedIndex: ;
                argumentNames: #('anObject'));
        wbAddEvent: (
            WBEventDescription new
                event: #clicked: ;
                argumentNames: #('anObject'));
        yourself! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBNLSEditorCompositePane methods !
valueEditFieldChanged: aString pane: aPane

    "Callback for the #textChanged: event triggered in the EntryField named 'valueEditField'.
     (Generated by WindowBuilder)"

	self selectedValue: aString.! !

!WBEventDescription methods !  
event

	^self key! !

!WinDialogInfo methods !
numberOfItems
        "Private - WBPro Development."
    #addedByOSI.
    ^self byteAtOffset: 4! !

!PComboBox methods ! 
wbSuggestedTempName
        "Answer the suggested temporary variable name used in code generation."
    ^'ComboBox'! !

!CursorManager class methods !
initializeWBCursors
        "Private - WB Development."
! !

!WindowFrameObject methods ! 
children

    ^children! !

!WBBitmapManagerWindow class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WindowBuilder methods ! 
layoutFormChanged

	self setDirty.
	self triggerChanged.! !

!WBTemplateEditor methods ! 
displayImage

	sample doGraphics: [
		sample
			backColor: sample class defaultBackColor;
			foreColor: sample class defaultForeColor;
			erase.
		template isNil
			ifFalse: [
				template rect moveBy: 
					(sample rectangle center - template rect center).
				template isCompositePane
					ifTrue: [template realClass: template realClass].
				[template 
					resetPen: sample pen;
					displayWith: sample pen clipRect: sample rectangle]
					on: Error 
					do: [sample pen
						foreColor: Color red;
						setTextAlign: TaTop;
						centerWinText: 'Drawing Error' at: sample rectangle center]]].! !

!WBScrollBarEditor methods !  
close
  ^self cancel: nil! !

!BitEditor methods ! 
colorSelected: aColor
    bitColor := aColor! !

!WBEventMessage methods ! 
moveBottom
	"Move the receiver's action to the bottom of the list."

	self moveToIndex: self actionList size.! !

!WBDefaultDialogScratchWindow class methods !  
isWBInternalClass

    ^true! !

!WBInterfaceObject methods ! 
mutationList
	| list |
	self realClass isNil ifTrue: [^nil].
	list := Set new.
	list addAll: self realClass withAllSubclasses.
	self mutationTypes do: [:className |
		(Smalltalk includesKey: className asSymbol)
			ifTrue: [list addAll: (Smalltalk at: className asSymbol) withAllSubclasses]].
	self mutationExceptions do: [:className |
		(Smalltalk includesKey: className asSymbol)
			ifTrue: [list remove: (Smalltalk at: className asSymbol)]].
	list remove: self realClass.
	list := (list reject: [:class | class isWBInternalClass]) collect: [:class | class name].
	list := list reject: [:className |
		(className beginsWith: 'PART') or: [className first == $ ]].
	(list includes: 'ScrollBar')
		ifTrue: [
			list
				remove: 'ScrollBar';
				add: 'WBVerticalScrollBar';
				add: 'WBHorizontalScrollBar'].
	^list asSortedCollection! !

!WBModelDefinitionEditor methods ! 
selectAttribute: selectedItem

    initialized selection: selectedItem initialized.
    hasAccessors selection: selectedItem hasAccessors.
    selectedItem myClass == selectedModel
        ifTrue: [self enableFields]
        ifFalse: [self disableFields].
    initialized selection: selectedItem initialized.
    hasAccessors selection: selectedItem hasAccessors.
    self enableModelFields.
    name contents: selectedItem name.
    myClass setValue: selectedItem valueClass name.
    lazy selection: selectedItem lazy.
    hasEvent selection: selectedItem hasEvent.
    self updateInitializeValue: selectedItem.! !

!Object methods !   
definedIn: aSelector
        "Set the selector of the creation method."
    #addedByOSI.
    self creationMethodSelector: aSelector! !

!WBCreateClassDialog methods !   
defaultType

    ^self class defaultType! !

!WBDevelopmentWindow methods !   
setStyle: selectedItem

	| theStyle currentWidget |
	selectedItem isNil ifTrue: [^self].
	(theStyle := selectedItem trimBlanks) notEmpty
		ifTrue: [
			currentWidget := self currentWidget.
			(currentWidget style: theStyle asSymbol) isNil
				ifTrue: [
					currentWidget reframe: self shellContentRect.
					self redraw].
			self redisplaySelection.
			self updateColorButton: self attributePalette for: currentWidget.
			self updateFramingButton: self attributePalette for: currentWidget.
			self updateText: currentWidget].! !

!WBPoolManagerWindow methods ! 
openOn: aWBPoolManager
	"Open the receiver on the specified pool."

	poolManager := aWBPoolManager.
	self open.! !

!WBInterfaceObject methods !
wbHasWidgetAttachment

	^false! !

!WBEventManagerWindow class methods !  
defaultWidgetFilters
	"Answer a dictionary mapping strings to filter selectors."

	^Dictionary new
		at: 'Windows' put: #isWindow;
		at: 'Models' put: #isWBModel;
		at: 'Inst Vars' put: #isWBInstVarObject;
		yourself! !

!WBManagedPNLSString methods !  
nlsAutosize
	"Answer true if the receiver should autosize based
		on the largest NLS string for the receiver's key."

	^self owner nlsAutosize and: [self key notNil]! !

!WBGeometryManager methods !  
morphSelectionsTo: newClass

    | selections |
    self layoutForm notNil
        ifTrue: [
            selections := self selections.
            (self layoutForm morphSelectionsTo: newClass) isNil
                ifFalse: [self owner updateOutboardWidgetsDestroyed: selections]].! !

!Window methods ! 
wbOldEventTable: anEventTable
	"Set the receiver's old event table from anEventTable."

	| newEventTable supportedEvents |
	anEventTable notNil ifTrue: [
		newEventTable := anEventTable species new.
		supportedEvents := self class supportedEvents.
		anEventTable associationsDo: [:each |
			(supportedEvents includes: each key) ifTrue: [
				newEventTable at: each key put: each value]]].
	self propertyAt: #oldHandlers put: newEventTable.! !

!WBAboutDialog class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!Window methods !
extent: e
        "Private - WBPro Development."
    #addedByOSI.
    self propertyAt: #extent put: e! !

!PStatusPane methods ! 
storeContentsOn: aStream indentString: indentString

	self statusBoxes isEmpty
		ifFalse: [
			aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'contents: ('; cr.
			aStream nextPutAll: indentString, '	OrderedCollection new'; cr.
			self statusBoxes do: [:fld |
				aStream nextPutAll: indentString, '		addLast: ('; cr.
				fld storeOn: aStream indentString: indentString, '			'.
				aStream cr; nextPutAll: indentString, '		)'.
				aStream nextPutAll: ';'; cr].
			aStream nextPutAll: indentString, '		yourself'; cr.
			aStream nextPutAll: indentString, ')'].! !

!WBAbstractCreateViewsModule methods !   
defaultTargetName
		"Answer the default target name."
	^'self'! !

!WindowBuilder class methods ! 
devBitmapFileNames
	"Answer the possible names of the development bitmap DLL."

	^#('WB2ASYSW.DLL' 'WB20SYSW.DLL')! !

!WBCreateViewModule methods ! 
generatePane: aPane
		"Private - Generate the pane definition."
	self stream cr.
	(self isInstVar: (self varNameFor: aPane)) & self useInstVars not
		ifTrue: [self stream nextPutAll: (self varNameFor: #owner); space].
	self stream
		nextPutAll: (self varNameFor: aPane);
		indentBy: 1.
	aPane == self view ifFalse: [
		self generatePaneComment: aPane].
	aPane isWBPrimaryModel
		ifFalse: [
			self
				generatePaneOwner: aPane;
				generatePaneName: aPane;
				generatePaneClipStyle: aPane].
	self generatePaneBody: aPane.
	self stream
		endExpression;
		indentBy: -1.! !

!PEntryField methods !  
preferredLabelOrientation

    ^#left! !

!WBModelObjectEditor methods !  
updateLabel

	self labelWithoutPrefix: 
		'Model Object Editor: [' , 
		(self owner classNameFor: self owner editedClass) , ']'! !

!WindowBuilder methods !
symbolNameChanged: ignore

	| badName newName |
	thePane isNil ifTrue: [^nil].
	(newName := name contents) = thePane paneName
		ifTrue: [^self].
	"The names are changing so..."
	thePane isInstVar
		ifTrue: [self paneNameIsInstVar: false].
	self paneNameIsValidInstVar: newName.
	self triggerAboutToChange.
	newName hasContent
		ifTrue: [
			newName do: [:c |
				c isAlphaNumeric
					ifFalse: [badName := true]].
			(self instVarNameCheck and: [newName first isUpperCase | (badName = true)])
				ifTrue: [
					MessageBox messageNote: '''' , newName , ''' is an invalid pane name.'.
					name contents: '']
				ifFalse: [
					thePane paneName: newName.
					self class partsSupportIsInstalled
						ifTrue: [
							self prototype wbPartEvents updatePaneNames: self prototype windows.
							self prototype wbPartMessages updatePaneNames: self prototype windows]]]
		ifFalse: [
			thePane paneName: nil.
			self class partsSupportIsInstalled
				ifTrue: [
					self prototype wbPartEvents updatePaneNames: self prototype windows.
					self prototype wbPartMessages updatePaneNames: self prototype windows]].
	self layoutFormChanged.! !

!WindowBuilder class methods !   
versionNumber: aFloat
	"Private - Set the window builder version."

	^self editorClass
			propertyValueAt: #VersionNumber
			category: self privateString
			put: aFloat! !

!WBUndoManager methods ! 
hasItems

    ^undoList size > 0! !

!WBTabOrderLayoutForm methods !  
totalTabCount

	^(self children select: [:widget | 
		widget isGrouper not & widget usesFocus]) size.! !

!WBPrimaryModelModule methods !
generateComment
        "Private - Generate the comment."

    super generateComment.
    self stream cr.! !

!WBModelDefinitionEditor methods !
clearDirty

    dirty := false.
    (self paneNamed: 'updateButton') disable! !

!WBEventManagerWindow methods ! 
preInitWindow

	super preInitWindow.
	handlerListBoxFramingBlock := handlerListBox framingBlock copy.
	methodTextEditFramingBlock := methodTextEdit framingBlock copy.

	widgetFilterBox update.
	widgetListBox ownerDrawFixed.
	eventListBox ownerDrawFixed.
	handlerListBox
		ownerDrawFixed;
		dragTargetForFormats: #('WBEventMessage') operations: #(#move).
	toField printSelector: #wbNameAndClass.
	self
		showButtons: true;
		handlerListBoxDragEnabled: true.

	methodTextEdit font: TextFont.
	widgetFilterBox font: ListFont.
	widgetListBox font: ListFont.
	eventListBox font: ListFont.
	handlerListBox font: ListFont.
! !

!WBAddInManager methods !
toggle: selectedItem

	(selectedItem beginsWith: '*')
		ifTrue: [self remove]
		ifFalse: [self install]! !

!BitEditor methods !
openOn: aBitmap
        "Open a BitEditor on aBitmap."
   self openOn: aBitmap clipRect: (0 @ 0 extent: aBitmap extent)! !

!WBCreateViewsModule methods !
createMethod
		"Private - Create the method."
	self objectHasMultipleViews
		ifTrue: [ super createMethod ].! !

!WBAttributeEditor methods !
openOn: aWin

    thePane := aWin.
    ^self open! !

!WindowBuilder class methods ! 
useGrid

    ^self editorClass
        propertyValueAt: #UseGrid
        category: self gridPropertyString.! !

!WBPoolManager methods !
defaultIndirectCodeGenerationStyle
	"Answer the code generation style.
		Answer #key to generate code that references the pool key directly.
		Answer #pool to generate code that is '(<pool> at: <key>)'.
		Answer #manager to generate code that is
			'(<valueClass> named: <key>)'  or  '(<managerClass> system at: <key>)'."

	^#manager! !

!WBManagedPNLSString methods ! 
pools
	"Answer a collection of pools the receiver can use."

	^self poolNames collect: [:sym | Smalltalk at: sym]! !

!WindowFrameObject methods !   
usesMenu

    ^self isDialog not! !

!PScrollBar methods !
attributeEditor

    ^WBScrollBarEditor! !

!WBFontSelectionWindow methods !  
poolManager

	^poolManager ifNil: [
		poolManager := self defaultPoolManager].! !

!WBEventManagerWindow methods !   
menuOptionDragDropHandlers

    "Callback for the menu item titled 'Drag drop handlers'.
     (Generated by WindowBuilder)"

    self handlerListBoxDragEnabled: self handlerListBoxDragEnabled not.! !

!FrameObject methods !
editor

	^editor! !

!WBScrollingPane methods !   
wmVScroll: wordInteger with: longInteger

        "This is the main entry point for scrolling frame communication with
    the ScrollingPane.  Subclassed from Subpane to avoid their turning everything
    into a percentage.  Using pixel absolutes is faster and more straightforward."

    | type |

    type := wordInteger lowWord.
    type = SbLineup         ifTrue: [self scrollVertical: self amountToScrollUp].
    type = SbLinedown     ifTrue: [self scrollVertical: self amountToScrollUp negated].
    type = SbPageup        ifTrue: [self scrollVertical: self amountToPageUp].
    type = SbPagedown    ifTrue: [self scrollVertical: self amountToPageUp negated].

    type = SbThumbposition ifTrue: [
        self updateVerticalSliderTo: wordInteger highWord.
        ^nil
    ].

    type = SbThumbtrack ifTrue: [
        self scrollVertical: topCorner y - wordInteger highWord.
        ^nil
    ].

    self updateVerticalSlider.

   ^nil! !

!WBAttributeWindow methods !  
hasChanged: aBoolean
		"Indicate that the receiver's contents has changed."
	hasChanged := aBoolean.! !

!WBScrapbookRetrieve methods !   
initWindow

    (self paneNamed: 'ok') disable.
    (self paneNamed: 'remove') disable.
    (self paneNamed: 'graphic') bringToTop.
    removedQuick := false.! !

!WBLayoutForm methods ! 
cloneWidgets: aCollection at: aPoint
	"Clone the widgets in <aCollection> and place them at <aPoint>"

	| newWidgets |
	[newWidgets := aCollection collect: [:aWidget |
		aWidget wbCloneWithParent: self shell]]
		on: Error do: [
			self wbHalt.
			newWidgets do: [:widget |
				widget isDestroyed ifFalse: [widget wbDestroyWidget]].
			self loadedWidgets: nil.
			^self].
	self
		placeNewWidgets: newWidgets
		at: aPoint;
		createUndoRedoForNewWidgets: newWidgets
			oldWidgets: #( )
			named: (newWidgets size == 1
				ifTrue: ['Duplicate Widget']
				ifFalse: ['Duplicate Widgets']);
		selections: newWidgets! !

!WBFramingEditor methods !
openOnFramer: framer
rects: rectList
parentRect: aParentRect
owner: owner

	self
		openOnFramer: framer
		rects: rectList
		parentRect: aParentRect.! !

!WBTreeNode methods !  
shiftLeft

    children do: [ :c |
        c shiftLeft.
    ].

    (currentString size < self indentString size) ifTrue: [ ^self ].

    currentString := currentString copyFrom: self indentString size + 1 to: currentString size.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBKeyAccel methods !
keyName

    ^text! !

!WBMenuItem methods !  
owner
        "Answer the owner of the menu item."
    ^owner! !

!WBCreateBitmap methods !   
bitmapHeight: anInteger

	heightField contents: anInteger asString.! !

!WBMenuEditor methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| actionButton cancelButton deleteItemButton 
	insertItemButton itemAttributesGroupbox linkButton 
	listEntryField mainView okButton selectorLabel separator 
	xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	dividerState := CheckBox new.
	hasAccelCheckBox := CheckBox new.
	isAlt := CheckBox new.
	isCtrl := CheckBox new.
	isShift := CheckBox new.
	keyShortCutEditor := WBComboBox new.
	menuItemsEditor := WBTreeListBox new.
	selectorEditor := WBEntryField new.
	shiftDownButton := Button new.
	shiftLeftButton := Button new.
	shiftRightButton := Button new.
	shiftUpButton := Button new.
	testItButton := Button new.
	
		"Temporary Variables"
	actionButton := Button new.
	cancelButton := Button new.
	deleteItemButton := Button new.
	insertItemButton := Button new.
	itemAttributesGroupbox := GroupBox new.
	linkButton := Button new.
	listEntryField := WBListEntryField new.
	okButton := Button new.
	selectorLabel := StaticText new.
	separator := StaticBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Menu Editor';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -153 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -63 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -153 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -63 * yDU).
	self addView: mainView.
	
	selectorLabel "StaticText"
		owner: self;
		setName: 'selectorLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 196 * xDU;
				topRatio: 0; topInset: 30 * yDU;
				rightRatio: 0; rightInset: -451/2 * xDU;
				bottomRatio: 0; bottomInset: -38 * yDU);
		contents: 'Selector:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: selectorLabel.
	
	listEntryField "WBListEntryField"
		owner: self;
		setName: 'listEntryField';
		when: #needsPopupMenu send: #popupNlsMenu: to: self withArgument: listEntryField;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 9/2 * xDU;
				topRatio: 0; topInset: 9/2 * yDU;
				rightRatio: 0; rightInset: -265/2 * xDU;
				bottomRatio: 0; bottomInset: -33/2 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: listEntryField;
		subPaneWithFocus: listEntryField.
	
	selectorEditor "WBEntryField"
		owner: self;
		setName: 'selectorEditor';
		when: #textChanged: send: #selectorEditorChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 227 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 0; rightInset: -299 * xDU;
				bottomRatio: 0; bottomInset: -40 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: selectorEditor.
	
	keyShortCutEditor "WBComboBox"
		owner: self;
		setName: 'keyShortCutEditor';
		when: #changed: send: #newAccelerator: to: self;
		when: #needsContents send: #loadKeyList: to: self withArgument: keyShortCutEditor;
		when: #textChanged: send: #newAccelerator: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 483/2 * xDU;
				topRatio: 0; topInset: 66 * yDU;
				rightRatio: 0; rightInset: -299 * xDU;
				bottomRatio: 0; bottomInset: -150 * yDU);
		dropDown;
		startGroup;
		font: SysFont.
	mainView addSubpane: keyShortCutEditor.
	
	insertItemButton "Button"
		owner: self;
		setName: 'insertItemButton';
		when: #clicked send: #insertItem to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 137 * xDU;
				topRatio: 0; topInset: 19 * yDU;
				rightRatio: 0; rightInset: -371/2 * xDU;
				bottomRatio: 0; bottomInset: -34 * yDU);
		defaultPushButton;
		contents: '&Insert';
		startGroup;
		font: SysFont.
	mainView addSubpane: insertItemButton.
	
	deleteItemButton "Button"
		owner: self;
		setName: 'deleteItemButton';
		when: #clicked send: #deleteItem to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 137 * xDU;
				topRatio: 0; topInset: 35 * yDU;
				rightRatio: 0; rightInset: -371/2 * xDU;
				bottomRatio: 0; bottomInset: -50 * yDU);
		contents: 'De&lete';
		startGroup;
		font: SysFont.
	mainView addSubpane: deleteItemButton.
	
	shiftUpButton "Button"
		owner: self;
		setName: 'shiftUpButton';
		when: #clicked send: #shiftUp to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 137 * xDU;
				topRatio: 0; topInset: 52 * yDU;
				rightRatio: 0; rightInset: -371/2 * xDU;
				bottomRatio: 0; bottomInset: -67 * yDU);
		contents: 'Shift &up';
		startGroup;
		font: SysFont.
	mainView addSubpane: shiftUpButton.
	
	shiftDownButton "Button"
		owner: self;
		setName: 'shiftDownButton';
		when: #clicked send: #shiftDown to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 137 * xDU;
				topRatio: 0; topInset: 68 * yDU;
				rightRatio: 0; rightInset: -371/2 * xDU;
				bottomRatio: 0; bottomInset: -83 * yDU);
		contents: 'Shift do&wn';
		startGroup;
		font: SysFont.
	mainView addSubpane: shiftDownButton.
	
	testItButton "Button"
		owner: self;
		setName: 'testItButton';
		when: #clicked send: #testMenu to: self;
		when: #needsPopupMenu send: #getTestItMenu: to: self withArgument: testItButton;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 137 * xDU;
				topRatio: 0; topInset: 85 * yDU;
				rightRatio: 0; rightInset: -371/2 * xDU;
				bottomRatio: 0; bottomInset: -201/2 * yDU);
		contents: '&Test menu';
		startGroup;
		font: SysFont.
	mainView addSubpane: testItButton.
	
	dividerState "CheckBox"
		owner: self;
		setName: 'dividerState';
		when: #clicked: send: #newDividerState: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 197 * xDU;
				topRatio: 0; topInset: 44 * yDU;
				rightRatio: 0; rightInset: -231 * xDU;
				bottomRatio: 0; bottomInset: -54 * yDU);
		contents: 'Di&vider';
		startGroup;
		font: SysFont.
	mainView addSubpane: dividerState.
	
	actionButton "Button"
		owner: self;
		setName: 'actionButton';
		when: #clicked send: #action to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 235 * xDU;
				topRatio: 0; topInset: 42 * yDU;
				rightRatio: 0; rightInset: -269 * xDU;
				bottomRatio: 0; bottomInset: -57 * yDU);
		contents: 'Action...';
		startGroup;
		font: SysFont.
	mainView addSubpane: actionButton.
	
	linkButton "Button"
		owner: self;
		setName: 'linkButton';
		when: #clicked send: #link to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 271 * xDU;
				topRatio: 0; topInset: 42 * yDU;
				rightRatio: 0; rightInset: -299 * xDU;
				bottomRatio: 0; bottomInset: -57 * yDU);
		contents: 'Li&nk...';
		startGroup;
		font: SysFont.
	mainView addSubpane: linkButton.
	
	hasAccelCheckBox "CheckBox"
		owner: self;
		setName: 'hasAccelCheckBox';
		when: #clicked: send: #accelCheckBoxChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 197 * xDU;
				topRatio: 0; topInset: 67 * yDU;
				rightRatio: 0; rightInset: -241 * xDU;
				bottomRatio: 0; bottomInset: -77 * yDU);
		contents: '&Key accel:';
		startGroup;
		font: SysFont.
	mainView addSubpane: hasAccelCheckBox.
	
	isShift "CheckBox"
		owner: self;
		setName: 'isShift';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 204 * xDU;
				topRatio: 0; topInset: 85 * yDU;
				rightRatio: 0; rightInset: -231 * xDU;
				bottomRatio: 0; bottomInset: -95 * yDU);
		contents: '&Shift';
		startGroup;
		font: SysFont.
	mainView addSubpane: isShift.
	
	isAlt "CheckBox"
		owner: self;
		setName: 'isAlt';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 237 * xDU;
				topRatio: 0; topInset: 85 * yDU;
				rightRatio: 0; rightInset: -509/2 * xDU;
				bottomRatio: 0; bottomInset: -95 * yDU);
		contents: '&Alt';
		startGroup;
		font: SysFont.
	mainView addSubpane: isAlt.
	
	isCtrl "CheckBox"
		owner: self;
		setName: 'isCtrl';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 260 * xDU;
				topRatio: 0; topInset: 85 * yDU;
				rightRatio: 0; rightInset: -300 * xDU;
				bottomRatio: 0; bottomInset: -95 * yDU);
		contents: 'Cont&rol';
		startGroup;
		font: SysFont.
	mainView addSubpane: isCtrl.
	
	shiftLeftButton "Button"
		owner: self;
		setName: 'shiftLeftButton';
		when: #clicked send: #shiftLeft to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 9/2 * xDU;
				topRatio: 0; topInset: 106 * yDU;
				rightRatio: 0; rightInset: -68 * xDU;
				bottomRatio: 0; bottomInset: -121 * yDU);
		contents: '<< &Demote item';
		startGroup;
		font: SysFont.
	mainView addSubpane: shiftLeftButton.
	
	shiftRightButton "Button"
		owner: self;
		setName: 'shiftRightButton';
		when: #clicked send: #shiftRight to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 139/2 * xDU;
				topRatio: 0; topInset: 106 * yDU;
				rightRatio: 0; rightInset: -133 * xDU;
				bottomRatio: 0; bottomInset: -121 * yDU);
		contents: '&Promote item >>';
		startGroup;
		font: SysFont.
	mainView addSubpane: shiftRightButton.
	
	okButton "Button"
		owner: self;
		setName: 'okButton';
		addClipsiblingsStyle;
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 192 * xDU;
				topRatio: 0; topInset: 106 * yDU;
				rightRatio: 0; rightInset: -485/2 * xDU;
				bottomRatio: 0; bottomInset: -121 * yDU);
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: okButton.
	
	cancelButton "Button"
		owner: self;
		setName: 'cancelButton';
		addClipsiblingsStyle;
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 251 * xDU;
				topRatio: 0; topInset: 106 * yDU;
				rightRatio: 0; rightInset: -302 * xDU;
				bottomRatio: 0; bottomInset: -121 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancelButton.
	
	menuItemsEditor "WBTreeListBox"
		owner: self;
		setName: 'menuItemsEditor';
		when: #clicked: send: #selectedItem: to: self;
		when: #preSelect: send: #commitSelection: to: self;
		when: #textChanged: send: #menuItemNameChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 9/2 * xDU;
				topRatio: 0; topInset: 19 * yDU;
				rightRatio: 0; rightInset: -265/2 * xDU;
				bottomRatio: 0; bottomInset: -201/2 * yDU);
		ownerDrawFixed;
		startGroup;
		font: SysFont.
	mainView addSubpane: menuItemsEditor.
	
	separator "StaticBox"
		owner: self;
		setName: 'separator';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 197 * xDU;
				topRatio: 0; topInset: 59 * yDU;
				rightRatio: 0; rightInset: -298 * xDU;
				bottomRatio: 0; bottomInset: -60 * yDU);
		blackRectangle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: separator.
	
	itemAttributesGroupbox "GroupBox"
		owner: self;
		setName: 'itemAttributesGroupbox';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 192 * xDU;
				topRatio: 0; topInset: 15 * yDU;
				rightRatio: 0; rightInset: -302 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		contents: 'Item attributes';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: itemAttributesGroupbox! !

!PStaticText methods ! 
usesFocus

    ^false! !

!PRadioButtonGroup methods !
suggestedSize

	^self children size <= 1
		ifTrue: [150@100]
		ifFalse: [
			(self children inject: 0 into: [:max :child |
				max max: (self font wbStringWidth: child contents)]) * self numColumns @ ((self children inject: 0 into: [:max :child |
				max max: child framingBlock bottomInset abs]) + 8)]! !

!PScrollBar methods ! 
storeSpecificsOn: aStream indentString: indentString

	self minimum = 0
		ifFalse: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'minimum: ', self minimum asString].
	self maximum = 100
		ifFalse: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'maximum: ', self maximum asString].
	self lineIncrement = 1
		ifFalse: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'lineIncrement: ', self lineIncrement asString].
	self pageIncrement = 24
		ifFalse: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'pageIncrement: ', self pageIncrement asString].! !

!DialogTopPane class methods !
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        removeKey: 'Maximize';
        removeKey: 'Minimize';
        removeKey: 'Sizable';
        add: (StylePropertyAccessor new
            name: 'SysModal';
            wbFrameStyle: (
                OperatingSystem isOS2
                    ifTrue: ['FcfSysmodal']
                    ifFalse: ['DsSysmodal']);
            pool: OperatingSystemConstants;
            wbAddStyle: #addSystemModalStyle);
        add: (StylePropertyAccessor new
            name: 'Modal';
            wbFrameStyle: (
                OperatingSystem isOS2
                    ifTrue: ['FcfBorder']
                    ifFalse: ['DsModalframe']);
            pool: OperatingSystemConstants;
            wbAddStyle: #addModalBorderStyle;
            wbAlwaysGenerate);
        add: (StylePropertyAccessor new
            name: 'AlignRelativeToScreen';
            wbFrameStyle: (
                OperatingSystem isOS2
                    ifTrue: ['FcfScreenalign']
                    ifFalse: ['DsAbsalign']);
            pool: OperatingSystemConstants;
            wbAddStyle: #alignRelativeToScreen);
        wbRemoveEventNamed: #validated ;
        wbRemoveEventNamed: #menuBarBuilt ;
        yourself! !

!WBTreeNode methods !   
addChild: aChild

    children addLast: aChild.
    aChild setParent: self.! !

!WBLookPolicy methods !  
scrollBarThumbHeight

    ^self class default scrollBarThumbHeight! !

!PRadioButton methods !
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	eventSymbol == #clicked: ifTrue: [^#('labelString')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBMultiToolPalette methods !  
at: key on: name selector: aSelector

    ^self at: key on: name put: nil selector: aSelector! !

!WBClassDefinition methods !
instVarNames: aCollection
        "Set a collection of instance variable names."
    instVarNames := aCollection! !

!WBLayoutForm methods !  
createUndoRedoForNewWidgets: newWidgets oldWidgets: oldWidgets
	widgetMap: widgetMap named: aString
    "Create the Undo/Redo blocks for adding new widgets."

    | childList sel theModel reverseWidgetMap |
    childList := self children copy.
    sel := self selections.
    theModel := self model.
    ^self undoManager
        add: aString
        undo:
            [self hideHandles.
            newWidgets isEmpty
                ifFalse: [
                    newWidgets do: [:aWidget |
                        [aWidget isDestroyed ifFalse: [aWidget wbDestroyWidget]] on: Error do: []]].
            oldWidgets isEmpty
                ifFalse: [
                    oldWidgets do: [:aWidget |
                        aWidget wbUnDestroyWidget].
                    childList reverseDo: [:child |
                        (self children includes: child)
                            ifTrue: [
                                child bringToFront.
                                self children
                                    remove: child;
                                    addFirst: child.
                                child wbSetDirty]].
                    oldWidgets do: [:aWidget |
                        aWidget manageChild]].
            self updateWidget.
			reverseWidgetMap isNil ifTrue: [
				reverseWidgetMap := IdentityDictionary new.
				widgetMap keysAndValuesDo: [:eachKey :eachValue |
					reverseWidgetMap at: eachValue put: eachKey]].
			self model prototype wbConvertEventTables: reverseWidgetMap.
            self isCurrentLayoutForm
                ifTrue: [
                    self selections: sel; drawOrderSymbols.
                    self model updateOutboardZOrderChange: self children]]
        redo:
            [self hideHandles.
            oldWidgets isEmpty
                ifFalse: [
                    oldWidgets do: [:aWidget |
                        [aWidget isDestroyed ifFalse: [aWidget wbDestroyWidget]] on: Error do: []]].
            newWidgets isEmpty
                ifFalse: [
                    newWidgets do: [:aWidget |
                        aWidget wbUnDestroyWidget].
                    childList reverseDo: [:child |
                        (self children includes: child)
                            ifTrue: [
                                child bringToFront.
                                self children
                                    remove: child;
                                    addFirst: child.
                                child wbSetDirty]].
                    newWidgets do: [:aWidget |
                        aWidget manageChild]].
            self model: theModel.
			self model prototype wbConvertEventTables: widgetMap.
            self updateWidget.
            self isCurrentLayoutForm
                ifTrue: [
                    self selections: newWidgets; drawOrderSymbols.
                    self model updateOutboardZOrderChange: self children]].! !

!WBEditClassDialog methods !  
anyFilter

    "Callback for the #clicked event triggered in the Button named 'anyFilter'.
     (Generated by WindowBuilder)"

    Notifier isAltKeyDown ifTrue: [alt := true].
    filter selectItem: self class defaultChoice.
    self class filter: self class defaultChoice.
    self updateListContents.! !

!WBTeamVCodePolicy methods ! 
versionFor: aCodeModule
        "Answer the version text."
    ^'Generated by WindowBuilder Pro - ', Date today asString,' ',Time now asString! !

!WindowBuilder methods !   
setStatusForToolBar: selector

    self setStatus: (self statusPaneHelp: selector).
    ! !

!ReadWriteStream methods !  
nextFourBytes
        "Private - WBPro Development.
            Answer the next four bytes from a byte array."
    | answer |
    #addedByOSI.
    answer := 0.
    #( 1 256 65536 16777216 ) do: [ : n |
        answer := answer + (self next * n)].
    ^answer! !

!WBOutboardAttributeWindow methods ! 
ok
    "Callback for the #clicked event in <Unnamed> [Button]
    (Generated by WindowBuilder Pro)"

    self
        apply;
        close.! !

!PropertyManager methods !
wbStore: anObject on: aCodeStream
	"Store the properties for anObject in aCodeStream."

	#addedByOSI.
	self keys asSortedCollection do: [:eachKey |
		(self associationAt: eachKey)
			wbStore: anObject on: aCodeStream].! !

!WBFontManagerWindow methods ! 
preInitMenus

	self categoryMenu removeItemDynamically: 'File out separately...'.
	categoryListBox getPopupMenu removeItemDynamically: 'File out separately...'.
	self optionMenu
		appendSeparator;
		appendItem: 'Portable file out format' selector: #menuOptionPortableFileOut acceleratorString: '';
		appendItem: 'Non portable file out format' selector: #menuOptionNonPortableFileOut acceleratorString: ''.
	super preInitMenus.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBHandle methods ! 
bounds
        ^self displayBox! !

!WBCreateBitmap class methods !
defaultBitmapWidth

	^32! !

!WBCreateViewModule methods !
layoutTemporaryExpressions

	self view isDialog ifFalse: [^super layoutTemporaryExpressions].
	^Array
		with: #xDU => '(SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2)'
		with: #yDU => '1'! !

!WBChoosePaneDialog methods !  
initWindow

    classListBox
            contents: (classList collect: [ :aClass |
                aClass name
            ]) asSortedCollection asOrderedCollection;
            selection: 1.! !

!WindowBuilder methods !  
updateQuickReferenceMenu

	| quickReferenceMenu index aString stream uCh |
	uCh := '\u' replaceEscapeCharacters first.
	quickReferenceMenu := self quickReferenceMenu.
	quickReferenceMenu removeAllItemsDynamically.
	index := quickReferenceMenu numberOfItems + 1.
	(self class scrapbook at: 'Quick Reference') keys asSortedCollection do: [:page |
		(page includes: uCh)
			ifFalse: [aString := page]
			ifTrue: [
				stream := WriteStream on: String new.
				page do: [:character |
					stream nextPut: character.
					character = uCh
						ifTrue: [stream nextPut: character]].
				aString := stream contents].
		quickReferenceMenu
			insertItemDynamically: aString
			selector: aString
			atIndex: index.
		index := index + 1].! !

!PLinkButton methods ! 
readSpecificsFrom: aWidget

	super readSpecificsFrom: aWidget.
	self link: (aWidget link isNil
		ifTrue: [nil]
		ifFalse: [aWidget link asString]).
	self type: aWidget type asString.! !

!PEntryField methods ! 
styles

    ^#(#defaultStyle #password #readOnly)! !

!WBLinkEditor class methods !   
descriptions: aDictionary
    " WBLinkEditor descriptions: nil "
    Descriptions := aDictionary! !

!Object methods !
wbRealClass

	^self wbRealWidget class! !

!WBMultiToolPalette methods !  
pages
    ^pages! !

!WBCodeStream methods !   
nextPutPool: aPoolName atKey: aKey
	"Store the reference to the pool variable."

	self
		nextPut: $(;
		nextPutAll: aPoolName;
		space;
		nextPutAll: #at: ;
		space;
		nextPutAll: aKey storeString;
		nextPut: $).! !

!WBEventManagerWindow methods !  
handlerSelected
    "Answer the currently selected handler if exactly one is selected,
        else answer nil."

	^self handlerSelections size = 1
        ifTrue: [self handlerSelections first]
        ifFalse: [nil]! !

!WBEventManagerWindow methods ! 
menuHandlerShowAll

    "Callback for the menu item titled 'Show All'.
     (Generated by WindowBuilder)"

    self handlerShowAll: self handlerShowAll not.! !

!WBGeometryManager methods !  
sizeByPixelUp
    "Size the selected widgets up one pixel"

    | selections |
    (selections := self selections copy) isEmpty
        ifTrue: [^self owner setWindowSize: (self shell width @ (self shell height - 1))].
    (self undoManager
        add: 'Size Pixel Up'
        undo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    configureWidget: aWidget x
                    y: aWidget y
                    width: aWidget width
                    height: aWidget height + 1
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections]
        redo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    configureWidget: aWidget x
                    y: aWidget y
                    width: aWidget width
                    height: (aWidget height - 1 max: 0)
                    borderWidth: aWidget borderWidth;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections])
        redoAction value.
    self updateWidget.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCompositePaneTester class methods !   
isWBInternalClass

    ^true! !

!PStaticGraphic methods !
usesMenu

    ^false! !

!WindowFrameObject class methods !   
newForClass: class

	(class inheritsFrom: CompositePane)
		ifTrue: [^CompositeFrameObject new].
	^self new! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutForm methods ! 
drawOrderSymbolsFor: aCollectionOfWidgets
    "Draw the order symbols for a <aCollectionOfWidgets>"

    | aPen center indexString font fontHeight radius backColor |
    self showOrder ifFalse: [^self].
    aPen := self pen.
    font :=  SysFont.
    fontHeight := font height.
    radius := (((font stringWidth: (self children size asString)) // 2) max: fontHeight // 2) + 3.
    (aCollectionOfWidgets reject: [:widget |
        widget isDestroyed]) do: [:widget |
        indexString := (widget parent children indexOf: widget) asString.
        backColor := (widget tabPosition notNil
            ifTrue: [Color red]
            ifFalse: [Color white]).
        aPen
            backColor: backColor;
            place: (center := widget hitRect center);
            circleFilled: radius;
            foreColor: Color black;
            place: center;
            circle: radius;
            setTextAlign: WBDisplayContext defaultTextAlign;
            centerWinText: indexString at: center;
            backColor: Color white].! !

!WBLayoutForm methods ! 
doDragDropAt: aPoint button: buttonIndex
        "Private - start a drag drop transfer with the receiver as the source."
    | sessionClass result |
    (sessionClass := self dragSessionClass ) isNil
        ifTrue: [sessionClass := DragDropSession defaultClass].
    (sessionClass symbol == #PARTSCatalogDragSession) 
        ifFalse: [^super doDragDropAt: aPoint button: buttonIndex ].
    self propertyAt: #wbDragSourceLocation put: aPoint.
    result := (sessionClass source: self) doDragDropAt: aPoint.
    self dragSourceSelection: nil.
    ^result! !

!WBModelObjectEditor methods ! 
updateSend: selectedObject

    | selector current |
    selectedObject class eventsTriggered isEmpty
        ifTrue: [send contents: ''].
    send setPopupMenu: nil.
    (current := self currentEvent) ifNil: [^self].
    selector := selectedObject eventHandlerSelectorAt: current.
    send
        contents: (selector isString
            ifTrue: [selector]
            ifFalse: ['  *****  ']).! !

!PListBox methods !  
mutateSpecificsFrom: aPane
	| list |
	((list := aPane contents) notNil and: [list isArray])
		ifTrue: [self contents: list deepCopy].! !

!ButtonListBox methods !   
wbContents
    "Answer the real contents of the list"
    #addedByOSI.
    ^(self contents ifNil: [^#()]) collect: [:item | item object].! !

!WBModelInstVar methods !  
okToGenerateBasicSet

    ^self okToGenerateMethod: self methodNameForBasicSet! !

!WindowBuilder class methods ! 
removeExtra: extraName

	self extras 
		removeKey: extraName 
		ifAbsent: [nil]! !

!WBLookPolicyWin31 methods !
drawSystemMenuWith: aPen at: aRect

    | innerRect center |
    center := ((aRect top + aRect bottom) / 2) ceiling.
    center := aRect center x @ center.
    aPen
        fill: aRect color: Color gray;
        foreColor: Color black;
        drawRectangle: aRect;
        fill: ((innerRect := (center leftAndUp: 7@2) rightBottom: (center rightAndDown: 6@1))
            rightAndDown: 1) color: Color darkGray;
        fill: innerRect color: Color white;
        drawRectangle: innerRect! !

!Window methods !  
wbFullCopyReal: aDictionary
	"Answer a full copy of the receiver."

	#addedByOSI.
	^self wbFullCopyProperties: aDictionary! !

!WBInterfaceObject methods ! 
setColorsUsing: colorElements

    self usesForeColor
        ifTrue: [self foreColor: (colorElements at: 'Fore Color' ifAbsent: [self defaultForeColor])].
    self usesBackColor
        ifTrue: [self backColor: (colorElements at: 'Back Color' ifAbsent: [self defaultBackColor])].! !

!WBInterfaceObject methods !  
manageChild

	self updateWidget.! !

!WBAttributeWindow class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!PropertyAccessor methods !  
wbPoolKey: aString

	#addedByOSI.
	self propertyAt: #wbPoolKey put: aString.
	^aString! !

!WBTabOrderLayoutForm methods !  
keyMove: direction x: dx y: dy
	"Do Nothing"! !

!WBLookPolicyOS2 methods !
drawRadioButton: aRadioButton with: aPen clipRect: clipRect

    | aPoint boundingBox |
    self
        drawToggle: aRadioButton
        with: aPen
        clipRect: clipRect.
    aPoint := aRadioButton rect left @ (aRadioButton rect center y up: self iconExtent y // 2 + 1).
    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class radioBitmap
                    from: (0 @ 0 extent: self class radioBitmap extent)  "(0@26 extent: 13@13)"
                    to: (aPoint extentFromLeftTop: self class radioBitmap extent)]
        ifFalse: [
            boundingBox := aPoint extent: 14@14.
            aPen
                fill: boundingBox color: Color gray;
                foreColor: Color darkGray;
                place: boundingBox center;
                partialArc: boundingBox width // 2 minor: boundingBox height // 2 angles: -30@-220;
                foreColor: Color darkGray;
                place: boundingBox center;
                partialArc: boundingBox width // 2 minor: boundingBox height // 2 angles: -30@140.
            boundingBox := boundingBox insetBy: 1.
            aPen
                foreColor: Color white;
                place: boundingBox center;
                partialArc: boundingBox width // 2 minor: boundingBox height // 2 angles: -30@-220;
                foreColor: Color darkGray;
                place: boundingBox center;
                partialArc: boundingBox width // 2 minor: boundingBox height // 2 angles: -30@140.
            aPen
                foreColor: Color white;
                place: boundingBox center;
                partialArc: boundingBox width // 2 - 1 minor: boundingBox height // 2 - 1 angles: -50@-180;
                foreColor: Color darkGray;
                place: boundingBox center;
                partialArc: boundingBox width // 2 - 1 minor: boundingBox height // 2 - 1 angles: -20@100.]! !

!WBLookPolicyOS2 methods !  
drawFrameBorder: aFrameObject with: aPen in: aRect

    (aFrameObject hasTitleBar or: [aFrameObject style includes: #sizable])
        ifFalse: [
            ^aPen
                foreColor: Color black;
                drawRectangle: aRect].
    aPen
        foreColor: Color white;
        wbLineFrom: aRect leftTop to: (aRect rightTop left: 1);
        wbLineFrom: aRect leftTop to: (aRect leftBottom up: 1);
        foreColor: Color darkGray;
        wbLineFrom: (aRect leftBottom up: 1) to: (aRect rightBottom up: 1);
        wbLineFrom: (aRect rightTop left: 1) to: (aRect rightBottom leftAndUp: 1);
        foreColor: Color gray;
        wbLineFrom: (aRect leftTop rightAndDown: 1) to: (aRect rightTop leftAndDown: 1);
        wbLineFrom: (aRect leftTop rightAndDown: 1) to: (aRect leftBottom rightAndUp: 1);
        wbLineFrom: (aRect leftBottom rightAndUp: 1@2) to: (aRect rightBottom leftAndUp: 1@2);
        wbLineFrom: (aRect rightTop leftAndDown: 2@1) to: (aRect rightBottom leftAndUp: 2);
        wbLineFrom: (aRect leftTop rightAndDown: 2) to: (aRect rightTop leftAndDown: 2);
        wbLineFrom: (aRect leftTop rightAndDown: 2) to: (aRect leftBottom rightAndUp: 2);
        wbLineFrom: (aRect leftBottom rightAndUp: 2@3) to: (aRect rightBottom leftAndUp: 2@3);
        wbLineFrom: (aRect rightTop leftAndDown: 3@2) to: (aRect rightBottom leftAndUp: 3);
        foreColor: Color white;
        wbLineFrom: (aRect leftBottom rightAndUp: 3@4) to: (aRect rightBottom leftAndUp: 3@4);
        wbLineFrom: (aRect rightTop leftAndDown: 4@3) to: (aRect rightBottom leftAndUp: 4);
        foreColor: Color darkGray;
        wbLineFrom: (aRect leftTop rightAndDown: 3) to: (aRect rightTop leftAndDown: 3);
        wbLineFrom: (aRect leftTop rightAndDown: 3) to: (aRect leftBottom rightAndUp: 3)
! !

!PStaticBox methods !
displayWith: aPen clipRect: clipRects

	| color |
	color := style first = $w 
		ifTrue: [Color windowBackground]
		ifFalse: [
			style first = $b 
				ifTrue: [Color windowBorder]
				ifFalse: [Color getSystemColor: SystemColorDesktop]].
	(style at: style size - 1) = $m 
		ifTrue: [
			aPen
				foreColor: color;
				drawRectangle: rect]
		ifFalse: [aPen fill: rect color: color].! !

!WBLookPolicy methods ! 
scrollBarHeight

    ^self class default scrollBarHeight! !

!WindowBuilder methods ! 
commentForTopPane: aTopPane event: eventSymbol

	^'Callback for the #' , eventSymbol asString , ' event in the ' , (aTopPane paneName isNil
		ifTrue: ['unnamed TopPane']
		ifFalse: ['TopPane ' , aTopPane paneName asQuotedString]) , '.'.! !

!WBTabOrderLayoutForm methods !
dragWidget: aWidget
    "Set the dragWidget."

    dragWidget := aWidget
! !

!WBLayoutFrameEditor methods !
update
	"The receiver has been activated and the
		owner has changed, so update the receiver's content's
		to reflect the change in the owner."

	super update.
	self 
		updateLabel;
		updateContents; 
		updateFramingBlocks; 
		updateExample.! !

!WBLayoutWizard methods !   
setDefaultStandardMenus

    self class defaultMenus: (self paneNamed: 'standardMenusList') value.
    self loadStandardMenus.! !

!WBActionEditor methods ! 
updateList
    | listPane |
    self loadList: (listPane := self paneNamed: 'list').
    action isNil ifFalse: [
        listPane selectItem: action.
        self select: action
    ].
    (self paneNamed: 'add') disable! !

!WBCreateViewModule methods !   
generatePaneOwner: aPane
		"Private - Generate the pane owner definition."
	self stream
		cr;
		nextPutAll: #owner: ;
		space;
		nextPutAll: (self varNameFor: #owner);
		endMessage.! !

!WBCodePolicy methods !
basicLogMethodFor: aCodeModule
		"Private - Log the specified method source."
	self implementedBySubclass.! !

!WBPMenuItem methods ! 
realSelector

    selector isArray ifTrue: [  ^selector ].
    selector isMessage ifTrue: [ ^selector ].
    ^selector isNil ifTrue: [ nil ] ifFalse: [ selector asSymbol ]! !

!WBGeometryManager methods !
moveByPixelRight
    "Move the selected widgets right one pixel"

    | selections |
    (selections := self selections copy) isEmpty
        ifTrue: [^self owner setWindowPosition: (self shell x + 1 @ self shell y)].
    (self undoManager
        add: 'Move Pixel Right'
        undo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    moveWidget: (aWidget x left: 1)
                    y: aWidget y;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections]
        redo:
            [self hideHandles.
            selections do: [:aWidget |
                aWidget
                    moveWidget: (aWidget x right: 1)
                    y: aWidget y;
                    wbUpdateConstraints].
            self layoutForm updateWidgetAttachments: selections])
        redoAction value.
    self updateWidget.! !

!WindowBuilder methods !  
propertyAt: aSymbol

	^self class propertyAt: aSymbol! !

!WindowBuilder class methods !  
licensed
	"Answer whether window builder is licensed."

	^self editorClass 
		propertyValueAt: #Licensed 
		category: self privateString.! !

!WBModelDefinitionEditor methods !   
selectModelType

	self
		loadModels;
		disableFields;
		disableModelFields;
		clearDirty.! !

!WBInterfaceObject class methods !  
templates: anIdentityDictionary

	^Templates := anIdentityDictionary.! !

!WindowBuilder class methods !  
togglePropertyValueAt: aSymbol

    ^self
        propertyValueAt: aSymbol
        put: (self propertyValueAt: aSymbol) not.! !

!PScrollBar methods !  
mutationExceptions

    ^#(#CPValuator #CPGauge #CPSlider)! !

!PWBToolBar methods !  
useSystem: aBoolean

    useSystem := aBoolean! !

!WBInterfaceObject methods !   
prototype

	^self parent editor prototype! !

!ApplicationCoordinator class methods ! 
wbGenerateInstVars

	^true! !

!PEntryFieldGroup methods !
backColor

    ^backColor.! !

!WBInterfaceObject methods !   
storeSpecificsOn: aStream indentString: aString
    "Subpanes subclass this to write out specific information about themselves
     as source code."! !

!WBCreateMenuModule methods !
defaultComment
		"Answer the default comment string."
	^self defaultLayoutComment! !

!WBCodeStream methods ! 
maxLineSize: anIntegerOrNil during: aBlock
		"Set the maximum number of characters per line.
			Nil indicates no maximum."
	| oldMax answer |
	oldMax := self maxLineSize.
	self maxLineSize: anIntegerOrNil.
	answer := aBlock value.
	self maxLineSize: oldMax.
	^answer! !

!WBPoolManagerWindow methods !   
menuOptionShowPath

    "Callback for the menu item titled 'Show path'.
     (Generated by WindowBuilder)"

	self isPathVisible
		ifTrue: [self hidePath]
		ifFalse: [self showPath].! !

!WBLayoutForm methods !
clipboard

    ^self model clipboard! !

!WindowBuilder methods ! 
updateOutboardNLSEnabled: aBoolean
	"Update all of the outboard windows the NLS status changes"

	self outboards do: [:window |
		window nlsEnabled: aBoolean].! !

!WBAbstractAddInModule class methods !  
cleanUpOnUnload
    "Clean up when unloading"! !

!PCompositePane methods !
initialFraming

    ^initialFraming! !

!WBInterfaceObject methods !  
copySpecificsTo: aCopy! !

!PStatusPane methods !   
statusBoxes: aCollection

    statusBoxes := aCollection! !

!WBCallOutModule methods !   
initTemporaries
	"Private - Initialize the variable names."

	| name |
	self initLayoutTemporaries.
	((self varNameFor: self object ifAbsent: [nil]) isNil
		or: [self targetClass isMetaClass])
		ifTrue: [
			name := self constructVarNameForPane: self object.
			self temporaries add: name.
			self varNameFor: self object put: name].
	self initFontDefinitions.! !

!PGroupbox methods !
usesFocus

	^false! !

!WBTeamVCodePolicy methods !   
basicRemoveSelector: aSelector fromClass: aClass
		"Remove aSelector from the specified class."
	aClass removeSelector: aSelector.! !

!WBCodeStream methods !
nextPutColor: aColor
		"Append the color definition to the receiver."
	aColor storeColorOn: self.! !

!CompositeFrameObject methods ! 
usesTitle

    ^false! !

!WBActionEditor methods !   
ok

    | answer |
    changed ifTrue: [
        answer := MessageBox yesNoCancelTitled: 'Please Confirm' text: 'Save action?'.
        answer isNil ifTrue: [
            ^nil
        ] ifFalse: [ answer == #yes ifTrue: [
            self add.
            changed := false.
        ]].
    ].
    thePane action: (self paneNamed: 'list') selectedItem.
    thePane isWBInterfaceObject ifTrue: [
        thePane contents: thePane action
    ].

    self close! !

!WBTabPosition methods ! 
groupPosition: anObject

    groupPosition := anObject! !

!WBCreatePowerMenuModule methods ! 
defaultTargetName
		"Answer the default target name."
	^'wbTarget'! !

!WBGeometryManager methods !   
selectAllInHierarchy

    self layoutForm selectAllInHierarchy! !

!PWBHorizontalScrollBar methods !  
winClassStyle

    ^SbsHorz! !

!WBCreateViewModule methods ! 
generateCallOutFor: aPane
        "Generate the code..."

	self 
		generateCallOutFor: aPane 
		instVar: false! !

!WBPoolManagerWindow methods !  
poolListNeedsContents: aPane

    "Callback for the #needsContents event triggered in the MultipleSelectListBox named 'poolListBox'.
     (Generated by WindowBuilder)"

	| oldSelection newContents newSelection |
	oldSelection := self selectedPools.
	newContents := self poolManager pools
		asSortedCollection: [:a :b | a poolName < b poolName].
	newSelection := oldSelection select: [:each | newContents includes: each].
	aPane contents: newContents.
	self selectedPools: newSelection.! !

!WBModelObjectEditor methods ! 
children

    ^self owner children! !

!WBEventMessage methods !  
asActionSequence

	^self asMessage asActionSequence! !

!WindowBuilder class methods !
serialNumber: aString
	"Set the window builder serial number."

	self editorClass
		propertyValueAt: #SerialNumber
		category: self userPropertyString
		put: aString.! !

!WBScrapbookRetrieve class methods !   
isWBInternalClass

    ^true! !

!WBInterfaceObject methods ! 
wbRealWidget: aWidget

	realWidget = aWidget
		ifFalse: [
			realWidget := aWidget.
			realWidget wbWrapper: self].! !

!WBLookPolicy methods !
menuBarHeight

    ^19! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutForm methods !   
setupDragOutline
    "Setup the dragging outline state."

    self bandRect: self selectedRect.
    self cursorOffset last x: self cursorOffset last x.
    self cursorOffset last y: self cursorOffset last y.
    self releaseState: #buttonReleaseMovingOutline:.
    self motionState: #button1MotionMovingOutline:.
    self setCursor: #move.! !

!WBTreeNode methods !   
addChild: aChild afterNode: aNode

    children add: aChild after: aNode.
    aChild setParent: self.! !

!Object methods !  
styles

    ^nil! !

!PFormattedEntryField methods !  
styles

    ^#(#defaultStyle #alpha #date #currency #float #integer #phoneNumber #positiveInteger).! !

!WBUndoAction methods !   
label: aString

    label := aString! !

!PStaticBox methods !
usesFocus

    ^false! !

!WBDevelopmentWindow methods !  
postEditUpdate

	self currentWidget changesTitle
		ifTrue: [self updateText: self currentWidget].
! !

!WindowBuilder class methods !   
extras

	Extras isNil
		ifTrue: [Extras := Dictionary new].
	^Extras! !

!WBPrimaryModelOpenOnModule methods !  
wrapComment
    "Answer true if the comment should be wrapped."

    ^false! !

!WBLayoutForm methods !  
currentNib: aSymbol
    "Set the value of currentNib."

    currentNib := aSymbol.! !

!WBLayoutWizard methods ! 
loadModels

    modelList contents: self modelClasses! !

!WBPowerViewAddInModule class methods ! 
comment

	^'WARNING!!  Experimental only!!
WindowBuilder will generate
#createViewsFor:owner: methods. The
first argument is the ViewManager to add
the views to. The second argument is the
owner of the subpanes within the views
(e.g., the target of the #when:perform:
messages).'! !

!WBFontManagerWindow methods ! 
updateOptionMenu

	super updateOptionMenu.
	self poolManager generatePortableFontCode
		ifTrue: [
			self optionMenu
				checkItem: #menuOptionPortableFileOut;
				uncheckItem: #menuOptionNonPortableFileOut]
		ifFalse: [
			self optionMenu
				uncheckItem: #menuOptionPortableFileOut;
				checkItem: #menuOptionNonPortableFileOut].! !

!Object methods !
setName: name

    self propertyAt: #name put: name.! !

!WBModelDefinitionEditor methods !   
codeGenerator

    ^self owner isNil
        ifTrue: [WBCodeGenerator new]
        ifFalse: [self owner codeGenerator].! !

!Font methods ! 
logicalBytes
        "Private - WBPro Development."
    | byteStream |
    #addedByOSI.
    byteStream := WriteStream on: String new.
    byteStream nextPutAll: '#( '.
    self logicalFont contents do: [ :b |
        byteStream nextPutAll: b asString, ' '.
    ].
    byteStream nextPut: $).
    ^byteStream contents! !

!WBPrototype methods !   
switchToWindow: window

    self layoutForm notNil ifTrue: [
        self layoutForm clearSelections].
    self layoutForm notNil ifTrue: [
        self scrollingForm hideWindow.
        self scrollingForm scrollToOrigin].
    shell := window.
    self owner notNil ifTrue: [
       self owner prototype: self].
	self scrollingForm notNil ifTrue: [
        self scrollingForm setScrollRanges].
    self children do: [:widget |
        widget reframe: shell frameContentRect].
    self scrollingForm notNil ifTrue: [
        self scrollingForm showWindow].
    self layoutForm notNil ifTrue: [
        self layoutForm
            triggerEvent: #selectionChanged:
            with: self layoutForm selections].! !

!WBFontSelectionWindow methods !
fontDrawItem: drawIndex pane: aPane

	"Callback for the #drawItem: event in fontList [ListBox].
		(Generated by WindowBuilder Pro)"

	| box aWBDisplayContext anAssociation |
    anAssociation := aPane contents at: drawIndex.
	aWBDisplayContext := aPane wbDisplayContext.
	box := aWBDisplayContext splitCellLeftRatio: 2/5.
	anAssociation key asString wbDisplayWith: aWBDisplayContext.
	aWBDisplayContext cellBox: box.
	(anAssociation value isFont
		ifTrue: [anAssociation value wbFontDescription]
		ifFalse: [anAssociation value asString]
	) wbDisplayWith: aWBDisplayContext.! !

!WBModelDefinitionEditor methods ! 
up

    | selectedItem index |
    selectedItem := attributes selectedItem.
    index := attributes contents indexOf: selectedItem.
    attributes contents
        remove: selectedItem;
        add: selectedItem beforeIndex: index - 1.
    attributes
        contents: attributes contents;
        selectItem: selectedItem.
    self
        setDirty;
        updateUpDownButtons.

! !

!WBCodeStream methods !
nextPutProperty: aWBProperty oldEventTable: anEventTable for: anObject
	"Store the property in the receiver."

	self nextPutOldEventTable: anEventTable for: anObject.! !

!WBAbstractCodeModule methods !   
generateCopyright
        "Private - Generate the comment."
	self stream wrapDuring: [
		self stream indentBy: 1 during: [
			self generateCopyrightBody]].! !

!WBPrototype methods !  
initializeModelObjects

    self modelObjects do: [:modelObject |
        (self object: modelObject isInstVarIn: self targetObject)
            ifTrue: [modelObject isInstVar: true]].! !

!WBPrototype methods !  
wbPartEvents: aWBPartEventsList
		"Set the part events list for the receiver."
	self propertyAt: #WBPartEvents put: aWBPartEventsList.! !

!PropertyAccessor methods !
wbAddStyleAction

	#addedByOSI.
	^(self propertyAt: #wbAddStyleAction) ifNil: [self wbDefaultAddStyleAction]! !

!WindowBuilder class methods !  
showZOrder

    ^self editorClass
        propertyValueAt: #ShowZOrder
        category: self editorPropertyString! !

!WindowBuilder methods ! 
menuNlsAutosize

    self class togglePropertyValueAt: #NlsAutosize.
	self updateNlsMenu.! !

!WBMenuItem methods !  
uncheck
        "Uncheck the receiver."
	self attribute: (self attribute bitAnd: (MfChecked bitXor: 16rFFFF)) | MfUnchecked.
	self update.! !

!PCompositePane methods ! 
realClass: aClass

	self realClass: aClass updateExtent: true.! !

!WBPoolEditorCompositePane methods !   
preInitWindow

	self children do: [:each | each font: SysFont].! !

!WBDevelopmentWindow methods !
updateColorButton: palette for: currentWidget
	"Update the Color button"

	(currentWidget notNil and: [currentWidget usesColor])
		ifTrue: [palette enableItem: #setColor]
		ifFalse: [palette disableItem: #setColor].! !

!WBVersionCodeModule methods ! 
wrapComment
	"Answer true if the comment should be wrapped."

	^false! !

!WindowFrameObject methods !   
postEdit: aWindowBuilder

    aWindowBuilder
        setWindowSizePrim: self extent
        shifted: false! !

!WBDevelopmentWindow methods !   
setMenu
	"Set the menu attributes for the current widget"

	| currentWidget menu |
	currentWidget := self currentWidget.
	(menu := (currentWidget menuEditor openOn: currentWidget menu) result) notNil
		ifTrue: [
			menu hasChildren not
				ifTrue: [currentWidget menu: nil]
				ifFalse: [currentWidget menu: menu].
			self redisplaySelection].! !

!PWBHorizontalScrollBar methods ! 
storeSpecificsOn: aStream indentString: indentString

	super storeSpecificsOn: aStream indentString: indentString.
	aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'horizontal'.! !

!PEntryField methods !  
backColor

    ^backColor.! !

!WBMenuEditor methods !
keyList

    ^#(
        'Accept'
        'Add'
        'Back'
        'Cancel'
        'Capital'
        'Clear'
        'Control'
        'Convert'
        'Decimal'
        'Delete'
        'Divide'
        'Down'
        'End'
        'Escape'
        'Execute'
        'F1'
        'F10'
        'F11'
        'F12'
        'F13'
        'F14'
        'F15'
        'F16'
        'F2'
        'F3'
        'F4'
        'F5'
        'F6'
        'F7'
        'F8'
        'F9'
        'Help'
        'Hiragana'
        'Home'
        'Insert'
        'Kana'
        'Kanji'
        'Lbutton'
        'Left'
        'Mbutton'
        'Menu'
        'Modechange'
        'Multiply'
        'Next'
        'Nonconvert'
        'Numlock'
        'Numpad0'
        'Numpad1'
        'Numpad2'
        'Numpad3'
        'Numpad4'
        'Numpad5'
        'Numpad6'
        'Numpad7'
        'Numpad8'
        'Numpad9'
        'Pause'
        'Print'
        'Prior'
        'Rbutton'
        'Return'
        'Right'
        'Romaji'
        'Select'
        'Separator'
        'Shift'
        'Snapshot'
        'Space'
        'Subtract'
        'Tab'
        'Up'
        'Zenkaku'
    )
! !

!WBTeamVCodePolicy class methods ! 
teamInterface: aTeamInterface
		"Set the Team/V interface."
		"WBTeamVCodePolicy teamInterface: nil."
		"WBTeamVCodePolicy teamInterface: WBTeamVCodePolicy defaultTeamInterface."
	WBTeamVInterface := aTeamInterface.! !

!WBEventDescription methods !   
arguments: aCollection

	self value: aCollection.! !

!WindowBuilder methods !
menuToolsInspectSystemValueConstants

    SystemValueConstants inspect! !

!StaticPane class methods !
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbRemoveEventNamed: #tabbed ;
        yourself! !

!ViewManager methods !  
isWBModel

	^false! !

!WBPropertyDescriptor methods !
default
    "Answer the value of default."

    ^default! !

!WBLayoutForm methods ! 
loadedWidgets
    "Answer the value of loadedWidgets."

    ^loadedWidgets! !

!WBAttributeWindow methods !  
shellName
		"Answer the shell name."
	^self shell paneName! !

!PDrawnButton methods !
defaultBackColor

    ^Color buttonFace! !

!StylePropertyAccessor methods !  
wbDefaultRemoveStyleAction

	#addedByOSI.
	^#removeStyle:! !

!WBAttributeEditor methods !   
result

    ^thePane! !

!PLinkButton methods !   
importantEvents

    ^super importantEvents
        remove: #clicked;
        yourself! !

!WBLayoutWizard methods !
loadAttributes

    | aClass classes instVars allInstVarNames get set
     accessors initValue isLazy attribute |
    aClass := (sourceInstance ifNil: [^attributesList contents: #()]) class.
    classes := aClass allSuperclasses
        addFirst: aClass;
        yourself.
    instVars := OrderedCollection new.
    allInstVarNames := aClass allInstVarNames.
    classes do: [:cls |
        instVars addAll: (cls instVarNames collect: [:str |
            set := (str, ':') asSymbol.
            get := str asSymbol.
            accessors := cls canUnderstand: set.
            isLazy := (sourceInstance instVarAt: (allInstVarNames indexOf: str)) isNil & accessors.
            initValue := accessors
                ifTrue: [[sourceInstance perform: get] on: Error do: [nil]]
                ifFalse: [nil].
            (attribute := WBModelInstVar new)
                name: str;
                myClass: cls;
                hasAccessors: accessors;
                initialized: initValue notNil;
                lazy: initValue notNil & isLazy;
                valueClass: initValue class;
                initializeValue: (self setInitValue: initValue);
                hasEvent: (sourceInstance canTriggerEvent: (str, 'Changed:') asSymbol);
                propertyAt: #inLayout put: accessors;
                propertyAt: #widgetType put: (self defaultWidgetTypeFor: attribute);
                propertyAt: #instVar put: false;
                propertyAt: #modelUpdatesWidget put: attribute hasEvent;
                propertyAt: #modelInitializesWidget put: attribute hasEvent;
                propertyAt: #widgetUpdatesModel put: accessors;
                yourself])].
    attributesList     contents: instVars.
    instVars do: [:instVar |
        instVar hasAccessors
            ifTrue: [attributesList checkIndex: (instVars indexOf: instVar)]
            ifFalse: [attributesList uncheckIndex: (instVars indexOf: instVar)]].! !

!WBPrototype methods !  
targetInstVars

	| answer |
	answer := OrderedCollection new.
	self targetObject wbInstVarMap associationsDo: [:each | answer add: each].
	^answer! !

!PRadioButtonGroup methods !
displayWith: aPen clipRect: inRect
	| region aRect clipRect |
	aRect := inRect.
	aPen fill: self rect color: self backColor.
	self style == #verticalScrollBar 
		ifTrue: [
			self displayWithLeftScrollBar: aPen.
			aRect := inRect insetBy: 1.
			aRect := Rectangle
				leftTop: aRect leftTop
				extent: ((aRect extent x - self lookPolicy scrollBarWidth + 1) @ (aRect extent y)).
			aRect := aRect intersect: inRect].
	self children do: [:child |
		child reframe: self rect.
		(aRect intersects: child rect) 
			ifTrue: [
				region := aPen setClipRect: (clipRect := aRect intersect: child rect).
				child resetPen: aPen.
				child displayWith: aPen clipRect: clipRect.
				aPen destroyRegion: region]].! !

!WBLayoutWizard class methods ! 
menuDefinitions

    ^MenuDefinitions ifNil: [MenuDefinitions := self initializeMenuDefinitions]! !

!WBEventManagerWindow methods !  
handlerListBoxNeedsContents: aPane

	"Callback for the #needsContents event triggered in the MultipleSelectListBox named 'handlerListBox'.
	 (Generated by WindowBuilder)"

	| oldSelection newContents |
	oldSelection := aPane selectedItems.
	newContents := OrderedCollection new.
	(self handlerShowAll ifTrue: [self widgetList] ifFalse: [self widgetSelections]) do: [:eachWidget |
		(self handlerShowAll ifTrue: [self allEvents] ifFalse: [self eventSelections]) do: [:eachEvent |
			(eachWidget actionListForEvent: eachEvent) do: [:eachMsg |
				newContents add: (
					eachMsg asEventMessage
						source: eachWidget;
						event: eachEvent;
					yourself)]]].
	aPane
		contents: newContents;
		selection: oldSelection;
		dragSource: self handlerListBoxDragTargetEnabled;
		dragTarget: self handlerListBoxDragTargetEnabled.
	newContents notEmpty ifTrue: [
		aPane selections isEmpty ifTrue: [
			aPane selection: (Array with: newContents first)]].
	"aPane triggerChanged."
	self zap.! !

!WBInterfaceObject methods !   
realClass

    ^realClass! !

!WBInterfaceObject methods !
creationMethodSelector
		"Answer the selector of the creation method (like #createViews)."
	^creationMethodSelector! !

!Bitmap class methods !   
buttonWidth: w height: h contents: aBitmap
	"Private - WBPro Development.
		Create a new tool bar button bitmap template"

	#addedByOSI.
	^(self screenWidth: w * 2 height: h) wbInitButton: aBitmap! !

!Object methods ! 
wbFramingEditor
	"Answer the class of the framing editor used to edit the receiver."

	^nil! !

!WBCompositePaneModule methods ! 
generatePaneOwner: aPane
		"Private - Generate the pane owner definition."
	aPane == self view ifFalse: [
		super generatePaneOwner: aPane ].! !

!WBInterfaceObject methods !   
defaultWizardEvent

    ^self importantEvents
        detect: [:sym | sym last == $:]
        ifNone: [nil]! !

!WBDevelopmentObject methods !  
isShiftKeyDown

	^Notifier isShiftKeyDown! !

!WBFileSelectorEditor methods ! 
descriptions: aCollection

    descriptions := aCollection! !

!WBCodeStream methods !
isSpaceOnLine: anInteger
		"Private - Answer true if there is space on the
			current line for anInteger number of characters."
	^(self maxLineSize ifNil: [ ^true ]) - self lineSize >= anInteger! !

!WBEnhancedEntryFieldEditor methods ! 
getFocusDict

    ^Dictionary new
        at: 'Select All' put: #selectAll;
        at: 'Cursor Before' put: #selectFirst;
        at: 'Cursor After' put: #selectLast;
        yourself! !

!WBMenuItem methods !
toggleSelector
        "Answer the toggle selector of the menu item."
    ^toggleSelector! !

!WBModelEventsTriggeredModule methods ! 
defaultComment
        "Answer the default comment string."
    ^'Private - answer all the events which can be triggered by instances of the receiver.',
        super defaultComment! !

!WBScrollingPane methods ! 
addSubpane: aPane

    children isNil ifTrue: [
        children := IdentityDictionary new].
    children at: self getNextChildId put: aPane.

	#osiHack.
	"Should (or can) we use super class method instead?"
	Smalltalk platformIsOS2
		ifTrue: [ aPane parent: ((Smalltalk at: #FrameWindow) new parent: self) ]
		ifFalse: [ aPane parent: self ].
    owner mainView add: aPane interestIn: aPane name.! !

!WBModelDefinitionEditor class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!PEntryFieldGroup methods !  
fieldClass

    ^WBEntryField! !

!WindowBuilder methods !
menuOptionsLookPolicyOS2

    self class lookPolicy: WBLookPolicyOS2.
    self shell backColor asRGBColor = Color gray asRGBColor
        ifTrue: [self shell backColor: Color white].
    self updateLookPolicy! !

!WBAbstractCodeModule methods !   
copyright

	^(((((self wbEditorClass copyright
			replaceAll: '%Y' with: Date today year printString)
			replaceAll: '%C' with: self wbEditorClass companyName)
			replaceAll: '%U' with: self wbEditorClass userName)
			replaceAll: '%D' with: Date today printString)
			replaceAll: '%T' with: Time now printString)! !

!WBListEditor methods ! 
select: selectedItem

    item contents: selectedItem; setFocus.
    self enable.! !

!PWBToolBar methods !  
minSize

    ^self cellSize! !

!WBGeometryManager methods !  
duplicate

    self hasSelections
        ifTrue: [
            self layoutForm duplicate.
            self owner setDirty].! !

!WBStaticTextEditor methods ! 
ok
    | contents |
    contents := (self paneNamed: 'text') contents.
	OperatingSystem isOS2 ifTrue: [
		contents := contents copyWithout: "Cr" (Character value: 13)].
    thePane contents: contents.

    self close! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBStatusPaneEditor methods !  
down

	| box index |
	index := list selection.
	index isNil ifTrue: [^nil].
	box := boxes at: index.
	index == boxes size ifTrue: [^nil].
	boxes removeIndex: index.
	boxes add: box afterIndex: index.
	list
		contents: (boxes collect: [:each | each name asString]);
		selection: index + 1.

	self updateBoxes.! !

!WBGraphicObject methods !
displayWithBorder: aPen

    ^self lookPolicy
        displayWithBorder: aPen
        rect: self rect
        backColor: self backColor! !

!WBOutboardWindow methods !
widgetsDestoyed: aCollectionOfWidgets
    "Some of the owners widgets have been destroyed."! !

!WBPoolManagerWindow methods ! 
menuPoolUpdateDependentClasses

    "Callback for the menu item titled 'Update dependent classes...'.
     (Generated by WindowBuilder)"

	| poolNames dependentClasses |
	poolNames := self selectedPools collect: [:each | each poolName].
	dependentClasses := Object withAllSubclasses select: [:each |
		(each sharedPools
			detect: [:eachPoolName | poolNames includes: eachPoolName]
			ifNone: [nil]) notNil].
	self menuPoolUpdateDependentClasses: dependentClasses.! !

!WBLayoutForm methods ! 
checkHideHandles

    ^(self propertyAt: #hideHandles) ==  true.! !

!WindowBuilder methods ! 
menuOptionsFontManager

	self class openFontManager.! !

!WBCreateClassDialog methods !   
setApplicationCoordinator
    "Callback for the #turnedOn event triggered in the RadioButton named 'setApplicationCoordinator'.
     (Generated by WindowBuilder)"

    | superClassSymbol |
    superClassSymbol := (limitTo = 'Window'
        ifTrue: [#ApplicationCoordinator]
        ifFalse: [#DialogCoordinator]).
    (self paneNamed: 'superclassName')
        contents: (self superclassListFor: superClassSymbol);
        selectItem: (self defaultSuperClassFor: superClassSymbol) asString;
        getSelection.! !

!WBAbstractAddInModule class methods ! 
addToBitmapModuleMap: aDictionary
    "Add to the bitmap module map"! !

!WBScrapbookStore methods !   
loadChapters: aPane

    aPane contents: self chapters.! !

!WBLayoutForm methods !   
keyMove: direction x: dx y: dy

    | sel contentRect |
    sel := self selections.
    (self undoManager
        add: 'Move ', direction
        undo:
            [self hideHandles.
            sel do: [:aWidget |
                aWidget
                    moveWidget: (aWidget x left: dx)
                    y: (aWidget y up: dy);
                    wbUpdateConstraints].
            self
                updateWidgetAttachments: sel;
                showHandles;
                notifyModelOfSizeOrPositionChange]
        redo:
            [self hideHandles.
            self useFence
                ifTrue: [
                    contentRect := self shell frameContentRect.
                    sel do: [:aWidget |
                        aWidget
                            moveWidget: (((aWidget x right: dx) rightMost: contentRect left) leftMost: (contentRect right left: aWidget width))
                            y: (((aWidget y down: dy) lowerOf: contentRect top) higherOf: (contentRect bottom up: aWidget height));
                            wbUpdateConstraints]]
                ifFalse: [
                    sel do: [:aWidget |
                        aWidget
                            moveWidget: (aWidget x right: dx)
                            y: (aWidget y down: dy);
                            wbUpdateConstraints]].
            self
                updateWidgetAttachments: sel;
                showHandles;
                notifyModelOfSizeOrPositionChange])
        redoAction value.
    self model isNil
        ifFalse: [self model setDirty].
    ^true
    ! !

!WBMenubarEditor methods !   
testMenu

    | tester list |
    self updateItem: menuItemsEditor selection.
    tester := WBMenuTester new.
	(list := menuItemsEditor listAttribute asFlatList) do: [:each |
		each title: (self nlsStringFor: each title)].
    tester menubar: menuItemsEditor contents asMenu.
	list do: [:each | 	each title: (self nlsKeyFor: each title)].
    tester open.! !

!WBPMenu methods ! 
asWBPMenu

    ^self! !

!WBTabOrderLayoutForm methods !  
selection: aWidget

	self triggerEvent: #clicked: with: aWidget.
	aWidget isGrouper
		ifTrue: [^super selection: aWidget].
	self clearSelections.
	aWidget usesFocus
		ifTrue: [
			aWidget tabPosition isNil
				ifTrue: [
					self setTabPositionFor: aWidget.
					self triggerEvent: #setTabPosition.
					self updateRect: (aWidget rect expandBy: 4)]
				ifFalse: [
					Notifier isAltKeyDown
						ifTrue: [
							self removeTabPositionFor: aWidget.
							self triggerEvent: #setTabPosition]
						ifFalse: [self setupDragTabPosition: aWidget]]]
		ifFalse: [Terminal bell].! !

!WindowBuilder methods !  
hasPrimaryModel

    ^self primaryModel notNil! !

!WindowBuilder class methods ! 
scrapbookFindAndLoadFile: aFileName
	"Find and load the scrapbook."

	| path |
	(path := File findOrPromptFileName: aFileName) notNil
		ifTrue: [self scrapbookLoadFile: path].
	! !

!PThreeStateButton methods !
importantEvents

    ^super importantEvents
        add: #checked;
        add: #unchecked;
        add: #indeterminate;
        yourself! !

!PWBToolBar methods !   
extraHandlers

	| aCollection |
	aCollection := OrderedCollection new.
	self elements do: [:element |
		(element selector isNil or: [element selector isEmpty])
			ifFalse: [aCollection add: element selector asSymbol].
		(element rbSelector isNil or: [element rbSelector isEmpty])
			ifFalse: [aCollection add: element rbSelector asSymbol]].
	^aCollection! !

!WBPrimaryModelInitializeModule methods !   
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self stream
            cr; nextPutAll: #generated storeString; nextPut: $.;
                cr; nextPutAll: 'super initialize.';
            cr; nextPutAll: #model;
            nextPutAll: ' := '; nextPutAll: self object primaryModel class name;
                space; nextPutAll: #new; endExpression].! !

!WBTreeListBox methods !   
insert

    | selection newNode |

    (selection := self selectedItem) notNil ifTrue: [
        newNode := self itemType new.
        selection insertNode:  newNode.
        newNode title: ''.
    ].
    owningEditBox setFocus.! !

!WindowBuilder methods !  
autoSize: aBoolean
	"Store into AutoSize property of WindowBuilder"

	self class autoSize: aBoolean! !

!WBPoolManagerWindow methods !   
defaultValueAt: aKey category: aCategory
	"Answer the default value for new keys."

	^nil! !

!WBInterfaceObject methods !   
defaultRealClassName

    ^self class defaultRealClassName! !

!WBLayoutForm methods !
notifyModelOfCursorUnload

    self triggerEvent: #cursorUnloaded.! !

!WBMenu methods !  
add: aSelector label: aLabelString for: theOwner

    ^self
        add: aSelector
        label: aLabelString
        mnemonic: nil
        enable: nil
        toggle: nil
        for: theOwner
        accelerator: ''.! !

!WindowBuilder class methods ! 
clearToolbarTool
	"   WindowBuilder clearToolbarTool    "

	ToolbarTool := nil.! !

!WBPoolManagerWindow methods !   
selectedCategoryOrPrompt: aString
	"Answer the currently selected category.  If exactly one
		is not selected, then prompt the user for a category."

	| list |
	(list := self selectedCategories) isEmpty ifTrue: [
		(list := self allCategories) isEmpty ifTrue: [
			^nil]].
	list size = 1 ifTrue: [^list first].
	^WBListChooser
		fromList: list asSortedCollection
		prompt: aString! !

!WindowBuilder methods !
generateApplicationCode

    [(self isDirty or: [self editedClass isScratchWindow])
            ifFalse: [^self].
        (self prepareAppWindowsForSave: self prototype windows) isNil
            ifTrue: [^nil].
        self setDefaultFonts.
        [self generateCode]
            on: Error
            do: [:ex |
                MessageBox message:
                    'There has been a serious code generation error: [ ' , ex description ,
                    ' ]. Check the Transcript for details. Hold the ALT key down when clicking OK to see the full walkback.'.
                Notifier isAltKeyDown
                    ifTrue: [ex pass]
                    ifFalse: [self dumpErrorToTranscript: ex].
                ^nil]] ensure: [self sendInputEvent: #resetFonts].
    self dirty: self editedClass isScratchWindow.
    self updateMenuFile.
    self updateParent.! !

!WBInterfaceObject class methods !  
clearTemplates
	" WBInterfaceObject clearTemplates "
	^self templates: IdentityDictionary new.! !

!WBFramerExample methods ! 
clientRectangle

	^0@0 extent: self rectangle extent - 2! !

!WBOutboardAttributeWindow class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBUndoManager methods ! 
setUndoState: aBoolean

    aBoolean
        ifTrue: [undoMenu enableItem: #undo]
        ifFalse: [undoMenu disableItem: #undo]! !

!PropertyAccessor methods !
wbStore: anObject on: aCodeStream

	(self wbStoreAction ifNil: [^self])
		wbEvaluateWithReceiver: aCodeStream
		arguments: (
			Array
				with: self
				with: (self getValueFor: anObject)
				with: anObject).! !

!WBUndoRedoDialog methods !
undoManager: anWBUndoManager

	undoManager := anWBUndoManager! !

!WBDescriptor methods ! 
value
    "Answer the value of value."

    ^nil! !

!WBPropertyEditor methods ! 
selectedCategory

	^categoryList selectedItem.! !

!WBPoolManagerWindow methods ! 
showAllCategories
	"Answer true if all categories should be shown."

	^showAllCategories ~= false! !

!WBHandle class methods !  
handleSize

    ^HandleSize ifNil: [HandleSize := WindowBuilder handleSize].! !

!WBEventMessage methods !
index
	"Answer the index of the receiver in the action list containing the receiver."

	^(self actionList ifNil: [^nil])
		findFirst: [:each |
			each receiver == self receiver
			and: [each selector asString = self selector]]
		ifAbsent: [nil]! !

!WBActionEditor methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| actionGroup add authorField authorLabel cancel fileIn 
	fileOut help list listLabel mainView methodField 
	methodTextLabel nameField nameLabel ok xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	actionGroup := GroupBox new.
	add := Button new.
	authorField := WBEntryField new.
	authorLabel := StaticText new.
	cancel := Button new.
	fileIn := Button new.
	fileOut := Button new.
	help := Button new.
	list := ListBox new.
	listLabel := StaticText new.
	methodField := SmalltalkToolInterface current textPaneClass new.
	methodTextLabel := StaticText new.
	nameField := WBEntryField new.
	nameLabel := StaticText new.
	ok := Button new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Action Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -227/2 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -117/2 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -227/2 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -117/2 * yDU).
	self addView: mainView.
	
	list "ListBox"
		owner: self;
		setName: 'list';
		when: #clicked: send: #select: to: self;
		when: #doubleClicked: send: #ok: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -80 * xDU;
				bottomRatio: 0; bottomInset: -98 * yDU);
		startGroup;
		font: SysFont.
	mainView
		addSubpane: list;
		subPaneWithFocus: list.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 100 * yDU;
				rightRatio: 0; rightInset: -41 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 44 * xDU;
				topRatio: 0; topInset: 100 * yDU;
				rightRatio: 0; rightInset: -81 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	nameField "WBEntryField"
		owner: self;
		setName: 'nameField';
		when: #textChanged: send: #newName: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 114 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -184 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: nameField.
	
	add "Button"
		owner: self;
		setName: 'add';
		when: #clicked send: #add to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 186 * xDU;
				topRatio: 0; topInset: 12 * yDU;
				rightRatio: 0; rightInset: -220 * xDU;
				bottomRatio: 0; bottomInset: -24 * yDU);
		contents: '&Add';
		startGroup;
		font: SysFont.
	mainView addSubpane: add.
	
	authorField "WBEntryField"
		owner: self;
		setName: 'authorField';
		when: #textChanged: send: #newAuthor: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 114 * xDU;
				topRatio: 0; topInset: 26 * yDU;
				rightRatio: 0; rightInset: -220 * xDU;
				bottomRatio: 0; bottomInset: -38 * yDU);
		startGroup;
		font: SysFont.
	mainView addSubpane: authorField.
	
	help "Button"
		owner: self;
		setName: 'help';
		when: #clicked send: #help to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 86 * xDU;
				topRatio: 0; topInset: 100 * yDU;
				rightRatio: 0; rightInset: -122 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		contents: '&Help';
		startGroup;
		font: SysFont.
	mainView addSubpane: help.
	
	methodField "TextPaneControl"
		owner: self;
		setName: 'methodField';
		when: #textChanged: send: #methodChanged: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 90 * xDU;
				topRatio: 0; topInset: 48 * yDU;
				rightRatio: 0; rightInset: -220 * xDU;
				bottomRatio: 0; bottomInset: -94 * yDU);
		removeHorizontalScrollbarStyle;
		removeVerticalScrollbarStyle;
		addBorderStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: methodField.
	
	fileOut "Button"
		owner: self;
		setName: 'fileOut';
		when: #clicked send: #fileOut to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 142 * xDU;
				topRatio: 0; topInset: 100 * yDU;
				rightRatio: 0; rightInset: -182 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		contents: '&File Out...';
		startGroup;
		font: SysFont.
	mainView addSubpane: fileOut.
	
	fileIn "Button"
		owner: self;
		setName: 'fileIn';
		when: #clicked send: #fileIn to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 184 * xDU;
				topRatio: 0; topInset: 100 * yDU;
				rightRatio: 0; rightInset: -224 * xDU;
				bottomRatio: 0; bottomInset: -114 * yDU);
		contents: 'File &In...';
		startGroup;
		font: SysFont.
	mainView addSubpane: fileIn.
	
	listLabel "StaticText"
		owner: self;
		setName: 'listLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -60 * xDU;
				bottomRatio: 0; bottomInset: -10 * yDU);
		contents: 'Select an Action:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: listLabel.
	
	nameLabel "StaticText"
		owner: self;
		setName: 'nameLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 90 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -112 * xDU;
				bottomRatio: 0; bottomInset: -22 * yDU);
		rightJustified;
		contents: 'Name:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: nameLabel.
	
	authorLabel "StaticText"
		owner: self;
		setName: 'authorLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 88 * xDU;
				topRatio: 0; topInset: 28 * yDU;
				rightRatio: 0; rightInset: -112 * xDU;
				bottomRatio: 0; bottomInset: -36 * yDU);
		rightJustified;
		contents: 'Author:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: authorLabel.
	
	methodTextLabel "StaticText"
		owner: self;
		setName: 'methodTextLabel';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 90 * xDU;
				topRatio: 0; topInset: 40 * yDU;
				rightRatio: 0; rightInset: -132 * xDU;
				bottomRatio: 0; bottomInset: -48 * yDU);
		contents: 'Method Text';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: methodTextLabel.
	
	actionGroup "GroupBox"
		owner: self;
		setName: 'actionGroup';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 86 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -224 * xDU;
				bottomRatio: 0; bottomInset: -98 * yDU);
		contents: 'Action Definition';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: actionGroup! !

!WBFontManagerWindow methods !   
defaultValueAt: aKey category: aCategory
	"Answer the default value for new keys."

	^Font
		face: SysFont faceName
		size: SysFont pointSize
		fixedWidth: SysFont fixedWidth
		attributes: 0
		graphicsMedium: Display! !

!WBKeyAccel methods !  
constantsDict

    KeyConstantsDict isNil ifTrue: [
        KeyConstantsDict := Dictionary new.
        OperatingSystemConstants keysDo: [ :k |
            ((k at: 1) = $V) & ((k at: 2) = $k) ifTrue: [
                KeyConstantsDict at: (OperatingSystemConstants at: k) put: k.
            ].
        ].
    ].

    ^KeyConstantsDict! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCodePolicy methods ! 
basicCreateClassFor: aWBClassDefinition
		"Define and answer a new class.
		Answer nil if one could not be created."
	self implementedBySubclass.! !

!WindowBuilder class methods ! 
wbUninitializeDevelopment
	"Perform uninitialization."

	| bitmapDict |
	self scrapbook: nil.
	WBBitmapManager system removeAll.
	(Smalltalk at: #CPBitmapDict ifAbsent: [nil]) isNil
		ifFalse: [
			bitmapDict currentDictMap removeAll.
			bitmapDict systemDictMap removeAll].
	ServiceRegistry
		globalRegistry unregister: #OSIProducts;
		unregister: #WindowBuilderPro.
	SessionModel current removeAllActionsWithReceiver: self.
	(Message 
		receiver: Notifier 
		selector: #reinitialize) performDeferred.! !

!Bitmap methods !
wbButtonUp: aBitmap
	"Private - WBPro Development."

	| srcBox dstBox ratio |
	srcBox := aBitmap boundingBox.
	dstBox := self wbButtonUpBox.
	srcBox extent < dstBox extent
		ifTrue: [ratio := 1]
		ifFalse: [
			ratio := dstBox extent / srcBox extent.
			ratio := ratio x min: ratio y].
	dstBox := (dstBox center leftAndUp: srcBox extent * ratio // 2)
		extentFromLeftTop: (srcBox extent * ratio) truncated.
	self pen copyBitmap: aBitmap from: srcBox to: dstBox.! !

!WBGraphicObject methods !   
extent

    ^rect extent! !

!WindowBuilder methods ! 
checkForDuplicateName

	| theName |
	(theName := name contents) isEmpty ifTrue: [^self].
	(self children select: [:child |
		child paneName = theName]) size > 1
		ifTrue: [
			MessageBox message: 'Duplicate widget name detected. Please enter a unique name.'.
			name setFocus; contents: self emptyString].! !

!WBPoolManagerWindow methods !
menuCategoryShowAll

    "Callback for the menu item titled 'Show all'.
     (Generated by WindowBuilder)"

	self showAllCategories: true.! !

!WBResizeBitmap methods !   
cancel

	"Callback for the #clicked event in cancelButton [Button].
		(Generated by WindowBuilder Pro)"

	self close.! !

!FrameObject methods !   
initializeLookPolicy

    ^WBLookPolicy initializePolicy! !

!WBLayoutForm methods !  
model: aWindowBuilder
    "Set the value of model."

    owner := aWindowBuilder.! !

!WindowBuilder class methods ! 
cacheSpecialProperties
    "Preserve special properties when reinitializing properties"

    | dict |
    dict := Dictionary new.
    #(
        #UserName
        #CompanyName
        #SerialNumber
        #Copyright
        #GenerateCopyright
        #CopyrightAfterBody
        "#CommentMethods"
        #LineBeforeComment
        "#MakeCallbacksPrivate"
        "#UseLongCallbackComments?"
        #GridSize
        #UseGrid
    ) do: [:aSymbol |
        dict at: aSymbol put: (self editorClass propertyValueAt: aSymbol)].
    ^dict! !

!WBAbstractCodeModule methods ! 
classDefinitionFor: aClass
		"Answer the class definition for the specified class."
	^self owner classDefinitionFor: aClass! !

!WBUndoAction methods !   
undoAction: aBlock

    undoAction := aBlock! !

!WBPrototype methods !   
properties
        "Private - Answer the properties Dictionary."
    ^properties! !

!WBLayoutWizard methods !
defineModel

    self mainView propertyAt: #defining put: true.
    WBModelDefinitionEditor new openOnModel: sourceInstance class.! !

!WBDevelopmentWindow methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| mainView xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	mainView := self topPaneClass new.
	
	mainView
		owner: self;
		setName: 'mainView';
		labelWithoutPrefix: 'New Window';
		noSmalltalkMenuBar;
		backColor: Color buttonFace;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: -75 * xDU;
				topRatio: 1/2; topInset: -109/2 * yDU;
				rightRatio: 1/2; rightInset: -75 * xDU;
				bottomRatio: 1/2; bottomInset: -91/2 * yDU).
	self addView: mainView! !

!WBPMenubar methods !
allTitles

    ^children collect: [ :n | n title ].! !

!WBLookPolicyWin31 methods !  
frameWidthSizable

    ^frameWidthSizable ifNil: [
        frameWidthSizable := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxframe" 32]
            ifFalse: [super frameWidthSizable]]! !

!WBInterfaceObject methods !   
contentsStringWidth
	"Answer the string width of the receiver's contents.
		If NLS-Autosize is enabled, then answer the maximum
		string width of all NLS strings for that key."

	| manager |
	(manager := self contentsValueManager) notNil
		ifTrue: [
			manager class == WBManagedPNLSString
				ifTrue: [^manager widthFor: self font]].
	^self font wbStringWidth: self contents! !

!WBInterfaceObject methods !  
wbFontsUsed
	"Answer all fonts used in the receiver."

	^self usesFont
		ifTrue: [Array with: self font]
		ifFalse: [Array new]! !

!SelectorPropertyAccessor methods !
wbSetValue: aValue for: anObject
    "Private - Set the value of the property."

	#addedByOSI.
	^super
		wbSetValue: (
			self isIntegerFormat
				ifTrue: [aValue asInteger]
				ifFalse: [aValue])
		for: anObject! !

!WBEventManagerWindow methods !   
eventListDrawItem: drawIndex pane: aPane
    "Callback for the #drawItem: event in eventListBox [MultipleSelectListBox]
    (Generated by WindowBuilder Pro)"

    | anEvent hasActionForEvent box aWBDisplayContext |
    anEvent := aPane contents at: drawIndex.
    hasActionForEvent :=
        (self widgetSelections
            detect: [:each | each hasActionForEvent: anEvent]
            ifNone: [nil]) notNil.
    aWBDisplayContext := aPane wbDisplayContext.
    aWBDisplayContext cellBorder: #displayNoBorder.
    box := aWBDisplayContext splitCellLeftInset: (aPane font stringWidth: '* ').
    (hasActionForEvent ifTrue: ['*'] ifFalse: ['']) wbDisplayWith: aWBDisplayContext.
    aWBDisplayContext cellBox: box.
    anEvent wbDisplayWith: aWBDisplayContext.! !

!WindowBuilder methods !  
menuToolsBrowseClasses: aClass

	ClassHierarchyBrowser new openOn: 
		(Array with: (Smalltalk at: aClass asSymbol)).! !

!WBLookPolicyWin95 methods !
scrollBarWidth

    ^scrollBarWidth ifNil: [
        scrollBarWidth := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxvscroll" 2]
            ifFalse: [super scrollBarWidth]]! !

!WBAboutDialog methods !  
showAddress

    MessageBox messageNote: self wbEditorClass osiMessage.! !

!WBInterfaceObject methods !  
listEditorAllowsSort

    ^true! !

!WBNLSDictionaryReader class methods !
fileOutPoolTableBeginOn: aStream
	"File out a token/value pair inside a comment."

	^self
		fileOutToken: 'POOLTABLE' inCommentOn: aStream;
		fileOutToken: 'POOLBEGIN' inCommentOn: aStream! !

!WBApplicationCoordinatorMenuModule methods ! 
defaultViewName
        "Answer the default view name."
    ^'aView'! !

!PCompositePane methods !
realClass: aClass updateExtent: aBoolean
	| temp convertor |
	super realClass: aClass.
	temp := aClass new.
	temp addSubpanes.
	self initialFraming: temp framingBlock deepCopy.
	temp backColor notNil
		ifTrue: [
			self backColor = self defaultBackColor
				ifTrue: [self backColor: temp backColor].
			self defaultBackColor: temp backColor]
		ifFalse: [
			self defaultBackColor: Color windowBackground.
			self backColor: Color windowBackground].
	aBoolean ifTrue: [self extent: self defaultSize].
	convertor := WBPrototype new.
	self children: (convertor convertWindow: temp inClass: aClass) children.
	self children do: [:child | child parent: self].! !

!WindowBuilder class methods !  
lineBeforeComment

    ^self editorClass
        propertyValueAt: #LineBeforeComment
        category: self codeGenerationPropertyString.! !

!WBTabPosition methods !  
makeFirstInGroup

    groupPosition := 1.! !

!WBInterfaceObject methods !
siblings

	^self parent children! !

!WBCodePolicy methods !  
createMethodFor: aCodeModule
		"Compile and store the method.  If the sourceString equals
			the source code for the current method, then do nothing."
	| assoc |
	(self hasMethodChanged: aCodeModule) ifFalse: [^true].
	(assoc := self compileMethodFor: aCodeModule) ifNil: [^false].

	"*** Side effect: set the message selector of the code module to the
		selector of the method that was just compiled to ensure that the
		source is logged to the correct method, and provide feedback to
		WBBasicCodeModule indicating what method was just compiled. ***"
	aCodeModule messageSelector: assoc key.

	self logMethodFor: aCodeModule.
	^true! !

!WBDevelopmentWindow methods ! 
setOther
    "Set the other attributes for the current widget"

    | currentWidget attributeEditor copy |
    (attributeEditor := (currentWidget := self currentWidget) attributeEditor) notNil
        ifTrue: [
            attributeEditor isClass ifTrue: [attributeEditor := attributeEditor new].
            self preEditCheck ifFalse: [^false].
            (copy := (attributeEditor openOn: currentWidget) result) notNil
                ifTrue: [
                    copy wbCopyTo: currentWidget.
                    currentWidget postEdit: self.
                    self postEditUpdate.
                    ^true]].
    ^false! !

!WBInstVarGetModule methods !
defaultComment
		"Answer the default comment string."
	^'Answer the value of ', self object, '.
		(Generated by WindowBuilder Pro)'! !

!WBClassDefinition methods ! 
basicAllInstVarNames
		"Private - Answer a collection of all instance variable names."
	^self classField superclass allInstVarNames, self instVarNames! !

!WBLookPolicyWin31 class methods ! 
isDefault

    ^self isWin32
        and: [self isWindows95 not
        and: [self ctl3dEnabled not]]! !

!WBScrapbookStore class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!PLinkButton methods !   
type

    ^type! !

!PWBToolBar methods ! 
changesSize

    ^true! !

!WBToolBarEditor methods ! 
toggleSystem: selection

    useSystem := selection.
    self getBitmaps: (self paneNamed: 'bitmaps').! !

!WBTargetObject methods ! 
wbInstVarMap

	^instVarMap! !

!WBCodeModule methods !
varNameForFont: aFont ifAbsentPut: aBlock
	"Answer the variable name (temporary variable or instance variable)
		for the specified object."

	self varNameForFont: aFont ifAbsent: [
		varNames at: aFont put: aBlock value].! !

!WBModelInstVar methods !
okToGenerateInitialize

    ^self okToGenerateMethod: #initialize! !

!WindowFrameObject methods !
owner: ignore
    "For Windows Conversion"! !

!WBLayoutForm methods ! 
setupSelecting: aPoint
    "Setup for the drag selecting state."

    self releaseState: #buttonReleaseSelecting:.
    self motionState: #button1MotionSelecting:.
    self minSize: 0@0.
    self maxSize: 32000@32000.
    self setupInWhiteSpace: aPoint.
    self setCursor: nil.! !

!WBInterfaceObject methods !  
isDialog

	^self parent isDialog! !

!WindowBuilder class methods !   
editWindow

	self wbEditorClass preOpen.
	self wbEditorClass new 
		openOn: (self basicNew getEditedClass ifNil: [^nil]).
	! !

!WBFileSelectorEditor methods !
initialize

    title := 'Select File'.
    filters := OrderedCollection with: '*.*'.
    descriptions := OrderedCollection with: 'All Files (*.*)'.! !

!WindowBuilder class methods ! 
generateByteArrayCode

    ^self editorClass
        propertyValueAt: #GenerateByteArrayCode
        category: self codeGenerationPropertyString.! !

!WBCreateViewModule methods ! 
viewIndex
		"Answer the receiver's index."
	^viewIndex! !

!WBBitmapManagerWindow methods !   
menuBitmapFromScreenIntoButtonUp

	| aBitmap selectedBitmap |
	selectedBitmap := self selectedValue ifNil: [^self].
	aBitmap := WBBitmapClass fromUser ifNil: [^self].
	selectedBitmap wbButtonUp: aBitmap.
	self updateEditor.! !

!WBInterfaceObject methods !  
contents

    ^contents wbManagedValue! !

!BitEditor methods !   
openOn: aBitmap clipRect: aRect
        "Open a BitEditor on aBitmap."
    | graphPane groupPane size imageSize |
    scale := 8.
    imageForm := aBitmap.
    imageSize := (aRect extent min: imageForm extent) min:
        (Display width - 80 // scale @
            (Display height - 20 // scale)).
    imageRect := aRect origin extent:
        (aRect extent min: imageSize).
    imageSize := imageSize * scale + (5 @ 5).
    size := 76 @ (300 max: imageSize y).
    copy := WBBitmapClass screenExtent: aRect extent.
    copy pen copyBitmap: aBitmap
        from: aRect
        at: 0 @ 0.
    self label: 'BitEditor'.
    self addSubpane: (
        (graphPane := GraphPane new)
            owner: self;
            when: #display send: #displayImage: to: self withArgument: graphPane;
            style: GraphPane noScrollbarsFrameStyle;
            framingBlock: [: box |
                box origin extent: (size x @ (box height // 2))]).
    self addSubpane:
        (groupPane := GroupPane new
            framingBlock: [: box |
                box origin x @ (box origin y + (box height // 2))
                    extent: (size x @ (box height // 2))]).
    groupPane addSubpane:
        (Button new
            owner: self;
            contents: 'Save';
            pushButton;
            when: #clicked send: #save to: self;
            framingBlock: [: box |
                (box origin x + (box width // 6)) @ (box origin y + (box height // 6))
                    extent: (box width * 2 // 3) @ (box height // 3)]).
   groupPane addSubpane:
        (Button new
            owner: self;
            contents: 'Exit';
            pushButton;
            when: #clicked send: #exit to: self;
            framingBlock: [: box |
                (box origin x + (box width // 6)) @ (box origin y + (box height // 2))
                    extent: (box width * 2 // 3) @ (box height  // 3)]).
    self addSubpane:
        ((graphPane := GraphPane new)
            owner: self;
            when: #needsPopupMenu send: #editMenu: to: self withArgument: graphPane;
            when: #display send: #displayBits: to: self withArgument: graphPane;
            when: #button1Down send: #changeBits: to: self withArgument: graphPane;
            when: #button1Moved send: #changeBits: to: self withArgument: graphPane;
            style: GraphPane noScrollbarsFrameStyle;
            framingBlock: [: box |
                box origin x + (size x @ 0)  extent: (
                    (box width - size x) @ box height)]).
    windowSize := 76 + imageSize x + 2 + 3 "framingFix" @
        (( 300 max: imageSize y) + SysFont height + 6 + 14 "framingFix").
    self openWindow.
    self menuWindow addMenu: (
        Menu colorMenu: self selector: #colorSelected:)! !

!WBAddInManager methods !   
loadList

	| list extras |
	list := SortedCollection new.
	extras := self wbEditorClass extras keys.
	WBAbstractAddInModule allSubclasses do: [:class |
		class loaded
			ifTrue: [list add: '*', class commonName]
			ifFalse: [list add: class commonName]].
	(self wbEditorClass listAddIns collect: [:sym |
		self wbEditorClass perform: sym with: #name]) do: [:ai |
			ai isNil
				ifFalse: [
					(extras includes: ai)
						ifTrue: [list add: '*' , ai]
						ifFalse: [list add: ai]]].
	(self paneNamed: 'list') contents: list.
	(self paneNamed: 'install') disable.
	(self paneNamed: 'remove') disable.! !

!PDropDownList methods !
styles

	^#(#dropDownList)! !

!WBTabOrderEditor methods !
reset

	layoutForm 
		restoreOldTabPositions;
		setWidgets: self children copy;
		updateWidget.
	self setFirstStatus.! !

!WBApplicationCoordinatorModule methods !   
generateMenuMessage: aSymbol
        "Private - Generate all the menu definitions."
    self stream cr; cr;
        nextPutAll: #self;
        space.
    self
        generateMessagePattern: aSymbol
        arguments: self messageArguments.
    self stream
        endExpression.! !

!WBResourceDescriptor methods !
value
    "Answer the value of value."

    ^value! !

!WBInterfaceObject methods !  
requiredPoolDictionaries

    ^#()! !

!ViewManager methods ! 
menuWindow

    "WBPro Development - Allow asking for a menu if no view
        has been created.  Used in Windows conversion."

    "Private - Answer the menu bar of the first view,
     retained for compatibility."

    #modifiedByOSI.
    views size < 1 ifTrue: [
        self addView: (
            (self topPaneClass) new
                owner: self)].
    ^self mainView menuWindow! !

!WBLookPolicy methods !
draw3DBoxWith: aPen at: aRect color: color

    aPen
        foreColor: Color gray;
        wbLineFrom: aRect leftTop to: (aRect rightTop left: 1);
        wbLineFrom: aRect leftTop to: (aRect leftBottom up: 1);
        foreColor: Color white;
        wbLineFrom: (aRect leftTop rightAndDown: 1) to: (aRect rightTop leftAndDown: 1);
        wbLineFrom: (aRect leftTop rightAndDown: 1) to: (aRect leftBottom rightAndUp: 1);
        foreColor: color;
        wbLineFrom: (aRect leftBottom up: 1) to: (aRect rightBottom leftAndUp: Rectangle leftTopUnit y @ 1);
        wbLineFrom: (aRect rightTop left: 1) to: (aRect rightBottom leftAndUp: 1);
        foreColor: Color darkGray;
        wbLineFrom: (aRect leftBottom rightAndUp: 1@2) to: (aRect rightBottom leftAndUp: 1 +  Rectangle leftTopUnit y @ 2);
        wbLineFrom: (aRect rightTop leftAndDown: 2@1) to: (aRect rightBottom leftAndUp: 2);
        up; down;
        fill: (aRect insetBy: 2) color: Color gray;
        foreColor: Color black;
        backColor: Color black.
    ^aRect insetBy: 2! !

!TopPane methods !   
wbStorePropertiesOn: aCodeStream

	#osiHack.
	"For compatibility when converting old p-style windows
		to new runtime-less windows, explicitly check for
		the old #modal flag and set the modal border style."
	((self propertyAt: #pStyleOld ifAbsent: [#( )]) includes: #modal) ifTrue: [
		self addModalBorderStyle].
	super wbStorePropertiesOn: aCodeStream.! !

!WBNLSDictionaryReader class methods !   
fileOutToken: aToken inCommentOn: aStream
	"File out a token/value pair inside a comment."

	aStream
		cr;
		nextPutAll: self commentStartString;
		nextPutAll: aToken;
		nextPutAll: self commentEndString.! !

!WBEditClassDialog methods !
updateOK

    selectedClass isNil
        ifTrue: [ok disable]
        ifFalse: [ok enable].! !

!WBTemplateEditor methods !
remove

    "Callback for the #clicked event triggered in the Button named 'removeButton'.
     (Generated by WindowBuilder)"

	| selectedItem |
	Notifier isAltKeyDown
		ifTrue: [
			(MessageBox confirm: 
				'Remove all of the templates?') ifFalse: [^self].
			self templates removeAll]
		ifFalse: [
			(selectedItem := templateList selectedItem) isNil ifTrue: [^self].
			(MessageBox confirm: 
				'Remove the template for ', selectedItem, '?') ifFalse: [^self].
			self	templateRemove: selectedItem].
	template := nil.
	templateGroup contents: 'Template'.
	self	
		loadList;
		updateFields.! !

!WBInterfaceObject methods !  
configureWidget: x y: y width: width height: height borderWidth: borderWidth

	self 
		rect: (Rectangle 
			leftTop: x @ y 
			extent: width @ height);
		updateWidgetMoved.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBScrollingPane methods !  
amountToPageLeft

    ^(self visibleExtent x - 10) max: 20! !

!WBUndoManager methods !   
inUndo

    ^inUndo! !

!WBMenuTester class methods ! 
isWBInternalClass

    ^true! !

!WBClassDefinition methods ! 
isScratchWindow
		"Answer true if the receiver describes a scratch window."
	^(self targetClass ifNil: [ ^false ]) isScratchWindow! !

!WBTreeNode methods !  
delete

    children notEmpty ifTrue: [
        (MessageBox confirm: self deleteMessage) ifFalse: [
            ^nil
        ].
    ].

    parent removeChild: self.! !

!WBInterfaceObject methods !  
menu

    ^menu! !

!WBUndoAction methods !   
redo
    "Perform the redo operation"

    redoAction value! !

!PListBox methods !  
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	(#(#changed: #clicked: #doubleClicked:) includes: eventSymbol)
		ifTrue: [^#('selectedItem')].
	(#(#drawFocus: #drawItem: #drawSelection: #measureItem:) includes: eventSymbol)
		ifTrue: [^#('drawIndex')].
	eventSymbol == #changedIndex: ifTrue: [^#('selectedIndex')].
	eventSymbol == #characterTyped: ifTrue: [^#('aCharacter')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!WBLinkEditor methods !  
ok

    thePane link: (self paneNamed: 'list') selectedItem.
    thePane type: (self paneNamed: 'types') selectedItem.
    (thePane isWBInterfaceObject and: [ thePane link notNil ]) ifTrue: [
        thePane contents: thePane link,'...'
    ].

    self close! !

!WBInterfaceObject methods !
wbSetDirty

	^self editor setDirty! !

!Message methods ! 
wbEvaluateWithReceiver: anObject arguments: anArray
    "Private - this method is part of the development environment and cannot be relied on in a run-time image.
    Answer the result of evaluating the receiver using <anObject> as the message receiver. "

	#addedByOSI.
    ^anObject
        perform: self selector
        withArguments: (self wbCollectArguments: anArray)! !

!WBLayoutWizard methods !  
generateModel

    | modelObject |
    self usesModel ifFalse: [^self].
    (modelObject := self primaryModel) isNil
        ifFalse: [self owner prototype modelObjects remove: modelObject ifAbsent: [ ]].
    sourceInstance
        propertyAt: #primaryModel put: true;
        setName: 'model';
        isInstVar: true.
    self owner prototype modelObjects add: sourceInstance.! !

!WBLookPolicyWin31 methods !   
scrollBarArrowWidth

    ^scrollBarArrowWidth ifNil: [
        scrollBarArrowWidth := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxhscroll" 21]
            ifFalse: [super scrollBarArrowWidth]]! !

!WindowBuilder methods ! 
reinitWindowBuilder

    self updateMenuAll.
    self undoManager reset.
    self layoutForm
        clearSelections;
        setShellHandlesFor: self shell;
        showShellHandles.
    self newSelection: self selections.! !

!WBLayoutForm methods ! 
redrawMovingWidget: aBoolean
    "Set the flag indicating that the widget currently
     being moved must be redrawn on the next move."

    redrawMovingWidget := aBoolean.! !

!WBResizeBitmap class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBEventManagerWindow methods !  
sendFieldList

	| answer eachClass mthFilter |
	eachClass := self toFieldSelection wbRealClass.
	mthFilter := (eachClass inheritsFrom: Window)
		ifTrue: [#('wm' 'part' 'wb' 'is' 'has' 'dm' 'default' 'code' 'fram' 'owner' 'scroll' 'add' 'draw' 'init' 'prop' 'remove' 'send')]
		ifFalse: [#( )].
	answer := Set new: 100.
	[eachClass notNil] whileTrue: [
		eachClass methodDictionary do: [:eachMth |
			mthFilter
				detect: [:eachBegin| eachMth selector beginsWith: eachBegin]
				ifNone: [answer add: eachMth selector]].
		self sendFieldShowAll
			ifFalse: [
				eachClass superclass instanceClass == Object
					ifTrue: [eachClass := nil]
					ifFalse: [eachClass := eachClass superclass]]
			ifTrue: [eachClass := eachClass superclass]].
	^answer asSortedCollection! !

!WBLayoutForm methods !   
drawTabOrderSymbolsFor: aCollectionOfWidgets
    "Draw the tab order symbols for a <aCollectionOfWidgets>"

    | aPen center font fontHeight radius |
    self showOrder ifFalse: [^self].
    aPen := self pen.
    font :=  SysFont.
    fontHeight := font height.
    radius := (((font stringWidth: (self children size asString)) // 2) max: fontHeight // 2) + 3.
    (aCollectionOfWidgets select: [:widget |
        widget tabPosition notNil & widget isGrouper not & widget usesFocus]) do: [:widget |
        aPen
            backColor: Color black;
            place: (center := widget hitRect center);
            circleFilled: radius;
            foreColor: Color white;
            font: (self fontFor: widget);
            setTextAlign: WBDisplayContext defaultTextAlign;
            centerWinText: widget tabPosition asString at: center].! !

!WBCreateClassDialog class methods !  
defaultType

    ^DefaultType ifNil: [DefaultType := #ViewManager]! !

!WBLayoutForm methods !
setupDragWidget
    "Setup the dragging widget state."

    self releaseState: #buttonReleaseMovingWidget:.
    self motionState: #button1MotionMovingWidget:.
    self setCursor: #move.
    self selections do: [:aWidget |
        aWidget propertyAt: #startOrigin put: aWidget origin].! !

!WBLookPolicyOS2 methods !  
systemMenuWidth

	^systemMenuWidth ifNil: [
		systemMenuWidth := self class isDefault
			ifTrue: [(pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCxminmaxbutton" 33) // 2]
			ifFalse: [super systemMenuWidth]]! !

!WBTabOrderEditor methods !  
createAllGroups

	layoutForm createAllGroups.
	self setFirstStatus.! !

!WBLayoutForm methods !  
morphSelectionsTo: newClass
	"Morph the selected widgets to <newClass>"

	| newWidgets widgetMap aNewWidget |
	self hideHandles.
	widgetMap := IdentityDictionary new.
	[newWidgets := self selections collect: [:aWidget |
		aNewWidget := aWidget wbMorphWithParent: self shell to: newClass.
		widgetMap at: aWidget put: aNewWidget.
		widgetMap at: aWidget wbRealWidget put: aNewWidget wbRealWidget.
		aNewWidget]]
		on: Error
		do: [
			self wbHalt.
			newWidgets do: [:aWidget |
				aWidget isDestroyed ifFalse: [aWidget wbDestroyWidget]].
			^nil].
	self
		createUndoRedoForNewWidgets: newWidgets
		oldWidgets: self selections
		widgetMap: widgetMap
		named: (newWidgets size == 1
			ifTrue: ['Morph Widget']
			ifFalse: ['Morph Widgets']).
	self selections do: [:aWidget |
		aWidget isDestroyed ifFalse: [[aWidget wbDestroyWidget] on: Error do: [ ]]].
	self
		placeNewWidgets: newWidgets
		at: self selectedRect topLeft.
	self model prototype wbConvertEventTables: widgetMap.
	self shell sortChildrenByTabOrder.
	self 
		updateWidget;
		selections: newWidgets.! !

!WBMenuEditor methods !   
menuItemNameChanged: menuEditor

    "If the name is a dash and it's legit, make the item a divider."

    | currentItem titleIsSeparator |

    self checkMnemonics.
    self updateTestButton.

    currentItem := menuEditor selectedItem.
    (self allowDividerFor: currentItem) ifFalse: [
        ^self
    ].

    titleIsSeparator := currentItem title notEmpty and: [ currentItem title first = $- ].

    (titleIsSeparator) ifTrue: [
        dividerState selection: true.
        currentItem isSeparator: true.
        self newDividerState: dividerState.
    ] ifFalse: [

     "If it was a divider, and isn't now, turn the divider off"
        (currentItem isSeparator & titleIsSeparator not) ifTrue: [
            dividerState selection: false.
            currentItem isSeparator: false.
            self newDividerState: dividerState.
        ].
    ].! !

!ToolPane class methods ! 
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #doubleClicked ;
                argumentNames: #( ));
        yourself! !

!WBListChooser methods !
cancel

    self mainView close! !

!WBClassDefinition methods !  
forceUpdate

    ^self owner forceUpdate! !

!WBUndoManager methods ! 
setInUndo

    inUndo := true! !

!WindowFrameObject methods !
drawFrameWith: aPen at: aPoint

    self lookPolicy
        drawFrame: self
        with: aPen! !

!WBUndoAction class methods !
label: aString undo: aBlock redo: aBlock2

    ^self new
        label: aString;
        undoAction: aBlock;
        redoAction: aBlock2;
        yourself! !

!Rectangle methods !   
centerTop
        "Private - WBPro Development.
            Answer the center top Point."
    #addedByOSI.
    ^(self right + self left)//2 @ self top! !

!WindowBuilder methods ! 
autoSave

    ^self class autoSave! !

!WBTreeListBox methods !   
delete

    owningEditBox setFocus.
    self selectedItem delete isNil ifTrue: [
        ^nil
    ].

    (self contents asFlatList size = 0) ifTrue: [
        self contents: (
            self contents
                addChild: self itemType new;
                yourself
        ).
    ].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PTextEdit methods !   
winClassStyle

    ^EsAutovscroll | EsMultiline! !

!PRadioButtonGroup methods !  
foreColor: aColor

	super foreColor: aColor.
	aColor = self defaultForeColor
		ifTrue: [self children do: [:child | child foreColor: child defaultForeColor]]
		ifFalse: [self children do: [:child | child foreColor: aColor]].! !

!WBTreeNode methods ! 
siblingPosition

    ^parent positionOf: self! !

!PStaticText methods !  
attributeEditor

    ^WBStaticTextEditor! !

!WBFramingEditor methods !   
openOnFramer: framer
rects: rectList
parentRect: aParentRect

    framingParameters := framer.
    currentRectList := rectList.
    parentRect := aParentRect.
    ^self open.! !

!WindowBuilder methods !  
wbUnlinkPartEvents
	"Do Nothing"! !

!WBDrawnButton methods !  
graphicsTool
        "Private - Answer the receiver's graphics tool."
    graphicsTool isNil ifTrue: [ graphicsTool := self getGraphicsTool ].
    ^graphicsTool! !

!WindowBuilder class methods !  
openOn: aClass

    self new openOn: aClass! !

!WBEditClassDialog class methods !
addToRecentList: aClass

    | recentClasses |
    ((recentClasses := self recentClasses) includes: aClass)
        ifTrue: [recentClasses remove: aClass].
    recentClasses addFirst: aClass.
    recentClasses size > self recentClassMaxSize
        ifTrue: [recentClasses removeLast]! !

!WBTabOrderLayoutForm methods !  
groupPaneHitBy: aPoint

	| groupersHit |
	groupersHit := self children select: [:widget |
		widget isGrouper and: [widget rect containsPoint: aPoint]].
	^groupersHit isEmpty
		ifTrue: [nil]
		ifFalse: [groupersHit first].! !

!WBEventMessage methods !  
changeSelector: aSymbol
	"Set the message selector."

	| index |
	index := self index.
	self selector: aSymbol.
	index notNil ifTrue: [
		(self actionList at: index)
			selector: (self selector asExistingSymbolOrNil ifNil: [self selector])].! !

!PStaticBox methods ! 
staysToBack

    ^true! !

!WBCreateViewModule methods !  
generatePaneComment: aPane
        "Private - Generate the pane definition."
    | vName cName |
    vName := self varNameFor: aPane.
    cName := aPane isWBPrimaryModel
        ifTrue: ['*Primary Model*']
        ifFalse: [aPane realClass name].
    ((vName
        copyFrom: 1
        to: (vName size min: cName size))
        asLowerCase equals: cName asLowerCase)
        ifFalse: [
            self stream
                space;
                nextPut: $";
                nextPutAll: cName;
                nextPut: $"].! !

!WBUndoRedoDialog methods ! 
openOn: anWBUndoManager

    self
        undoManager: anWBUndoManager;
        open.! !

!WBPoolManagerWindow methods !
keyListChanged: selectedItem pane: aPane

    "Callback for the #changed: event triggered in the MultipleSelectListBox named 'keyListBox'.
     (Generated by WindowBuilder)"

	self selectedKeysChanged.! !

!WBPoolManagerWindow methods !   
menuPoolRemove: aCollectionOfPools

	aCollectionOfPools copy do: [:each |
		self poolManager removePool: each].! !

!WindowBuilder class methods !   
editorClass

    ^EditorClass ifNil: [EditorClass := self]! !

!WBApplicationCoordinatorModule methods !  
generatePanes
        "Private - Generate the pane definitions."
    self stream cr.
    self
        generatePane: self view.
    self children do: [:each |
        self stream cr.
        each creationMethodSelector isNil
            ifTrue: [self generatePane: each]
            ifFalse: [self generatePaneHandlersOnly: each].
        self generateAddPane: each to: self view using: #addSubpane:].! !

!WBScrapbookRetrieve methods !   
ok
    | aPage |
    (chapter notNil and: [page notNil])
        ifTrue: [
            aPage := (scrapbook at: chapter) at: page ifAbsent: [^nil].
            aPage isArray ifTrue: [aPage := aPage first].
            layoutPane
                clipboard: aPage;
                loadedWidgets: layoutPane clipboard.
            self close].! !

!WBToolBarEditor methods ! 
validBitmapsFrom: aBitmapManager withSize: aPoint

	| size answer |
	size := aPoint x * 2 @ aPoint y.
	answer := SortedCollection new: 40.
	aBitmapManager associationsDo: [:each |
		each value isBitmap ifTrue: [
			each value extent = size ifTrue: [
				answer add: each]]].
	^answer! !

!WindowBuilder methods !   
timer: ignore

    | time index |
    time := Time now printString.
    (index := time indexOf: $ ) == 0
        ifTrue: [time := time copyFrom: 1 to: 5]
        ifFalse: [time := (time copyFrom: 1 to: 5), (time copyFrom: index to: time size)].
    (status statusBoxAt: #time) contents: time.! !

!PStatusPane methods !  
framingBlock: framer

	| width |
	width := parentWindow isNil
		ifTrue: [300]
		ifFalse: [parentWindow rect width].
	framingBlock := LayoutFrame new
		leftRatio: 0; leftInset: 0;
		topRatio: 1; topInset: self height negated;
		rightRatio: 1; rightInset: 0;
		bottomRatio: 1; bottomInset: 0.
	self updateBoxes! !

!PGraphPane methods !   
backColor

    ^Color white! !

!WindowBuilder class methods !
clearHelpDict
	"   WindowBuilder clearHelpDict    "

	HelpDict := nil.! !

!WBLookPolicyWin95 methods !  
titleBarHeight

    ^titleBarHeight ifNil: [
        titleBarHeight := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCysize" 31]
            ifFalse: [super titleBarHeight]]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!SelectorPropertyAccessor methods !
wbDuplicate: anAction

	self propertyAt: #wbDuplicateAction put: anAction.! !

!WBCodeModule methods !
temporaries
		"Answer a collection of temporary variable names."
	^temporaries ifNil: [
		temporaries := Set new
			addAll: self defaultTemporaries;
			yourself ]! !

!PWBVerticalScrollBar methods ! 
defaultSize

    ^self suggestedSize x @ 100! !

!WBInterfaceObject methods ! 
supportedEvents

	| answer |
	[(answer := self realClass supportedEvents) isNil
			ifTrue: [^#()]] on: Error do: [^#()].
	^answer asSortedCollection! !

!WBCodeStream methods !   
nextPutArrayElement: anObject
	"Append a representation of an array element to the receiver."

	anObject isSymbol ifTrue: [self nextPut: $#].
	self nextPutAll: anObject printString.! !

!ApplicationWindow methods !  
clearDependents
    "Remove all of the dependents"
    #addedByOSI.
    dependents := nil! !

!WBCodeStream methods !
nextPutEventTable: anEventTable for: anObject
    "Store the event table on aCodeStream.
    Generate #when:send:... code, along with #dragSource:, #dragTarget:
    if the #dragSourceNeedsObject:, #dragTargetDrop: events are handled."

    | ddReceiver ddSender dragSource dragTarget selector sorted target |
    sorted := SortedCollection new: anEventTable size.
    ddSender := ddReceiver := dragSource := dragTarget := false.
    (self owner filterEventTable: anEventTable for: anObject)
        associationsDo: [:each | sorted add: each].
    sorted do: [:eachAssoc |
        "new"
        eachAssoc key == #dragSourceNeedsObject: ifTrue: [dragSource := true].
        eachAssoc key == #dragTargetDrop: ifTrue: [dragTarget := true].
        "old"
        eachAssoc key == #needsDragDropObjects ifTrue: [ddSender := true].
        eachAssoc key == #dragDropped: ifTrue: [ddReceiver := true].

        eachAssoc value asActionSequence do: [:eachMsg |
            selector := (eachMsg selector ifNil: ['']) asSymbol.
            target := self owner
                varOrGlobalNameFor: eachMsg receiver
                ifAbsent: [
                    "Report an error only if..."
                    self wbHalt.
                    nil].
            selector notEmpty & target notNil ifTrue: [

                "Spin off a method stub code module..."
                eachMsg receiver == self owner targetObject ifTrue: [
                    self addModule: (
                        WBEventHandlerStubModule new
                            source: anObject;
                            event: eachAssoc key;
                            message: eachMsg;
                            targetClass: self owner targetClass instanceClass;
                            yourself)].

                self cr;
                    nextPutAll: #when:;
                    space;
                    nextPutAll: eachAssoc key storeString;
                    space;
                    nextPutAll: #send:;
                    space;
                    nextPutAll: selector storeString;
                    space;
                    nextPutAll: #to:;
                    space.
                (self owner isInstVar: target) & self owner useInstVars not
                    ifTrue: [self nextPutAll: (self owner varNameFor: #owner); space].
                self nextPutAll: target.
                ((Message numberOfArgumentsFor: selector) >
                    (Message numberOfArgumentsFor: eachAssoc key)
                    and: [self wbEditorClass runtimeLessCode not])
                    ifTrue: [
                        self
                            space;
                            nextPutAll: #withArgument:;
                            space;
                            nextPutVarNameFor: anObject].
                self endMessage]]].

    dragSource ifTrue: [
        self cr;
            nextPutAll: #dragSource: ;
            nextPutAll: ' true';
            endMessage].
    dragTarget ifTrue: [
        self cr;
            nextPutAll: #dragTarget: ;
            nextPutAll: ' true';
            endMessage].
    ddSender ifTrue: [
        self cr;
            nextPutAll: #dragDropSender ;
            endMessage].
    ddReceiver ifTrue: [
        self cr;
            nextPutAll: #dragDropReceiver ;
            endMessage].! !

!WBLayoutForm methods ! 
inTitle: aPoint
		"Answer true if aPoint is in the title bar."
	^(self shell titleRectFrom: self shell frameLeftTop) containsPoint: aPoint! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PActionButton methods ! 
readSpecificsFrom: aWidget

    super readSpecificsFrom: aWidget.
    self action: aWidget action asString.! !

!LayoutFrame methods !   
wbBottomAttachedToTop: aBoolean
	"Set true if the receiver's bottom is attached to the receiver's top."

	self propertyAt: #wbBottomAttachedToTop put: aBoolean.
	^aBoolean! !

!WindowBuilder methods !
menuEditPasteWindowBitmapToClipboard

    Clipboard setBitmap: self layoutForm layoutAsBitmap! !

!WBAbstractAddInModule class methods !  
modifyProperties: theProperties
    "Modify the properties"! !

!WBMultiListChooser methods !  
ok

    reply := (self paneNamed: 'list') selectedItems.
    self mainView close! !

!PCompositePane methods !   
children: aCollection

    children := aCollection! !

!WBMenu methods !  
checkItem: item
        "Place a check mark on an item.
         item can be the label or the selector."
    (self isThere: item) ifFalse: [^nil].
    (self getMenuItem: item) check.! !

!WBLayoutWizard class methods !  
defaultMenus: aCollectionOfStrings

    DefaultMenus := aCollectionOfStrings! !

!WBInterfaceObject methods ! 
staysToBack

    ^false! !

!WBActionLinkAddInModule class methods !  
commonName

	^'Action and Link Button Support'! !

!WBInterfaceObject methods !   
isCompositePane

    ^false! !

!WBLayoutForm methods !   
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received."
    | virtualKey |
    virtualKey := aKeyboardInputEvent virtualKey.
    (self arrowKeyInput: virtualKey)
        ifFalse: [super keyboardInput: aKeyboardInputEvent].! !

!ByteArray methods !
wbStoreOn: aStream

	aStream nextPutArrayOfBytes: self.
	aStream generateByteArrayCode ifFalse: [
		aStream
			space;
			nextPutAll: #asByteArray].! !

!PCompositePane methods ! 
styles

    ^Smalltalk platformIsWin32
        ifTrue: [
            #(#defaultStyle #borders #scrollbars #verticalScrollBar #mdiToolBar #mdiToolBarBordered) ]
        ifFalse: [
            #(#defaultStyle #borders #scrollbars #verticalScrollBar) ]
! !

!WBTreeListBox class methods !
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #textChanged:;
        add: #preSelect:;
        yourself! !

!WBInterfaceObject class methods !   
newFromStyle: style classID: classID rect: aRect text: aString resID: id

	| pWidget smalltalkClass theStyle |

	(smalltalkClass := self classFrom: classID and: style) == PGenericSubpane 
		ifTrue: [pWidget := PGenericSubpane new realClass: SubPane] 
		ifFalse: [
			pWidget := smalltalkClass wbPseudoClass.
			theStyle := pWidget styleFrom: style.
			pWidget := pWidget new.
			pWidget realClass: smalltalkClass].
	pWidget 
		contents: aString;
		rect: aRect;
		resID: id;
		style: theStyle;
		framingBlock: aRect asLayout.
	pWidget font isNil 
		ifTrue: [pWidget font: pWidget defaultFont].
	^pWidget! !

!WBPoolManagerWindow methods !
updateActiveCategory: aCategory

	activeCategoryField selection: aCategory.
	self updateActiveCategoryMenu: aCategory.! !

!PComboBox methods !  
displayWith: aPen clipRect: clipRect

    self lookPolicy
        drawComboBox: self
        with: aPen
        clipRect: clipRect! !

!WindowBuilder methods !
customPanes

	CustomPanes isNil
		ifTrue: [CustomPanes := SortedCollection new].
	^CustomPanes! !

!PropertyAccessor methods !  
wbMutateFrom: anObject to: copyObject using: aPropertyManager
	"Mutate the property."

	#addedByOSI.
	(aPropertyManager getAccessor: self name ifAbsent: [^self])
		wbMutateValue: (self getValueFor: anObject)
		for: copyObject.
	^copyObject! !

!WindowBuilder methods ! 
inTeamV

	^self class teamIsInstalled! !

!WBLookPolicyWin95 methods !
titleRectFrom: aFrameObject

    | aPoint titleRect leftIndent rightIndent |
    aPoint := aFrameObject frameLeftTop.
    titleRect := (aPoint extentFromLeftTop: aFrameObject extent) insetBy: (self borderWidthFrom: aFrameObject).
    titleRect := titleRect leftTop extentFromLeftTop: titleRect width @ (self titleBarHeightFrom: aFrameObject).
    leftIndent := rightIndent := 0.
    (aFrameObject style includes: #sysmenu)
        ifTrue: [
            aFrameObject isDialog
                ifFalse: [leftIndent := self systemMenuWidth].
            rightIndent := self closeButtonSize x + 4].
    ((aFrameObject style includes: #maximize) or: [aFrameObject style includes: #minimize])
        ifTrue: [rightIndent := rightIndent + self minimizeButtonSize x + self maximizeButtonSize x].
    aFrameObject isDialog
        ifFalse: [rightIndent := rightIndent + 0].
    ^(titleRect left right: leftIndent) @ titleRect top
        extentFromLeftTop: (titleRect width - rightIndent - leftIndent) @ titleRect height.! !

!WBPoolManagerWindow class methods !  
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBGeometryManager methods ! 
selectAllInSameClass

    self layoutForm selectAllInSameClass! !

!WBBitmapManagerWindow methods !   
menuCategoryNew: aCollection

	| aBitmap |
	aCollection do: [:eachCategory |
		self poolManager addCategory: eachCategory.
		self poolManager pools do: [:eachPool |
			eachPool keys do: [:eachKey |
				eachPool at: eachKey in: eachCategory ifAbsentPut: [
					aBitmap := eachPool at: eachKey.
					self sameValueForAllCategories | aBitmap isOperatingSystemBitmap
						ifTrue: [aBitmap]
						ifFalse: [aBitmap wbCopy]]]]].! !

!ViewManager class methods ! 
isScratchWindow
         "Private - WBPro Development."
    #addedByOSI.
    ^false! !

!Rectangle methods ! 
moveToLeftTop: aPoint
        "Private - WBPro Development."
    #addedByOSI.
    self moveBy: aPoint - self leftTop! !

!WBMenuEditor methods ! 
newDividerState: selection

    | isNowDivider  |

    isNowDivider := selection.

    keyShortCutEditor text: ''.

    hasAccelCheckBox selection: false.
    self disableAttributes: (self allowAttributesFor: menuItemsEditor selectedItem) not | isNowDivider.

    isNowDivider ifTrue: [
        menuItemsEditor setSelectionText:  '--------'.
     ].! !

!WBNLSManagerWindow methods !
addEditorCompositePaneTo: aModel

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	
	(editorCompositePane := WBNLSEditorCompositePane new)
		definedIn: #addEditorCompositePaneTo:;
		owner: aModel;
		setName: 'editorCompositePane';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2; leftInset: 0 * xDU;
				topRatio: 0; topInset: 141/2 * yDU;
				rightRatio: 1; rightInset: 3 * xDU;
				bottomRatio: 1; bottomInset: 5/2 * yDU);
		startGroup;
		noTabStop.
	^editorCompositePane! !

!WBOutboardWindow methods ! 
undoManager

	^self owner undoManager! !

!WBTabOrderLayoutForm methods ! 
usesFocus

    ^false! !

!WBPool methods !   
fileOutCategories: aCollection on: aStream
	"File out the receiver's contents."

	| aSubPool |
	self fileOutHeaderOn: aStream.
	aCollection asSortedCollection do: [:each |
		(aSubPool := self subPoolFor: each) notNil ifTrue: [
			aSubPool fileOutOn: aStream]].
	self fileOutFooterOn: aStream.! !

!WindowBuilder methods !   
styleLabel

	^styleText! !

!WBCodeStream methods !   
contents
		"Answer the receiver's contents."
	^stream contents! !

!WBBitmapManagerWindow methods !   
menuKeyResizeBitmap: keysAndPoolsCollection categories: categoriesCollection
    all: resizeAll from: oldExtent to: newExtent operation: aSymbol

    | aBitmap |
    oldExtent = newExtent ifTrue: [^self].
    keysAndPoolsCollection do: [:eachKeyAndPool |
        categoriesCollection do: [:eachCategory |
            aBitmap := eachKeyAndPool value
                at: eachKeyAndPool key
                in: eachCategory
                ifAbsent: [nil].
            (aBitmap isBitmap and: [resizeAll or: [aBitmap extent = oldExtent]]) ifTrue: [
                aBitmap extent = newExtent ifFalse: [
                    eachKeyAndPool value
                        at: eachKeyAndPool key
                        in: eachCategory
                        put: (aBitmap perform: aSymbol with: newExtent)]]]].! !

!WBPoolManagerWindow methods ! 
promptForNewFileName: titleString
	"Prompt the user for a new file."

	| selectedPool |
	selectedPool := self selectedPool.
	^self 
		promptForNewFileName: (selectedPool isNil 
			ifTrue: [self defaultNewFileName] 
			ifFalse: [selectedPool poolName, self defaultExtension])
		title: titleString! !

!Screen methods !  
wbPointFromUser: aRectangle offset: anOffset executing: aBlock
        "Private - WBPro Development.  Display aRectangle
            and answer a point selected by the user.
            Execute aBlock for each location."

    | oldLoc oldCorner loc newCorner |
	#addedByOSI.
    oldLoc := Cursor sense - anOffset.
    oldCorner := oldLoc + aRectangle extent.
    graphicsTool setRop2: R2Notxorpen;
        place: oldLoc;
        box: oldCorner.
    Notifier consumeInputUntil: [: event |
        loc := Cursor sense - anOffset.
        aBlock isNil ifFalse: [ aBlock value: loc ].
        oldCorner := oldLoc + aRectangle extent.
        newCorner := loc + aRectangle extent.
        loc ~= oldLoc
            ifTrue: [
                graphicsTool
                    place: oldLoc;
                    box: oldCorner;
                    place: loc;
                    box: newCorner.
                oldLoc := loc].
        event selector = #button1Down:].
    "Added by OSI."
    graphicsTool
        place: loc;
        box: newCorner.
    ^loc! !

!WBTreeListBox methods !   
indent

    self selectedItem indent.
    owningEditBox setFocus.! !

!Dictionary methods !  
isValidNLSDictionary
    "Added by OSI to determine if the receiver is a valid NLS dictionary"
    #addedByOSI.
    self associationsDo: [:assoc |
        (assoc key isString
            and: [assoc key notEmpty
            and: [assoc key first isUppercase
            and: [assoc value isString]]]) ifFalse: [^false]].
    ^true! !

!WBTabOrderEditor methods !  
owner

	^owner! !

!WBCreateMenuModule methods !  
initVarNames
		"Private - Initialize the variable names."
	super initVarNames.
	self
		varNameFor: #pane ifAbsentPut: [ self defaultPaneName ];
		varNameFor: #target ifAbsentPut: [ self defaultTargetName ];
		varNameFor: #owner ifAbsentPut: [ self defaultOwnerName ].! !

!WBInterfaceObject methods !  
extraHandlers

    ^#()! !

!WindowBuilder class methods !
userPropertyString

    ^#UserProperties! !

!String methods !
asUnarySelectorToken
		"Answer the receiver as a unary selector token."
	| answer |
	#addedByOSI.
	((answer := self asBasicToken) isEmpty
		or: [ answer first isLetter not ])
			ifTrue: [ answer := 'a', answer ].
	^answer! !

!WBCreateClassDialog class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBEditClassDialog methods ! 
selectedClass

    ^selectedClass! !

!WBModelObjectEditor methods !  
setIsInstVar: aBoolean

    | selectedObject |
    instVar perform:
        (aBoolean = true
            ifTrue: [#check]
            ifFalse: [#uncheck]).
    nameLabel    contents:
        (aBoolean = true
            ifTrue: ['I-Var:']
            ifFalse: ['Name:']).
    (selectedObject := self selectedObject) notNil
        ifTrue: [selectedObject isInstVar: aBoolean].! !

!WBAbstractCodeModule methods !
policy
		"Answer the receiver's code policy."
	^self owner policy! !

!WBTemplateEditor methods ! 
redisplaySelection

	self redraw! !

!WBTargetObject methods !
realClass

	^realClass! !

!WBTabOrderEditor methods !
includeOuter

	self class includeOuter: self class includeOuter not.
	self setIncludeOuter! !

!PEntryFieldGroup methods !   
styleMap

    ^super styleMap
        at: #verticalScrollBar put: #(#addVerticalScrollbarStyle #addBorderStyle);
        yourself.! !

!WindowBuilder class methods !   
useFence

    ^self editorClass
        propertyValueAt: #UseFence
        category: self editorPropertyString! !

!WBNLSEditorCompositePane methods !  
updateValue

	| aValue |
	(aValue := self selectedValue) notNil
		ifTrue: [
			valueEditLabel wbGrayEnable.
			valueEditField enable.
			valueEditField contents = aValue ifFalse: [
				valueEditField contents: aValue]]
		ifFalse: [
			valueEditLabel wbGrayDisable.
			valueEditField disable.
			valueEditField contents: ''].! !

!WBModelObjectEditor methods ! 
sendChanged: aString
    "Callback for the #textChanged: event in send [WBEntryField]"
    "(Generated by WindowBuilder Pro)"

    (aString isEmpty or: [self selectedObject isNil]) ifTrue: [^self].
    (send contents wbValidTriggeredSelectorFor: self currentEvent) =
        (self selectedObject eventHandlerSelectorAt: self currentEvent) ifTrue: [^self].
    self saveWhenSend.
    self owner setDirty.! !

!WBFramingEditor methods !  
originYAnchorChanged: selectedItem

    selectedItem = 'Pane bottom'
        ifTrue:
            [cornerYAnchor disableItem: 'Pane top'.
            ]
        ifFalse:
            [cornerYAnchor enableItem: 'Pane top'.
            ].
    self setExampleRects.! !

!WBColorDialog methods !   
ok

    | c |

    result := Array new: 2.
     (c := (self paneNamed: 'foreColorList') selectedItem) = #default ifTrue: [
        result at: 1 put: nil.
    ] ifFalse: [
        result at: 1 put: (Color perform: c).
    ].

     (c := (self paneNamed: 'backColorList') selectedItem) = #default ifTrue: [
        result at: 2 put: nil.
    ] ifFalse: [
        result at: 2 put: (Color perform: c).
    ].

    self close.! !

!WBLayoutWizard methods !   
disableFields

    #('upButton' 'downButton' 'instVarButton' 'otherTypeButton' 'setDefaultTypeButton'
        'widgetUpdatesModelButton' 'modelUpdatesWidgetButton' 'modelInitializesWidgetButton') do: [:name |
        (self paneNamed: name) disable].
    (self paneNamed: 'classLabel') foreColor: Color darkGray.
    (self paneNamed: 'widgetTypeLabel') foreColor: Color darkGray.
    (self paneNamed: 'attributeClass') disable; contents: self emptyString.
    (self paneNamed: 'widgetType') disable; value: nil.! !

!WBBitmapEditorCompositePane methods !   
setSameBitmapForAllCategories: aBoolean pane: aPane

	"Callback for the #clicked: event in sameBitmapButton [CheckBox].
		(Generated by WindowBuilder Pro)"! !

!WindowBuilder methods ! 
menuAddRemoveCustomPane

	| result |
	result := WBListChooser fromList: self customPanes prompt: 'Remove which pane?'.
	result isNil ifTrue: [^self].
	(self customPanes includes: result)
		ifTrue: [
			self customPanes remove: result.
			customSubMenu removeItemDynamically: result].
	self updateMenuAdd.! !

!PEnhancedEntryField methods !
justification: aSymbol

    justification := aSymbol! !

!WBGeometryManager methods ! 
updateWidget

    self updateWidget: self layoutForm! !

!WindowBuilder methods ! 
updateSendField

	| selector isTriggered current |
	thePane supportedEvents isEmpty & thePane eventsTriggered isEmpty
		ifFalse: [currentWhen := when selectedItem]
		ifTrue: [
			currentWhen := #none.
			perform contents: ''].
	perform setPopupMenu: nil.
	current := self currentEvent.
	isTriggered := self currentEventIsTriggered.
	selector := isTriggered
		ifTrue: [thePane eventHandlerSelectorAt: current]
		ifFalse: [thePane oldEventHandlerSelectorAt: current].
	(self paneNamed: 'performText')
		contents: (isTriggered
			ifTrue: ['Send:']
			ifFalse: ['Perform:']).
	perform 
		contents: (selector isString
			ifTrue: [selector]
			ifFalse: ['  *****  ']).
	! !

!WBAttributeWindow methods ! 
aboutToDiscardChanges
		"Prompt the user to discard changes.
			Answer true if discard, false if don't discard."
	^MessageBox confirm: 'Discard the changes?'! !

!PStatusPane methods ! 
staysToBack

    ^true! !

!WBLayoutForm methods !
motionState
    "Answer the value of motionState."

    ^motionState! !

!WBOutboardWindow methods ! 
preInitWindow

	self mainView children do: [:each | each font: SysFont].
	self mainView backColor: Color gray.
	self mainView
		when: #opened send: #opened to: self;
		when: #activated send: #activated to: self;
		when: #aboutToClose send: #aboutToClose to: self;
		when: #closed send: #closed to: self.
	ownerChanged := false.! !

!BitEditor methods !   
fillAt: aPoint

    | imagePoint originalColor |
	imagePoint := aPoint // scale.
    originalColor := GDILibrary getPixel: copy pen handle
        x: imagePoint x
        y: imagePoint y.
    copy pen backColor: bitColor.
    GDILibrary extFloodFill: copy pen handle
        x: imagePoint x
        y: imagePoint y
        color: originalColor
        fillType: Floodfillsurface.

    self displayImage: imagePen graphicsMedium.
    self displayBits: bitPen graphicsMedium.! !

!WBFontSubPool methods !   
fileOut: anAssociation on: aStream
	"File out the specified key/value pair."

	anAssociation value isFont ifFalse: [^self].
	aStream cr;
		nextPutAll: #at: ;
		space;
		nextPutAll: anAssociation key storeString;
		space;
		nextPutAll: #in: ;
		space;
		nextPutAll: self category storeString;
		space;
		nextPutAll: #put: ;
		openParenthesis;
		noParenthesis;
		cr;
		nextPutFontDef: anAssociation value;
		closeParenthesis;
		endMessage.! !

!WBLayoutForm class methods !  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #cursorUnloaded;
        add: #selectionChanged:;
        add: #changed;
        add: #editPane;
        add: #gettingFocus;
        add: #rightButtonDown:;
        yourself! !

!WBPoolManagerWindow methods !   
menuPoolDelete

    "Callback for the menu item titled 'Delete'.
     (Generated by WindowBuilder)"

	| msg |
	self selectedPools isEmpty ifTrue: [^self].
	msg := self selectedPools size = 1
		ifTrue: [ 'Delete the pool named ', self selectedPools first poolName, '?' ]
		ifFalse: [ 'Delete ', self selectedPools size printString, ' pools?' ].
	(MessageBox confirm: msg) ifFalse: [^self].
	[self menuPoolDelete: self selectedPools]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].! !

!Object methods !
wbMutateTo: anObject
	"Mutate the receiver's properties into anObject."

	#addedByOSI.
	"Default is to copy nothing during mutation."
	^anObject! !

!WBHandle methods !   
setLocator: aLocator
    locator := aLocator! !

!WBLookPolicy methods !   
titleBarHeightFrom: aFrameObject

    ^aFrameObject hasTitleBar
        ifTrue: [self titleBarHeight]
        ifFalse: [0]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WindowBuilder methods !
hasCompositeSelection

	^self hasSelections and: [self selections first isCompositePane]! !

!PStaticGraphic methods !
displayWith: aPen clipRect: clipRect

    self displayGenericWith: aPen clipRect: clipRect! !

!WindowBuilder methods !   
menuToolsInspectUndoManager

    self undoManager inspect! !

!PEntryFieldGroup methods ! 
mutationExceptions

    ^#(#CPScrollingPane)! !

!WBLayoutFrameEditor methods !   
attachProportionalLeftTopRight

    "Callback for the WBToolBar named ''.
     (Generated by WindowBuilder)"

	self attach: (
		Array
			with: self proportional
			with: 0
			with: self proportional
			with: 0).! !

!WBLayoutForm methods !   
button1MotionResizingShell: aPoint
    "Process a motion event that occurred while we are resizing the shell."

    | x y delta |
    x := aPoint x left: self cursorOffset first x.
    y := self rectangle top distanceDown: (aPoint y up: self cursorOffset first y).
    delta := self shell isDialog
        ifTrue: [(self shell borderWidth * 2) @ ((self shell borderWidth * 2) + self shell titleHeight)]
        ifFalse: [0@0].
    x := x left: delta x.
    y := y - delta y.
    self useGrid
        ifTrue: [
            x := x roundTo: (self gridSize x max: 1).
            y := y roundTo: (self gridSize y max: 1)].
    self
        drawBand;
        resizeBand: ((x @ (self rectangle top down: y)) rightAndDown: delta);
        drawBand.

    self notifyModelOfShellSizeChange: (bandRect leftTop extentFromLeftTop: (x @ y) - (self handleSize // 2)).! !

!WBToolBarEditor methods !
remove

    | index |
    index := list selection.
    index isNil ifTrue: [ ^nil ].
    elements removeIndex: index.
    list
        contents: (elements collect: [ :element | element selector asString ]);
        selection: (index min: elements size).

    self updateButtons.! !

!PropertyManager methods ! 
wbCopyFrom: anObject to: copyObject
	"Copy properties in anObject to copyObject."

	| propMgr |
	#addedByOSI.
	propMgr := copyObject wbPropertyManager.
	self associationsDo: [:each | each wbCopyFrom: anObject to: copyObject using: propMgr].
	^copyObject! !

!WBPrototype methods ! 
exportToResFile: fName

	| i hFile f theName dlgTemplate items fStyle r tempByteArray |
	theName := fName.
	((fName size < 3) or: [((fName copyFrom: fName size - 2 to: fName size) asUpperCase = 'RES') not])
		ifTrue: [theName := fName , '.res'].
	f := File newFile: theName.
	hFile := File newFile: (theName copyFrom: 1 to: theName size - 3) , 'H'.
	i := 0.
	self children do: [:p |
			p paneName notNil
				ifTrue: [
					i := i + 1.
					hFile
						nextPutAll: '#define    ' , p paneName asString , '    ' , i asString;
						cr]].
	hFile close.
	r := shell rect origin extent: (shell frameContentRect extent / self realDialogUnit) rounded.
	fStyle := DsNoidlemsg | WsClipchildren | WsPopup.
	(shell style includes: #sysmenu)
		ifTrue: [fStyle := fStyle | WsSysmenu].
	(shell style includes: #titlebar)
		ifTrue: [fStyle := fStyle | WsCaption].
	(shell style includes: #sysmodal)
		ifTrue: [fStyle := fStyle | DsSysmodal | DsModalframe].
	(shell style includes: #modal)
		ifTrue: [fStyle := fStyle | DsModalframe]
		ifFalse: [fStyle := fStyle | WsBorder].
	dlgTemplate := WinDialogInfo
			dialogTemplateStyle: fStyle
			itemCount: 0
			x: r origin x
			y: r origin y
			cx: r extent x
			cy: r extent y
			menuName: nil
			className: nil
			text: shell contents.
	items := self convertWidgetsToRes: shell contents.
	dlgTemplate byteAtOffset: 4 put: items size.
	tempByteArray := dlgTemplate contents.
	items do: [:each |
		tempByteArray := tempByteArray , each contents].
	dlgTemplate contents: tempByteArray.
	"Resource Header"
	#(255 5 0 66 0 16 240) do: [:b |
			f nextBytePut: b].
	f
		nextTwoBytesPut: dlgTemplate contents size;
		nextBytePut: 0;
		nextBytePut: 0.
	dlgTemplate contents do: [:b |
			f nextBytePut: b].
	f close.! !

!WBOutboardAttributeWindow methods !  
result
    "Always return nil because it is the responsibility
        of the receiver to make the modification to the pane,
        add the modification to the undo manager, and
        notify the owner via the setDirty message."

    ^nil! !

!WBLayoutForm methods !  
cursorSelectPoint: aPoint
    "Set the value of cursorSelectPoint."

    cursorSelectPoint := aPoint.! !

!WBHandle methods !
extent

	^HandleSize! !

!WBLayoutWizard methods !
useSourceModel

    self selectModel: (self paneNamed: 'modelList') selectedItem
! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLinkEditor class methods ! 
descriptions

    Descriptions isNil ifTrue: [
        (Descriptions := Dictionary new)
            at: 'Independent' put: 'Opens the selected window with no parent.';
            at: 'Child' put: 'Opens the selected window as a child of the current window.';
            at: 'MDIChild' put: 'Opens the selected window as an MDI child of the current MDI parent window.';
            at: 'Sibling' put: 'Opens the selected window as a child of the current window''s parent.'.
    ].
    ^Descriptions! !

!PEntryField methods ! 
contents

	^super contents = ''
		ifTrue: [nil]
		ifFalse: [super contents]! !

!WBMultiToolPalette methods !   
addPage: aPage name: name
    self pages at: name put: aPage.
    ^aPage! !

!WBPropertyManager class methods !   
current
	"Answer the current overall property manager."

	^self! !

!WBEventManagerWindow methods !  
update

	super update.
	widgetList := nil.
	widgetFilterBox update.
	self 
		widgetListUpdate;
		updateLabel.! !

!WBCreateBitmap methods !  
result

    ^result! !

!WBOutboardAttributeWindow methods !  
apply
	"Callback for the #clicked event in <Unnamed> [Button]
		(Generated by WindowBuilder Pro)"

	self applyChange.
	self dirty: false.
	self setDirty.! !

!WBCodeStream methods ! 
nextPutBitmap: aBitmap
	"Append a bitmap reference.  Answer true if found,
		false if not found."

	WBBitmapManager managers do: [:eachManager |
		eachManager pools do: [:eachPool |
			eachPool pool associationsDo: [:eachAssoc |
				aBitmap == eachAssoc value ifTrue: [
					self
						nextPutValue: aBitmap
						key: eachAssoc key
						pool: eachPool
						manager: eachManager.
					^true]]]].
	self
		nextPutAll: #WBBitmapManager;
		space;
		nextPutAll: #current;
		space;
		nextPutAll: #anyBitmap.
	^false! !

!WBAbstractAddInModule class methods !  
modifiesMenus
    "Does this add-in modify the menus?"

    ^false! !

!Window methods ! 
getId
        "Private - WBPro Development."
    | i |
    #addedByOSI.
    (i := self id) isNil ifTrue: [
        ^1
    ].

    ^i! !

!WBStatusPaneEditor methods !  
up

	| box index |
	index := list selection.
	index isNil ifTrue: [^nil].
	box := boxes at: index.
	index == 1 ifTrue: [^nil].
	boxes removeIndex: index.
	boxes add: box beforeIndex: index - 1.
	list
		contents: (boxes collect: [:each | each name asString]);
		selection: index - 1.

	self updateBoxes.! !

!WBInstVarObject methods !  
isWBInstVarObject

	^true! !

!WBScrollingPane methods !  
setScrollRanges: redraw

    | oldRange newRange visibleExtent childSize f |

    visibleExtent := self visibleExtent.
    oldRange := self getScrollRanges.
    childSize := self childSize.
    newRange := (childSize - visibleExtent + 10) max: 0@0.


   UserLibrary
        setScrollRange: self asParameter
        bar: SbHorz
        min: 0
        max: newRange x
        redraw: redraw.

    UserLibrary
        setScrollRange: self asParameter
        bar: SbVert
        min: 0
        max: newRange y
        redraw: redraw.

    ^f = true! !

!WBLookPolicyOS2 methods !
scrollBarColor

    ^Color gray! !

!WBLocator class methods !
copyAt: aFigure
        ^self copyAt: aFigure ifAbsent: [aFigure copy]! !

!PColumnListBox methods !   
styles

    ^nil! !

!WBLookPolicy methods !  
drawCheckBox: aCheckBox with: aPen clipRect: clipRect

    | aPoint |
    self
        drawToggle: aCheckBox
        with: aPen
        clipRect: clipRect.
    aPoint := aCheckBox rect left @ (aCheckBox rect center y up: self iconExtent y // 2).
    aPen drawRectangle: (aPoint extentFromLeftTop: self iconExtent).! !

!WBTabOrderLayoutForm methods !  
useFence
    "Answer the value of useFence."

	^true! !

!WindowBuilder methods !
currentLayoutForm: aWBLayoutForm

    currentLayoutForm := aWBLayoutForm! !

!WBLayoutWizard methods !
setDefaultStandardButtons

    self class defaultButtons: (self paneNamed: 'standardButtonsList') value.
    self loadStandardButtons.! !

!WBLookPolicyWin95 methods !  
drawRadioButton: aRadioButton with: aPen clipRect: clipRect

    | aPoint boundingBox |
    self
        drawToggle: aRadioButton
        with: aPen
        clipRect: clipRect.
    aPoint := aRadioButton rect left @ (aRadioButton rect center y up: self iconExtent y // 2).
    OperatingSystem isWindows95
        ifTrue: [
            aPen
                copyBitmap: self class radioBitmap
                    from: (0@26 extent: 13@13)
                    to: (aPoint extent: self iconExtent)
                    rule: 15597702; "CopyRuleSourcePaint"
                copyBitmap: self class radioBitmap
                    from: (39@13 extent: 13@13)
                    to: (aPoint extent: self iconExtent)
                    rule: 12255782; "CopyRuleMergePaint"
                copyBitmap: self class radioBitmap
                    from: (0@13 extent: 13@13)
                    to: (aPoint extent: self iconExtent)
                    rule: 8913094 "CopyRuleSourceAnd"]
        ifFalse: [
            boundingBox := aPoint extentFromLeftTop: 12@12.
            aPen
                foreColor: Color black;
                place: boundingBox center;
                partialArc: boundingBox width // 2 minor: boundingBox height // 2 angles: -30@-220;
                foreColor: Color white;
                place: boundingBox center;
                partialArc: boundingBox width // 2 minor: boundingBox height // 2 angles: -30@140.
            boundingBox := boundingBox insetBy: 1.
            aPen
                foreColor: Color black;
                place: boundingBox center;
                partialArc: boundingBox width // 2 minor: boundingBox height // 2 angles: -30@-220;
                foreColor: Color gray;
                place: boundingBox center;
                partialArc: boundingBox width // 2 minor: boundingBox height // 2 angles: -30@140;
                foreColor: Color white;
                backColor: Color white.
            OperatingSystem isOS2
                ifTrue: [
                    aPen
                        place: boundingBox center; down;
                        circle: boundingBox width // 2 - 1;
                        foreColor: Color darkGray;
                        place: boundingBox center; down;
                        circle: boundingBox width // 2;
                        foreColor: Color black;
                        place: boundingBox center; down;
                        circle: boundingBox width // 2 + 1]
                ifFalse: [aPen ellipse: (boundingBox insetBy: 1)]]! !

!WindowBuilder class methods !  
serialNumber
    "Answer the window builder serial number."

    | answer |
    self licensed ifFalse: [^''].
    answer := self serialNumberPrim.
    "
    answer = '' | answer isNil ifTrue: [
        self promptForUserInfo.
        answer := self serialNumberPrim].
    "
    ^answer ifNil: ['']! !

!PComboBox class methods ! 
styleFrom: style

	^(style bitIsOn: CbsDropdownlist)
		ifTrue: [#dropDownList]
		ifFalse: [
			(style bitIsOn: CbsDropdown)
				ifTrue: [#dropDown]
				ifFalse: [#simpleList]].! !

!WBGeometryManager methods !
alignCenterHorizontally
    "Align the selected widgets along their horizontal centers"

    | target selections origins aWidget redoBlock |
    (selections := self selections copy) size > 1 ifFalse: [^self].
    target := selections first.
    origins := selections collect: [:widget | widget origin].
    self undoManager
        add: 'Align Center Horizontal'
        undo:
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (origins at: i) x
                    y: (origins at: i) y;
                    wbUpdateConstraints]]
        redo: (redoBlock :=
            [self hideHandlesExceptFor: target.
            2 to: selections size do: [:i |
                (aWidget := selections at: i)
                    moveWidget: (target x + ((target width - aWidget width) // 2))
                    y: aWidget y;
                    wbUpdateConstraints]]).
    redoBlock value.
    self updateWidget.! !

!PGraphPane methods !   
displayWith: aPen clipRect: clipRect

    style == #noBorders
        ifTrue: [^self displayWithNoBorder: aPen].
    style == #noScrollBars
        ifTrue: [
            ^self lookPolicy
                displayWithBorder: aPen
                rect: self rect
                backColor: self backColor].
    self lookPolicy
        displayWithRightBottomScrollBars: aPen
        rect: self rect
        backColor: self backColor! !

!WBPropertyEditor methods !
cancel

	self close! !

!WBModelDefinitionEditor methods !
enableFields

    name enable; backColor: Color white.
    (self paneNamed: 'nameLabel') foreColor: Color black.
    myClass enable; backColor: Color white.
    (self paneNamed: 'classLabel') foreColor: Color black.
    hasAccessors enable.
    initialized enable.
    (self paneNamed: 'otherClassButton') enable.
    initialized selection & hasAccessors selection
        ifTrue: [lazy enable]
        ifFalse: [lazy selection: false; disable].
    hasAccessors selection
        ifTrue: [hasEvent enable]
        ifFalse: [hasEvent selection: false; disable].! !

!WBFontEditorCompositePane methods !
updateValue

	| value |
	self addSubpanesOnce.
	value := self selectedValueForAll.
	self
		enableFields: value;
		updateValue: value.! !

!WBBitmapManagerWindow methods !   
menuKeyNewButton

    "Callback for the menu item titled 'New...'.
     (Generated by WindowBuilder)"

	| newKey newAssoc newBitmap |
	newAssoc := WBCreateButton new
		openOn: self defaultNewKey;
		result.
	newAssoc isNil ifTrue: [^self].
	newKey := self checkNewKey: newAssoc key.
	newKey isNil ifTrue: [^self].
	newBitmap := newAssoc value.
	self menuKeyNew: (Array with: newKey => newBitmap).! !

!WBChoosePaneDialog methods !  
classList: listOfClasses

    self abstractPaneList do: [ :cn |
        (Smalltalk includesKey: cn) ifTrue: [
            listOfClasses remove: (Smalltalk at: cn) ifAbsent: [ nil ]
        ].
    ].
    (listOfClasses includes: ScrollBar) ifTrue: [
        listOfClasses
            remove: ScrollBar;
            add: WBHorizontalScrollBar;
            add: WBVerticalScrollBar.
    ].
    ^self classList: listOfClasses default: listOfClasses first! !

!WBPoolManagerWindow methods !  
menuKeyMove: aCollection toPool: newPool

	| aKey oldPool anAssoc values aValue |
	aCollection do: [:each |
		aKey := each key.
		oldPool := each value.
		anAssoc := oldPool associationAt: aKey.
		values := Dictionary new.
		oldPool categories do: [:eachCat |
			(aValue := oldPool at: aKey in: eachCat ifAbsent: [nil]) notNil ifTrue: [
				values at: eachCat put: aValue]].
		oldPool removeKey: aKey.

		#osiHack.
		"The process of calling Team/V to remove a pool variable from the system
			causes the pool variable association key to be changed to a symbol !!!!!!
			So change it back to a string."
		anAssoc key: aKey.

		newPool add: anAssoc.
		values associationsDo: [:eachAssoc |
			newPool at: aKey in: eachAssoc key put: eachAssoc value]].! !

!PLinkButton methods !
type: aString

    type := aString! !

!WindowBuilder methods !   
triggerChanged
	"Trigger the changed event."

	self triggerEvent: #changed.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventManagerWindow methods ! 
methodTextSaved: aPane

	"Callback for the #saved event triggered in the TextPaneControl named 'methodTextEdit'.
	 (Generated by WindowBuilder)"

	| aClass bClass aString aHandler newHandler codeModule |
	(aHandler := self handlerSelected) isNil ifTrue: [
		self mustHaveOneActionListSelected ifFalse: [^self].
		aHandler := Message new
			source: self widgetSelected;
			event: self eventSelected;
			receiver: self toFieldSelection;
			yourself].
	aHandler receiver isNil ifTrue: [^self].

	aClass := aHandler receiver wbRealClass.
	aClass isScratchWindow ifTrue: [^self].
	bClass := aClass.
	[bClass notNil and: [
		(bClass compiledMethodAt: aHandler selector asSymbol) isNil
	]] whileTrue: [bClass := bClass superclass].
	aClass == bClass | bClass isNil ifFalse: [
		aClass := WBListChooser
			fromList: (Array with: aClass with: bClass)
			prompt: 'Compile method into which class?'].
	aClass isNil ifTrue: [^self].
	self warningClasses do: [:each |
		(aClass inheritsFrom: each) ifTrue: [
			(MessageBox confirm:
				'WARNING!!  You are about to add or modify a method in ', aClass name,
				' which is a subclass of ', each name, '.  Continue?'
			) ifFalse: [^self]]].

	aString := aPane contents.
	CursorManager execute changeFor: [
		((codeModule := WBBasicCodeModule new)
			messageSelector: aHandler selector;
			sourceString: aString;
			targetClass: aClass;
			createMethod) ifFalse: [^aPane modified: true]].
	(newHandler := aHandler copy) selector: codeModule messageSelector.
	newHandler = aHandler ifFalse: [
		aHandler selector isNil
			ifTrue: [newHandler add]
			ifFalse: [
				(MessageBox confirm:
					'Change send field of selected handler from #', aHandler selector asString,
					' to #', codeModule messageSelector asString, ' ?')
						ifTrue: [newHandler replace: aHandler]
						ifFalse: [newHandler := nil]].
		newHandler notNil ifTrue: [
			handlerListBox update.
			self handlerSelected: newHandler]].
	aPane modified: false.! !

!BitEditor methods !
fill
    | aPoint |
    Notifier consumeInputUntil: [: event |
        event selector = #button1Up: ].
    aPoint := Cursor sense mapScreenToClient: bitPen graphicsMedium.
    ((0 @ 0 extent: bitPen graphicsMedium rectangle extent)
        containsPoint: aPoint)
            ifTrue: [self fillAt: aPoint]! !

!CompositeFrameObject methods ! 
supportedEvents

    ^#()! !

!WBGraphicObject methods !  
displayWith: aPen

    ^self displayWithBorder: aPen! !

!WBFramerExample methods !   
frameRect: aRect

    frameRect := aRect.! !

!WBEventMessage methods !   
moveToIndex: anInteger
	"Move the receiver to anInteger position in the action sequence."

	| actions index |
	actions := self actionList.
	(index := self index) = anInteger ifTrue: [^self].
	actions :=
		(actions copyFrom: 1 to: index - 1),
		(actions copyFrom: index + 1 to: actions size).
	index := (anInteger min: actions size + 1) max: 1.
	actions := 
		(actions copyFrom: 1 to: index - 1),
		self asActionSequence,
		(actions copyFrom: index to: actions size).
	self actionList: actions.! !

!WBPMenuItem methods !  
accelerator: aKeyAccel

    keyAccel := aKeyAccel! !

!WindowBuilder class methods !  
addInModuleClass

    ^WBAbstractAddInModule! !

!WBLookPolicyWin31 methods ! 
drawMaximizeButtonWith: aPen at: aRect

    | innerRect |
    innerRect := self draw3DBoxWith: aPen at: aRect.
    aPen
        foreColor: Color white;
        wbLineFrom: (aRect leftTop rightAndDown: 1@1) to: (aRect leftBottom rightAndUp: 1@2);
        wbLineFrom: (aRect leftTop rightAndDown: 1@1) to: (aRect rightTop leftAndDown: 2@1);
        foreColor: Color gray;
        wbLineFrom: (aRect leftTop rightAndDown: 2@2) to: (aRect leftBottom rightAndUp: 2@3);
        wbLineFrom: (aRect leftTop rightAndDown: 2@2) to: (aRect rightTop leftAndDown: 3@2);
        foreColor: Color black;
        polygonFilled: (Array
            with: (innerRect center leftAndUp: 1@3)
            with: (innerRect center rightAndDown: 2@0)
            with: (innerRect center leftAndDown: 4@0)).! !

!WBEventManagerWindow methods !
widgetListBoxNeedsContents: aPane

    "Callback for the #needsContents event triggered in the MultipleSelectListBox named 'widgetListBox'.
     (Generated by WindowBuilder)"

	| oldSelection newContents filter selector |
	newContents := self widgetList.
	(filter := self widgetFilter) isClass
		ifTrue: [
			newContents := newContents select: [:each | each class == filter]]
		ifFalse: [
			(selector := self widgetFilters at: filter ifAbsent: [nil]) notNil ifTrue: [
				newContents := newContents select: [:each | each perform: selector]]].
	oldSelection := aPane selectedItems.
    aPane
		contents: newContents;
		selection: oldSelection.
	self zap.! !

!PropertyAccessor methods ! 
wbDefaultPoolName

	#addedByOSI.
	^nil! !

!WBCreateClassDialog methods !
defaultSuperClassFor: aType

    ^self class defaultSuperClassFor: aType! !

!WBLayoutFrameEditor class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!PEntryFieldGroup methods !  
text

    ^self label! !

!WindowPolicy methods ! 
addWindowBuilderMenu
	"Do Nothing"
	#addedByOSI.! !

!WBPropertyDescriptor methods !  
noDefaultFlag

    ^#noDefault! !

!WBLookPolicyWin95 methods !   
leftJustificationWordWrap

    ^"SsLeft" 0! !

!WBCreateViewModule methods !  
generateBody
		"Private - Generate the method body."
	self stream indentBy: 1 during: [
		self
			generateGeneratedSymbol;
			generateLayoutTemporaries;
			generateDefinitions;
			generatePanes;
			generateMenus ].! !

!WBLayoutForm methods !  
boundingBoxFor: aCollection
    "Answer the rectangle encompassing all the widgets in <aCollection>."

    ^aCollection
        inject: aCollection first boundingBox
        into: [:aRect :widget | aRect merge: widget boundingBox].! !

!WBMenu methods !  
appendSeparator
        "Append a separator line to the receiver menu."
    | mi |
    (mi := self menuItemClass new)
        position: nil;
        style: MfSeparator;
        attribute: 0;
        id: 0;
        label: nil;
        selector: nil;
        menu: self.
    items add: mi.
    accel add: nil.! !

!WBManagedPValue methods !  
value

	^value! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBInterfaceObject class methods !
clearClassAndStyleDict
	"	WBInterfaceObject clearClassAndStyleDict	 "
	ClassAndStyleDict := nil.! !

!WindowBuilder class methods !   
menuName

	^('\u' , self labelName) replaceEscapeCharacters! !

!WBToolMenuAddInModule class methods !
commonName

	^'Tools and Inspectors'! !

!WBPrototype methods !   
owner: aWindowBuilder

	owner := aWindowBuilder! !

!PWBToolBar methods ! 
suggestedSize

	^self elements isEmpty
		ifTrue: [self cellSize]
		ifFalse: [
			OperatingSystem isOS2
				ifTrue: [
					self vertical
						ifTrue: [(self cellSize x + 1) @ (elements first rectangle top + 2)]
						ifFalse: [((elements at: elements size) rectangle right + 2) @ (self cellSize y + 1)]]
				ifFalse: [
					self vertical
						ifTrue: [(self cellSize x) @ ((elements at: elements size) rectangle bottom + 2)]
						ifFalse: [((elements at: elements size) rectangle right + 2) @ (self cellSize y)]]]
! !

!WBCreateButton class methods !  
defaultBitmapWidth

	^25! !

!WBMenuItem methods !
menu: aMenu
        "Private - Set the menu parent of the menu item."
    menu := aMenu! !

!WBCodeStream methods !   
maxLineSize: anIntegerOrNil
		"Set the maximum number of characters per line.
			Nil indicates no maximum."
	maxLineSize := anIntegerOrNil.! !

!WBDevelopmentWindow methods !   
updateOtherButton: palette for: currentWidget
	"Update the 'other' button"

	(currentWidget notNil 
		and: [currentWidget hasOtherEditor 
		or: [currentWidget isCompositePane 
		and: [currentWidget isFrameObject not]]]) 
		ifTrue: [palette enableItem: #setOther]
		ifFalse: [palette disableItem: #setOther].! !

!WBTreeNode methods !   
isRoot

    ^parent isNil! !

!StylePropertyAccessor methods !
getValueFor: anObject

    "Private - Answer true if the style property is on."

    OperatingSystem isOS2 ifTrue: [
        self wbFrameStyle notNil ifTrue: [
            ^ anObject hasFrameCreationFlag: ( self pool at: self wbFrameStyle ifAbsent: [ ^self error: 'Unknown style' ])]].
    ^ anObject hasStyle: ( self pool at: self style ifAbsent: [ ^self error: 'Unknown style' ])! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCompositePaneModule methods !  
generatePanes
        "Private - Generate the pane definitions."
    self stream cr.
    self generatePane: self view.
    self children do: [:each |
        self stream cr.
        each creationMethodSelector isNil
            ifTrue: [self generatePane: each]
            ifFalse: [self generatePaneHandlersOnly: each].
        self generateAddPane: each to: self view using: #addSubpane:].! !

!WBEditClassDialog methods !  
ok

    "Callback for the #clicked event triggered in the Button named 'ok'.
     (Generated by WindowBuilder)"

    selectedClass isNil ifTrue: [^self].
    self class
        addToRecentList: selectedClass;
        addToFrequentList: selectedClass.

    self close.! !

!PDrawnButton methods !   
justFileName: pathName
	| fileName |
	fileName := (File splitPath: pathName in: Disk) at: 3.
	^(fileName occurrencesOf: $.) = 1
		ifTrue: [fileName upTo: $.]
		ifFalse: [fileName]! !

!WBInterfaceObject methods !   
defaultSize
    | size |
    (size := self suggestedSize) notNil ifTrue: [^size].
    ^140@100! !

!WBLookPolicyWin31 methods !  
menuBarHeight

    ^menuBarHeight ifNil: [
        menuBarHeight := (self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCymenu" 15]
            ifFalse: [super menuBarHeight]) + 1]! !

!WBCompositePaneModule methods !  
initVarNames
		"Private - Initialize the variable names."
	self varNameFor: self view ifAbsentPut: [ 'self' ].
	super initVarNames.! !

!WBInterfaceObject methods ! 
setWindowClass: aClass
	"Do nothing"! !

!WBPrototype methods !
object: object isInstVarIn: aWindow
        "Answer true if the object is an inst var in the view."
    1 to: aWindow class instSize do: [:index |
        (aWindow instVarAt: index) == object
            ifTrue: [
                (aWindow class allInstVarNames at: index) = object paneName
                    ifTrue: [^true]]].
    ^false! !

!WBMenuItem methods !
owner: anObject
        "Private - Set the owner of the menu item."
    owner := anObject! !

!WBApplicationCoordinatorModule methods !   
defaultOwnerName
        "Answer the default owner name."
    ^'aModel'! !

!PCompositePane methods ! 
copySpecificsTo: aPane

    aPane
        initialFraming: self initialFraming.! !

!WBVersionCodeModule methods !
defaultMessageSelector
		"Private - Answer the default message selector."
	^#wbBasicVersion! !

!WBDevelopmentWindow methods !
updateStyle: currentWidget
	"Update the style setting"

	(currentWidget isNil or: [currentWidget styles isNil])
		ifTrue: [
			self styleEditor
				contents: #(' ');
				selection: ' ';
				disable.
			self styleLabel disable]
		ifFalse: [
			self styleEditor
				contents: currentWidget styles;
				selection: currentWidget style;
				enable.
			self styleLabel enable].! !

!PEntryField methods !   
mutationExceptions

    ^#(#CPChildEntryField #Toggle #CPSpinEditor)! !

!WBTabOrderLayoutForm methods !  
moveGroupboxesToBack

	self children copy do: [:widget |
		widget staysToBack
			ifTrue: [
				self children remove: widget.
				self children addLast: widget]].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCodeGenBase methods !   
owner: anObject
		"Private - Set the receiver's owner."
	owner := anObject.! !

!WBLookPolicyWin31 methods !  
drawFrameBorder: aFrameObject with: aPen in: inRect

    | aRect borderWidth borderColor topRect bottomRect leftRect rightRect linePos |
    aRect := inRect.
    borderWidth := (aFrameObject style includes: #sizable)
        ifFalse: [(self borderWidthFrom: aFrameObject) - 1]
        ifTrue: [(self borderWidthFrom: aFrameObject) - 2].
    linePos := borderWidth + (self systemMenuWidth @ self titleBarHeight).
    aPen
        foreColor: Color windowBorder;
        drawRectangle: aRect.
    (aFrameObject style includes: #sizable) | aFrameObject isModal
        ifTrue: [
            aRect := aRect insetBy: 1.
            topRect := aRect leftTop rightBottom: aRect right @ (aRect top down: borderWidth).
            leftRect := aRect leftTop rightBottom: (aRect left right: borderWidth) @ aRect bottom.
            bottomRect := aRect left @ (aRect bottom up: borderWidth) rightBottom: aRect rightBottom.
            rightRect := ((aRect right left: borderWidth) @ aRect top rightBottom: aRect rightBottom).
            borderColor := (aFrameObject style includes: #sizable)
                ifTrue: [Color activeWindowBorder]
                ifFalse: [Color activeTitleBar].
            aPen
                fill: topRect color: borderColor;
                fill: leftRect color: borderColor;
                fill: bottomRect color: borderColor;
                fill: rightRect color: borderColor;
                foreColor: Color windowBorder.
            (aFrameObject style includes: #sizable)
                ifTrue: [
                    aPen
                        drawRectangle: (topRect insetBy: (linePos x @ -1));
                        drawRectangle: (leftRect insetBy: (-1@ linePos y));
                        drawRectangle: (rightRect insetBy: (-1@ linePos y));
                        drawRectangle: (bottomRect insetBy: (linePos x @ -1));
                        drawRectangle: (aRect insetBy: borderWidth)]].! !

!PTextPane methods !  
usesFocus

    ^false! !

!WBCreateViewsModule methods !  
layoutTemporaries
	"Private - Answer the variable names."

	^#( )! !

!WindowFrameObject methods !   
eventsTriggered

    ^(self realClass basicNew topPaneClass eventsTriggered
        ifNil: [^#()]) asSortedCollection! !

!WBTeamVCodePolicy methods !   
basicCompileMethodFor: aCodeModule
		"Private - Compile and store the method.
			Answer an association with key = selector and value = compiled method
			if sucessful, else answer nil."
	| mthDef |
	aCodeModule shouldLogMethodSource
		ifTrue: [
			mthDef := (self packageFor: aCodeModule)
				addMethodInClassNamed: aCodeModule targetClass instanceClass symbol
				meta: aCodeModule targetClass isMetaClass
				sourceString: aCodeModule sourceString
				notifying: nil.
			mthDef isNil ifTrue: [^nil].
			mthDef
				annotationNamed: self categoriesLabel put: (self categoryFor: aCodeModule);
				annotationNamed: self versionLabel put: (self versionFor: aCodeModule)]
		ifFalse: [
			mthDef := aCodeModule targetClass compile: aCodeModule sourceString.
			mthDef isNil ifTrue: [^nil].
			mthDef := self currentSubsystem
				definitionOfMethod: mthDef key
				inClassNamed: aCodeModule targetClass instanceClass name
				meta: aCodeModule targetClass isMetaClass.
			mthDef isNil ifTrue: [^nil].
			mthDef moveTo: (self packageFor: aCodeModule)].
	^mthDef selector => (
		(Smalltalk at: mthDef className asSymbol)
			compiledMethodAt: mthDef selector)! !

!WBInterfaceObject methods !  
nlsAutosize
	"Answer true if the receiver should autosize based
		on the largest NLS string for the receiver's key."

	^(self editor ifNil: [^false]) nlsAutosize! !

!WBLayoutWizard methods ! 
widgetTypesFor: selectedItem

    ^(self widgetMapFor: selectedItem)
        select: [:sym | Smalltalk includesKey: sym]! !

!WBResourceDescriptor class methods !   
name: aString commonName: aString2 comment: aString3 value: anObject

    ^self new
            name: aString;
            commonName: aString2;
            comment: aString3;
            value: anObject! !

!PDrawnButton methods !   
changesTitle

    ^true! !

!WBPrototype class methods !  
importFromResFile: resFile owner: aWindowBuilder

	^self new
		owner: aWindowBuilder;
		importFromResFile: resFile.! !

!WBFontSelectionWindow methods !
atleastOneKey
	"Answer true if there is atleast one pool keys defined."

	self poolManager pools do: [:each | each pool notEmpty ifTrue: [^true]].
	^false! !

!WBInterfaceObject methods ! 
supportedInDialogs

	^true! !

!WBLookPolicy methods !
drawTitleBar: aFrameObject with: aPen in: aRect

    | titleRect |
    titleRect := aRect leftTop extentFromLeftTop: aRect width @ (self titleBarHeightFrom: aFrameObject).
    aPen drawRectangle: titleRect.
    self drawTitleBarText: aFrameObject with: aPen in: aRect! !

!WindowBuilder class methods ! 
wbInitializeOldBitmapNames
	"Initialize the old bitmap names."

	(Smalltalk at: #CPBitmapDict ifAbsent: [^self])
		addCurrentMap: (Dictionary new 
			at: 'calculator' put: 'WBCalculatorBitmap';
			at: 'camera' put: 'WBCameraBitmap';
			at: 'checkBox' put: 'WBCheckBoxBitmap';
			at: 'checkBoxOn' put: 'WBCheckBoxOnBitmap';
			at: 'clear' put: 'WBClearBitmap';
			at: 'copy' put: 'WBCopyBitmap';
			at: 'crayons' put: 'WBCrayonsBitmap';
			at: 'cut' put: 'WBCutBitmap';
			at: 'cutCopyPaste' put: 'WBCutCopyPasteBitmap';
			at: 'dateTime' put: 'WBDateTimeBitmap';
			at: 'disc' put: 'WBDiscBitmap';
			at: 'divide' put: 'WBDivideBitmap';
			at: 'graph' put: 'WBGraphBitmap';
			at: 'greaterThan10' put: 'WBGreaterThan10Bitmap';
			at: 'handshake' put: 'WBHandshakeBitmap';
			at: 'letter' put: 'WBLetterBitmap';
			at: 'minus' put: 'WBMinusBitmap';
			at: 'monaLisa' put: 'WBMonaLisaBitmap';
			at: 'movie' put: 'WBMovieBitmap';
			at: 'openNew' put: 'WBOpenNewBitmap';
			at: 'orgChart' put: 'WBOrgChartBitmap';
			at: 'paste' put: 'WBPasteBitmap';
			at: 'plus' put: 'WBPlusBitmap';
			at: 'radioButton' put: 'WBRadioButtonBitmap';
			at: 'radioButtonOn' put: 'WBRadioButtonOnBitmap';
			at: 'save' put: 'WBSaveBitmap';
			at: 'times' put: 'WBTimesBitmap';
			at: 'toolPaneExample' put: 'WBToolPaneExampleBitmap';
			yourself).
	! !

!WBInterfaceObject class methods ! 
templateAt: aClassName put: anInterfaceObject

	^self templates 
		at: aClassName asSymbol 
		put: anInterfaceObject.! !

!WBRGBColorDialog methods !   
fillColorPaneWith: anRGBColor

    | colorPane |
    (colorPane := (self paneNamed: 'color'))
        backColor: anRGBColor;
        invalidateRect: nil.! !

!WBEventMessage methods !
remove
	"Remove the receiver from the source event table."

	| actions index |
	index := self index ifNil: [^self].
	actions := self actionList.
	self actionList: (
		(actions copyFrom: 1 to: index - 1),
		(actions copyFrom: index + 1 to: actions size)).! !

!WBDevelopmentWindow methods !   
setFont
	"Set the font attributes for the current widget"

	| font |
	(font := self currentWidget getFont: self) notNil
		ifTrue: [
			self selections do: [:widget |
				widget usesFont ifTrue: [widget font: font]].
			self postEditUpdate].! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBManagedPValue methods !
key

	^key! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBNLSDictionaryReader class methods !
fileOutPoolFileName: aString on: aStream
	"File out a token/value pair inside a comment."

	^self
		fileOutToken: WBNLSManager tagFileName
		value: aString
		inCommentOn: aStream! !

!WBApplicationCoordinatorMenuModule methods !  
defaultMessageArguments
        "Private - Answer the default message selector arguments."
    ^Array
        with: self defaultViewName
        with: self defaultOwnerName! !

!PCompositePane methods !  
importantEvents

    ^[self realClass importantEvents]
            on: MessageNotUnderstood
            do: [^super importantEvents].! !

!WBCodeStream methods !   
generatePortableFontCode: aBoolean

	self propertyAt: #generatePortableFontCode put: aBoolean.! !

!WBCodePolicy methods !
renameKey: oldKey to: newKey inPoolNamed: aSymbol
	"Rename the specified key in a pool in the system."

	| pool assoc |
	pool := Smalltalk at: aSymbol.
	assoc := pool associationAt: oldKey.
	pool removeAssociation: assoc.
	assoc key: newKey.
	pool add: assoc.! !

!WBInstVarGetModule methods !   
generateBody
        "Private - Generate the method body."
    self stream indentBy: 1 during: [
        self generateGeneratedSymbol.
        self stream cr; nextPut: $^; nextPutAll: self object]! !

!PComboBox methods !   
copySpecificsTo: aPane

    aPane
        contents: self contents.! !

!WBLocator methods !  
copy
        ^CopiedFigures notNil
                ifTrue: [self copyOn: (WBLocator copyAt: receiver)]
                ifFalse: [super copy]! !

!WBCodeModule methods ! 
isInstVar: aString
		"Private - Answer true if aString is defined as an instance variable name."
	^(self targetClassDefinition allInstVarNames
		detect: [ :each | each = aString ]
		ifNone: [ nil ]) notNil! !

!WBLayoutForm methods !   
loadedWidgets: aCollection
    "Set the value of loadedWidgets."

    loadedWidgets := aCollection.
    aCollection isNil
        ifTrue: [self notifyModelOfCursorUnload].! !

!WBPrototype class methods !   
on: aWindowClass owner: aWindowBuilder

    ^self new
            owner: aWindowBuilder;
            convertClass: aWindowClass;
            initializeModelObjects.! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PScrollBar methods !
mutateSpecificsFrom: aPane

	(aPane respondsTo: #realPane)
		ifTrue: [
			(aPane realPane respondsTo: #min)
				ifTrue: [self minimum: aPane realPane min].
			(aPane realPane respondsTo: #max)
				ifTrue: [self maximum: aPane realPane max].
			^nil].
	(aPane respondsTo: #minimum)
		ifTrue: [self minimum: aPane minimum].
	(aPane respondsTo: #maximum)
		ifTrue: [self maximum: aPane maximum].
	(aPane respondsTo: #pageIncrement)
		ifTrue: [self pageIncrement: aPane pageIncrement].
	(aPane respondsTo: #lineIncrement)
		ifTrue: [self lineIncrement: aPane lineIncrement].! !

!WBModelInstVar methods !
okToGenerateGet

    ^self okToGenerateMethod: self methodNameForGet! !

!WBUserInfoDialog methods !  
ok

	"Callback for the #clicked event in okButton [Button].
		(Generated by WindowBuilder Pro)"

	self wbEditorClass
		userName: nameField contents;
		companyName: companyField contents;
		serialNumber: serialNumberField contents.
	self close.! !

!WindowBuilder class methods ! 
propertyAt: aSymbol put: aValue

	^(self propertiesAtCategory: self privateString)
		at: aSymbol put: aValue! !

!WBEditClassDialog methods !
mostRecentSelect: selectedItem

    "Callback for the #clicked: event triggered in the WBComboBox named 'mostRecent'.
     (Generated by WindowBuilder)"

    selectedClass := Smalltalk at: (selectedItem ifNil: [^nil]) asSymbol ifAbsent: [^nil].
    list clearSelection.
    self setWindowTitle.! !

!WBTabOrderLayoutForm methods !   
notifyModelOfCursorUnload
	"Do Nothing"! !

!String methods !  
asToken
		"Answer the receiver as a valid token."
	| answer |
	#addedByOSI.
	((answer := self asBasicToken) isEmpty
		or: [ answer first isLetter not ])
			ifTrue: [ answer := 'temp', answer ].
	^answer
! !

!WBCreateViewsModule methods !  
generateViewMessage: aSymbol
		"Private - Generate the view creation message."
	self stream cr;
		nextPutAll: #self;
		space.
	self
		generateMessagePattern: aSymbol
		arguments: self messageArguments.
	self stream
		endExpression.! !

!WBResourceDescriptor methods !
lookupDictionary

    ^OperatingSystemConstants! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutWizard methods !
generateMenus

    | menusToGenerate menuBar |
    (menusToGenerate := self menusToGenerate) isEmpty ifTrue: [^self shell menu: nil].
    menuBar := WBPMenubar new.
    menusToGenerate do: [:menuLabel |
        menuBar addChild: ((self class menuDefinitions includesKey: menuLabel)
            ifTrue: [(self class menuDefinitions at: menuLabel) fullCopy]
            ifFalse: [WBPMenuItem new title: menuLabel])].
    self shell menu: menuBar! !

!WBCodeGenerator class methods !   
policy
		"Answer the current code policy."
	^CurrentCodePolicy ifNil: [
		CurrentCodePolicy := self defaultPolicy ]! !

!WBLookPolicyWin31 methods ! 
titleBarHeightFrom: aFrameObject

    ^aFrameObject hasTitleBar
        ifTrue: [
            aFrameObject isDialog
                ifTrue: [self titleBarHeight + 1]
                ifFalse: [self titleBarHeight]]
        ifFalse: [0]! !

!WBPMenubar methods ! 
asMenu

    | realMenus |

    realMenus := OrderedCollection new: children size.
    children do: [ :n | realMenus addLast: n asMenu ].

    ^realMenus! !

!SelectorPropertyAccessor methods ! 
wbDefaultStoreAction

	^#nextPutProperty:value:for:! !

!Bitmap methods ! 
wbButtonUpBox
	"Private - Answer the up button contents box."

	| inset box |
	inset := 1.
	box := self boundingBox.
	^(box leftTop rightAndDown: 2 + inset)
		extentFromLeftTop: (box width // 2 @ box height) - 5 - (2 * inset)! !

!SelectorPropertyAccessor methods !
wbMutate: anAction

	self propertyAt: #wbMutateAction put: anAction.! !

!WBAboutDialog methods ! 
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| address copyright mainView ok osilogo registeredTo user 
	version wbpro window xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	address := WBDrawnButton new.
	copyright := StaticText new.
	ok := Button new.
	osilogo := WBDrawnButton new.
	registeredTo := StaticText new.
	user := StaticText new.
	version := StaticText new.
	wbpro := WBStaticGraphic new.
	window := WBStaticGraphic new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'About WindowBuilder Pro';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -217/2 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -64 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -217/2 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -64 * yDU).
	self addView: mainView.
	
	copyright "StaticText"
		owner: self;
		setName: 'copyright';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3/2 * xDU;
				topRatio: 0; topInset: 74 * yDU;
				rightRatio: 0; rightInset: -431/2 * xDU;
				bottomRatio: 0; bottomInset: -90 * yDU);
		centered;
		backColor: Color paleGray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: copyright.
	
	version "StaticText"
		owner: self;
		setName: 'version';
		when: #needsContents send: #getVersion: to: self withArgument: version;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 80 * xDU;
				topRatio: 0; topInset: 58 * yDU;
				rightRatio: 0; rightInset: -138 * xDU;
				bottomRatio: 0; bottomInset: -74 * yDU);
		centered;
		contents: '';
		backColor: Color paleGray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: version.
	
	user "StaticText"
		owner: self;
		setName: 'user';
		when: #needsContents send: #getUser: to: self withArgument: user;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 123/2 * xDU;
				topRatio: 0; topInset: 110 * yDU;
				rightRatio: 0; rightInset: -168 * xDU;
				bottomRatio: 0; bottomInset: -127 * yDU);
		contents: '';
		backColor: Color paleGray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: user.
	
	registeredTo "StaticText"
		owner: self;
		setName: 'registeredTo';
		when: #needsContents send: #getSerialNumber: to: self withArgument: registeredTo;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 110 * yDU;
				rightRatio: 0; rightInset: -57 * xDU;
				bottomRatio: 0; bottomInset: -127 * yDU);
		rightJustified;
		backColor: Color paleGray;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: registeredTo.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 170 * xDU;
				topRatio: 0; topInset: 110 * yDU;
				rightRatio: 0; rightInset: -213 * xDU;
				bottomRatio: 0; bottomInset: -124 * yDU);
		defaultPushButton;
		contents: 'OK';
		startGroup;
		font: SysFont.
	mainView
		addSubpane: ok;
		subPaneWithFocus: ok.
	
	address "WBDrawnButton"
		owner: self;
		setName: 'address';
		when: #clicked send: #showAddress to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 30 * xDU;
				topRatio: 0; topInset: 94 * yDU;
				rightRatio: 0; rightInset: -193 * xDU;
				bottomRatio: 0; bottomInset: -105 * yDU);
		stretchToFit;
		startGroup;
		font: SysFont.
	mainView addSubpane: address.
	
	wbpro "WBStaticGraphic"
		owner: self;
		setName: 'wbpro';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 72 * xDU;
				topRatio: 0; topInset: 6 * yDU;
				rightRatio: 0; rightInset: -144 * xDU;
				bottomRatio: 0; bottomInset: -54 * yDU);
		stretchToFit;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: wbpro.
	
	osilogo "WBDrawnButton"
		owner: self;
		setName: 'osilogo';
		when: #clicked send: #thanks to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 145 * xDU;
				topRatio: 0; topInset: 0 * yDU;
				rightRatio: 0; rightInset: -217 * xDU;
				bottomRatio: 0; bottomInset: -72 * yDU);
		stretchToFit;
		startGroup;
		font: SysFont.
	mainView addSubpane: osilogo.
	
	window "WBStaticGraphic"
		owner: self;
		setName: 'window';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 0 * xDU;
				topRatio: 0; topInset: 0 * yDU;
				rightRatio: 0; rightInset: -72 * xDU;
				bottomRatio: 0; bottomInset: -72 * yDU);
		stretchToFit;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: window! !

!WBLayoutForm methods ! 
buttonDown: aPoint

    | aNib shifted alt ctrl child |

    self propertyAt: #hideHandles put: true.
    self captureMouseInput.
    self directEditor isNil
        ifFalse: [
            self loadedWidgets: self directEditor loadedWidgets copy.
            self directEditor finished.
            self directEditor: nil.
            self notifyModelOfLayoutChange].

    child := self findChildFor: aPoint.

    self loadedWidgets isNil
        ifFalse: [
            self clearMouseCapture.
            ^self placeWidgets: aPoint].

    self isLeftButton ifFalse: [^self].

    "Give keyboard focus to the canvas when button 1 is pressed."
    self setFocus.

    "Save the original selection point and clear the allowMove flag.
     This is used to avoid moving the widget in the case of very small mouse jiggles."
    self cursorSelectPoint: aPoint.
    self allowMove: false.

    self handles notEmpty ifTrue: ["See if selected widget's resizers are under the mouse."
        (aNib := self handleAt: aPoint) notNil
            ifTrue: [
                self selection: aNib owner.
                self currentNib: aNib selector.
                self hideHandles.
                ^self setupResizing]].

    self shellHandles notEmpty ifTrue: ["See if shell's resizers are under the mouse."
        (aNib := self shellHandleAt: aPoint) notNil
            ifTrue: [
                self clearSelections.
                self currentNib: aNib selector.
                self hideHandles.
                self hideShellHandles.
                ^self setupShellResizing: aPoint]].

    shifted := Notifier isShiftKeyDown.
    alt := Notifier isAltKeyDown.
    ctrl := Notifier isControlKeyDown.

    child notNil ifTrue: [
        alt
            ifTrue: [
                self hideHandles.
                self clearSelections.
                ^self directEditor: child wbDirectEdit point: aPoint].
        shifted | ctrl
            ifTrue: [
                self clearMouseCapture.
                ^self toggleSelect: child]
            ifFalse: [
                    self hideHandles.
                    (self selections includes: child)
                        ifFalse: [self selection: child].

                    "Remember the cursor offset into the widget."
                    self cursorOffset: (self selections collect: [:widget | aPoint distanceLeftAndUp: widget origin]).

                    self dragOutline "| self model drawGrid"
                        ifTrue: [
                            self cursorOffset addLast: (aPoint distanceLeftAndUp: self selectedRect leftTop).
                            self setupDragOutline]
                        ifFalse: [
                            self
                                hideHandles;
                                setupDragWidget].

                    ^self]]
        ifFalse: [
            "Must have selected white space, deselect current widget."
            shifted | ctrl
                ifFalse: [
                    self
                        hideHandles;
                        clearSelections;
                        setupSelecting: aPoint]]! !

!WBAttributeEditor methods ! 
cancel: aPane

    thePane := nil.
    super close! !

!WBCallOutEditor methods !
ok

    "Callback for the #clicked event triggered in the Button named 'ok'.
     (Generated by WindowBuilder)"

    callOutMap associationsDo: [:assoc |
        assoc key creationMethodSelector: (assoc value isNil
            ifTrue: [nil] ifFalse: [assoc value asSymbol])].
    self owner redisplaySelection.
    self close! !

!WBTabPosition methods ! 
initialize

    basicTabPosition := 0! !

!WBLayoutForm methods ! 
duplicateOffset: aPoint
    "Set the value of duplicateOffset."

    duplicateOffset := aPoint.! !

!WBTreeNode methods !
setCurrentString: aString

    currentString := aString! !

!WBEventManagerWindow methods !   
widgetListUpdate

	widgetListBox update.
	self eventListUpdate.
	self zap.! !

!WindowFrameObject methods ! 
copySpecificsTo: aPane

    aPane
        iconFile: self iconFile.! !

!WindowBuilder methods !  
menuOptionsAutoSave

    self class togglePropertyValueAt: #AutoSave.
    self updateOptionsMenu.! !

!WindowBuilder methods !   
menuScrapbookRetrieve

	(WBScrapbookRetrieve new openOn: self layoutForm) removedQuick
		ifTrue: [self updateQuickReferenceMenu]! !

!WBInterfaceObject methods !
removeFirstEventHandlerAt: aSymbol
	"Remove the first event handler at aSymbol.
		Answer true if it was removed, else false."

	| actions |
	actions := self wbRealWidget actionListForEvent: aSymbol.
	actions notEmpty ifFalse: [^false].
	actions := actions copyFrom: 2 to: actions size.
	self wbRealWidget
		setActionList: actions
		forEvent: aSymbol.! !

!WBTemplateEditor methods !
currentWidget

	^template! !

!WBFileSelectorEditor class methods !   
titled: titleString filters: filterCollection descriptions: descCollection
    | new |
    new := super new.
    new
        title: titleString;
        filters: filterCollection;
        descriptions: descCollection.
    ^new! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PRadioButtonGroup methods ! 
mutationTypes

    ^#(#ListBox #CPScrollingPane #RadioButtonGroup #EntryFieldGroup)! !

!WBInterfaceObject methods !  
tabPosition: aWBTabPosition

    tabPosition := aWBTabPosition! !

!BitEditor methods !   
clear
    imagePen erase.
    bitPen erase.
    copy pen blank: copy boundingBox.
    self grid: scale! !

!WindowBuilder class methods !   
scrapbookLoadFile: aFileName

	(Smalltalk includesKey: #ObjectFiler)
		ifTrue: [self scrapbook: ((Smalltalk at: #ObjectFiler) loadFromPathName: aFileName)].
	! !

!Object methods !
wbEditorClass
	"Answer the current WindowBuilder class in use"

	#addedByOSI.
	^WindowBuilder editorClass.! !

!WBInterfaceObject methods ! 
defaultFont

    ^self wbEditorClass wbDefaultFont! !

!WBBitmapEditorCompositePane class methods !   
wbPartEventItems

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your wb-parts definition."

	#generated.
	^#(#rightClicked #tabbed)! !

!WindowBuilder class methods ! 
openTranslator

	(Smalltalk at: #WBTranslator
		ifAbsent: [^MessageBox message: 'Translator not installed.']) translate! !

!WBToolMenuAddInModule class methods !   
comment

	^'Adds a Tools menu to the WBPro
menubar. This provides numerous
inspectors and other debugging
aids'! !

!WBToolBarEditor methods ! 
help

    MessageBox notify: 'Instructions for Creating Toolbars' withText:
'1) Create toolbar buttons using the BitmapManager and ButtonEditor. They must be the same size as the ''Cell Size''.
2) Insert a blank button using the ''Insert'' button.
3) Select a button bitmap from the Bitmap combobox (only bitmaps of the chosen Cell Size will appear). Each button MUST have an associated bitmap.
4) Specify any other desired attributes.'! !

!WindowBuilder class methods !   
removeMenu: aString

	| menus target |
	menus := self wbMenus.
	target := menus detect: [:m | 	(m at: 1) = aString] 	ifNone: [nil].
	target isNil 	ifFalse: [^menus remove: target ifAbsent: [nil]].
	menus 	do: [:menu |
		(menu at: 3) do: [:mi |
			mi isSymbol
				ifFalse: [
					(mi at: 1) = aString
						ifTrue: [^(menu at: 3) remove: mi ifAbsent: [nil]].
					(mi at: 3) isString
						ifFalse: [
							(mi at: 3) do: [:msi |
								msi isSymbol
									ifFalse: [
										(msi at: 1) = aString
											ifTrue: [^(mi at: 3) remove: msi ifAbsent: [nil]]]]]]]]! !

!PGraphPane methods !   
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	eventSymbol == #clicked: ifTrue: [^#('aPoint')].
	^super eventHandlerArgNamesFor: eventSymbol! !

!PStatusPane methods !   
updateBoxesRightJustified

    | xPos aRect box |
    xPos := self updateBoxesRightJustifiedFixed.
    self statusBoxes isEmpty ifTrue:[^self].
    box := self statusBoxes first.
    xPos := xPos right: box space.
    xPos := xPos right: box width + 6.
    aRect := Rectangle leftTop: (12 + box space @ rect top) rightBottom: xPos @ (rect bottom down: 2).
    aRect := aRect insetBy: (0 @ self inset).
    box rectangle: aRect.! !

!WBLookPolicyWin95 methods !  
displayWithBorder: aPen rect: aRect backColor: backColor

    | innerRect |
    aPen
        foreColor: Color gray;
        wbLineFrom: aRect topLeft to: (aRect topRight left: 1);
        wbLineFrom: aRect topLeft to: (aRect bottomLeft up: 1);
        wbLineFrom: (aRect topRight left: 1) to: (aRect bottomRight leftAndUp: 1);
        wbLineFrom: (aRect bottomLeft up: 1) to: (aRect bottomRight leftAndUp: 1);
        wbLineFrom: (aRect topLeft rightAndDown: 2) to: (aRect topRight leftAndDown: 3@2);
        wbLineFrom: (aRect topLeft rightAndDown: 2) to: (aRect bottomLeft rightAndUp: 2@3);
        wbLineFrom: (aRect topRight leftAndDown: 3@2) to: (aRect bottomRight leftAndUp: 3);
        wbLineFrom: (aRect bottomLeft rightAndUp: 2@3) to: (aRect bottomRight leftAndUp: 3);
        foreColor: Color darkGray;
        wbLineFrom: (aRect topLeft rightAndDown: 1) to: (aRect topRight leftAndDown: 2@1);
        wbLineFrom: (aRect topLeft rightAndDown: 1) to: (aRect bottomLeft rightAndUp: 1@2);
        foreColor: Color white;
        wbLineFrom: (aRect bottomLeft rightAndUp: 1@2) to: (aRect bottomRight leftAndUp: 2);
        wbLineFrom: (aRect topRight leftAndDown: 2@1) to: (aRect bottomRight leftAndUp: 2@(1 + Rectangle leftTopUnit y));
        foreColor: Color black;
        wbLineFrom: (aRect topLeft rightAndDown: 2) to: (aRect topRight leftAndDown: (3 + Rectangle leftTopUnit y)@2);
        wbLineFrom: (aRect topLeft rightAndDown: 2) to: (aRect bottomLeft rightAndUp: 2@(3 + Rectangle leftTopUnit y));
        fill: (innerRect := aRect insetBy: 3)
        color: backColor.
    ^innerRect! !

!WBCodeModule methods !
varOrGlobalNameFor: anObject
        "Answer the variable name (temporary variable or instance variable)
            for the specified object."
    ^self varOrGlobalNameFor: anObject ifAbsent: [
        self error: 'no var or global name for ', anObject printString ].! !

!WBCodeStream methods !
nextPutFontDef: aFont indentString: indentString
	"Append a font definition."

	self openParenthesis.
	self generatePortableFontCode
		ifTrue: [
			"Portable code generation for fonts - use this for portability to V/Win & V/OS2"
			aFont portableStoreOn: self indentString: indentString]
		ifFalse: [
			"Default non-portable code generation for fonts"
			aFont nonPortableStoreOn: self indentString: indentString].
	self closeParenthesis.! !

!WBBitmapManagerWindow methods ! 
defaultExtension

	^'.BPL'! !

!WBInterfaceObject methods !   
update

	self updateManagedValues.! !

!WBLayoutWizard class methods !
defaultButtons

    ^DefaultButtons ifNil: [DefaultButtons := self initializeDefaultButtons]! !

!PropertyAccessor methods !  
wbDefaultRemoveStyleAction

	#addedByOSI.
	^nil! !

!WBLayoutForm methods !  
addWidgetOfClass: aClass
    "Add a widget of class <aClass> to the editor"

    aClass isNil ifTrue: [^self loadedWidgets: nil].
    self loadedWidgets: (OrderedCollection 
        with: (aClass wbPseudoClass exampleFrom: aClass symbol)).! !

!WBLookPolicy methods !
asRGBColor: aColor

    ^[aColor asRGBColor]
            on: Error
            do: [RGBColor fromInteger: aColor asInteger].! !

!WBPoolManagerWindow methods ! 
selectedPool: aPool
	"Select the pool."

	self selectedPools: (OrderedCollection with: aPool).! !

!WBLayoutForm methods !   
bandRect: aRectangle
    "Set the value of bandRect."

    bandRect := aRectangle.! !

!WBMultiViewAddInModule class methods !   
commonName

	^'Multiple Views Support'! !

!WindowBuilder methods !   
wbLinkPartEvents
    "Do Nothing"! !

!WBFontManagerWindow methods !   
windowTitle

	^'Font Manager'! !

!WBPrototype methods !  
eventsSummaryString

    | stream nameString |
    stream := WriteStream on: String new.
    self modelObjects notEmpty
        ifTrue: [
            stream nextPutAll: 'Model Events:'; cr.
            self modelObjects do: [:model |
                stream tab;
                    nextPutAll: model wbNameAndClass; cr.
                model eventTable keys asSortedCollection do: [:key |
                    (model eventTable at: key) asActionSequence do: [:msg |
                        stream tab; tab;
                            nextPutAll: 'when: #', key;
                            nextPutAll: ' send: #', msg selector; cr]].
                    model eventTable isEmpty
                        ifTrue: [stream tab; tab; nextPutAll:  '*** No events assigned ***';     cr].
                    stream cr    ]].
    windows do: [:view |
        windows size > 1
            ifTrue: [nameString := ' (', view paneName asQuotedString, ') ']
            ifFalse: [nameString := ' '].
        stream nextPutAll: 'View' , nameString , 'Events:'; cr.
        view wbRealWidget handlers keys asSortedCollection do: [:key |
            stream tab; tab;
                nextPutAll: 'when: #', key;
                nextPutAll: ' perform: #', (view wbRealWidget handlers at: key); cr].
        view wbRealWidget eventTable keys asSortedCollection do: [:key |
            (view wbRealWidget eventTable at: key) asActionSequence do: [:msg |
                stream tab; tab;
                    nextPutAll: 'when: #', key;
                    nextPutAll: ' send: #', msg selector; cr]].
        view wbRealWidget handlers isEmpty & view wbRealWidget eventTable isEmpty
            ifTrue: [stream tab; tab; nextPutAll: '*** No events assigned ***'; cr].
        view children size > 0
            ifTrue: [stream cr; nextPutAll: 'Widget Events:' , nameString; cr].
        (view children asSortedCollection: [:a :b |
            a wbRealWidget handlers size > b wbRealWidget handlers size]) do: [:child |
            stream tab; nextPutAll: child wbNameAndClass; cr.
            child wbRealWidget handlers keys asSortedCollection do: [:key |
                stream tab; tab;
                    nextPutAll: 'when: #', key;
                    nextPutAll: ' perform: #', (child wbRealWidget handlers at: key); cr].
            child wbRealWidget eventTable keys asSortedCollection do: [:key |
                (child wbRealWidget eventTable at: key) asActionSequence do: [:msg |
                    stream tab; tab;
                        nextPutAll: 'when: #', key;
                        nextPutAll: ' send: #', msg selector; cr]].
            child wbRealWidget handlers isEmpty & child wbRealWidget eventTable isEmpty
                ifTrue: [stream tab; tab; nextPutAll:  '*** No events assigned ***'; cr].
            stream cr    ]].
    ^stream contents! !

!WindowBuilder methods !  
menuToolsInspectOutboards

    self outboards inspect! !

!WBEditClassDialog class methods !  
filterList: aCollection

    FilterList := aCollection! !

!WBTabOrderLayoutForm methods !
removeTabPositionFor: widget

	widget tabPosition: nil.
	self soloWidgets add: widget.
	self 
		resetGroups;
		normalizeTabOrder;
		updateRect: self shell frameContentRect.! !

!WBEventMessage methods !   
= aMessage
	"Answer <true> if the receiver and <aMessage> are equal."

	^self == aMessage
		or: [self class == aMessage class
			and: [self receiver == aMessage receiver
			and: [self selector = aMessage selector
			and: [self arguments = aMessage arguments
			and: [self source == aMessage source
			and: [self event == aMessage event]]]]]]! !

!WBModelInstVar methods !
valueClass: aClass

    valueClass := aClass! !

!LayoutFrame methods !   
wbFramingEditor
	"Answer the class of the framing editor used to edit the receiver."

	^WBLayoutFrameEditor! !

!WBTeamVCodePolicy methods ! 
addPoolNamed: aSymbol
	"Add the specified pool to the system."

	self currentSubsystem unpackagedPackage
		addPoolNamed: aSymbol.! !

!WBPoolManagerWindow methods !
checkNewKey: aKey
	"Check to see if the key conflicts with any existing classes.
		Answer the key or nil."

	| aSymbol |
	aSymbol := aKey asExistingSymbolOrNil ifNil: [^aKey].
	(Smalltalk includesKey: aSymbol) ifTrue: [
		(MessageBox confirm:
			'There already exists a global named #', aSymbol,
			'.  Do you wish to add a new pool variable with the same name?'
		) ifFalse: [^nil]].
	^aKey! !

!WBPoolManagerWindow methods !   
defaultNewFileName
	"Answer the default new file."

	^'*', self defaultExtension! !

!WBScrapbookRetrieve methods !  
scrapbook

    ^scrapbook! !

!WindowBuilder methods !
okToSetFraming

    ^self shell isDialog not
        or: [Notifier isControlKeyDown].! !

!WindowFrameObject methods !   
titleHeight

    ^self lookPolicy titleBarHeightFrom: self! !

!WindowBuilder class methods ! 
categoryWithProperty: aSymbol

    ^self properties
        detect: [:category | category includesKey: aSymbol]
        ifNone: [nil]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!PWBVerticalScrollBar methods !  
mutationRotationList

    ^#(#WBHorizontalScrollBar #CPHorizontalBarGauge #CPHorizontalSlider)! !

!PEntryFieldGroup methods !
backColor: aColor

	super backColor: aColor.
	aColor = self defaultForeColor
		ifTrue: [self children do: [:child | child foreColor: child defaultForeColor]]
		ifFalse: [self children do: [:child | child backColor: aColor]].! !

!WBCodeStream methods !   
endMessage
		"Signal end of message."
	endChar := $; .! !

!WBMenuItem methods !  
window
        "Private - Answer the receiver's MenuWindow."
    self menu isNil ifTrue: [^nil].
    ^self menu window! !

!PActionButton methods !  
importantEvents

    ^super importantEvents
        remove: #clicked;
        yourself! !

!WBMenu methods !
updateState
        "Update the state of all items for the receiver."
    items do: [:mi | mi updateState].! !

!WBModelInstVar methods ! 
initialized: aBoolean

    initialized := aBoolean! !

!WindowBuilder methods !   
menuFileExit

    self confirmSaveChanges ifFalse: [^self].
    self stopTimer.
    Smalltalk platformIsWin32
        ifTrue: [
            self mainView parent isNil
                ifFalse: [self mainView parent mainView bringToTop]].
    self mainView propertyAt: #parentWB put: nil.
    self close.! !

!WindowBuilder methods !
initializePalettes

	| editorFont |
	self initializePalettesMap.
	groups
		useSystem: true;
		size: 1 @ 14.
	entries
		useSystem: true;
		size: 1 @ 14.
	self toolCollection do: [:group |
		groups 
			add: (self initializePalettesBitmapFor: group key) 
			selector: group key.
		entries
			add: (WBBitmapManager system at: 'WBArrowToolSysBitmap' ifAbsent: [nil])
			selector: 'ArrowTool'
			on: group key.
		group value do: [:tool |
			entries
				add: (self initializePalettesBitmapFor: tool)
				selector: tool
				on: group key]].
	entries switchTo: 'Text'.
	editorFont := self editorFont.
	positionPane font: editorFont.
	sizePane font: editorFont.
	status font: editorFont.
	sizeButton contents: (WBSizeSysBitmap handle; yourself).
	positionButton contents: (WBPositionSysBitmap handle; yourself).
	editPalette restoreAllBitmaps.
	"toolBar restoreAllBitmaps."
	groups restoreAllBitmaps.
	entries restoreAllBitmaps.
	attributeBar restoreAllBitmaps.
	! !

!WBTreeNode methods !  
updateManagedValues
	"Update the receiver's managed values."

	listString updateValue.! !

!WBPoolManagerWindow methods !
defaultPoolManager
	"Answer a pool manager for testing purposes."

	| partialKeys answer catNum keyNum eachCategory eachPool eachKey |
	partialKeys := #('A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M' 'N' 'O' 'P' 'Q').
	answer := WBPoolManager new.
	catNum := 1.
	keyNum := 1.
	#(#TestPool1 #TestPool2 #TestPool3 #TestPool4) do: [:eachPoolName |
		answer addPoolNamed: eachPoolName.
		eachPool := answer poolFor: eachPoolName.
		catNum to: catNum + 2 do: [:catIndex |
			eachCategory := 'category', catIndex printString.
			eachPool addCategory: eachCategory.
			keyNum to: keyNum + 3 do: [:keyIndex |
				eachKey := 'Key', (partialKeys at: keyIndex).
				eachPool
					at: eachKey
					in: eachCategory
					put: ('value',
						catIndex printString,
						(partialKeys at: keyIndex))]].
		keyNum := keyNum + 4.
		catNum < 3 ifTrue: [
			catNum := catNum + 1]].
	^answer! !

!WBAboutDialog class methods ! 
initTranscriptAfterClose
		"Initialize the Transcript after an instance of the receiver
			has been opened and closed."
	InitTranscript := true.! !

!WBInterfaceObject class methods !  
defaultRealClassName

    ^self name copyFrom: 2 to: self name size.! !

!WBTreeListBox class methods !   
isWBInternalClass

    ^true! !

!PComboBox methods ! 
genReceiveWindowMessagesOn: aStream indentString: spaceString

    "Don't generate method for subclasses of EntryField or ListBox - they already have it"! !

!WindowBuilder methods !
setFraming

	| selections oldFrameCollection newFrameCollection |
	self layoutForm hideHandles.
	selections := self selections copy.
	oldFrameCollection := selections collect: [:widget | 
		widget framingBlock copy].
	(newFrameCollection := super setFraming) isNil ifTrue: [^self].
	newFrameCollection := newFrameCollection collect: [:framer | framer copy].
	1 to: selections size do: [:i |
		(selections at: i) reframe: self shellFrameContentRect].
	self layoutFormChanged.
	self undoManager
		add: 'Set Framing'
		undo: [
			1 to: selections size do: [:i |
				(selections at: i) 
					framingBlock: (oldFrameCollection at: i);
					reframe: self shellFrameContentRect]]
		redo: [
			1 to: selections size do: [:i |
				(selections at: i) 
					framingBlock: (newFrameCollection at: i);
					reframe: self shellFrameContentRect]].
	self layoutForm
		showHandles;
		showShellHandles.! !

!WBTreeListBox methods ! 
moveSelectionUp

    self commitSelection.
    self wbSelectIndex: ((self selection - 1) max: 1).
    owningEditBox setFocus.! !

!WBLookPolicyWin95 methods !  
drawSystemMenuWith: aPen at: aRect

    self class isDefault
        ifTrue: [
            aPen
                copyBitmap: self class sysMenuBitmap
                from: self class sysMenuBitmap boundingBox
                to: aRect]! !

!WBUndoManager methods !  
statusPaneHelp: aKey
    "Answer the default dictionary used by
    the status bar for help support"

    ^self owner statusPaneHelp: aKey! !

!ViewManager class methods ! 
defaultCodeModuleClass
        "Answer the default code module for the receiver."
    ^WBCreateViewsModule! !

!Rectangle methods !   
localizeRect: aRect
        "Private - WBPro Development.
     Answer a rectangle that is in coordinates relative to
     self.  The rectangle passed in is assumed in the
     same coordinates as self.  This method is system independent."
    #addedByOSI.
    ^(aRect leftTop - self origin) extentFromLeftTop: aRect extent! !

!WBFontEditorCompositePane methods !   
updateValue: aFont

	nameField selection: (
		aFont notNil
			ifTrue: [aFont faceName]
			ifFalse: ['']).
	sizeField text: (
		aFont notNil
			ifTrue: [aFont pointSize printString]
			ifFalse: ['']).
	boldCheckBox selection: (
		aFont notNil and: [aFont bold]).
	italicCheckBox selection: (
		aFont notNil and: [aFont italic]).
	strikeOutCheckBox selection: (
		aFont notNil and: [aFont strikeOut]).
	underscoreCheckBox selection: (
		aFont notNil and: [aFont underscore]).
	fixedWidthCheckBox selection: (
		aFont notNil and: [aFont fixedWidth]).
	sampleTextEdit font: (
		aFont notNil
			ifTrue: [aFont]
			ifFalse: [SysFont]).! !

!PropertyManager methods ! 
wbEventNamed: eventName
	"Answer the event definition."

	#addedByOSI.
	^self wbEventNamed: eventName ifAbsent: [
		WBEventDescription new
			event: eventName;
			argumentNames: (
				(Array new: (Message numberOfArgumentsFor: eventName))
					atAllPut: 'anObject';
					yourself);
			yourself]! !

!WBLookPolicy methods !   
titleRectFrom: aFrameObject

    ^aFrameObject rect leftTop
        extentFromLeftTop: aFrameObject rect width @ self titleBarHeight! !

!WBEventManagerWindow methods ! 
eventListBoxNeedsContents: aPane

	"Callback for the #needsContents event triggered in the MultipleSelectListBox named 'eventListBox'.
	 (Generated by WindowBuilder)"

	| oldSelection newContents allEvents |
	allEvents := Set new.
	self widgetSelections do: [:each |
		allEvents addAll: each wbEventsTriggered].
	allEvents := allEvents asSortedCollection.
	newContents := OrderedCollection new.
	allEvents do: [:each |
		(self widgetSelections
			detect: [:w | w hasActionForEvent: each]
			ifNone: [nil]
		) notNil ifTrue: [
			(newContents includes: each) ifFalse: [
				newContents add: each]]].
	allEvents do: [:each |
		(self widgetSelections
			detect: [:w |
				w wbWrapper isWBInterfaceObject
					and: [w wbWrapper importantEvents includes: each]]
			ifNone: [nil]
		) notNil ifTrue: [
			(newContents includes: each) ifFalse: [
				newContents add: each]]].
	allEvents do: [:each |
		(newContents includes: each) ifFalse: [
			newContents add: each]].
	oldSelection := aPane selectedItems.
	aPane
		contents: newContents;
		selection: oldSelection.
	aPane selectedItems isEmpty ifTrue: [
		newContents notEmpty ifTrue: [
			aPane selection: 1]].
	self zap.! !

!PRealWidgetControl methods !   
backColor

	#osiHack.
	"This should probably be moved up..."
	^self wbRealWidget backColor ifNil: [self defaultBackColor]! !

!WBModelObjectEditor methods !
editedClass

    ^self owner editedClass! !

!WBPoolManagerWindow methods !   
menuCategoryFileOutSeparately

    "Callback for the menu item titled 'File out separately...'.
     (Generated by WindowBuilder)"

	| newFileName aDirectory |
	self selectedPools isEmpty ifTrue: [^self].
	self selectedCategories isEmpty ifTrue: [^self].
	newFileName := self
		promptForNewFileName: self selectedPools first fileName
		title: 'File out ', self selectedPools first poolName, '...'.
	(newFileName isNil or: [newFileName isEmpty]) ifTrue: [^self].
	aDirectory := Directory pathName: newFileName fileNamePath.
	newFileName := newFileName fileNameLessPath.
	self selectedPools first fileName: newFileName.
	self selectedPools do: [:eachPool |
		eachPool fileName isEmpty ifTrue: [
			newFileName := self promptForNewFileName: 'File out ', eachPool poolName, '...'.
			(newFileName isNil or: [newFileName isEmpty]) ifTrue: [^self].
			newFileName fileNamePath = aDirectory drivePathName ifFalse: [
				(MessageBox confirm:
					'WARNING!! ', eachPool poolName, ' will be filed out to ',
					aDirectory drivePathName, '\', newFileName fileNameLessPath,
					'  Continue?') ifFalse: [^self]].
			eachPool fileName: newFileName fileNameLessPath].
		self selectedCategories do: [:eachCategory |
			(eachPool fileNameFor: eachCategory) isEmpty ifTrue: [
				newFileName := self promptForNewFileName: 'File out ', eachCategory, ' in ', eachPool poolName, '...'.
				(newFileName isNil or: [newFileName isEmpty]) ifTrue: [^self].
				newFileName fileNamePath = aDirectory drivePathName ifFalse: [
					(MessageBox confirm:
						'WARNING!! ', eachPool poolName, ' ', eachCategory, ' will be filed out to ',
						aDirectory drivePathName, '\', newFileName fileNameLessPath,
						'  Continue?') ifFalse: [^self]].
				eachPool fileNameFor: eachCategory put: newFileName fileNameLessPath]]].
	[self menuCategoryFileOutSeparately: aDirectory]
		on: Error
		do: [:exception | ^self menuErrorHandler: exception].! !

!WBCreatePowerMenuModule methods !   
defaultMessageArguments
		"Private - Answer the default message selector arguments."
	^super defaultMessageArguments,
		(Array
			with: self defaultTargetName
			with: self defaultOwnerName)! !

!WBLinkEditor class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!WBEditClassDialog class methods !   
frequentClasses

    ^FrequentClasses ifNil: [FrequentClasses := Bag new]! !

!PComboBox methods !
minSize

	^self style = #simpleList
		ifTrue: [1@1]
		ifFalse: [1@ (self font height + 8)	].! !

!WBEventManagerWindow methods !
handlerMenu

    ^self menuTitled: 'Handler'! !

!WBInstVarObject methods !   
name

	^name ifNil: ['<Invalid>']! !

!WBGeometryManager methods !
bringForward: targets
    "Bring the <targets> forward in the z-order"

    | zOrder zTarget children aLayoutForm |
    zOrder := (children := self children) copy.
    zTarget := ((children indexOf: targets first) == 1
        ifTrue: [^self] ifFalse: [children before: targets first]).
    aLayoutForm := self layoutForm.
    (self undoManager
        add: 'Bring Forward'
        undo:
            [zOrder reverseDo: [:child |
                child bringToFront.
                children
                    remove: child;
                    addFirst: child.
                child wbSetDirty].
            self owner updateOutboardZOrderChange: zOrder.
            self updateWidget: aLayoutForm]
        redo:
            [targets do: [:child |
                child bringToFrontOf: zTarget.
                children
                    remove: child;
                    add: child before: zTarget.
                child wbSetDirty].
            self owner updateOutboardZOrderChange: targets.
            self updateWidget: aLayoutForm])
        redoAction value.! !

!WBLocator class methods !
on: anObject at: aSymbol withArguments: anArray
        ^self new setReceiver: anObject selector: aSymbol arguments: anArray! !

!WBLookPolicy methods !   
drawComboBox: aComboBox with: aPen clipRect: clipRect

    self
        displayWithBorder: aPen
        rect: aComboBox hitRect
        backColor: aComboBox backColor.
    aComboBox style == #simpleList
        ifFalse: [
            self
                drawDownArrowWith: aPen
                at: ((aComboBox hitRect rightTop left: 16) rightBottom: aComboBox hitRect rightBottom)]! !

!WindowBuilder class methods ! 
teamIsInstalled
	" Private - answer whether TeamV is currently installed. "

	| globalRegistry teamRegistry |
	globalRegistry := ServiceRegistry globalRegistry.
	teamRegistry := globalRegistry serviceNamed: #TeamVServices ifNone: [^false].
	teamRegistry serviceNamed: #TeamInstallation ifNone: [^false].
	^true! !

!PGraphPane class methods !   
styleFrom: style

	^(style bitIsOn: WsBorder)
		ifFalse: [#noBorders]
		ifTrue: [
			(style bitIsOn: WsHscroll)
				ifFalse: [#noScrollBars]
				ifTrue: [#defaultStyle]].! !

!WBSystemBitmapViewer methods !   
initWindow

    list contents: (OperatingSystemConstants keys
        select: [:str |
            (str beginsWith: 'Obm') and: [(str beginsWith: 'ObmOld') not]]) asArray.
    "(list contents collect: [:str |
        OperatingSystemConstants at: str])
        asSortedCollection asArray inspect"! !

!WBCallOutEditor methods !
updatePaneList

    panesList contents: ((callOutMap select: [:sym |
        sym isNil]) keys asSortedCollection: [:a :b | a printString <= b printString])! !

!WBCodePolicy methods !  
addKey: aKey inPoolNamed: aSymbol
	"Add the specified key to a pool in the system."

	(Smalltalk at: aSymbol) at: aKey put: nil.! !

!WindowBuilder class methods !  
defaultWBIconFileName
	"Answer the window builder icon file name."

	^'wb.ico'! !

!WindowBuilder methods !  
tagOldEvents
	"Answer the string appended to supported events."

	^' (old)'! !

!WBEventManagerWindow methods !  
menuHandlerBottom

    "Callback for the menu item titled 'Bottom'.
     (Generated by WindowBuilder)"

	| aHandler |
	self mustHaveOneHandlerSelected ifFalse: [^self].
	(aHandler := self handlerSelected) moveBottom.
	self owner updateSendField.
	handlerListBox update.
	self handlerSelected: aHandler.! !

!BitEditor methods !   
exit
    self close! !

!WBGraphicObject methods ! 
containsPoint: point

	^rect containsPoint: point! !

!WBStaticTextEditor methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel mainView ok text xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	ok := Button new.
	text := TextEdit new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Static Text Attributes';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -97 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -46 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -97 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -46 * yDU).
	self addView: mainView.
	
	text "TextEdit"
		owner: self;
		setName: 'text';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 2 * yDU;
				rightRatio: 0; rightInset: -191 * xDU;
				bottomRatio: 0; bottomInset: -73 * yDU);
		addHorizontalScrollbarStyle;
		addVerticalScrollbarStyle;
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: text.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 2 * xDU;
				topRatio: 0; topInset: 76 * yDU;
				rightRatio: 0; rightInset: -46 * xDU;
				bottomRatio: 0; bottomInset: -90 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView
		addSubpane: ok;
		subPaneWithFocus: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 48 * xDU;
				topRatio: 0; topInset: 76 * yDU;
				rightRatio: 0; rightInset: -92 * xDU;
				bottomRatio: 0; bottomInset: -90 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel! !

!WBPMenuItem methods !   
selector:  aSelector

    (selector isMessage and: [
        selector receiver isWBAction]) ifTrue: [
        selector receiver receiver: nil
    ].

    selector := aSelector.! !

!WBLookPolicyWin31 methods !
drawMinimizeButtonWith: aPen at: aRect

    | innerRect |
    innerRect := self draw3DBoxWith: aPen at: aRect.
    aPen
        foreColor: Color white;
        wbLineFrom: (aRect leftTop rightAndDown: 1@1) to: (aRect leftBottom rightAndUp: 1@2);
        wbLineFrom: (aRect leftTop rightAndDown: 1@1) to: (aRect rightTop leftAndDown: 2@1);
        foreColor: Color gray;
        wbLineFrom: (aRect leftTop rightAndDown: 2@2) to: (aRect leftBottom rightAndUp: 2@3);
        wbLineFrom: (aRect leftTop rightAndDown: 2@2) to: (aRect rightTop leftAndDown: 3@2);
        foreColor: Color black;
        polygonFilled: (Array
            with: (innerRect center leftAndDown: 1)
            with: (innerRect center rightAndUp: 2@2)
            with: (innerRect center leftAndUp: 4@2)).! !

!WBEventManagerWindow methods !
menuOptionSendFieldShowAll

    "Callback for the menu item titled 'Show all selectors'.
     (Generated by WindowBuilder)"

	self sendFieldShowAll: self sendFieldShowAll not.! !

!PEntryFieldGroup methods !
suggestedSize

	^self rect width @ self bestSize y! !

!WBPropertyDescriptor methods !
changeBlock: aBlock
    "Set the value of changeBlock."

    changeBlock := aBlock! !

!WBCreateViewModule methods ! 
generateAddPane: aPane to: aParent using: aSymbol
		"Private - Generate the addSubpane: code."
	| isTabStop |
	aPane isWBInterfaceObject ifFalse: [^self].
	isTabStop := false.
	(self propertyAt: #subPaneWithFocus) isNil ifTrue: [
		(aPane generateTabStopsAndGroups
			and: [aPane usesFocus & aPane tabPosition notNil]
		) ifTrue: [
			self propertyAt: #subPaneWithFocus put: aPane.
			isTabStop := true]].
	self stream 
		cr;
		nextPutAll: (self varNameFor: aParent).
	isTabStop
		ifTrue: [self stream indentBy: 1; cr]
		ifFalse: [self stream space].
	self stream
		nextPutAll: aSymbol ;
		space.
	(self isInstVar: (self varNameFor: aPane)) & self useInstVars not
		ifTrue: [self stream nextPutAll: (self varNameFor: #owner); space].
	self stream
		nextPutAll: (self varNameFor: aPane);
		endMessage.
	isTabStop ifTrue: [
		self stream cr;
			nextPutAll: #subPaneWithFocus: ;
			space;
			nextPutAll: (self varNameFor: aPane);
			endMessage;
			indentBy: -1].
	self stream
		endExpression.! !

!WBModelDefinitionEditor methods !   
setInitialized: aBoolean

    | selectedItem |
    selectedItem := attributes selectedItem ifNil: [^nil].
    selectedItem initialized == aBoolean ifTrue: [^self].
    selectedItem initialized: aBoolean.
    aBoolean & hasEvent selection
        ifTrue: [
            lazy selection: true; enable.
            selectedItem lazy: true.
            self setClass: myClass selectedItem]
        ifFalse: [
            lazy selection: false; disable.
            selectedItem lazy: false].
    self updateInitializeValue: attributes selectedItem.
    self setDirty.! !

!PCompositePane methods !  
storeSpecificsOn: aStream indentString: indentString

    super storeColorOn: aStream indentString: indentString.

	#addSubpanes.
	"No longer needed as this is called in CompositePane>>buildWindow:"
    "aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'addSubpanes'"! !

!ApplicationCoordinator class methods ! 
wbReservedInstVarNames
        "Answer a collection of reserved inst var names."
    ^ApplicationCoordinator allInstVarNames! !

!WBPrototype methods !   
realClass
		"Answer the real class."
	^self shell realClass! !

!WBOutboardAttributeWindow methods !  
cancel
    "Callback for the #clicked event in <Unnamed> [Button]
	    (Generated by WindowBuilder Pro)"

    self close.! !

!WindowBuilder methods !  
codeGenerator
	"Private - Answer the code generator."

	^self 
		propertyAt: #CodeGenerator 
		ifAbsent: [self defaultCodeGenerator]! !

!WBEventManagerWindow class methods ! 
warningClasses

	^warningClasses ifNil: [
		warningClasses := self defaultWarningClasses].! !

!WBEventManagerWindow methods !   
widgetSelections

	^widgetListBox selectedItems! !

!WBAttributeWindow methods !  
shellChildren
		"Answer the shell children."
	^self shell children! !

!WBInterfaceObject methods !   
mutationExceptions

    ^#()! !

!WBOutboardAttributeWindow methods ! 
dirty: aBoolean
    "Set the dirty flag."

    | panes button |
    panes := (#('okButton' 'applyButton')
        collect: [:each | self paneNamed: each])
        select: [:each | each notNil].
    (dirty := aBoolean)
        ifTrue: [panes do: [:each | each enable]]
        ifFalse: [panes do: [:each | each disable]].
	(button := self paneNamed: 'cancelButton') notNil ifTrue: [
		button contents: (aBoolean ifTrue: ['Cancel'] ifFalse: ['Close'])].! !

!WBAbstractCodeModule methods !  
initCodeGeneration
		"Private - Initialize before code generation."! !

!SelectorPropertyAccessor methods !
wbMutateAction

	^self propertyAt: #wbMutateAction! !

!WBLookPolicyOS2 methods ! 
leftJustification

    ^"DtLeft" 0! !

!WBLookPolicyWin95 methods !   
drawMaximizeButtonWith: aPen at: aRect

    | innerRect |
    innerRect := self
        drawTitleBarBoxWith: aPen
        at: aRect.
    aPen
        foreColor: Color black;
        drawRectangle: (innerRect insetBy: (2 @ (2 + Rectangle leftTopUnit y) extent: 0 @ (-1 - (Rectangle leftTopUnit y))));
        wbLineFrom: (innerRect leftTop rightAndDown: 2@(1-Rectangle leftTopUnit y)) 
			to: (innerRect rightTop leftAndDown: (2 + Rectangle leftTopUnit y) @(1 - Rectangle leftTopUnit y)).! !

!WBGeometryManager methods !  
hideHandles: aCollection

    self layoutForm hideHandles: aCollection! !

!WBPropertyEditor methods !
selectCategory: selectedItem

    propertyList contents:
        ((WindowBuilder propertiesAtCategory: self selectedCategory) values
            collect: [:property | self labelForProperty: property]) asSortedCollection asArray.

    self setValue: nil.
    comment contents: self emptyString.
    propertyList clearSelection! !

!LayoutFrame methods !
wbRightAttachedToLeft
	"Answer true if the receiver's right is attached to the receiver's left."

	^(self propertyAt: #wbRightAttachedToLeft) ifNil: [
		self wbRightAttachedToLeft: (
			self wbLeftProportional and: [
				(self rightRatio = self leftRatio) & (self rightInset ~= 0)])]! !

!WBCodeStream methods !   
nextPutArrayOfBytes: aCollection

	self generateByteArrayCode
		ifTrue: [self nextPutAll: '#[']
		ifFalse: [self nextPutAll: '#('].
	aCollection do: [:eachByte |
		self
			nextPutAll: eachByte printString;
			space].
	self generateByteArrayCode
		ifTrue: [self nextPutAll: ']']
		ifFalse: [self nextPutAll: ')'].! !

!WindowBuilder class methods !  
helpDict

    HelpDict isNil
        ifTrue: [
            (HelpDict := Dictionary new)
                at: 'File' put: 'Create, edit, import, export window definitions; edit app code.';
                at: #menuFileNew put: 'Create a new window.';
                at: #menuFileNewDialog put: 'Create a new dialog.';
                at: #menuFileOpen put: 'Open an existing window or dialog.';

                at: 'Composite Panes' put: 'Create, edit, or ungroup CompositePanes.';
                at: #menuFileNewComposite put: 'Create a new CompositePane.';
                at: #menuFileOpenComposite put: 'Open an existing CompositePane.';
                at: #menuFileCreateComposite put: 'Create a CompositePane from the selected widgets.';
                at: #menuFileUngroupComposite put: 'Ungroup the selected CompositePane.';

                at: 'Model Objects' put: 'Select, edit and define model objects.';
                at: #menuFileSelectPrimaryModel put: 'Select the primary model to use with this window.';
                at: #menuFileEditModelObjects put: 'Edit the model objects used with this window window.';
                at: #menuFileDefineModelObject put: 'Create or edit model class definitions.';

                at: 'Res Files' put: 'Import and export dialogs to/from .RES files..';
                at: #menuFileImportFromResFile put: 'Convert dialog resources (.RES files) to Smalltalk dialogs.';
                at: #menuFileExportToResFile put: 'Save the current dialog layout as a resource (.RES) file.';

                at: #menuFileLayoutWizard put: 'Build a default screen using the layout wizard.';
                at: #menuFileSave put: 'Save the currently edited window.';
                at: #menuFileSaveAs put: 'Save the currently edited window with a new class name.';
                at: #menuFileSaveAsDefault put: 'Use the current layout of windows as the default for new windows.';
                at: #menuFileExit put: 'Exit WindowBuilder Pro.';
                at: #menuFileAbout put: 'Launch WindowBuilder Pro About Dialog.';
                at: #menuFileInstalledProducts put: 'Get a list of installed products.';

                at: 'Edit' put: 'Widget editing, selection, ordering;  window testing, tab order editing, edit app code';
                at: #undo put: 'Undo the last command.';
                at: #redo put: 'Redo the last command.';
                at: #undoRedoList put: 'Launch the Undo/Redo List dialog.';
                at: #cutSelections put: 'Remove currently selected widgets from layout, place on clipboard.';
                at: #copySelections put: 'Copy the currently selected widgets to the clipboard.';
                at: #pasteSelections put: 'Load the cursor with the widgets on the clipboard.';
                at: #clearSelections put: 'Remove currently selected widgets from layout.';
                at: #menuEditClear put: 'Remove currently selected widgets from layout.';

                at: 'Select' put: 'Select all, select in same class, select in same hierarchy.';
                at: #selectAll put: 'Add all widgets in window to the selection.';
                at: #selectAllInSameClass put: 'Select all widgets of the same class as the selected widget.';
                at: #selectAllInHierarchy put: 'Select all widgets in the same class hierarchy as the selected widget.';

                at: #bringToFront put: 'Bring currently selected widget to the front of all overlapping widgets.';
                at: #sendToBack put: 'Send currently selected widget behind all overlapping widgets.';
                at: #bringForward put: 'Bring currently selected widget forward one layer in the Z-order.';
                at: #sendBackward put: 'Send currently selected widget backward one layer in the Z-order.';
                at: #duplicate put: 'Duplicate the currently selected widgets.';
                at: #menuEditMorph put: 'Morph the currently selected widget into a different type.';

                at: #menuEditBrowseClass put: 'Browse the code for the currently edited window.';
                at: #menuEditBrowseWidgetClass put: 'Browse the code for the currently selected widget.';
                at: #menuEditEventSummary put: 'Launch window summarizing event usage in this window.';
                at: #menuEditPasteWindowBitmapToClipboard put: 'Copy a bitmap of current window to the clipboard.';
                at: #menuEditTestWindow put: 'Launch an example of currently edited window.';

                at: 'Attributes' put: 'Widget and window attributes.';
                at: #setFont put: 'Set the font of the selected widgets.';
                at: #setColor put: 'Set the color of the selected widgets.';
                at: #setFraming put: 'Set the framing characteristics of the selected widgets.';
                at: #setMenu put: 'Set the popup menu of the selected widgets.';
                at: #setEvents put: 'Edit the event handlers of the selected widgets.';
                at: #setOther put: 'Set the attributes of the selected widgets.';
                at: #setTabbing put: 'Edit widget tabbing order and grouping of buttons.';
                at: #setCallOuts put: 'Define call out selectors for widgets in the window.';

                at: 'NLS' put: 'Manage NLS features.';
                at: #setNLSPools put: 'Set the NLS Pool Dictionaries to be used with this window.';
                at: #menuNlsAutosize put: 'Toggle whether NLS strings should be used for autosizing.';

                at: #setParts put: 'Add a PARTS Workbench interface to the window.';

                at: 'View' put: 'View creation, removal, switching.';
                at: #viewSwitchTo put: 'Switch to another view in this ViewManager.';
                at: #viewCreate put: 'Create a new view in this ViewManager.';
                at: #viewRemove put: 'Remove a view from this ViewManager.';

                at: 'Align' put: 'Alignment commands.';
                at: #alignLeft put: 'Align selected widgets along left sides.';
                at: #alignTop put: 'Align selected widgets along tops.';
                at: #alignRight put: 'Align selected widgets along right sides.';
                at: #alignBottom put: 'Align selected widgets along bottoms.';

                at: 'Center' put: 'Centering selected widgets.';
                at: #alignCenterHorizontally put: 'Align selected widgets along their horizontal centers.';
                at: #alignCenterVertically put: 'Align selected widgets along their vertical centers.';

                at: 'Distribute' put: 'Distribute selected widgets.';
                at: #distributeHorizontally put: 'Distribute selected widgets horizontally.';
                at: #distributeVertically put: 'Distribute selected widgets vertically.';

                at: 'Move By Pixel' put: 'Nudge selection around by one pixel increments.';
                at: #moveByPixelUp put: 'Nudge selection up one pixel.';
                at: #moveByPixelDown put: 'Nudge selection down one pixel.';
                at: #moveByPixelLeft put: 'Nudge selection left one  pixel.';
                at: #moveByPixelRight put: 'Nudge selection right one pixel.';

                at: 'Size By Pixel' put: 'Size selection by one pixel increments.';
                at: #sizeByPixelUp put: 'Shrink selection''s height by one pixel.';
                at: #sizeByPixelDown put: 'Grow selection''s height by one pixel.';
                at: #sizeByPixelLeft put: 'Shrink selection''s width by one pixel.';
                at: #sizeByPixelRight put: 'Grow selection''s width by one pixel.';

                at: 'Size' put: 'Size widgets or window, set window position.';
                at: #autoSize put: 'Size selected widgets according to predefined hints.';
                at: #replicateWidth put: 'Set width of selected widgets to be the same.';
                at: #replicateHeight put: 'Set height of selected widgets to be the same.';
                at: #menuSizeSetWidgetSize put: 'Specify the size of the selected widget or window, in pixels.';
                at: #menuSizeSetWidgetPosition put: 'Specify initial launching position of the window.';

                at: 'Options' put: 'Set grid, window zooming, templates, properties.';

                at: 'Grid' put: 'Toggle using or drawing the grid.Set grid size.';
                at: #menuOptionsUseGrid put: 'Toggle using the grid.';
                at: #menuOptionsDrawGrid put: 'Toggle display of the grid.';
                at: #menuOptionsSetGridSize put: 'Set the size of the snap-to grid, in pixels.';

                at: 'Look Policy' put: 'Set the look policy for displaying the edited window.';
                at: #menuOptionsLookPolicyDefault put: 'Use the default look policy.';
                at: #menuOptionsLookPolicyWin31 put: 'Use the Windows 3.1 look policy.';
                at: #menuOptionsLookPolicyWin95 put: 'Use the Windows 95 look policy.';
                at: #menuOptionsLookPolicyOS2 put: 'Use the OS/2 look policy.';

                at: #menuOptionsDragOutlines put: 'Toggle dragging widgets by outline.';
                at: #menuOptionsShowZOrder put: 'Toggle showing the Z-order.';
                at: #menuOptionsTargetIsFirst put: 'Toggle whether the target is the first or last selection.';
                at: #menuOptionsUseFence put: 'Toggle using the window boundary to constrain the widget positions.';
                at: #menuOptionsMiniHelpEnabled put: 'Toggle whether popup mini help is used.';
                at: #menuOptionsAutoUpdateOutboards put: 'Toggle automatic updating of outboard windows.';
                at: #menuOptionsAutoSave put: 'Toggle prompting for saving before Test Window.';
                at: #menuOptionsAutoSize put: 'Toggle autosizing of StaticText and Buttons as text is entered.';
                at: #menuOptionsZoomLayout put: 'Zoom/unzoom the layout area of WindowBuilder Pro.';
                at: #menuOptionsTemplates put: 'Invoke the Template Editor.';
                at: #menuOptionsProperties put: 'Invoke the Property Editor.';

                at: 'Managers' put: 'Invoke one a manager window.';
                at: #menuOptionsAddInManager put: 'Invoke the WindowBuilder Pro Add-In Manager.';
                at: #menuOptionsBitmapManager put: 'Manage bitmaps.';
                at: #menuOptionsFontManager put: 'Manage fonts.';
                at: #menuOptionsNlsManager put: 'Manage NLS strings and pools.';

                at: #menuOptionsRedraw put: 'Redraw the editing window.';

                at: 'Scrapbook' put: 'Scrapbook commands.';
                at: #menuScrapbookStore put: 'Store the currently selected panes as a page in the scrapbook.';
                at: #menuScrapbookRetrieve put: 'Retrieve a page from the scrapbook.';
                at: #menuScrapbookNew put: 'Create a new scrapbook.';
                at: #menuScrapbookLoad put: 'Load a scrapbook from disk.';
                at: #menuScrapbookMerge put: 'Merge a scrapbook from disk with the current one.';
                at: #menuScrapbookSave put: 'Save the current scrapbook to disk.';

                at: 'Quick Reference' put: 'Retrieve a page from the Quick Reference list.';
                at: #menuScrapbookQuickReference put: 'Use an item in the Quick Reference list.';

                at: 'Add' put: 'Load cursor with controls.';
                at: 'Button' put: 'Load cursor with one of the buttons.';
                at: '3D Button' put: 'Load the cursor with one of the 3D buttons.';
                at: 'List' put: 'Load the cursor with one of the listboxes.';
                at: 'Valuator' put: 'Load the cursor with one of the valuators.';
                at: 'Text' put: 'Load the cursor with one of the text editors.';
                at: 'Group' put: 'Load the cursor with one of the groupboxes.';
                at: 'Misc' put: 'Load the cursor with one of the miscellaneous widgets.';
                at: 'Composite' put: 'Load the cursor with one of the composite widgets.';
                at: 'Windows 95' put: 'Load the cursor with one of the Windows 95 widgets.';

                at: 'Custom Widgets' put: 'Load the cursor with one of the user-defined widgets.';
                at: #menuAddAddCustomPane put: 'Add a new custom widget to the Custom Widgets menu.';
                at: #menuAddRemoveCustomPane put: 'Remove a custom widget from the Custom Widgets menu.';
                at: #addWidget: put: 'Add a widget to the window.'.
            ].
    ^HelpDict! !

!PButton methods !   
style: aStyle
	"Note that there can only be one default or
	 cancel pushbutton in a window."
	| button  |
	super style: aStyle.
	self style == #defaultPushButton
		ifTrue: [
			self specialId: 1.
			(button := self otherButtonWithID: 1) isNil
				ifFalse: [
				button specialId: nil; style: #pushButton.
				^nil]]
		ifFalse: [
			self style == #cancelPushButton
				ifTrue: [
					self specialId: 2.
					(button := self otherButtonWithID: 2) isNil
						ifFalse: [
							button specialId: nil; style: #pushButton.
							^nil]]
				ifFalse: [self specialId: nil]].! !

!WBBitmapManagerWindow methods !   
menuKeyFileOutRCFile

	"Must perform a copy to file out bitmaps in a DLL."

	self menuKeyFileOutRCFile: #wbCopy.! !

!WBLookPolicyOS2 methods ! 
defaultWidgetBackColor

    ^self defaultOS2WidgetBackColor! !

!EntryFieldGroup class methods !  
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #textChanged:pane: ;
                argumentNames: #('anObject'));
        yourself! !

!CompositeFrameObject methods !
paneName: aString! !

!WBActionEditor methods ! 
newAuthor: aString

    (self paneNamed: 'add')
        contents: '&Change';
        enable.
    author := aString.
    changed := true.! !

!PEnhancedEntryField methods !   
storeSpecificsOn: aStream indentString: indentString

	self maximumSize == 0
		ifFalse: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'setTextLimit: ', self maximumSize asString].
	self getFocus == #selectAll
		ifFalse: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'getFocus: #', self getFocus asString].
	self case notNil
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'case: #', self case asString].
	self character notNil
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'character: #', self character asString].
	self field notNil
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'field: #', self field asString].
	self justification == #left
		ifFalse: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, self justification asString].
	self autoTab
		ifTrue: [aStream nextPutAll: ';'; cr; nextPutAll: indentString, 'autoTab'].! !

!WindowBuilder methods !   
updateNlsMenu

	self nlsAutosize
		ifTrue: [self nlsMenu checkItem: #menuNlsAutosize]
		ifFalse: [self nlsMenu uncheckItem: #menuNlsAutosize].! !

!WindowBuilder methods ! 
layoutForm

    "self prototype isNil ifTrue: [^nil]."
    ^self currentLayoutForm! !

!WBCreateClassDialog methods !
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel className mainView nameText ok packageLabel 
	packageName setApplicationCoordinator setDefault 
	setViewManager superclassLabel superclassName xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	className := WBComboBox new.
	nameText := StaticText new.
	ok := Button new.
	packageLabel := StaticText new.
	packageName := WBComboBox new.
	setApplicationCoordinator := RadioButton new.
	setDefault := Button new.
	setViewManager := RadioButton new.
	superclassLabel := StaticText new.
	superclassName := WBComboBox new.
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Save New Class';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -82 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -111/2 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -82 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -111/2 * yDU).
	self addView: mainView.
	
	className "WBComboBox"
		owner: self;
		setName: 'className';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 14 * yDU;
				rightRatio: 0; rightInset: -160 * xDU;
				bottomRatio: 0; bottomInset: -74 * yDU);
		dropDown;
		startGroup;
		font: SysFont.
	mainView
		addSubpane: className;
		subPaneWithFocus: className.
	
	superclassName "WBComboBox"
		owner: self;
		setName: 'superclassName';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 40 * yDU;
				rightRatio: 0; rightInset: -160 * xDU;
				bottomRatio: 0; bottomInset: -100 * yDU);
		dropDownList;
		startGroup;
		font: SysFont.
	mainView addSubpane: superclassName.
	
	setViewManager "RadioButton"
		owner: self;
		setName: 'setViewManager';
		addClipsiblingsStyle;
		when: #turnedOn send: #setViewManager to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 13/2 * xDU;
				topRatio: 0; topInset: 52 * yDU;
				rightRatio: 0; rightInset: -133/2 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		contents: '&ViewManager';
		startGroup;
		font: SysFont.
	mainView addSubpane: setViewManager.
	
	setApplicationCoordinator "RadioButton"
		owner: self;
		setName: 'setApplicationCoordinator';
		addClipsiblingsStyle;
		when: #turnedOn send: #setApplicationCoordinator to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 137/2 * xDU;
				topRatio: 0; topInset: 52 * yDU;
				rightRatio: 0; rightInset: -317/2 * xDU;
				bottomRatio: 0; bottomInset: -64 * yDU);
		contents: '&ApplicationCoordinator';
		noTabStop;
		font: SysFont.
	mainView addSubpane: setApplicationCoordinator.
	
	packageName "WBComboBox"
		owner: self;
		setName: 'packageName';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 76 * yDU;
				rightRatio: 0; rightInset: -160 * xDU;
				bottomRatio: 0; bottomInset: -136 * yDU);
		dropDownList;
		startGroup;
		font: SysFont.
	mainView addSubpane: packageName.
	
	ok "Button"
		owner: self;
		setName: 'ok';
		addClipsiblingsStyle;
		when: #clicked send: #ok to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 92 * yDU;
				rightRatio: 0; rightInset: -44 * xDU;
				bottomRatio: 0; bottomInset: -108 * yDU);
		defaultPushButton;
		contents: '&OK';
		startGroup;
		font: SysFont.
	mainView addSubpane: ok.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		addClipsiblingsStyle;
		when: #clicked send: #cancel to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 50 * xDU;
				topRatio: 0; topInset: 92 * yDU;
				rightRatio: 0; rightInset: -90 * xDU;
				bottomRatio: 0; bottomInset: -108 * yDU);
		cancelPushButton;
		contents: '&Cancel';
		startGroup;
		font: SysFont.
	mainView addSubpane: cancel.
	
	setDefault "Button"
		owner: self;
		setName: 'setDefault';
		addClipsiblingsStyle;
		when: #clicked send: #setDefault to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 114 * xDU;
				topRatio: 0; topInset: 92 * yDU;
				rightRatio: 0; rightInset: -160 * xDU;
				bottomRatio: 0; bottomInset: -108 * yDU);
		contents: 'Set Default';
		startGroup;
		font: SysFont.
	mainView addSubpane: setDefault.
	
	packageLabel "StaticText"
		owner: self;
		setName: 'packageLabel';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 66 * yDU;
				rightRatio: 0; rightInset: -160 * xDU;
				bottomRatio: 0; bottomInset: -74 * yDU);
		contents: 'Package:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: packageLabel.
	
	nameText "StaticText"
		owner: self;
		setName: 'nameText';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -160 * xDU;
				bottomRatio: 0; bottomInset: -12 * yDU);
		contents: 'New Class Name:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: nameText.
	
	superclassLabel "StaticText"
		owner: self;
		setName: 'superclassLabel';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 30 * yDU;
				rightRatio: 0; rightInset: -160 * xDU;
				bottomRatio: 0; bottomInset: -38 * yDU);
		contents: 'Superclass:';
		startGroup;
		noTabStop;
		font: SysFont.
	mainView addSubpane: superclassLabel! !

!WBTabOrderLayoutForm methods ! 
notifyModelOfSizeOrPositionChange
	"Do Nothing"! !

!WBLookPolicyWin31 methods !   
titleBarHeight

    ^titleBarHeight ifNil: [
        titleBarHeight := (self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCysize" 31]
            ifFalse: [super titleBarHeight]) + 1]! !

!WBManagedPValue class methods !  
for: anOwner value: anObject
	"Answer an new initialized instance."

	^self new
		owner: anOwner;
		value: anObject;
		yourself! !

!WBManagedPValue methods !
owner: anObject

	owner := anObject.! !

!WindowBuilder class methods !   
defineProperties
    "Define the initial properties used in WindowBuilder Pro"

    | collection |
    collection := OrderedCollection new: 24.

    self
        defineGridProperties: collection;
        defineEditorProperties: collection;
        defineUserProperties: collection;
        defineCodeGenerationProperties: collection.

    ^collection! !

!WBScrollingPane methods !   
scrollTopCorner: p unlimited: bool

    | oldCorner aPoint scrollRanges |

    aPoint := p x @ p y.

    oldCorner := topCorner deepCopy.

    scrollRanges := self getScrollRanges.

    bool ifFalse: [
        topCorner x: ((topCorner x - aPoint x  min: (scrollRanges x)) max: 0).
        topCorner y: ((topCorner y - aPoint y min: (scrollRanges y)) max: 0).
    ] ifTrue: [
        topCorner x: ((topCorner x - aPoint x) max: 0).
        topCorner y: ((topCorner y - aPoint y) max: 0).
    ].

    oldCorner = topCorner ifFalse: [

        UserLibrary
            scrollWindow: handle
            xAmount: oldCorner x - topCorner x
            yAmount: oldCorner y - topCorner y
            lpRect: nil
            clipRect: nil.

        self updateWindow.
    ].! !

!WBApplicationCoordinatorMenuModule methods ! 
initVarNames
        "Private - Initialize the variable names."
    self varNameFor: #pane ifAbsentPut: [ self defaultViewName ].
    super initVarNames.! !

!WBTemplateEditor methods !
setText: aString

	template isNil ifTrue: [^self].
	template text: aString.
	self redraw.! !

!WBLayoutForm methods !   
replaceSelectionsWithComposite: compositeClass
    "Replace the selected widgets with an instance of <compositeClass>"

    | boundingBox newWidgets |
    self hideHandles.
    boundingBox := self boundingBoxFor: self selections.
    newWidgets := OrderedCollection
        with: ((compositeClass wbPseudoClass exampleFrom: compositeClass symbol)
            wbCloneWithParent: self shell width: boundingBox width height: boundingBox height).
    self
        createUndoRedoForNewWidgets: newWidgets
        oldWidgets: self selections
        named: 'Replace With Composite'.
    self selections do: [:aWidget |
        aWidget isDestroyed ifFalse: [[aWidget wbDestroyWidget] on: Error do: []]].
    self
        placeNewWidgets: newWidgets
        at: self selectedRect topLeft.
    self shell sortChildrenByTabOrder.
    self selections: newWidgets.! !

!WBCodeModule methods ! 
initVarNames
		"Private - Initialize the variable names."! !

!CheckBoxGroup class methods !   
wbConstructPropertyManager
    "Construct the WindowBuilder property manager
        based on the Digitalk property manager."

    #addedByOSI.
    ^super wbConstructPropertyManager
        wbAddEvent: (
            WBEventDescription new
                event: #changedIndex:set: ;
                argumentNames: #('anObject'));
        yourself! !

!WBModelDefinitionEditor methods ! 
initWindow

	models printSelector: #name.
	attributes printSelector: #name.
	(self paneNamed: 'modelTypes')
		contents: self modelTypeList;
		selectItem: self modelTypeList first.
	self
		loadModels;
		disableFields;
		clearDirty.
	selectedModel isNil
		ifTrue: [self disableModelFields]
		ifFalse: [
			models selectItem: selectedModel.
			self select: selectedModel].! !

!WindowBuilder class methods ! 
clearCustomPanes
	"  WindowBuilder clearCustomPanes   "

	CustomPanes := nil.! !

!WBInterfaceObject methods !   
wbCloneWithParent: aParent

	^(aParent children add: self wbDuplicate)
		parent: aParent;
		yourself.! !

!WindowBuilder class methods !
initializePrivateProperties

    | propertyCollection categories |

    categories := Set new.
    (propertyCollection := self definePrivateProperties) do: [:property |
        categories add: property category].

    categories do: [:category |
        Properties at: category put: IdentityDictionary new].

    propertyCollection do: [:property |
        property value: property default.
        (Properties at: property category)
            at: property name
            put: property].

    self propertyAt: #OpenMethodType put: #createViews.
    self propertyAt: #CodeGenerationHook put: nil.
    self propertyAt: #WBCreateClassDialog put: WBCreateClassDialog.! !

!WBAbstractPrompter methods !
prompt: aString

	self promptField contents: aString.! !

!WBPrototype methods !  
propertyAt: key put: aValue
        "Set the value associated with key
        in the properties dictionary."
    properties isNil ifTrue: [properties := IdentityDictionary new].
    aValue isNil ifTrue: [^properties removeKey: key ifAbsent: [nil]].
    ^properties at: key put: aValue! !

!String methods !
asSuggestedUnarySelectorToken
		"Answer the receiver as a suggested token."
	#addedByOSI.
	^self asUnarySelectorToken asLowerCaseFirstCaps! !

!PropertyAccessor methods !   
wbRemoveStyle: aSymbol

	#addedByOSI.
	self propertyAt: #wbRemoveStyleAction put: aSymbol.! !

!SelectorPropertyAccessor methods !   
wbDuplicateAction

	^self propertyAt: #wbDuplicateAction! !

!WBCallOutEditor methods !   
cancel

    "Callback for the #clicked event triggered in the Button named 'cancel'.
     (Generated by WindowBuilder)"

    self close! !

!WindowBuilder class methods ! 
userNamePrim
	"Answer the window builder user's name."

	^self editorClass
		propertyValueAt: #UserName
		category: self userPropertyString! !

!WBGraphicObject methods ! 
wbDuplicateTo: copy

	self fullCopy: copy.
	^copy! !

!WindowBuilder methods !   
miniHelpEnabled

    ^self class miniHelpEnabled! !

!WBInterfaceObject methods ! 
updateWidgetMoved

    (self layoutForm ifNil: [^nil])
        updateRects: self lastRect
        and: self hitRect! !

!WBTabPosition methods !
groupPosition

    ^groupPosition! !

!WindowFrameObject methods !
convertFramingBlocks
	"Convert all framingBlocks."

	self wbEditorClass useLayoutFrame
		ifTrue: [
			self framingBlock: self framingBlock asLayout.
			self children do: [:each |
				each framingBlock: each framingBlock asLayout]]
		ifFalse: [
			self framingBlock: (self framingBlock asFramingParameters: Display boundingBox).
			self children do: [:each |
				each framingBlock: (each framingBlock asFramingParameters: self rect)]].! !

!WBLayoutForm methods !   
hideOrderSymbols
    "Hide the order symbols"

    ^self hideOrderSymbolsFor: self children! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBTemplateEditor methods ! 
okToSetFraming

	^true! !

!WBEventManagerWindow methods !
promptForGlobal

	^WBListChooser promptForGlobal! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBDevelopmentWindow methods !  
templateAt: aSymbol put: anInterfaceObject

	^WBInterfaceObject templateAt: aSymbol put: anInterfaceObject! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBNLSDictionaryReader class methods !
fileOutToken: aToken on: aStream
	"File out a token/value pair."

	aStream
		cr;
		nextPutAll: aToken.! !

!WBCodeStream methods ! 
closeBracket
	"Append a ']' to the code stream."

	stream nextPut: $].
	self indentBy: -1.! !

!WBCodePolicy methods !  
logMethodFor: aCodeModule
	"Private - Log the specified method source."

	| hook |
	aCodeModule shouldLogMethodSource ifFalse: [^self].
	(hook := self wbEditorClass codeGenerationHook) notNil
		ifTrue: [
			(self respondsTo: hook)
				ifTrue: [
					^self
							perform: hook asSymbol
							with: aCodeModule sourceString
							with: aCodeModule messageSelector
							with: aCodeModule targetClass].
			(self wbEditorClass respondsTo: hook)
				ifTrue: [
					^self wbEditorClass
							perform: hook asSymbol
							with: aCodeModule sourceString
							with: aCodeModule messageSelector
							with: aCodeModule targetClass]].
	self basicLogMethodFor: aCodeModule.! !

!WindowBuilder methods !
createLayoutForm

    ^currentLayoutForm := self layoutFormClass new
        owner: self;
        paneName: 'mainPane';
        framingBlock: [:box | (box leftTop leftAndUp: 2@2) extentFromLeftTop: 10000@10000];
        when: #cursorUnloaded send: #cursorUnloaded to: self;
        when: #selectionChanged: send: #newSelection: to: self;
        when: #changed send: #layoutFormChanged to: self;
        when: #gettingFocus send: #resetFocus to: self;
        when: #editPane send: #setOther to: self;
        when: #rightButtonDown: send: #popupPaneMenu: to: self;
        yourself.! !

!PComboBox methods !
mutationTypes

    ^#(#ListBox #CPScrollingPane #RadioButtonGroup)! !

!WBLocator methods !   
selector
        ^selector! !

!WBPoolManager methods !
codeSelector
	"Answer the selector to access the receiver from its class."

	^self == self class current
		ifTrue: [#current] ifFalse: [#system]! !

!WBPoolManagerWindow methods ! 
updateEditor

	editorCompositePane updateEditor.! !

!WBTabOrderEditor methods !  
createLayoutForm

    ^layoutForm := self layoutFormClass new
        owner: self owner;
        paneName: 'layoutPane';
        framingBlock: [:box | (box leftTop leftAndUp: 2@2) extentFromLeftTop: 10000@10000];
        "when: #gettingFocus send: #resetFocus to: self;"
        when: #setTabPosition send: #tabPlaced to: self;
        when: #setGroup send: #setGroup to: self;
        when: #deletedGroup send: #deletedGroup to: self;
        when: #clicked: send: #clicked: to: self;
        yourself! !

!WBLayoutForm methods !   
arrowKeyInput: virtualKey

    | x y |
    x := (self gridSize x max: 1) * Rectangle leftRightUnit.
    y := (self gridSize y max: 1) * Rectangle topBottomUnit.
    virtualKey = UpKey
        ifTrue: [^self keyMove: 'Up' x: 0 y: y negated].
    virtualKey = DownKey
        ifTrue: [^self keyMove: 'Down' x: 0 y: y].
    virtualKey = LeftKey
        ifTrue: [^self keyMove: 'Left' x: x negated y: 0].
    virtualKey = RightKey
        ifTrue: [^self keyMove: 'Right' x: x y: 0].
    ^false.
! !

!PColumnListBox methods ! 
listEditorValidation

    ^#okPositiveInteger:! !

!WBTabOrderLayoutForm methods !
createUndoRedoForNewWidgets: newWidgets oldWidgets: oldWidgets named: aString
    "Do Nothing"! !

!WBColorDialog methods !
foreColor: f backColor: b paneEdited: aPane

    foreColor := f.
    backColor := b.
    thePane := aPane.

    self open.

    ^result! !

!WBLayoutForm methods ! 
selectAllInSameClass
    "Select all of the widgets in the same class as the selected widget."

    | newSelections |
    newSelections := self children select: [:child |
        child ~~ self selections first and: [
        child realClass == self selections first realClass]].

    self
        selections: (newSelections addFirst: self selections first; yourself);
        showHandles! !

!WBCreateViewModule methods ! 
generateCallOutFor: aPane instVar: aBoolean
		"Generate the code..."
	self stream cr.
	aBoolean
		ifTrue: [
			self stream
				nextPutAll: (self varNameFor: #owner);
				space;
				nextPutAll: (self varNameFor: aPane);
				nextPutAll: ': (']
		ifFalse: [
			self stream
				nextPutAll: (self varNameFor: aPane);
				nextPutAll: ' := '].
	self stream
		nextPutAll: #self;
		space;
		nextPutAll: aPane creationMethodSelector;
		space;
		nextPutAll: (self varNameFor: #owner).
	aBoolean ifTrue: [self stream nextPut: $)].
	self stream 	endExpression.

	self addModule: (
		WBCallOutModule new
			targetClass: self targetClass;
			targetObject: self targetObject;
			view: self view;
			object: aPane;
			yourself).! !

!WindowBuilder methods !   
menuFileInstalledProducts

	self class installedProducts! !

!WBLayoutForm methods !  
placeWidgets: aPoint
    "Handle the placement of widgets in the editor"

    self hideHandles.
    self loadedWidgets size > 1
        ifTrue: [
            self cloneWidgets: self loadedWidgets at: aPoint.
            self isLeftButton ifTrue: [self loadedWidgets: nil]]
        ifFalse: [self setupPlacing: aPoint].! !

!LayoutFrame methods !   
storeForDialogSubPaneOn: aStream indentString: indentString
	"Append the definition of the receiver to aStream."

	| xDU yDU xR yR |
	"xDU := (WindowDialog dialogUnit x / WindowDialog unitMultiplier x * 2) ceiling / 2."
	"xDU := WindowDialog dialogUnit x / WindowDialog unitMultiplier x."
	"yDU := WindowDialog dialogUnit y / WindowDialog unitMultiplier y."

	xDU := (SysFont width + 1 roundTo: 2) / 4.
	yDU := SysFont height / 8.
	xR := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yR := 1.


	aStream
		nextPutAll: indentString;
		nextPutAll: self class name;
		space;
		nextPutAll: #new;
		indentBy: 1.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #leftRatio: ;
		space;
		nextPutAll: self leftRatio printString;
		endMessage.

	aStream
		nextPut: $ ;
		nextPutAll: #leftInset: ;
		space;
		nextPutAll: (self leftInset / xDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #xDU;
		endMessage.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #topRatio: ;
		space;
		nextPutAll: self topRatio printString;
		endMessage.

	aStream
		nextPut: $ ;
		nextPutAll: #topInset: ;
		space;
		nextPutAll: (self topInset / yDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #yDU;
		endMessage.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #rightRatio: ;
		space;
		nextPutAll: self rightRatio printString;
		endMessage.

	aStream
		nextPut: $ ;
		nextPutAll: #rightInset: ;
		space;
		nextPutAll: (self rightInset / xDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #xDU;
		endMessage.

	aStream cr;
		nextPutAll: indentString;
		nextPutAll: #bottomRatio: ;
		space;
		nextPutAll: self bottomRatio printString;
		endMessage.

	aStream
		nextPut: $ ;
		nextPutAll: #bottomInset: ;
		space;
		nextPutAll: (self bottomInset / yDU) printString;
		nextPutAll: ' * ';
		nextPutVarNameFor: #yDU;
		indentBy: -1.! !

!WBTabOrderEditor methods ! 
setStatus: aString

	(status statusBoxAt: #status) contents: aString! !

!WindowFrameObject methods ! 
backColor
        "Answer the receiver's backColor."
    ^backColor! !

!WBCodeStream methods !   
nextPutFont: aFont
	"Look up the receiver in the Font pools to find a match.
		If found, then include the pool variable in the code
		and answer true, else include a font definition,
		and answer false."

	^self nextPutFont: aFont indentString: ''! !

!Object methods ! 
eventHandlerTargetAt: aSymbol
    "Answer the first event handler at aSymbol as a string
        or an empty string if there is no handler defined."

    ^(((self actionForEvent: aSymbol) ifNil: [^nil])
        asActionSequence first receiver ifNil: [^nil])
        wbWrapper! !

!WBPoolManagerWindow methods !
menuPoolNew: newPoolNames

	newPoolNames do: [:each |
		self poolManager addPoolNamed: each].! !

!WBLookPolicy class methods !  
isWindows

    ^OperatingSystem isWindows! !

!WindowBuilder methods !
clipboard

    ^WBClipboard! !

!WBChooseClassDialog methods !
classList: listOfClasses allowOthers: bool

    allowOthers := bool.

    ^self classList: listOfClasses default: (
         listOfClasses notEmpty ifTrue: [
            listOfClasses first
        ] ifFalse: [
            nil
        ]
    )! !

!WBCreatePowerMenuModule methods ! 
defaultOwnerName
		"Answer the default owner name."
	^'wbOwner'! !

!WBInstVarObject methods !
isWBModel

	^false! !

!WBGraphicObject methods ! 
rect

    ^rect! !

!WBLookPolicyWin95 methods !  
frameWidthBorder

    ^frameWidthBorder ifNil: [
        frameWidthBorder := self class isDefault
            ifTrue: [userLibrary getSystemMetrics: "SmCxborder" 5]
            ifFalse: [super frameWidthBorder]]! !

!WindowBuilder class methods ! 
wbMenuArray

^#(
    #('\uFile' nil
        #(
            #('\uNew Window\tCtrl+N' #menuFileNew 'Ctrl+N' nil nil nil)
            #('New \uDialog' #menuFileNewDialog '' nil nil nil)
            #('\uOpen...\tCtrl+O' #menuFileOpen 'Ctrl+O' nil nil nil)
            #separator
            #('\uComposite Panes' nil
                #(
                    #('\uNew' #menuFileNewComposite '' nil nil nil)
                    #('\uOpen...' #menuFileOpenComposite '' nil nil nil)
                    #separator
                    #('\uCreate...' #menuFileCreateComposite '' #hasMultipleSelections nil nil)
                    #('\uUngroup' #menuFileUngroupComposite '' #hasCompositeSelection nil nil)
                ))
            #('\uModel Objects' nil
                #(
                    #('\uSelect Primary Model...' #menuFileSelectPrimaryModel '' nil #hasPrimaryModel nil)
                    #('\uEdit Models...' #menuFileEditModelObjects '' nil nil nil)
                    #separator
                    #('\uModel Wizard...' #menuFileDefineModelObject '' nil nil nil)
                ))
            "#('\uRes Files' nil
                #(
                    #('\uImport From...' #menuFileImportFromResFile '' nil nil nil)
                    #('Ex\uport To...' #menuFileExportToResFile '' nil nil nil)
                ))"
            #separator
            #('\uLayout Wizard...\tCtrl+L' #menuFileLayoutWizard 'Ctrl+L' nil nil nil)
            #separator
            #('\uSave\tCtrl+S' #menuFileSave 'Ctrl+S' #isDirty nil nil)
            #('Save \uAs...' #menuFileSaveAs '' nil nil nil)
            #('Save As De\ufault' #menuFileSaveAsDefault '')
            #separator
            #('E\uxit\tCtrl+Q' #menuFileExit 'Ctrl+Q' nil nil nil)
            #separator
            #('A\ubout...' #menuFileAbout '' nil nil nil)
            #('Installed \uProducts...' #menuFileInstalledProducts '' nil nil nil)
        ))
    #('\uEdit' nil
        #(
            #('\uUndo\tCtrl+Z' #undo 'Ctrl+Z' nil nil #undoManager)
            #('\uRedo\tShift+Ctrl+Z' #redo 'ShiftCtrl+Z' nil nil #undoManager)
            #('Undo/Redo List...' #undoRedoList '' #hasItems nil #undoManager)
            #separator
            #('Cu\ut\tCtrl+X' #cutSelections 'Ctrl+X' #hasSelections nil #geometryManager)
            #('\uCopy\tCtrl+C' #copySelections 'Ctrl+C' #hasSelections nil #geometryManager)
            #('\uPaste\tCtrl+V' #pasteSelections 'Ctrl+V' #clipboardHasItems nil #geometryManager)
            #('Cl\uear\tCtrl+Delete' #menuEditClear 'Ctrl+27' #hasSelections nil nil)
            #separator
            #('\uSelect' nil
                #(
                    #('\uAll\tCtrl+/' #selectAll 'Ctrl+/' #hasChildren nil #geometryManager)
                    #('All In Same \uClass\tCtrl+Alt+C' #selectAllInSameClass 'CtrlAlt+C' #hasSelections nil #geometryManager)
                    #('All In Same \uHierarchy\tCtrl+Alt+H' #selectAllInHierarchy 'CtrlAlt+H' #hasSelections nil #geometryManager)
                ))
            #separator
            #('\uBring To Front\tCtrl+F' #bringToFront 'Ctrl+F' #hasSelections nil #geometryManager)
            #('Send To B\uack\tCtrl+B' #sendToBack 'Ctrl+B' #hasSelections nil #geometryManager)
            #('Bring \uForward' #bringForward '' #hasSelections nil #geometryManager)
            #('Send Backward' #sendBackward '' #hasSelections nil #geometryManager)
            #('\uDuplicate\tCtrl+D' #duplicate 'Ctrl+D' #hasSelections nil #geometryManager)
            #('\uMorph...\tCtrl+M' #menuEditMorph 'Ctrl+M' #hasSelections nil nil)
            #separator
            #('\uBrowse Class...\tCtrl+E' #menuEditBrowseClass 'Ctrl+E' nil nil nil)
            #('Browse Wid\uget Class...' #menuEditBrowseWidgetClass '' #hasSelections nil nil)
            #separator
            #('E\uvent Summary...\tCtrl+R' #menuEditEventSummary 'Ctrl+R' nil nil nil)
            #('Paste W\uindow Bitmap to Clipboard' #menuEditPasteWindowBitmapToClipboard '' nil nil nil)
            #('Test \uWindow\tCtrl+T' #menuEditTestWindow 'Ctrl+T' nil nil nil)
        ))
    #('\uAttributes' nil
        #(
            #('\uFont...' #setFont '' #selectionsHaveFontAttributes nil nil)
            #('\uColor...' #setColor '' #selectionsHaveColorAttributes nil nil)
            #('\uFraming...' #setFraming '' #hasSelections nil nil)
            #('\uMenus...' #setMenu '' #selectionsHaveMenuAttributes nil nil)
            #('\uEvents...' #setEvents '' nil nil nil)
            #('\uAttributes...' #setOther '' #selectionsHaveOtherAttributes nil nil)
            #separator
            #('Tabbing/\uGroups...\tCtrl+G' #setTabbing 'Ctrl+G' #hasChildren nil nil)
            #('Call \uOuts...' #setCallOuts '' #hasChildren nil nil)
            #('\uNLS' nil
                #(
                    #('\uSet Pools...' #setNLSPools '' nil nil nil)
                    #('\uNLS Manager...' #menuOptionsNlsManager '' nil nil nil)
                    #('\uNLS Autosize' #menuNlsAutosize '' nil nil nil)
                    #separator
                ))
            #separator
            #('PARTS \uInterface...' #setParts '' #partsSupportEnabled nil nil)
        ))
    #('A\ulign' nil
        #(
            #('\uLeft\tCtrl+Shift+L' #alignLeft 'ShiftCtrl+L' #hasMultipleSelections nil #geometryManager)
            #('\uTop\tCtrl+Shift+T' #alignTop 'ShiftCtrl+T' #hasMultipleSelections nil #geometryManager)
            #('\uRight\tCtrl+Shift+R' #alignRight 'ShiftCtrl+R' #hasMultipleSelections nil #geometryManager)
            #('\uBottom\tCtrl+Shift+B' #alignBottom 'ShiftCtrl+B' #hasMultipleSelections nil #geometryManager)
            #('\uCenter' nil
                #(
                    #('\uHorizontally\tCtrl+Shift+C' #alignCenterHorizontally 'ShiftCtrl+C' #hasMultipleSelections nil #geometryManager)
                    #('\uVertically\tCtrl+Alt+Shift+C' #alignCenterVertically 'AltShiftCtrl+C' #hasMultipleSelections nil #geometryManager)
                ))
            #('\uDistribute' nil
                #(
                    #('\uHorizontally\tCtrl+Shift+D' #distributeHorizontally 'ShiftCtrl+D' #has3orMoreSelections nil #geometryManager)
                    #('\uVertically\tCtrl+Alt+Shift+D' #distributeVertically 'AltShiftCtrl+D' #has3orMoreSelections nil #geometryManager)
                ))
            #separator
            #('\uMove By Pixel' #doByPixel:
                #(
                    #('\uUp\tCtrl+Up' #moveByPixelUp 'Ctrl+22' nil nil #geometryManager)
                    #('\uDown\tCtrl+Down' #moveByPixelDown 'Ctrl+24' nil nil #geometryManager)
                    #('\uLeft\tCtrl+Left' #moveByPixelLeft 'Ctrl+21' nil nil #geometryManager)
                    #('\uRight\tCtrl+Right' #moveByPixelRight 'Ctrl+23' nil nil #geometryManager)
                ))
            #('\uSize By Pixel' #doByPixel:
                #(
                    #('\uUp\tCtrl+Shift+Up' #sizeByPixelUp 'ShiftCtrl+22' nil nil #geometryManager)
                    #('\uDown\tCtrl+Shift+Down' #sizeByPixelDown 'ShiftCtrl+24' nil nil #geometryManager)
                    #('\uLeft\tCtrl+Shift+Left' #sizeByPixelLeft 'ShiftCtrl+21' nil nil #geometryManager)
                    #('\uRight\tCtrl+Shift+Right' #sizeByPixelRight 'ShiftCtrl+23' nil nil #geometryManager)
                ))
        ))
    #('\uSize' nil
        #(
            #('\uAuto Size Selection\tCtrl+Shift+A' #autoSize 'ShiftCtrl+A' #hasSelections nil #geometryManager)
            #separator
            #('Replicate \uWidth\tCtrl+Shift+W' #replicateWidth 'ShiftCtrl+W' #hasMultipleSelections nil #geometryManager)
            #('Replicate \uHeight\tCtrl+Shift+H' #replicateHeight 'ShiftCtrl+H' #hasMultipleSelections nil #geometryManager)
            #separator
            #('\uSet Window Size...' #menuSizeSetWidgetSize '' #hasSelections nil nil)
            #('Set Window \uPosition...' #menuSizeSetWidgetPosition '' #hasSelections nil nil)
        ))
    #('\uOptions' nil
        #(
            #('\uGrid' nil
                #(
                    #('Use \uGrid' #menuOptionsUseGrid '' nil #useGrid nil)
                    #('\uDraw Grid' #menuOptionsDrawGrid '' nil #drawGrid nil)
                    #('\uSet Grid Size...' #menuOptionsSetGridSize '' nil nil nil)
                ))
            #('\uLook Policy' nil
                #(
                    #('\uDefault' #menuOptionsLookPolicyDefault '' nil #usesLookPolicyDefault nil)
                    #separator
                    #('\uWindows 3.1' #menuOptionsLookPolicyWin31 '' nil #usesLookPolicyWin31 nil)
                    #('Windows \u9.5' #menuOptionsLookPolicyWin95 '' nil #usesLookPolicyWin95 nil)
                    #('\uOS/2' #menuOptionsLookPolicyOS2 '' nil #usesLookPolicyOS2 nil)
                ))
            #separator
            #('Drag \uOutlines' #menuOptionsDragOutlines '' nil #dragOutline nil)
            #('Show \uZ-Order' #menuOptionsShowZOrder '' nil #showZOrder nil)
            #('Target Is \uFirst' #menuOptionsTargetIsFirst '' nil #targetIsFirst nil)
            #('Use Fen\uce' #menuOptionsUseFence '' nil #useFence nil)
            "#('Mini \uHelp' #menuOptionsMiniHelpEnabled '' nil #miniHelpEnabled nil)"
            #separator
            #('\uUpdate Outboards' #menuOptionsAutoUpdateOutboards '' nil #autoUpdateOutboards nil)
            #('\uAuto Save' #menuOptionsAutoSave '' nil #autoSave nil)
            #('\uAuto Size' #menuOptionsAutoSize '' nil #autoSize nil)
            #('\uZoom Layout\tAlt+Z' #menuOptionsZoomLayout 'Alt+Z' nil nil nil)
            #separator
            #('\uTemplates...' #menuOptionsTemplates '' nil nil nil)
            #('\uProperties...' #menuOptionsProperties '' nil nil nil)
            #('\uManager' nil
                #(
                    #('\uAdd-In Manager...' #menuOptionsAddInManager '' nil nil nil)
                    #('\uBitmap Manager...' #menuOptionsBitmapManager '' nil nil nil)
                    #('\uFont Manager...' #menuOptionsFontManager '' nil nil nil)
                    #('\uNLS Manager...' #menuOptionsNlsManager '' nil nil nil)
                ))
            #separator
            #('\uRedraw' #menuOptionsRedraw '' nil nil nil)
        ))
    #('S\ucrapbook' nil
        #(
            #('\uStore...' #menuScrapbookStore '' nil nil nil)
            #('\uRetrieve...' #menuScrapbookRetrieve '' nil nil nil)
            #separator
            #('\uNew' #menuScrapbookNew '' nil nil nil)
            #('\uLoad...' #menuScrapbookLoad '' nil nil nil)
            #('\uMerge...' #menuScrapbookMerge '' nil nil nil)
            #('Sa\uve...' #menuScrapbookSave '' nil nil nil)
            #separator
            #('\uQuick Reference' #menuScrapbookQuickReference: #( ))
        ))
    #('A\udd' nil
        #(
            #('\uText' #addWidget:
                #(
                    #('\uStaticText' 'StaticText' '')
                    #('\uEntryField' 'EntryField' '')
                    #('EnhancedEntry\uField' 'EnhancedEntryField' '')
                    #('\uTextEdit' 'TextEdit' '')
                    #('Text\uPane' 'TextPane' '')
                ))
            #('\uButton' #addWidget:
                #(
                    #('\uButton' 'Button' '')
                    #('\uDrawnButton' 'DrawnButton' '')
                    #('\uRadioButton' 'RadioButton' '')
                    #('\uCheckBox' 'CheckBox' '')
                    #('\uThreeStateButton' 'ThreeStateButton' '')
                ))
            #('\uList' #addWidget:
                #(
                    #('\uListBox' 'ListBox' '')
                    #('List\uPane' 'ListPane' '')
                    #('\uMultipleSelectListBox' 'MultipleSelectListBox' '')
                    #('\uDropDownList' 'DropDownList' '')
                    #('\uComboBox' 'ComboBox' '')
                    #('\uButtonListBox' 'ButtonListBox' '')
                ))
            #('\uValuator' #addWidget:
                #(
                    #('\uHorizontal Scroll Bar' 'WBHorizontalScrollBar' '')
                    #('\uVertical Scroll Bar' 'WBVerticalScrollBar' '')
                ))
            #('\uGroup' #addWidget:
                #(
                    #('\uGroupBox' 'GroupBox' '')
                    #('\uStaticBox' 'StaticBox' '')
                ))
            #('\uMisc' #addWidget:
                #(
                    #('\uStaticGraphic' 'WBStaticGraphic' '')
                    #('\uGraphPane' 'GraphPane' '')
                    #('\uAnimationPane' 'AnimationPane' '')
                    #('\uWBToolBar' 'WBToolBar' '')
                    #('Status\uPane' 'StatusPane' '')
                ))
            #('\uComposite' #addWidget:
                #(
                    #('\uRadioButtonGroup' 'RadioButtonGroup' '')
                    #('\uCheckBoxGroup' 'CheckBoxGroup' '')
                    #('\uEntryFieldGroup' 'EntryFieldGroup' '')
                    #('\uSexPane' 'SexPane' '')
                ))
            #separator
            #('\uCustom Widgets' #addWidget: #( ))
            #('\uAdd Custom Widget...' #menuAddAddCustomPane ''  nil nil nil)
            #('\uRemove Custom Widget...' #menuAddRemoveCustomPane ''  #hasCustomPanes nil nil)
        ))
    )! !

!WindowBuilder methods ! 
menuOptionsDragOutlines

    | aBoolean |
    aBoolean := self class togglePropertyValueAt: #DragOutlines.
    self updateOptionsMenu.
    self layoutForm isNil
        ifFalse: [self layoutForm dragOutline: aBoolean]! !

!WBScrapbookStore class methods !   
isWBInternalClass

    ^true! !

!WBEventManagerWindow methods !  
widgetSelected: anObject
    "Set the currently selected widget."

    self widgetSelections: (OrderedCollection with: anObject).! !

!WindowBuilder methods !   
generateCode
	"Private - Generate the code."

	| answer |
	"Stuff the pane list into the mainPane
		so that the code generated uses the latest child
		list when generating code."
	"self editedPane children: self layoutForm panes."
	CursorManager execute changeFor: [
		answer := self codeGenerator generateCodeUsing: 
			(self codeModulesFor: self prototype)].
	answer = false
		ifTrue: [MessageBox message: 'Compilation errors during code generation... see System Transcript'].
	^answer! !

!WBStaticTextEditor methods !  
initWindow

    (self paneNamed: 'text')
        contents: thePane contents;
        setFocus;
        selectAll.! !

!WBPMenuItem methods !   
type: aString
    | aSymbol aSelector |
    (aString isNil or: [ aString isEmpty ]) ifTrue: [ ^nil ].
    aSymbol := aString asSymbol.
    aSymbol == #Child ifTrue: [
        aSelector := #openWithParent:
    ] ifFalse: [ aSymbol == #Sibling ifTrue: [
        aSelector := #openWithMyParent:
    ] ifFalse: [ aSymbol == #MDIChild ifTrue: [
        aSelector := #openWithMDIParent:
    ] ifFalse: [
        aSelector := #open
    ]]].
    selector isMessage ifFalse: [
        selector := (Message new)
                            receiver: nil;
                            selector: aSelector;
                            arguments: #();
                            yourself
    ] ifTrue: [
        selector selector: aSelector
    ]! !

!WBEventManagerWindow methods !  
widgetSelections: aCollection

    widgetListBox selection: aCollection.
	self eventListUpdate.! !

!WBInterfaceObject methods ! 
wbFramingBlock

    ^self framingBlock! !

!WBPropertyDescriptor methods !
hasResources

    ^self resourceValues notNil! !

!WindowBuilder methods !
menuToolsFixFraming

    | framingBlock fraction |
    self children do: [:child |
        (framingBlock := child framingBlock) isFramingParameters
            ifFalse: [
                (fraction := framingBlock top) isFraction
                    ifTrue: [framingBlock tP: (fraction denominator - fraction numerator) / fraction denominator].
                (fraction := framingBlock bottom) isFraction
                    ifTrue: [framingBlock bP: (fraction denominator - fraction numerator) / fraction denominator]]].
    self layoutForm
        reframeAll;
        updateWidget.
    self setDirty.! !

!PEntryFieldGroup methods ! 
readSpecificsFrom: aWidget

	self
		label: aWidget label;
		style: aWidget cpStyle;
		contents: aWidget list.
	self style isNil ifTrue: [self style: self styles first].! !

!WBTreeListBox methods ! 
performOnSelection: aSymbol  selectionDelta: delta  moveWithSelection: moveWithSelection

    |  oldPosition oldTopIndex positionDelta selection selectionIndex |

    (selection := self selectedItem) isNil ifTrue: [
        ^self
    ].

    self commitSelection.

    oldPosition := selection nonHierarchicalPosition.
    oldTopIndex := self getTopIndex.
    selectionIndex := self selection.


    (self perform: aSymbol) isNil ifTrue: [
        positionDelta := 0.  "Unsuccessful, therefore no delta"
    ] ifFalse: [
        (delta isNil) ifTrue: [
            positionDelta :=  selection nonHierarchicalPosition - oldPosition.
        ] ifFalse: [
            positionDelta := delta.
        ].
    ].

    self noRedraw: true.
    noSelect := moveWithSelection.
    self deleteAll.
    self insertArray: (list asFlatList collect: [ :i | i listString ]).
    self wbSelectIndex: ((selectionIndex + positionDelta max: 1) min: list asFlatList size).
    (moveWithSelection) ifTrue: [
        self setTopIndex: (oldTopIndex + positionDelta max: 1).
    ].
    self noRedraw: false.

    self invalidateRect: self rectangle.! !

!WBModelDefinitionEditor methods ! 
setInitializeValue: aString

    | selectedItem newValue |
    selectedItem := attributes selectedItem ifNil: [^nil].
    ((selectedItem valueClass inheritsFrom: String)
        or: [(selectedItem valueClass inheritsFrom: Number)
        or: [selectedItem valueClass inheritsFrom: Boolean]])
        ifFalse: [^nil].
    newValue := self compilerEvaluate: aString.
    selectedItem initializeValue = newValue ifTrue: [^self].
    selectedItem initializeValue: newValue.
    self setDirty.! !

!WBColorDialog methods !
drawItemFore: index pane: aPane

    | c s |

	(s := colors at: index) = #default
		ifTrue: [ c :=  thePane defaultForeColor ]
		ifFalse: [ c := Color perform: s ].

    aPane pen
        fill: aPane drawBox color: Color white;
        fill: ((aPane drawBox leftTop extent: self colorBarWidth @ aPane drawBox height) insetBy: 1) color: c;
        setTextAlign: WBDisplayContext defaultTextAlign;
        font: ListFont;
        displayText: s at: aPane drawBox leftTop + ((self colorBarWidth + 5) @ 0)! !

!Window methods !
wbWrapper

	^self propertyAt: #wbWrapper! !

!WBFontManagerWindow methods !   
menuOptionNonPortableFileOut

	[self poolManager generatePortableFontCode: false]
		on: WBPoolError
		do: [:exception | ^self menuErrorHandler: exception].
	self updateOptionMenu.! !

!SelectorPropertyAccessor methods !
wbGetValueFor: anObject
    "Private - Answer the value of the property."

	| answer |
	#addedByOSI.
	answer := super wbGetValueFor: anObject.
	self isIntegerFormat ifTrue: [answer := answer asString].
	^answer! !

!WBLookPolicyOS2 methods !
displayWithRightScrollBar: aPen rect: aRect backColor: aColor

    | innerRect newInnerRect backColor |
    backColor := (self class isDefault not
        and: [(self asRGBColor: aColor) = (self asRGBColor: Color white)])
        ifTrue: [self defaultWidgetBackColor]
        ifFalse: [aColor].
    innerRect := self displayWithBorder: aPen rect: aRect backColor: backColor.
    newInnerRect := innerRect leftTop rightBottom: (innerRect rightBottom left: self scrollBarWidth).
    self
        drawVScrollBarWith: aPen
        at: (newInnerRect rightTop
            rightBottom: (innerRect rightBottom rightAndDown: 1)).
    ^newInnerRect! !

!WBLookPolicyWin95 methods !
drawMinimizeButtonWith: aPen at: aRect

    | innerRect leftBottom |
    innerRect := self
        drawTitleBarBoxWith: aPen
        at: aRect.
    leftBottom := innerRect leftBottom.
    aPen
        foreColor: Color black;
        lineFrom: (leftBottom rightAndUp: 3@(2+Rectangle leftTopUnit y)) to: (leftBottom rightAndUp: 9@(2+Rectangle leftTopUnit y));
        lineFrom: (leftBottom rightAndUp: 3@(3+Rectangle leftTopUnit y)) to: (leftBottom rightAndUp: 9@(3+Rectangle leftTopUnit y)).! !

!WBCodeStream methods !
nextPutNoWrap: aCharacter
		"Append aCharacter to the code stream."
	self checkEnd.
	"(self isSpaceOnLine: 1) ifFalse: [ self cr ]."
	stream nextPut: aCharacter.! !

!WBCodeModule methods !   
defaultTemporaries
		"Answer a collection of temporary variable names."
	^#( )! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCreateClassDialog methods !
superclassListFor: superClassSymbol

    | classList |
    (classList := self cacheAt: superClassSymbol) isNil
        ifFalse: [^classList].
    superClassSymbol == #CompositePane
        ifTrue: [
            ^self
                cacheAt: superClassSymbol
                put: (CompositePane withAllSubclasses collect: [:aClass |
                    aClass name]) asSortedCollection asArray].
    superClassSymbol == #EventManager
        ifTrue: [
            ^self
                cacheAt: superClassSymbol
                put: (Array with: 'EventManager'), (EventManager wbCreatedClasses collect: [:aClass |
                    aClass name]) asSortedCollection asArray].
    superClassSymbol == #ViewManager
        ifTrue: [
            Notifier isAltKeyDown
                ifTrue: [
                    ^self
                        cacheAt: superClassSymbol
                        put: (ViewManager withAllSubclasses     collect: [:aClass |
                            aClass name]) asSortedCollection asArray]
                ifFalse: [
                    ^self
                        cacheAt: superClassSymbol
                        put: ((ViewManager withAllSubclasses reject: [:aClass |
                            (aClass inheritsFrom: WindowDialog) |
                            (self wbEditorClass allViewManagerClasses includes: aClass)]) collect: [:aClass |
                                aClass name]) asSortedCollection asArray]].
    superClassSymbol == #WindowDialog
        ifTrue: [
            Notifier isAltKeyDown
                ifTrue: [
                    ^self
                        cacheAt: superClassSymbol
                        put: (WindowDialog withAllSubclasses collect: [:aClass |
                            aClass name]) asSortedCollection asArray]
                ifFalse: [
                    ^self
                        cacheAt: superClassSymbol
                        put: ((WindowDialog withAllSubclasses reject: [:aClass |
                            (self wbEditorClass allViewManagerClasses includes: aClass)]) collect: [:aClass |
                                aClass name]) asSortedCollection asArray]].
    superClassSymbol == #ApplicationCoordinator
        ifTrue: [
            Notifier isAltKeyDown
                ifTrue: [
                    ^self
                        cacheAt: superClassSymbol
                        put: (ApplicationCoordinator withAllSubclasses collect: [:aClass |
                            aClass name]) asSortedCollection asArray]
                ifFalse: [
                    ^self
                        cacheAt: superClassSymbol
                        put: ((ApplicationCoordinator withAllSubclasses reject: [:aClass |
                            (aClass inheritsFrom: DialogCoordinator) |
                            (self wbEditorClass allViewManagerClasses includes: aClass)]) collect: [:aClass |
                                aClass name]) asSortedCollection asArray]].
    superClassSymbol == #DialogCoordinator
        ifTrue: [
            Notifier isAltKeyDown
                ifTrue: [
                    ^self
                        cacheAt: superClassSymbol
                        put: (DialogCoordinator withAllSubclasses collect: [:aClass |
                            aClass name]) asSortedCollection asArray]
                ifFalse: [
                    ^self
                        cacheAt: superClassSymbol
                        put: ((DialogCoordinator withAllSubclasses reject:     [:aClass |
                            (self wbEditorClass allViewManagerClasses includes: aClass)]) collect: [:aClass |
                                aClass name]) asSortedCollection asArray]].! !

!FrameObject methods !
wbBottomRightOffset

    ^self frameContentRect rightBottom rightAndDown: (WBHandle handleSize // 2 + self borderWidth)! !

!CompositePane methods !  
modelObjects

    ^self propertyTableForEdit
        at: #modelObjects
        ifAbsentPut: [OrderedCollection new]! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBEventManagerWindow methods !
handlerSelections: aCollection
    "Set the currently selected handler."

    handlerListBox selection: aCollection.
	self toFieldUpdate.! !

!WBEditClassDialog methods !  
inENVY

	^self wbEditorClass envyIsInstalled! !

!Message methods !   
wbEvaluateWithReceiver: anObject
    "Private - this method is part of the development environment and cannot be relied on in a run-time image.
    Answer the result of evaluating the receiver using <anObject> as the message receiver. "

	#addedByOSI.
    ^anObject
        perform: self selector
        withArguments: self arguments! !

!WBModelObjectEditor methods !
remove

	(MessageBox confirm: 'Are you sure you want to remove: ', self selectedObject wbNameAndClass)
		ifFalse: [^self].
	self owner prototype modelObjects remove: self selectedObject ifAbsent: [ ].
	self
		updateObjectList;
		disableFields.
	removeButton disable.
	self owner setDirty.! !

!WBModelInstVar methods ! 
methodNameForSet

    ^self name, ':'! !

!WBPrimaryModelOpenOnModule methods !   
defaultCategory
        "Answer the default category for the receiver."
    ^'primary model'! !

!PComboBox methods ! 
backColor

    ^backColor.! !

!WBPoolManagerWindow methods ! 
menuKeyPrevious

	| index |
	(index := self keysAndPools
		indexOf: self selectedKeyAndPool
		ifAbsent: [self keysAndPools size + 1]
	) > 1 ifTrue: [
		self selectedKeyAndPool: (self keysAndPools at: index - 1)].! !

!WindowBuilder methods !
autoUpdateOutboards

    ^self class autoUpdateOutboards! !

!WBLocator class methods !   
copyWhile: aBlock
        "Answer a copy of aFigure preserving the identity of shared Figures."

        | anObject |
        CopiedFigures := IdentityDictionary new.
        anObject := aBlock value.
        CopiedFigures := nil.
        ^anObject! !

!WBEventManagerWindow methods ! 
targetClass

	^self owner editedClass! !

!WBCreateBitmap methods !   
bitmapWidth: anInteger

	widthField contents: anInteger asString.! !

!WBScrollingPane methods !  
updateSliders

    handle = NullHandle ifTrue: [^self].

        self updateVerticalSlider.
        self updateHorizontalSlider.! !

!WBCallOutEditor methods !
remove

    "Callback for the #clicked event triggered in the Button named 'remove'.
     (Generated by WindowBuilder)"

	callOutList selectedItem ifNil: [ ^self ].
    callOutMap at: callOutList selectedItem put: nil.
    self
        updatePaneList;
        updateCallOutList.
    selector contents: ''! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBCodeModule methods ! 
initialize
		"Private - Initialize the receiver."
	super initialize.
	varNames := IdentityDictionary new.! !

!WBCreateViewModule methods !  
panesWithFonts
	"Answer a collection of panes with fonts."

	^self withChildren select: [:eachPane |
		eachPane creationMethodSelector isNil]! !

!WindowBuilder class methods !
handleSize

    ^self editorClass
        propertyValueAt: #HandleSize
        category: self editorPropertyString! !

!WBOutboardAttributeWindow methods ! 
currentWidget

    ^self currentWidgets notEmpty
		ifTrue: [self currentWidgets first]
		ifFalse: [nil]! !

!WindowBuilder methods !
topLayoutForm

    ^self currentLayoutForm! !

!WBAttributeWindow methods !   
aboutToClose

    "Callback for the #aboutToClose event in the TopPane 'mainView'.
     (Generated by WindowBuilder)"

	#osiHack.  "Is there a better way to detect shutdown?"
	"If shutting down, then don't prompt for save changes."
    Transcript isNil ifTrue: [ ^self ].

	self hasChanged ifTrue: [
		self aboutToDiscardChanges ifFalse: [
			self mainView abortClose ] ].! !

!WBOutboardAttributeWindow methods !
dirty
    "Answer the dirty flag."

    ^dirty ifNil: [false]! !

!WBAttributeEditor methods !   
nlsStringFor: aString
	| nlsString nlsKey nlsPool |
    nlsString := aString.
    (aString notEmpty and: [aString first == $#])
        ifTrue: [
            nlsKey := aString copyFrom: 2 to: aString size.
            thePane parent nlsPools detect: [:sym |
                (nlsString := (nlsPool := Smalltalk at: sym) at: nlsKey
                    ifAbsent: [nlsString := nlsPool at: nlsKey asSymbol
                    ifAbsent: [aString]]) ~= aString]
                    ifNone: []].
	^nlsString! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBLayoutCodeModule methods !  
generateLayoutTemporaries
	"Private - Geterate the layout temporaries."

	self layoutTemporaryExpressions do: [:each |
		self stream cr;
			nextPutVarNameFor: each key;
			nextPutAssignment;
			nextPutAll: each value;
			endExpression].! !

!WBGeometryManager methods !   
undoManager

    ^self owner undoManager! !

!WBTabOrderEditor methods !  
setByColumnMajorOrder

	layoutForm setByColumnMajorOrder.
	self setFirstStatus.! !

!PButton class methods ! 
autoRecognizeOkCancel: aBoolean

    AutoRecognizeOkCancel := aBoolean! !

!WBCodePolicy methods !
basicRemoveSelector: aSelector fromClass: aClass
		"Remove aSelector from the specified class."
	self implementedBySubclass.! !

!PEnhancedEntryField methods !   
justification

	^justification ifNil: [justification := #left]! !

!WindowBuilder methods !   
saveWidgetTemplate

    self hasSelections ifFalse: [^self].
    self selections size > 1
        ifTrue: [(MessageBox confirm: 'Save templates for multiple widget types?') ifFalse: [^self]]
        ifFalse: [(MessageBox confirm: 'Save template for ', self selections first realClass name, '?') ifFalse: [^self]].
    self selections do: [:widget |
        self
            templateAt: widget realClass name asSymbol
            put: widget wbDuplicate].! !

!SelectorPropertyAccessor methods ! 
wbDuplicateValue: aValue for: anObject
	"Duplicate the property's value."

	| anAction |
	#addedByOSI.
	(anAction := self wbDuplicateAction) notNil
		ifTrue: [
			PropertyManager
				performAction: anAction
				object: anObject
				arguments: (Array with: aValue)]
		ifFalse: [
			super
				wbDuplicateValue: aValue
				for: anObject].! !

!WBCreatePowerMenuModule class methods !  
defaultMessageSelector
		"Private - Answer the default message selector."
	^#createMenus:for:owner:! !

!WBPoolEditorCompositePane methods !  
selectedValueForAll

	| selectedCategories first value eachValue |
	first := true.
	selectedCategories := self selectedCategories.
	self selectedKeysAndPools do: [:eachKeyAndValue |
		selectedCategories do: [:eachCategory |
			eachValue :=
				eachKeyAndValue value
					at: eachKeyAndValue key
					in: eachCategory
					ifAbsent: [^nil].
			first
				ifTrue: [
					value := eachValue.
					first := false]
				ifFalse: [
					value == eachValue ifFalse: [^nil]]]].
	^value! !

!WindowBuilder methods !  
menuOptionsNlsManager

	self class openNlsManager.! !

!WindowBuilder methods !   
propertyAt: aSymbol put: anObject

	self class 
		propertyAt: aSymbol 
		put: anObject! !

!WindowBuilder methods ! 
menuOptionsBitmapManager

	self class openBitmapManager.! !

!WindowBuilder class methods !   
openAddInManager

	WBAddInManager new open! !

!PEntryFieldGroup methods !
foreColor: aColor

	super foreColor: aColor.
	aColor = self defaultForeColor
		ifTrue: [self children do: [:child | child foreColor: child defaultForeColor]]
		ifFalse: [self children do: [:child | child foreColor: aColor]].! !

!WBEventMessage methods ! 
event: aSymbol
	"Set the receiver's event."

	event := (aSymbol ifNil: ['']) asSymbol.! !

!WindowBuilder methods !  
menuFileSave

    self isDirty ifFalse: [^self].
    self editedClass isScratchWindow
        ifTrue: [^self menuFileSaveAs].
    ^self generateApplicationCode.! !

!WBModelDefinitionEditor methods !
otherClass

	myClass setValue: ((WBListChooser
		fromList: ((Object allSubclasses reject: [:cls | cls isWBInternalClass])
			asSortedCollection: [:a :b | a name <= b name])
		prompt: 'Select Initializer Class') ifNil: [^self])! !

!WBAbstractAddInModule class methods !  
addToButtonModuleMap: aDictionary
    "Add to the button module map"! !

!WBLookPolicyOS2 methods !
scrollBarWidth

	^scrollBarWidth ifNil: [
		scrollBarWidth := self class isDefault
			ifTrue: [pmWindowLibrary querySysValue: hwndDesktop sysValue: "SvCxvscroll" 22]
			ifFalse: [super scrollBarWidth]]! !

!WBTeamVCodePolicy methods ! 
wbGeneratedPackage
	"Answer the generated package... create it if necessary."

	^(self currentSubsystem packageNamed: self wbGeneratedPackageName)
		ifNil: [self currentSubsystem createPackageNamed: self wbGeneratedPackageName]! !

!WBLookPolicyWin95 methods !
centerJustification

    ^"SsCenter" 1! !

!WBCreateBitmap methods !  
bitmapType: aSymbol
	"Set the currently selected bitmap type."

	| button |
	self class bitmapTypes associationsDo: [:each |
		button := self paneNamed: each key.
		each value notNil
			ifTrue: [
				button
					enable;
					selection: aSymbol = each value]
			ifFalse: [
				button
					disable;
					selection: false]].! !

!WBCodeStream methods ! 
checkEnd
		"Private - If endChar not nil, then append."
	endChar notNil ifTrue: [
		stream nextPut: endChar.
		endChar := nil ].! !

!WBLayoutFrameEditor methods ! 
paneLeft

	^'Pane left'! !

!WBKeyAccel methods ! 
printAccelOn: aStream

    | pmCode |

    aStream nextPut: $'.

    self isAlt ifTrue: [
        aStream nextPutAll: 'Alt'.
    ].
    self isShift ifTrue: [
        aStream nextPutAll: 'Shift'.
    ].
    self isCtrl ifTrue: [
        aStream nextPutAll: 'Ctrl'.
    ].

    keyCode notNil ifTrue: [
        aStream nextPut: $+.
    ].

    keyCode isCharacter ifTrue: [
        aStream nextPut: keyCode.
    ] ifFalse: [
        pmCode := Smalltalk platformIsWin32
			ifTrue: [ self pmKeyCodeFor: keyCode ]
			ifFalse: [ keyCode ].

        pmCode notNil ifTrue: [
            aStream nextPutAll: pmCode asString
        ].
    ].

    aStream nextPut: $'.! !

!WBPrimaryModelInitializeModule methods !   
defaultMessageSelector
        "Private - Answer the default message selector."
    ^#initialize! !

!WBInterfaceObject methods ! 
eventHandlerArgNamesFor: eventSymbol
	"Answer an array of argument names."

	(#(#dragDropped: #dragSourceNeedsObject: #dragSourceCut: #dragTargetNeedsOperations: #dragTargetEnter:
		#dragTargetLeave: #dragTargetOver: #dragTargetDrawEmphasis: #dragTargetEraseEmphasis: #dragTargetDrop:)
		includes: eventSymbol) ifTrue: [^#('dragSession')].
	eventSymbol == #mouseMoved: ifTrue: [^#('aPoint')].
	(eventSymbol notEmpty and: [eventSymbol last = $:]) ifTrue: [^#('anObject')].
	^#( )! !

!FrameObject methods !   
shell

	^self! !

!WBEventMessage methods !   
selector: aSymbol
	"Set the message selector."

	super selector: (aSymbol ifNil: ['']) asString.
	self arguments: self arguments.! !

!WBEditClassDialog methods !  
clearMostFrequent

    "Callback for the #clicked event triggered in the Button named 'clearMostFrequent'.
     (Generated by WindowBuilder)"

	Notifier isAltKeyDown
		ifTrue: [
			self class frequentClasses elements removeKey: 
				(Smalltalk at: (mostFrequent selectedItem ifNil: [^nil]) asSymbol ifAbsent: [^nil]).
			mostFrequent text: '']
		ifFalse: [self class clearFrequentClasses].
    self loadMostFrequent.
	selectedClass := nil.
	self setWindowTitle.! !

!Message methods !   
asEventMessage

	^WBEventMessage new
		receiver: self receiver;
		selector: self selector;
		arguments: self arguments;
		yourself! !

!WBModelInstVar methods !  
myClass: aClass

    myClass := aClass! !

!UndefinedObject methods !
osiIgnoredInitializerSource !

!WBPlaceHolderObject methods !
owner

	^owner! !

!WBCreateViewModule methods !  
initTemporaries
		"Private - Initialize the variable names."
	| name |
	super initTemporaries.
	self withChildren do: [ :each |
		self varNameFor: each ifAbsentPut: [
			name := self constructVarNameForPane: each.
			self temporaries add: name.
			self varNameFor: each wbRealWidget put: name.
			name ] ].
	self initFontDefinitions.! !

!WBNLSEditorCompositePane methods ! 
updateKey

	| aKey |
	(aKey := self selectedKey) notNil
		ifTrue: [
			keyEditLabel wbGrayEnable.
			keyEditField contents = aKey ifFalse: [
				keyEditField contents: aKey]]
		ifFalse: [
			keyEditLabel wbGrayDisable.
			keyEditField contents: ''].! !

!WindowBuilder methods !
layoutFormClass

    ^WBLayoutForm! !

!WBOutboardAttributeWindow methods !   
currentWidgets

    ^currentWidgets! !

!WBLayoutCodeModule methods ! 
defaultComment
		"Answer the comment string."
	^self defaultLayoutComment! !

!WBTabOrderEditor methods ! 
cleanUp

	layoutForm removeGroupingPanes.! !

!WBEnhancedAttributeEditor methods !
initFields

	self fieldNames do: [:each |
		self
			initField: (self thePropertyManager getAccessor: each ifAbsent: [nil])
			pane: (self paneNamed: each)].! !

!WindowBuilder methods !  
invoke: aClass

    | existing |
    (existing := outboards detect: [:window |
        window class == aClass]
        ifNone: [nil]) isNil
        ifTrue: [
            aClass new
                openOn: self]
        ifFalse: [existing activate].! !

!WBInstVarObject methods !
wbNameAndClass

	^self name! !

!WindowBuilder methods !  
menuToolsDebugCodeGeneration

	MessageBox message: 'A walkback follows...'.
    "The halt in the next line should be there. You may now step through
     the code generation process."
	self codeGenerator generateCodeUsing: (self codeModulesFor: self prototype) halt.! !

!WBLayoutForm methods ! 
buttonReleaseMovingOutline: aPoint
    "Process a button release event while moving just the widgets outline."

   | x y gridX gridY useGrid sel curOffset origins redoBlock contentRect |
    self allowMove ifFalse: [^self].
    "We actually started moving the widget."
    self drawBand.
    "Move the widget to the new position."
    (useGrid := self useGrid)
        ifTrue: [
            gridX := self gridSize x max: 1.
            gridY := self gridSize y max: 1].
    sel := self selections copy.
    curOffset := self cursorOffset copy.
    contentRect := self shell frameContentRect.
    origins := sel collect: [:widget | widget origin].
    self undoManager
        add: 'Move'
        undo:
            [self hideHandles.
            1 to: sel size do: [:index |
                (sel at: index)
                    moveWidget: (origins at: index) x
                    y: (origins at: index) y;
                    wbUpdateConstraints].
            self
                updateWidgetAttachments: sel;
                showHandles;
                notifyModelOfSizeOrPositionChange]
        redo: (redoBlock :=
            [self hideHandles.
            1 to: sel size do: [:index |
                x := aPoint x left: (curOffset at: index) x.
                y := aPoint y up: (curOffset at: index) y.
                useGrid
                    ifTrue: [
                        x := contentRect left distanceRight: x.
                        y := contentRect top distanceDown: y.
                        x := contentRect left right: (x roundTo: gridX).
                        y := contentRect top down: (y roundTo: gridY)].
                self useFence
                    ifTrue: [
                        x := (x rightMost: contentRect left) leftMost: (contentRect right left: (sel at: index) width).
                        y := (y lowerOf: contentRect top) higherOf: (contentRect bottom up: (sel at: index) height)].
                (sel at: index)
                    moveWidget: x
                    y: y;
                    wbUpdateConstraints].
            self
                updateWidgetAttachments: sel;
                showHandles;
                notifyModelOfSizeOrPositionChange]).
    redoBlock value.
    self model isNil
        ifFalse: [self model setDirty].! !

!WBLookPolicyWin95 methods !   
drawFrameBorder: aFrameObject with: aPen in: aRect

    (aFrameObject hasTitleBar or: [aFrameObject style includes: #sizable])
        ifFalse: [
            ^aPen
                foreColor: Color black;
                drawRectangle: aRect].
    aPen
        foreColor: Color gray;
        wbLineFrom: aRect leftTop to: (aRect rightTop left: 1);
        wbLineFrom: aRect leftTop to: (aRect leftBottom up: 1);
        foreColor: Color white;
        wbLineFrom: (aRect leftTop rightAndDown: 1) to: (aRect rightTop leftAndDown: 1);
        wbLineFrom: (aRect leftTop rightAndDown: 1) to: (aRect leftBottom rightAndUp: 1);
        foreColor: Color black;
        wbLineFrom: (aRect leftBottom up: 1) to: (aRect rightBottom up: 1);
        wbLineFrom: (aRect rightTop left: 1) to: (aRect rightBottom leftAndUp: 1);
        foreColor: Color darkGray;
        wbLineFrom: (aRect leftBottom rightAndUp: 1@2) to: (aRect rightBottom leftAndUp: 1@2);
        wbLineFrom: (aRect rightTop leftAndDown: 2@1) to: (aRect rightBottom leftAndUp: 2);
        foreColor: Color gray;
        wbLineFrom: (aRect leftTop rightAndDown: 2) to: (aRect rightTop leftAndDown: 2);
        wbLineFrom: (aRect leftTop rightAndDown: 2) to: (aRect leftBottom rightAndUp: 2);
        wbLineFrom: (aRect leftTop rightAndDown: 3) to: (aRect rightTop leftAndDown: 3);
        wbLineFrom: (aRect leftTop rightAndDown: 3) to: (aRect leftBottom rightAndUp: 3);
        wbLineFrom: (aRect leftBottom rightAndUp: 2@3) to: (aRect rightBottom leftAndUp: 2@3);
        wbLineFrom: (aRect rightTop leftAndDown: 3@2) to: (aRect rightBottom leftAndUp: 3);
        wbLineFrom: (aRect leftBottom rightAndUp: 3@4) to: (aRect rightBottom leftAndUp: 3@4);
        wbLineFrom: (aRect rightTop leftAndDown: 4@3) to: (aRect rightBottom leftAndUp: 4)
! !

!WBScrollingPane methods !   
setScrollRanges

    self setScrollRanges: true! !

!WBStaticTextEditor class methods !   
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk Enterprise 3.1.0 Win32"

	^3.1! !

!PStaticBox methods !
usesMenu

    ^false! !

!WBPropertyDescriptor methods !  
noDefault: aBoolean

    aBoolean
        ifTrue: [self addFlag: self noDefaultFlag]
        ifFalse: [self removeFlag: self noDefaultFlag]! !

!WBSystemBitmapViewer methods ! 
select: selectedItem
    "Callback for the #clicked: event in list [ListBox]
    (Generated by WindowBuilder Pro)"

    graphic contents isBitmap
        ifTrue: [graphic contents release].
    graphic contents: (WBBitmapClass new
        fromSysID: (OperatingSystemConstants at: selectedItem)).
    Notifier isAltKeyDown ifTrue: [graphic contents inspect].! !

!WBCodeModule methods !   
isVarName: aString
		"Private - Answer true if aString is defined as a variable name."
	 ^(varNames
			detect: [ :each | each = aString ]
			ifNone: [ nil ] ) notNil! !

!CompositePane class methods !
wbTestOpenIn: aRectangle
	"Open a new instance of the receiver."

    WBCompositePaneTester new
		openOn: self in: aRectangle.! !

!WBFontManagerWindow methods !   
menuCategoryFileOut: aPath
	"File out the selected pools and categories."

	| stream fileStream |
	CursorManager execute changeFor: [
		stream := self newCodeStream.
		self selectedPools
			do: [:each | each fileOutCategories: self selectedCategories on: stream].
		fileStream := File newFile: aPath.
		[fileStream nextPutAll: stream contents] ensure: [fileStream close]].! !

!WBEventManagerWindow methods !   
methodTextUpdate

	methodTextEdit update.! !

!WBModelObjectEditor methods !  
styleLabel

    ^self paneNamed: 'styleLabel'! !

!WBEventManagerWindow methods ! 
widgetFilterNeedsContents: aPane
	"Callback for the #needsContents event in widgetFilter [WBComboBox]
	(Generated by WindowBuilder Pro)"

	| filters classes eachSelector ignoreClasses |
	filters := OrderedCollection new.
	filters add: '** All **'.
	self widgetFilters keys asSortedCollection do: [:eachFilter |
		eachSelector := self widgetFilters at: eachFilter.
		(self widgetList
			detect: [:each | each perform: eachSelector]
			ifNone: [nil]) notNil ifTrue: [filters add: eachFilter]].
	classes := Set new.
	self widgetList do: [:each | classes add: each class].
	classes := classes asSortedCollection: Class sortBlock.
	ignoreClasses := Array with: TopPane with: WBTargetObject with: WBInstVarObject.
	filters addAll: (classes reject: [:each | ignoreClasses includes: each]).
	aPane
		contents: filters;
		selection: 1.
	self zap.! !

!WBPoolManagerWindow methods !
hidePath
	"Hide the category and pool path fields."

	| pane listBox |
	(self paneNamed: 'poolPathLabel') hideWindow.
	(pane := self paneNamed: 'poolPathField') hideWindow.
	(listBox := self paneNamed: 'poolListBox') framingBlock
		bottomInset: pane framingBlock bottomInset.
	listBox isHandleOk ifTrue: [listBox resize: self mainView rectangle].
	
	(self paneNamed: 'categoryPathLabel') hideWindow.
	(pane := self paneNamed: 'categoryPathField') hideWindow.
	(listBox := self paneNamed: 'categoryListBox') framingBlock
		bottomInset: pane framingBlock bottomInset.
	listBox isHandleOk ifTrue: [listBox resize: self mainView rectangle].

	self optionMenu
		uncheckItem: #menuOptionShowPath.! !

!WBTemplateEditor methods ! 
shellContentRect

	^0 @ 0 extent: sample rectangle extent! !

!WindowBuilder methods !
currentWidget

	^thePane! !

!WBAttributeEditor methods ! 
emptyString

    ^''.! !

!WBScrapbookRetrieve methods !  
updateScrollBar
    | scrollbar size index |
    size := (scrapbook at: chapter) size.
    scrollbar := (self paneNamed: 'scrollbar').
    scrollbar
        minimum: (1 min: size) ;
        maximum: size;
        pageIncrement: 1.
    page isNil ifFalse: [
        index := self pages indexOf: page.
        scrollbar position: index.
    ] ifTrue: [
        index := 0
    ].
    (self paneNamed: 'count') contents: (index asString,' of ',size asString)! !

!WBGeometryManager methods !   
selections

    self layoutForm isNil ifTrue: [^#()].
    ^self layoutForm selections! !

!WBTargetObject methods !  
wbEventsTriggered: aSet

	eventsTriggered := aSet.! !

!WBLayoutCodeModule methods !  
initTemporaries
	"Private - Initialize the variable names."

	self initLayoutTemporaries.
	super initTemporaries.! !

!WBEventMessage methods ! 
moveDown
	"Move the receiver's action down in the list."

	self moveToIndex: (self index + 1 min: self actionList size).! !
  
UndefinedObject removeSelector: #osiIgnoredInitializerSource!
   
"======== Initializers"!

  
WBDevelopmentBitmaps at: 'ActionButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 102' )!

WBDevelopmentBitmaps at: 'ButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 119' )!
  
WBDevelopmentBitmaps at: 'CheckBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 121' )!

WBDevelopmentBitmaps at: 'CP3DCheckBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 128' )!

WBDevelopmentBitmaps at: 'CP3DRadioButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 130' )!
 
WBDevelopmentBitmaps at: 'CPBitmapPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 132' )!

WBDevelopmentBitmaps at: 'CPCircularGaugeSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 134' )!
 
WBDevelopmentBitmaps at: 'CPDateEditorSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 136' )!

WBDevelopmentBitmaps at: 'CPHorizontalBarGaugeSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 138' )!

WBDevelopmentBitmaps at: 'CPNumericEditorSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 140' )!
 
WBDevelopmentBitmaps at: 'CPTableEditorSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 143' )!
   
WBDevelopmentBitmaps at: 'CPValueSetSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 145' )!
  
WBDevelopmentBitmaps at: 'CPVerticalSliderSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 147' )!

WBDevelopmentBitmaps at: 'EnhancedEntryFieldSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 156' )!
  
WBDevelopmentBitmaps at: 'EntryFieldSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 157' )!
  
WBDevelopmentBitmaps at: 'GroupBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 161' )!

WBDevelopmentBitmaps at: 'ListBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 164' )!
 
WBDevelopmentBitmaps at: 'MultipleSelectListBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 170' )!
   
WBDevelopmentBitmaps at: 'RadioButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 180' )!
 
WBDevelopmentBitmaps at: 'StaticBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 194' )!
   
WBDevelopmentBitmaps at: 'StaticTextSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 196' )!
  
WBDevelopmentBitmaps at: 'TextEditSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 201' )!

WBDevelopmentBitmaps at: 'TextSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 200' )!

WBDevelopmentBitmaps at: 'WB3DButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 101' )!
  
WBDevelopmentBitmaps at: 'WBAddressPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 105' )!
   
WBDevelopmentBitmaps at: 'WBAlignBottomSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 106' )!
   
WBDevelopmentBitmaps at: 'WBAlignCenterVerticalSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 108' )!
   
WBDevelopmentBitmaps at: 'WBAlignDistributeVerticalSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 110' )!
   
WBDevelopmentBitmaps at: 'WBAlignRightSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 112' )!

WBDevelopmentBitmaps at: 'WBAnimationPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 114' )!
 
WBDevelopmentBitmaps at: 'WBAutosizeSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 116' )!
  
WBDevelopmentBitmaps at: 'WBBringToFrontSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 118' )!
  
WBDevelopmentBitmaps at: 'WBCheckBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 120' )!
  
WBDevelopmentBitmaps at: 'WBCompositeSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 126' )!
 
WBDevelopmentBitmaps at: 'CPStaticGraphicSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 142' )!
 
WBDevelopmentBitmaps at: 'WBCreateNewSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 148' )!
 
WBDevelopmentBitmaps at: 'WBDictionaryEditorPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 151' )!
  
WBDevelopmentBitmaps at: 'WBEditAppCodeSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 154' )!
   
WBDevelopmentBitmaps at: 'WBGroupSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 160' )!
 
WBDevelopmentBitmaps at: 'WBListEditorPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 165' )!

WBDevelopmentBitmaps at: 'WBLittleDownArrowSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 167' )!
   
WBDevelopmentBitmaps at: 'WBMiscSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 169' )!
  
WBDevelopmentBitmaps at: 'WBOkCancelPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 172' )!
  
WBDevelopmentBitmaps at: 'WBOsilogoSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 174' )!
   
WBDevelopmentBitmaps at: 'WBPasteSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 176' )!
 
WBDevelopmentBitmaps at: 'WBPositionSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 178' )!
  
WBDevelopmentBitmaps at: 'WBRadioButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 179' )!
   
WBDevelopmentBitmaps at: 'WBReplicateWidthSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 184' )!

WBDevelopmentBitmaps at: 'WBSendToBackSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 186' )!

WBDevelopmentBitmaps at: 'WBSetDrawGridSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 188' )!
   
WBDevelopmentBitmaps at: 'WBSetFramingSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 190' )!

WBDevelopmentBitmaps at: 'WBSizeSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 193' )!
  
WBDevelopmentBitmaps at: 'WBTestWindowSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 199' )!

WBDevelopmentBitmaps at: 'WBToolPaneExampleSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 204' )!
   
WBDevelopmentBitmaps at: 'WBVerticalScrollBarSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 209' )!
 
WBDevelopmentBitmaps at: 'WBWindowBuilderToolbarBitmapSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 211' )!

WBDevelopmentBitmaps at: 'CheckBoxGroupSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 122' )!
   
WBDevelopmentBitmaps at: 'CP3DFrameSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 129' )!
   
WBDevelopmentBitmaps at: 'CPBitmapToggleSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 133' )!
  
WBDevelopmentBitmaps at: 'CPHierarchicalListBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 137' )!
   
WBDevelopmentBitmaps at: 'CPSpinButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 141' )!

WBDevelopmentBitmaps at: 'CPVerticalBarGaugeSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 146' )!
  
WBDevelopmentBitmaps at: 'EntryFieldGroupSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 158' )!
 
WBDevelopmentBitmaps at: 'LinkButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 162' )!
  
WBDevelopmentBitmaps at: 'RadioButtonGroupSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 181' )!

WBDevelopmentBitmaps at: 'StaticGraphicSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 195' )!
   
WBDevelopmentBitmaps at: 'TextPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 202' )!

WBDevelopmentBitmaps at: 'WBAddressEditorPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 104' )!
 
WBDevelopmentBitmaps at: 'WBAlignCenterHorizontalSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 107' )!
 
WBDevelopmentBitmaps at: 'WBAlignLeftSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 111' )!
 
WBDevelopmentBitmaps at: 'WBArrowToolSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 115' )!
 
WBDevelopmentBitmaps at: 'WBCheckBoxOnSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 123' )!

WBDevelopmentBitmaps at: 'WBCopySysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 127' )!
  
WBDevelopmentBitmaps at: 'WBCutSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 150' )!
   
WBDevelopmentBitmaps at: 'WBEditTabbingSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 155' )!
   
WBDevelopmentBitmaps at: 'WBListSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 163' )!
  
WBDevelopmentBitmaps at: 'WBNamePaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 171' )!
  
WBDevelopmentBitmaps at: 'WBOtherSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 175' )!
 
WBDevelopmentBitmaps at: 'WBRadioButtonOnSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 182' )!
 
WBDevelopmentBitmaps at: 'WBSaveSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 185' )!
  
WBDevelopmentBitmaps at: 'WBSetFontSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 189' )!
   
WBDevelopmentBitmaps at: 'WBSteelPatternSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 198' )!
  
WBDevelopmentBitmaps at: 'WBValuatorSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 205' )!
  
WBDevelopmentBitmaps at: 'WBWindowSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 210' )!

WBDevelopmentBitmaps at: 'ComboBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 125' )!

WBDevelopmentBitmaps at: 'CPColumnarListBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 135' )!
   
WBDevelopmentBitmaps at: 'CPTimeEditorSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 144' )!

WBDevelopmentBitmaps at: 'GraphPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 159' )!
   
WBDevelopmentBitmaps at: 'SexPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 192' )!
 
WBDevelopmentBitmaps at: 'ThreeStateButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 203' )!

WBDevelopmentBitmaps at: 'WBAlignDistributeHorizontalSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 109' )!
 
WBDevelopmentBitmaps at: 'WBBitmapManagerToolbarSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 117' )!
  
WBDevelopmentBitmaps at: 'WBCreateNewDialogSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 149' )!
   
WBDevelopmentBitmaps at: 'WBHorizontalScrollBarSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 206' )!
   
WBDevelopmentBitmaps at: 'WBOpenNewSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 173' )!
   
WBDevelopmentBitmaps at: 'WBReplicateHeightSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 183' )!
   
WBDevelopmentBitmaps at: 'WBSetMenuSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 191' )!
   
WBDevelopmentBitmaps at: 'WBWbproSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 207' )!
 
WBDevelopmentBitmaps at: 'CPBitmapButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 131' )!
  
WBDevelopmentBitmaps at: 'CPHorizontalSliderSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 139' )!
  
WBDevelopmentBitmaps at: 'DrawnButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 152' )!
 
WBDevelopmentBitmaps at: 'ListPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 166' )!

WBDevelopmentBitmaps at: 'StatusPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 197' )!
  
WBDevelopmentBitmaps at: 'WBAddressSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 248' )!
   
WBDevelopmentBitmaps at: 'WBAlignTopSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 113' )!
  
WBDevelopmentBitmaps at: 'WBClearSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 124' )!
 
WBDevelopmentBitmaps at: 'WBDuplicateSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 153' )!
 
WBDevelopmentBitmaps at: 'WBLittleUpArrowSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 168' )!
 
WBDevelopmentBitmaps at: 'WBPersonPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 177' )!

WBDevelopmentBitmaps at: 'WBSetColorSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 187' )!
  
WBDevelopmentBitmaps at: 'WBToolBarSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 208' )!
   
WBDevelopmentBitmaps at: 'WBPartsButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 240' )!
   
WBDevelopmentBitmaps at: 'WBDUMMYSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 212' )!
 
WBDevelopmentBitmaps at: 'VideoPaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 224' )!
   
WBDevelopmentBitmaps at: 'RichEditSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 218' )!

WBDevelopmentBitmaps at: 'UpDownSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 223' )!
  
WBDevelopmentBitmaps at: 'HeaderSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 215' )!
  
WBDevelopmentBitmaps at: 'SpinButtonSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 219' )!
  
WBDevelopmentBitmaps at: 'ColumnListBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 214' )!
   
WBDevelopmentBitmaps at: 'ProgressBarSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 217' )!
 
WBDevelopmentBitmaps at: 'TreeViewSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 222' )!

WBDevelopmentBitmaps at: 'ButtonListBoxSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 213' )!
   
WBDevelopmentBitmaps at: 'TabControlSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 220' )!
  
WBDevelopmentBitmaps at: 'TrackBarSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 221' )!

WBDevelopmentBitmaps at: 'ListViewSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 216' )!

WBDevelopmentBitmaps at: 'WBWindows95SysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 243' )!
 
WBDevelopmentBitmaps at: 'WBFramingAttachAllSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 227' )!
  
WBDevelopmentBitmaps at: 'WBFramingAttachLeftBottomSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 230' )!
   
WBDevelopmentBitmaps at: 'WBFramingAttachRightBottomSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 237' )!
  
WBDevelopmentBitmaps at: 'WBFramingAttachLeftTopSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 235' )!
  
WBDevelopmentBitmaps at: 'WBFramingAttachRightTopSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 239' )!
 
WBDevelopmentBitmaps at: 'WBFramingAttachPercentSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 236' )!
  
WBDevelopmentBitmaps at: 'WBEventEditorSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 226' )!
   
WBDevelopmentBitmaps at: 'WBPropertyEditorSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 241' )!

WBDevelopmentBitmaps at: 'WBTemplateEditorSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 242' )!

WBDevelopmentBitmaps at: 'WBFramingAttachLeftBottomRightSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 229' )!
  
WBDevelopmentBitmaps at: 'WBFramingAttachLeftTop2SysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 231' )!
 
WBDevelopmentBitmaps at: 'WBFramingAttachLeftBottomRight2SysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 228' )!
 
WBDevelopmentBitmaps at: 'WBFramingAttachLeftTopRight2SysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 233' )!

WBDevelopmentBitmaps at: 'WBFramingAttachLeftTopBottomSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 232' )!

WBDevelopmentBitmaps at: 'WBFramingAttachRightTopBottomSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 238' )!
   
WBDevelopmentBitmaps at: 'WBFramingAttachLeftTopRightSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 234' )!
 
WBDevelopmentBitmaps at: 'CPTablePaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 103' )!
 
WBDevelopmentBitmaps at: 'StatusWindowSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 246' )!

WBDevelopmentBitmaps at: 'ToolbarSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 247' )!
 
WBDevelopmentBitmaps at: 'OLEClientSitePaneSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 244' )!
   
WBDevelopmentBitmaps at: 'OLEControlPartSysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 245' )!
  
WBDevelopmentBitmaps at: 'WBDUMMY2SysBitmap' put: (
    Compiler evaluate:
'WBBitmapClass
    fromModule: ''wb31sysw.dll''
    id: 212' )!

"bindAction:
	Message
		receiver: WindowBuilder
		selector: #wbInitializeDevelopment"

	WindowBuilder wbInitializeDevelopment.!