3.1.0.106
   
defaultBackColor
        "Answer the default background color for windows of
         this class."
    ^Color dialogBackground!
platformDefaultFont
        "Answer the font which is traditionally used for dialog
        windows on this host platform; this font is not automatically
        applied to dialogs unless a client sends 'self mainView font:
        self class platformDefaultFont' from within a WindowDialog."
    | font |
    NationalLanguage isDoubleByteCp ifTrue: [ ^nil ].
    font := Font new
        faceName: 'MS Sans Serif';
        pointSize: 8;
        fixedWidth: false.
    ( OperatingSystem isWin32 and: [ OperatingSystem versionMajor = 4 ] ) ifFalse: [ font bold: true ].
    ^font!   
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #aboutToClose ;
        add: #aboutToDisplayMenu ;
        add: #activated ;
        add: #closed ;
        add: #deactivated ;
        add: #help ;
        add: #maximized ;
        add: #menuBarBuilt ;
        add: #minimized ;
        add: #opened ;
        add: #resized ;
        add: #restored ;
        add: #rightClicked ;
        add: #timer: ;
        add: #validated ;
        add: #button1Down ;
        yourself!  
fileMenu
        "Private - Answer the File menu."
    | menu runtime |
    runtime := Smalltalk isRunTime.
    menu := Menu new
        appendItem: '&New Workspace	Alt+N' selector: #openWorkspace accelKey: $n accelBits: AfAlt | AfChar ;
        appendItem: '&Open...	Alt+O' selector: #openFile accelKey: $o accelBits: AfAlt | AfChar ;
        title: '&File'.

    runtime ifFalse: [
        menu appendItem: '&Install...	Alt+I' selector: #install accelKey: $i accelBits: AfAlt | AfChar ].
    menu
        appendItem: '&Save	Alt+S' selector: #accept accelKey: $s accelBits: AfAlt | AfChar;
        appendItem: 'Save &As...	Alt+A' selector: #saveAs accelKey: $a accelBits: AfAlt | AfChar.
    runtime ifFalse: [
        menu appendItem: '&Browse Classes	Alt+B' selector: #openClassBrowser accelKey: $b accelBits: AfAlt | AfChar;
            appendItem: 'Browse &Disk	Alt+D' selector: #openDiskBrowser accelKey: $d accelBits: AfAlt | AfChar ].
    menu
        appendItem: '&Print	Alt+P' selector: #print accelKey: $p accelBits: AfAlt | AfChar ;
        appendItem: 'Prin&t Setup...	Alt+T' selector: #printSetup accelKey: $t accelBits: AfAlt | AfChar ;
        appendItem: '&Restore	Alt+R' selector: #restore accelKey: $r accelBits: AfAlt | AfChar.
    runtime ifFalse: [
        menu appendSeparator ;
            appendItem: 'Save Image...' selector: #saveImage ].
    ^menu!  
textWindowClass
        "Private - answer the default class of text window to use."
    ^Smalltalk isRunTime
        ifTrue: [ TextWindow ]
        ifFalse: [ self textWindowClassDev ]! 
handle: aWindowHandle
        "Private - Answer a new instance of the receiver
         whose handle is aWindowHandle."
    ^(self new) handle: aWindowHandle; yourself!   
fromBytes: aVariableByteObject
        "Answer a new instance of the receiver
          whose handle is aVariableByteObject."
    ^self handle: (WindowHandle fromBytes: aVariableByteObject)! 
initializeEventsTriggered
        "Private - initialize all the events which can be triggered
        by instances of the receiver."
    self eventsTriggered: self constructEventsTriggered!  
fromInteger: anInteger
        "Private - Answer a new instance of the receiver
          whose handle is anInteger."
    ^self handle: ( WindowHandle fromInteger: anInteger )!   
tooManyWindows
        "Private - An error occurred while trying to open a window,
         so warn the user."
    Notifier warning: '\\        WARNING!!!!\\  OS has run out of window resources.\  You must close some windows to continue.' withCrs.
    CursorManager normal change.
    Process errorNoWalkback. "Does not return."!
defaultFont
        "Answer the default font to be used for this
         class of Window, unless otherwise explicitly
         set with #font:"
    ^SysFont!
eventsTriggered
        "Answer all the events which can be triggered
        by instances of the receiver."
    eventsTriggered isNil ifTrue: [ self initializeEventsTriggered ].
    ^eventsTriggered!  
eventsTriggered: aCollection
        "Private - specify all the events which can be triggered
        by instances of the receiver."
    eventsTriggered := aCollection!   
turtleWindow: aTitle
        "Create a new graphics window with aTitle
         and assign its pen to Turtle."
    | answer |
    answer := GraphPane openWindow: aTitle.
    Turtle := answer pen.
    Turtle home.
    ^answer!  
new
		"Answer a new instance of the receiver."
	^super new initialize!  
wmSize: wordInteger with: longInteger
        "Private - Process the window resizing message."
    ^nil!
buildWindow: aParentWindow
        "Private - Create the dialog window for the receiver."
    | result |
    style isNil ifTrue: [ style := self getStyle ].
    framingBlock isNil
        ifTrue: [
            rectangle := self initSize.
            framingBlock := rectangle ]
        ifFalse: [ rectangle := framingBlock value: parent rectangle ].

    NotificationManager newWindow: self.
    result := UserLibrary
        createDialogIndirect: OperatingSystem hInstanceExe
        dialogTemplate: ( WinDialogInfo dialogTemplateFor: self ) asParameter
        parent: parent asParameter
        dialogFunction: DialogProcInstance asParameter.
    NotificationManager newWindow: nil.
    result = 0 ifTrue: [ ^self osError ].
    handle := WindowHandle fromInteger: result.
    self
        receiveMessages;
        buildDialogItems.

    PoppedModelessWindows add: handle.
    self isHidden ifFalse: [ self showWindow ].
    self sendDeferredEvent: #subclassRecursively!
mainWindow
        "Answer the receiver's main window.  If the DialogTopPane's
          parent is kind of Window then it returns its parent's main
          window else it returns self. (Needed for cases where
          DialogTopPane is a subpane of TopPane.)"
    ^(owner notNil)
        ifTrue: [owner mainView]
        ifFalse: [self]!
boxOfSize: aPoint
        "Private - Answer a Rectangle with extent of aPoint
         and upper left corner at the cursor position."
    | corner |
    corner := Cursor sense.
    parent notNil ifTrue: [ corner := corner mapToWindow: parent ].
    corner := corner * ( WindowDialog unitMultiplier / WindowDialog dialogUnit ).
    ^( ( corner max: 0@0 ) min: ( Display extent - aPoint ) )
        extent: aPoint!  
defaultStyle
        "Private - Answer the default frame style for the receiver."
    | dialogStyle |
    dialogStyle := WsCaption | WsSysmenu | WsPopup | WsVisible.
    dialogStyle := dialogStyle | ( parent isNil ifTrue: [ WsBorder ] ifFalse: [ DsModalframe ] ).
    ( OperatingSystem isWin32 and: [ OperatingSystem versionMajor = 4 ] )
        ifTrue: [ dialogStyle := dialogStyle | Ds3dlook ].
    ^dialogStyle! 
getWindowToDisable: aParent
        " Private - answer the window to disable when the receiver is opened. "
    ^aParent isNil
        ifTrue: [ Notifier findWindow: WindowHandle queryActive ]
        ifFalse: [ aParent ]!
openModeless
        "Open a modeless dialog box."
    [ CursorManager execute changeFor: [
        self buildWindow.
        self event: #opened.
        self triggerEvent: #opened ] ] ifCurtailed: [ self close ]!   
openModal: aParent
        "Open the dialog box modal to the
         current active window."
     [ CursorManager execute changeFor: [
            self isHandleOk
                ifTrue: [
                    self bringToTop.
                    self triggerEvent: #opened.
                    ^self ].
           parent := self getWindowToDisable: aParent.
            "Disable parent now to ensure that there are no further
             activities at parent."
            parent notNil ifTrue: [ parent disable ].
            self buildWindow.
            self event: #opened.
            self triggerEvent: #opened ].
        Processor currentProcessIsRecursive ifFalse: [ self processInput ] ]
            ifCurtailed: [ self close. parent notNil ifTrue: [ parent setFocus ] ]!   
addSystemModalStyle
        "Add the system modal style."
    ^self addStyle: DsSysmodal!   
alignRelativeToScreen
        "Add the align relative to screen style."
    ^self addStyle: DsAbsalign! 
wmPaint: wordInteger with: longInteger
        "Private - Process the window painting message."
    ^nil!   
close
        "Private - Close the dialog box."
    self isOkToClose ifFalse: [ ^self ].

    parent notNil ifTrue: [ parent enable ].
    handle hideWindow.
    children size > 0 ifTrue: [
        children do: [ :subpane | subpane close ] ].
    self stopReceivingMessages.

    PoppedModelessWindows remove: handle ifAbsent: [ ].
    self destroy.
    self subPaneWithFocus: nil.
    self triggerEvent: #closed.

    Processor currentProcessIsRecursive ifTrue: [ ^self ].   "no semaphore wait"

    sem notNil ifTrue: [
        sem signal.
        sem := nil.
        Processor suspendActive ]!  
open
        "Open the dialog box modal to the
         current active window."
    ^ self openModal: parent!  
maximizingWindow
        "Private - Maximizing window.  Trigger an event notifying
        interested clients."
    self triggerEvent: #maximized! 
windowPolicy
        "Answer the receiver's instance of WindowPolicy or a
	    subclass which is used to construct the menu bar."
    ^self propertyAt: #windowPolicy
        ifAbsentPut: [ [ owner windowPolicyClass new ]
            on: MessageNotUnderstood
            do: [ :e | StandardWindowPolicy new ] ]!  
addSubpane: aPane
        "Add aPane to the receiver."
    super addSubpane: aPane.
    self addTabInfoFor: aPane! 
triggerOpenedEvent
        "Private - trigger the #opened event."
    self event: #opened.
    self triggerEvent: #opened.!
deferredResizeRectangleFor: aRectangle
        "Private - Answer the rectangle to
        use to resize the receiver to aRectangle
        when drawing is being delayed."

    ^framingBlock value: aRectangle! 
initMenu
        "Private - Initialize the menu."
    menuWindow notNil
        ifTrue: [ menuWindow aboutToStartMenu ].
    self activeTextPane notNil
        ifTrue: [ self activeTextPane initMenu ]!
releaseEventTable
        "Private - Break all connections to event handlers."
    handlers := nil! 
restoringWindow
        "Private - Restoring window.  Trigger an event notifying
        interested clients."
    self triggerEvent: #restored!
button2Up: aPoint
        "Private - signal the right clicked event."
    self triggerEvent: #rightClicked
        ifNotHandled: [ super button2Up: aPoint ]!  
framingBlock: oneArgBlock
        "Initialize the framingBlock to the one
        argument block aBlock which, when executed,
        yields the receiver's frame rectangle."
    framingBlock := oneArgBlock!
framingRatio: aRectangle
        "Private - Initialize the framingBlock to a one
        argument block which, when executed, yields the
        pane frame rectangle proportional with the ratios
        specified by aRectangle."
    framingBlock := [ :box | box scaleTo: aRectangle ]! 
buildMenuBar
        "Private - Create the menus that make up the menu bar."
    | windowPolicy |
    windowPolicy := self windowPolicy.
    windowPolicy window: self.
    windowPolicy addMenus!   
canTab
        "Private -Cannot tab into or out of a Window or a
        DialogTopPane"
    ^false!
handlersAttribute
        "Private - answer the event handlers instance variable."
    ^handlers!   
handlersAttribute: eventHandlers
        "Private - set the handlers instance variable."
    handlers := eventHandlers! 
tabScope
        "Private - Answer self meaning the window contains the
        tabbing information."
    ^self!   
initWindowSize
        "Private - Answer default initial window extent."
    ^framingBlock notNil
        ifTrue: [framingBlock value: Display boundingBox]
        ifFalse: [super initWindowSize]!  
activate
        "Private - The receiver was activated."
    super activate.
    self event: #activate.
    self triggerEvent: #activated!
timerID
        "Answer the id of the timer that is being
         notified, during the #timer event.  Else answer nil."
    ^self propertyAt: #timerID!   
okToClose
        "Private - answer the okToClose property."
    ^self propertyAt: #okToClose ifAbsent: [ true ]!   
okToClose: aBooleanOrNil
        "Private - set the okToClose property."
    self propertyAt: #okToClose put: aBooleanOrNil!
framingBlock
        "Private - Answer the framing block."
    ^framingBlock!   
sizeChanged: extent
        "Private - The size of the receiver has been changed
         to extent."
    super sizeChanged: extent.
    ( extent x > 0 or: [ extent y > 0 ] ) ifTrue: [ self triggerEvent: #resized ]!   
eventTableForEdit
        "Private - answer the table of event handlers for the receiver.
        Allocate if necessary so that updates can be stored."
    ^handlers := self eventTable!  
windowPolicy: aWindowPolicy
        "Set the receiver's instance of WindowPolicy or a
        subclass which is used to construct the menu bar."
    self propertyAt: #windowPolicy put: aWindowPolicy!
validate
        "Private - Create the window or recreate after saving
         image."
    super validate isNil ifTrue: [ ^nil ].
    self event: #validated.
    self triggerEvent: #validated.!   
saveAs
        "Private - The saveAs item on the File menu
         is selected."
    ( self owner notNil and: [ self owner ~= self ] ) ifTrue: [ self owner saveAs ]! 
abortClose
        "Veto the window close which is about to occur."
    self okToClose: false!  
close
        "Private - Raise the close event."
    "to support the old event system, treat any calls to #close during the
    handling of the #close event as a request to closeView (don't recursively
    trigger the close event again)."
    ( self propertyAt: #handlingCloseEvent ifAbsent: [ false ] ) ifTrue: [ ^self closeView ].
    ( self handlesEvent: #close )
        ifTrue: [  " compatibility support for old close event "
            self propertyAt: #handlingCloseEvent put: true.
            ( self event: #close ) isNil
                ifTrue: [ self closeView ].
            self propertyAt: #handlingCloseEvent put: nil.
            ^self ].
    self isOkToClose
        ifTrue: [
            self closeView.
            self triggerEvent: #closed ]! 
deactivate
        "Private - The receiver was deactivated."
    super deactivate.
    self event: #deactivate.
    self triggerEvent: #deactivated!  
eventTable
        "Private - answer the table of event handlers for the receiver."
    handlers isNil ifTrue: [ ^self eventTableCreate ].
    ^handlers!  
isOkToClose
        "Private - answer whether it is OK to close.
        Triggers the veto-able #aboutToClose event."
    | isOk |
    self
        okToClose: true;
        triggerEvent: #aboutToClose.
    isOk := self okToClose.
    self okToClose: nil.
    ^isOk!
isTopPane
        "Answer whether the receiver is a kind of TopPane."
    ^true!
noSmalltalkMenuBar
        "Does not create the default Smalltalk menu bar (File,
        Edit, Smalltalk menus).  By sending this message,
        the owner takes the responsibility for creating the
        menu bar upon reception of #menuBuilt event.
        Menu specific to SubPanes, (built with #getMenu event)
        will not be added to the MenuBar but will only be added
        to the popup menu."
    self propertyAt: #noSmalltalkMenuBar put: true!   
hasSmalltalkMenuBar
        "Answers whether the receiver should have the
        default Smalltalk menu bar."
    ^( self propertyAt: #noSmalltalkMenuBar ) isNil!
removeSubpane: aWindow
        "Remove aWindow from the receiver."

    aWindow affectsFreeClientArea
        ifTrue: [
            self childrenAffectingClientArea remove: aWindow ifAbsent: [] ].

    super removeSubpane: aWindow.

    ( self isHandleOk and: [ aWindow affectsFreeClientArea ])
        ifTrue: [ self resizeChildren ]! 
triggerOpenedEvent
        "Private - Do nothing"!   
defaultPushButton
        "Private - Answer the subpane which is the default
        push button."
    ^self propertyAt: #defaultPushButton!   
showIconicWindow
        "Private - Show the receiver window as an icon."
    self frameWindow addStyle: WsVisible.
    self isHandleOk
        ifTrue: [
            self minimizingWindow.
            self frameWindow handle showIconicWindow ]
        ifFalse: [ self whenValid: #showIconicWindow ]!
showRestoredWindow
        "Private - Show the receiver window as a normal/restored window."
    self frameWindow addStyle: WsVisible.
    self isHandleOk
        ifTrue: [ self frameWindow handle showRestoredWindow ]
        ifFalse: [ self whenValid: #showRestoredWindow ]!  
statusPane
        "Private - Answer the status pane if any, else answer nil."
    children isNil ifTrue: [ ^nil ].
    ^children detect: [ :c | c isStatusPane ] ifNone: [ nil ]! 
toggleWrap
        "Word wrap was selected from the Options menu; pass on the
        request to the active TextPane (TextPaneControl)."
    self activeTextPane notNil
        ifTrue: [ self activeTextPane toggleWrap ]!   
childrenAffectingClientArea
    "Private - Answer the children that reduces
    the amount of visible client area in the receiver"

    ^self propertyAt: #childrenAffectingClientArea
        ifAbsent: [ OrderedCollection new ]!  
close
        "Close the receiver and all its children."
    self closeView!
clearTextModified
        "Private - Clear the modified flag on all the
         receiver's TextPanes."
    self allChildrenDo: [ :pane |
        pane isTextPane
            ifTrue: [ pane modified: false ] ]!
performMenuItem: anInteger
        "Private - Perform the menu item whose id is anInteger."
    menuWindow notNil
        ifTrue: [ menuWindow performMenuItem: anInteger ]!   
textModified
        "Private - If any text pane has been modified,
         ask the user whether the changes should be saved,
         ignored, or cancel the operation.  If the user chooses
         save, the changes are saved.  Answer true if the
         user chooses save or ignore.  Otherwise, answer false."
    | title answer |
    self isTextModified ifFalse: [ ^false ].
    ( title := self label ) size = 0 ifTrue: [ title := 'Unsaved Changes' ].
    answer :=  MessageBox new
        title: title;
        message: 'Save current changes?';
        yesNoCancel;
        iconQuestion;
        defaultButton: 3;
        open.
    answer isNil ifTrue: [ ^true ].
    answer ifTrue: [
        self accept.
        ^self isTextModified ].
    self clearTextModified.  "in case 2 modified text pane"
    ^false!  
activeTextPane
        "Answer the subpane that has the typing focus."
    ^activeTextPane! 
maximumSize: aPoint
        "Set the maximum size that the receiver may be resized to
        with the sizing border."
    self propertyAt: #maximumSize put: aPoint!  
minimumSize: aPoint
        "Set the minimum size that the receiver may be resized to
        with the sizing border."
    self propertyAt: #minimumSize put: aPoint!  
activeTextPane: aTextPane
        "Private - Change the active text pane. Change the
         owner of the Edit and Smalltalk menus
         to aTextPaneWindow."
    self activeTextPaneNoSetFocus: aTextPane.
    aTextPane notNil ifTrue: [ aTextPane setFocus ]! 
subclassRecursively
        "Private - subclass the children."
    self children do: [ :child | child subclassRecursively ]!
isApplicationWindow
        "Answer true if receiver is a kind of ApplicationWindow."
    ^true!
menuTitled: aString
        "Answer the menu from the receiver's menu bar
         whose title is aString.  Case is ignored
         and aString can include '&', '~', or neither."
    ^self menuWindow isNil
        ifTrue: [ nil ]
        ifFalse: [ self menuWindow menuTitled: aString ]!
menuWindow: aMenuWindow
        "Private - Set the menu bar window for the receiver."
    menuWindow := aMenuWindow!
label: aString
        "Set the window label of the receiver to aString."
    self labelWithoutPrefix: aString! 
subPaneWithFocus: aSubPane
        "Private - remember the SubPane of the receiver
         that last had the focus"
    self propertyAt: #subPaneWithFocus put: aSubPane! 
activeTextPaneNoSetFocus: aTextPane
        "Private - Change the active text pane. Change the
        owner of the Edit and Smalltalk menus
        to aTextPaneWindow.  Don't attempt to set the
        focus to aTextPane."
    | menu |
    aTextPane isNil ifTrue: [ ^nil ].
    activeTextPane := aTextPane.
    self hasSmalltalkMenuBar ifTrue: [
        ( menu := ( menuWindow menuTitled: '\uEdit' replaceEscapeCharacters ) )
            notNil ifTrue: [ menu allOwners: activeTextPane ] ]! 
mainWindow
        "Answer the main window for the receiver."
    ^self!
menuWindow
        "Private - Answer the menu bar window for the receiver."
    ^menuWindow!
initWindowSize
        "Private - Answer default initial window extent."
    ^Display extent * 3 // 5!  
initSize
        "Private - Answer the initial size of the receiver."
    | size |
    rectangle notNil ifTrue: [ ^rectangle ].
    size := [ owner initWindowSize ]
        on: MessageNotUnderstood do: [ :e | self initWindowSize ].
    ^size isRectangle
        ifTrue: [ size ]
        ifFalse: [ size isPoint
            ifTrue: [ self boxOfSize: size ]
            ifFalse: [ 0 @ 0 extent: 100@100 ] ]!   
fileMenu
        "Private - Answer the File menu for the receiver."
    ^self class fileMenu!   
icon
        "Answer the receiver's icon."
    ^self propertyAt: #icon.!
unorderedChildren
        "Private - Answer an OrderedCollection which contain
        the children missing in orderedChildren."
    | orderedChildren |

    orderedChildren := self orderedChildren.
    ^self children reject: [ :child |
        ( orderedChildren includes: child )
            or: [ self childrenAffectingClientArea includes: child ]].!  
accept
        "Private - The user selected 'Save' menu item.
         Pass it on to the active TextPane."
    self activeTextPane notNil ifTrue: [ self activeTextPane accept ]!  
remove: anObject interestIn: aFacet
        "Remove anObject as a dependent of aFacet in the receiver.
         anObject."
    | list |
    list := self dependents at: aFacet ifAbsent: [ ^nil ].
    list remove: anObject ifAbsent: [ nil ].
    list isEmpty ifTrue: [ self dependents removeKey: aFacet ]! 
defaultPushButton: aButton
        "Private - Set the subpane which is the default push button."
    ^self propertyAt: #defaultPushButton put: aButton! 
subPaneWithFocus
        "Answer the SubPane of the receiver that last had the focus"
    ^self
        propertyAt: #subPaneWithFocus
        ifAbsentPut: [ self searchForDefaultTextPane ]! 
closeInnerWindows
        "Private - close the inner windows in the view.
        Answer whether successful."
    | inner |
    inner := OrderedCollection new.
    Notifier windows do: [:w|
        ((w == self) not and: [
        w isApplicationWindow and: [
            w isHandleOk and:[
                self hasDescendant: w]]])
                    ifTrue: [inner add: w]].
    inner do: [:w| w textModified ifTrue: [^false] ifFalse: [w clearTextModified]].
    inner do: [:w| w close].
    self textModified ifTrue: [^false].
    ^true!
childrenAffectingClientArea: anOrderedCollection
    "Private - Set the children that reduces
    the amount of visible client area in the receiver"

    ^self propertyAt: #childrenAffectingClientArea
        put: anOrderedCollection!   
framingBlock
        "Private - Answer bounding rectangle as
         the framingBlock."
    ^rectangle!   
print
        "Private - User selected the Print menu item
         from the File menu."
    self activeTextPane notNil
        ifTrue: [ self activeTextPane print ]
        ifFalse: [ Display outputToPrinter: self frameRectangle ]! 
initSize: aRectangle
        "Private - Set the initial the size of the receiver
         to aRectangle."
    rectangle := aRectangle! 
freeClientArea
    "Answer the remaining visible area after children
    affecting the available free client area have
    their rectangles removed from the receiver's
    rectangle."

    ^self freeClientArea: self entireClientArea!   
changed: aFacet
        "Something has changed related to the dependents
         of the receiver.  Send update message to all the
         dependents of aFacet (usually the name of a subpane)."
    (self dependents at: aFacet ifAbsent: [#()]) do: [ :dependent |
        dependent update]!
dependents
        "Private - Answer the dictionary of dependents."
	dependents isNil ifTrue: [ dependents := Dictionary new ].
    ^dependents!   
validate
        "Private - Set initial values and make window visible."
    CursorManager execute changeFor: [
        self validateBuild isNil ifTrue: [ ^nil ].
        self validateShow ]!   
childrenInBuildOrder
        "Private - answer the child panes in the order they should be built."

    ^self childrenAffectingClientArea, super childrenInBuildOrder! 
open
        "Private - Open the receiver."
    ^self openWindow!   
validateBuild
        "Private - create or recreate the window for the receiver
         without showing it."
    ^self buildWindow!   
showMaximizedWindow
        "Private - Show the receiver window maximized."
    self frameWindow addStyle: WsVisible.
    self isHandleOk
        ifTrue: [ self frameWindow handle showMaximizedWindow ]
        ifFalse: [ self whenValid: #showMaximizedWindow ]! 
addSubpane: aPane
        "Add aPane to the receiver."

    aPane affectsFreeClientArea
        ifTrue: [
            self childrenAffectingClientArea:
                ( self childrenAffectingClientArea
                    add: aPane; yourself ) ].

    super addSubpane: aPane.
    ( self isHandleOk and: [ aPane affectsFreeClientArea ])
        ifTrue: [
            aPane isHandleOk
                ifTrue: [ self resizeChildren ]
                ifFalse: [ aPane whenValid: #resizeSiblings ]]!   
maximumSize
        "Answer the maximum size that the receiver may be resized to
        with the sizing border."
    ^self propertyAt: #maximumSize!  
minimumSize
        "Answer the minimum size that the receiver may be resized to
        with the sizing border."
    ^self propertyAt: #minimumSize!  
changed: aFacet
    with: firstParameter
        "Something has changed related to the dependents
         of the receiver.  Send update: firstParameter message to all the
         dependents of aFacet (usually the name of a subpane)."
    (self dependents
        at: aFacet
        ifAbsent: [#()])
            do: [ :dependent |
                dependent
                    update: firstParameter]!  
restore
        "Private - User selected the Restore menu item
         from the File menu."
    self activeTextPane notNil ifTrue: [ self activeTextPane cancel ]!
add: anObject interestIn: aFacet
        "Add anObject as a dependent of aFacet in the receiver.
         anObject is usually a subpane and aFacet is usually
         a selector (the name of the subpane).
         See also Window addSubpane:"
	aFacet isNil ifTrue: [ ^self ].
    (self dependents at: aFacet ifAbsent: [
        self dependents at: aFacet put: OrderedCollection new])
            add: anObject!
freeClientArea: aRectangle
    "Private - Answer the remaining visible area
    after children affecting the free client area have
    their rectangles removed from <aRectangle>."
    | freeArea |

    freeArea := aRectangle.
    self childrenAffectingClientArea do: [ :aChild |
         freeArea := aChild freeClientArea: freeArea ].
    ^freeArea!
label
        "Answer the receiver's label."
    ^label!
openWindow
        "Open the receiver."
    ^self openIn: self initSize!
updateZoomMenu
        "Private - the Zoom menu item was selected/deselected;
         set the menu item check mark appropriately."
    | optionMenu |
    ( optionMenu := self mainWindow menuTitled: 'Options' ) isNil
        ifTrue: [ optionMenu := self mainWindow systemMenu ].
    optionMenu isNil ifTrue: [ ^nil ].
    self zoomed
        ifTrue: [ optionMenu checkItem: #zoom ]
        ifFalse: [ optionMenu uncheckItem: #zoom ]!
changed: aFacet
    with: firstParameter
    with: secondParameter
        "Something has changed related to the dependents
         of the receiver.  Send the 'update: firstParameter
         with: secondParameter' to all the dependents of
         aFacet (usually the name of a subpane)."
    (self dependents
        at: aFacet
        ifAbsent: [#()])
            do: [ :dependent |
                dependent
                    update: firstParameter
                    with: secondParameter]!  
resizeChildren
        "Private - Resize all children."
    | remainingClientArea |

    children size = 0 ifTrue: [ ^self ].

    remainingClientArea :=
        self isHandleOk
            ifTrue: [ self entireClientArea ]
            ifFalse: [ rectangle copy ].
    self childrenAffectingClientArea
        do: [ :subpane |
            subpane resize: remainingClientArea.
            remainingClientArea :=
                subpane freeClientArea: remainingClientArea ].

    children do: [ :subpane |
        subpane affectsFreeClientArea
            ifFalse: [ subpane resize: remainingClientArea ]]!   
buildIcon
        "Private - create the icon for the receiver."
    | icon |
    ( icon := self icon ) notNil ifTrue: [ ^self icon: icon ].  "specified using #icon: "
    icon := [ self owner class icon ]
        on: MessageNotUnderstood
        do: [ :e | Icon new ].  "use default runtime icon if not specified"
    self icon: icon! 
openFile
        "Private - User selected Open... from the File menu."
    | dialog file |
    ( dialog := FileDialog new openFile ) isNil 
        ifTrue: [ ^self ].
    ( file := dialog file ) isNil 
        ifTrue: [ ^self ].
    ( File exists: file ) ifFalse: [
        ( MessageBox confirm: 'File does not exist.  Do you want to create it?' )
            ifTrue: [ File createFileNamed: file ]
            ifFalse: [ ^self ] ].
    file := File pathNameReadOnly: file.
    self class textWindowClass new openOnFile: file.
    file close!   
isTextModified
        "Private - Answer true if any text pane in the receiver
         has been modified."
    self allChildrenDo: [ :pane |
        ( pane isTextPane and: [ pane modified ] ) ifTrue: [ ^true ] ].
    ^false!
allChildrenDo: aOneArgumentBlock
        "Private - evaluate aOneArgumentBlock for each of the
        receiver's children, and any nested children (children of children, etc.),
        passing the child as an argument."
    children notNil ifTrue: [
        children do: [ :child |
            aOneArgumentBlock value: child.
            child allChildrenDo: aOneArgumentBlock ] ]! 
affectsFreeClientArea
    "Answer whether the receiver reduces the amount of
    free client area in its parent for the receiver's siblings."

    ^self propertyAt: #affectsFreeClientArea ifAbsent: [ false ]!  
asParameter
        "Answer the receiver in a form suitable for passing
         as a parameter to a host procedure call."
    ^handle!
sendInputEvent: selector with: argument
        "Private - Add a Message with argument to CurrentEvents."
    [   CurrentEvents add: ( Message new
            receiver: self
            selector: selector
            arguments: ( Array with: argument ) ) ] evaluateWithoutInterrupts.
    OSEventSemaphore signal!
allChildrenInBuildOrderDo: aOneArgumentBlock
        "Private - evaluate aOneArgumentBlock for each of the
        receiver's children, and any nested children (children of children, etc.),
        passing the child as an argument.  Traverse the children in order of build."
    children notNil ifTrue: [
        self childrenInBuildOrder do: [ :child |
            aOneArgumentBlock value: child.
            child allChildrenInBuildOrderDo: aOneArgumentBlock ] ]!  
helpManager
        "Private - Answer the HelpManager for the receiver."
    ^self propertyAt: #helpManager!
framingRectangleFor: aRectangle
        " Private - answer the real rectangle "
    ^self zoomed
        ifTrue: [ aRectangle ]
        ifFalse: [ self framingBlock value: aRectangle ]! 
extent
        "Answer the receiver's extent."
    ^self rectangle extent!  
rectangleAttribute: aRectangle
        "Private - set the rectangle instance variable of
        the receiver to aRectangle."
    rectangle := aRectangle! 
initMenu
        "Private - Initialize the menu."
    ^nil! 
listFont: aFont
        "Set the list pane font of all children to aFont."
    children isNil ifFalse: [
        children do: [:each |
            each listFont: aFont]]!
statusPane
        "Answer the receiver's status bar"
    ^self mainWindow statusPane!  
canTab
        "Private - Answer true if the window can
        be tabbed into and out of."
    ^true! 
textFont: aFont
        "Set the text pane font of all children to aFont."
    children isNil ifFalse: [
        children do: [ :each |
            each textFont: aFont ] ]! 
ownerDrawStruct
        "Private - answer the drawing structure for
        the current drawItem request."
    ^self propertyAt: #ownerDrawStruct! 
losingFocus
        "Private - The receiver is losing the input focus.
         Implemented by subclasses.
         Default is do nothing."!   
enableUpdate
        "Enable update of the receiver and all its children."
    self isHandleOk ifTrue: [ handle enableUpdate ]! 
previousInGroup: aSubPane
        "Private - Answer the subpane which has the next
        tabstop."
    | orderedChildren index |
    orderedChildren := self orderedChildren
        select: [ :pane | pane canArrowInto and: [ pane disabled not and: [ pane isHidden not ] ] ] .
    index := ( orderedChildren indexOf: aSubPane ) - 1.
    ( index <= 0 or: [ aSubPane isAGroupLeader ] )
        ifFalse: [ ^orderedChildren at: index ].
    index := index + 2.
    [ index <= orderedChildren size ] whileTrue:
        [ ( orderedChildren at: index ) isAGroupLeader
            ifTrue: [ ^orderedChildren at: ( index - 1 ) ].
        index := index + 1 ].
    ^orderedChildren last!   
previousTabStop: aSubPane
        "Private - Answer the subpane which has the previous
        tabstop."
    | orderedChildren  index startIndex child |
    ( orderedChildren := self orderedChildren ) isEmpty
        ifTrue: [ ^self ].
    startIndex := orderedChildren indexOf: aSubPane.
    "Circulate through the orderedChildren
        and find the first tabstop."
    index := startIndex - 1.
    index < 1
        ifTrue: [index := orderedChildren size].
    ^(child := orderedChildren at: index) hasFocus
        ifTrue: [child]
        ifFalse: [child previousTabStop]!   
drawHighlight: aDrawStruct
        "Private - Highlight the requested menu item.  Usually
        reimplemented by subclasses."
    self defaultDrawHighlight: aDrawStruct!
performWhenValids
        "Perform the messages that require a valid handle
         (created by calls to #whenValid:)"
    | whenValid |
    self isHandleOk ifFalse: [ ^nil ].
    whenValid := self propertyAt: #whenValid ifAbsent: [ ^nil ].
    whenValid do: [ :aMessage | aMessage perform ].
    self propertyAt: #whenValid put: nil!
defaultDrawItem: aDrawStruct
        "Private - Draw the requested menu item."
    self ownerDrawPen
        setTextAlign: TaTop;
        place: self drawBox origin;
        displayText: '<OwnerDrawn>'!   
isBeingEdited: aBoolean
        "Set whether the receiver is being edited."
	^self propertyAt: #isBeingEdited put: ( aBoolean == true ifTrue: [ true ] ifFalse: [ nil ] )!  
rectangle: aRectangle
        "Set the position of the receiver to aRectangle."
    self rectangleAttribute: aRectangle.
    self isHandleOk ifTrue: [ self resizeWindow ]!
owner
        "Answer the owner of the receiver."
    ^owner!   
whenValid: selector withArguments: anArray
        "Add a message to the list of messages
         that must be sent to the receiver's host window
         after the handle is valid (the window has
         been created)."
    | aMessage whenValid |
    aMessage := Message new
        receiver: self;
        selector: selector;
        arguments: anArray.
    whenValid := self propertyAt: #whenValid ifAbsentPut: [ OrderedCollection new ].
    whenValid add: aMessage!
mouseMove: aPoint
        "Private - The user moved the mouse at aPoint
         with no buttons down.
         Implemented by subclasses.
         Default is do nothing."!  
currentCursor
        "Private - Answer the mouse cursor that's
         appropriate for the receiver window."
    ^Cursor handle notNil
        ifTrue: [ Cursor ]
        ifFalse: [
            self mainWindow isBeingEdited
                ifTrue: [ CursorManager arrow ]
                ifFalse: [ self defaultCursor ] ]!   
defaultFont
        "Answer the default font of the receiver."
    ^self class defaultFont! 
sizeChanged: extent
        "Private - The size of the receiver has been changed
         to extent."
    ( parent isNil and: [ rectangle extent = extent ] ) ifTrue: [ ^self ].
    self adjustFraming: self frameRelativeRectangle.
    self updateRectangle.
    self resizeChildren.
    self event: #resize.
    self triggerEvent: #resized.!   
updateRectangle
        "Private - Update rectangle to be the same
         as that maintained by the host window."
    rectangle := self entireClientArea.
    graphicsTool notNil ifTrue: [
        graphicsTool
            width: rectangle width;
            height: rectangle height ]! 
orderedChildren
        "Private - Answer an OrderedCollection which is the
        ordering of the children for tab and arrow keys."
    | orderedChildren |
    ( orderedChildren := self propertyAt: #orderedChildren ) isNil ifTrue: [
        orderedChildren := OrderedCollection new.
        children notNil ifTrue: [ self orderedChildren: orderedChildren ] ].
    ^orderedChildren!
defaultBackColor
        "Answer the default background color of the receiver."
    ^self class defaultBackColor!   
isHidden
       "Answer whether the receiver is hidden."
    ^( self frameWindow hasStyle: WsVisible ) not! 
helpContext
        "Private - Answer the receiver's help context"
    ^self propertyAt: #helpContext!  
button2Move: aPoint
        "Private - The user moved the mouse  to aPoint while
         holding down button 2."
    | sourceLocation |
    ( self isLocalDragSource and: [ self dragOnMove and: [ self isDragSourceInitiation: aPoint ] ] ) ifTrue: [
        sourceLocation := self dragSourceLocation.
        self dragOnMove: nil location: nil.
        self doDragDropAt: sourceLocation button: 2 ]!  
defaultForeColor
        "Answer the default foreground color of the receiver."
    ^self class defaultForeColor!   
getStyle
        "Answer the initial style of the receiver, composed of
       its basicStyle and its defaultStyle."
    ^self basicStyle | self defaultStyle! 
propertyAt: key ifAbsent: aBlock
        "Answer the value associated with key
        in the properties dictionary; if absent, 
        answer the result of evaluating aBlock."
    properties isNil ifTrue: [ ^aBlock value ].
    ^properties at: key ifAbsent: aBlock!  
boundingBox
        "Answer the bounding box of the receiver."
    ^self rectangle! 
fontAttribute: aFont
        "Set the font attribute to aFont."
	self propertyAt: #font put: aFont! 
zoomed
        "Private - Answer true if the receiver is zoomed."
     ^( self propertyAt: #zoomed ) == true!   
height
        "Answer the receiver's height."
    ^self rectangle height!  
handle: aWindowHandle
        "Private - Set the handle to aWindowHandle."
    handle := aWindowHandle! 
escapeKeyInput: aKeyboardInputEvent
        "Private - Respond to the esc keystroke; by default do nothing, may
        be reimplemented by subclasses."!   
restoringWindow
        "Private - Window being restored.  Do nothing."! 
noRedraw: aBoolean
        "Private - Stop the receiver from
         repainting itself."
    handle noRedraw: aBoolean!   
when: eventName send: selector
        "Form an action with the window's owner as the receiver and
        a <selector> as the message selector and append
        it to the actions list for the event named <eventName>."
    self owner isNil
        ifTrue: [self error: 'no owner'].
    self when: eventName send: selector to: self owner!  
sendDeferredEvent: selector with: arg
        "Private - Add a Message with arg to DeferredRequests."
    ( Message new
        receiver: self
        selector: selector
        arguments: ( Array with: arg ) ) performDeferred.
    OSEventSemaphore signal!
parent: aWindow
        "Private - Set the receiver's parent to aWindow."
    parent := aWindow!
allChildrenInBuildOrder
        "Private - Answer a collection containing the
         receiver's children, and any nested children
         (children of children, etc.), in the order they are built."
    | collection |
    collection := OrderedCollection new.
    children notNil ifTrue: [
        self childrenInBuildOrder do: [ :child |
            collection add: child.
            collection addAll: child allChildrenInBuildOrder ] ].
    ^collection!   
style
        "Private - Answer the window style."
    ^style!  
getMnemonicHandler: char
        "Answer an object to handle the mnemonic <char>.
        Default is to answer nil."
    ^nil! 
disableAll
        "Disable the receiver and all its children, forwarding the disable
        message to all children.  Sending #disableAll will result in all
        children updating their visual appearance to indicate that they are
        disabled, whereas #disable does not."
    self isHandleOk
        ifTrue: [
            self disable.
            self children size ~= 0
                ifTrue: [ self children do: [ :child | child disableAll ] ] ]
        ifFalse: [ self whenValid: #disableAll ]

!
initialize
        "Private - Initialize the receiver."
    self handle: WindowHandle nullValue!
display
        "Private - The receiver should display its contents.
         Implemented by subclasses.
         Default is do nothing."! 
hideWindow
        "Make the receiver invisible."
    self frameWindow removeStyle: WsVisible.
    self isHandleOk ifTrue: [ self frameWindow handle hideWindow ]! 
buttonFont: aFont
        "Set the font of all button children to aFont."
    children isNil ifFalse: [
        children do: [ :each | each buttonFont: aFont ] ]! 
itemSize
        "Answer the size of the menu item for which a #measureItem:
        event handler is being executed."
    ^self propertyAt: #itemSize!
basicKeyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process the F9 (cycle) key."
    | wasHandled superWindow |
    ( aKeyboardInputEvent virtualKey == F9Key
        and: [ aKeyboardInputEvent isShiftKeyDown not
        and: [ aKeyboardInputEvent isControlKeyDown not
        and: [ aKeyboardInputEvent isAltKeyDown not ] ] ] )
            ifTrue: [ Notifier cycle ].

    aKeyboardInputEvent virtualKey = EscapeKey
        ifTrue: [ self escapeKeyInput: aKeyboardInputEvent ].

    aKeyboardInputEvent altCharacter notNil ifTrue: [
        ( superWindow := self superWindow ) isWindow
            ifTrue: [
                wasHandled :=
                    superWindow
                        altKeyInput: aKeyboardInputEvent altCharacter
                        from: self.
                wasHandled ifTrue: [ ^self ] ].

            "Alt-UpKey enables notebook controls to set focus to notebook"
            ( aKeyboardInputEvent virtualKey == UpKey
                and: [ Notifier isAltKeyDown
                and: [ ( superWindow := self superWindow ) isNotebookPagePane ] ] )
                    ifTrue: [ superWindow containingNotebook arrowFromPagePane ] ]!  
tabScope
        "Private - Answer the parent window which determines
        the tabbing scope for this control."
    ^self parent isWindow
        ifTrue: [ parent tabScope ]
        ifFalse: [ nil ]!   
name
        "Answer the pane name.  Pane's name is given by
        sending the #setName: message to the pane.
        For backward compatibility with the old event system,
        if no pane name has been provided, it defaults to the
        selector for the #getContents event.  #name: should
        not be used, and it is provided for backward compatibility
        only."
    | answer oldHandlers |
    answer := self propertyAt: #myOwnName.
    answer notNil ifTrue: [^answer].
    ( oldHandlers := self handlersOrNil ) isNil ifTrue: [ ^nil ].
    answer := oldHandlers at: #getContents ifAbsent: [^nil].
    ^answer selector!
childrenSize
        "Answer the size of all descendents."
    | size |
    ( size := children size ) > 0 ifTrue: [
        children do: [ :each |
            size := size + each childrenSize ] ].
    ^size! 
zoomed: aBoolean
        "Private - Set the zoomed state of the receiver
        to aBoolean."
    self propertyAt: #zoomed put: aBoolean! 
hasFocus
        "Answer true if the receiver currently has the focus."
    ^WindowHandle queryFocus = handle!  
makeActive
        "Make the receiver the active window."
    self isHandleOk
        ifTrue: [ handle makeActive ]
        ifFalse: [ self whenValid: #makeActive ]! 
enableAll
        "Enable the receiver and all its children, forwarding the enable
        message to all children.  Sending #disableAll will result in all
        children updating their visual appearance to indicate that they are
        enabled, whereas #enable does not."
    self isHandleOk
        ifTrue: [
            self enable.
            self children size ~= 0
                ifTrue: [ self children do: [ :child | child enableAll ] ] ]
        ifFalse: [ self whenValid: #enableAll ]
!  
button1DoubleClick: aPoint
        "Private - The user double clicked button 1 at aPoint.
         Implemented by subclasses.
         Default is do nothing."!
button2DoubleClick: aPoint
        "Private - The user double clicked button 2 at aPoint.
         Implemented by subclasses.
         Default is do nothing."!
hasStyle: aStyle
        "Answer whether the receiver has the specified bits set in
        its style flag."
    | flags |
    flags := style isNil ifTrue: [ self getStyle ] ifFalse: [ style ].
    ^( flags bitAnd: aStyle ) = aStyle!
defaultDrawHighlight: aDrawStruct
        "Private - Highlight the item to be drawn."
    self ownerDrawPen
        reverse: aDrawStruct boundingBox!  
handle
        "Private - Answer receiver's handle."
    ^handle!   
cursorWindowPosition
        "Answer the current position of the cursor
         in window coordinates."
    ^Cursor sense mapScreenToClient: self!
pen: aGraphicsTool
        "Private - Set the graphics tool of the receiver to aGraphicsTool."
    self graphicsTool: aGraphicsTool!
allChildren
        "Private - Answer a collection containing the
         receiver's children, and any nested children
         (children of children, etc.)"
    | collection |
    collection := OrderedCollection new.
    children notNil ifTrue: [
        children do: [ :child |
            collection add: child.
            collection addAll: child allChildren ] ].
    ^collection!  
setStyle: newStyle
        "Set the receiver's host style to newStyle. "
    self style: newStyle.
    self isHandleOk ifTrue: [
        self canApplyStyle
            ifTrue: [ self applyStyle ]
            ifFalse: [ self recreateWindow ] ]! 
graphicsToolClass
        "Private - Answer the graphics tool class used by the receiver."
    ^Pen!
sendInputEvent: selector
        "Private - Add a Message to CurrentEvents."
    [   CurrentEvents add: ( Message new
            receiver: self
            selector: selector
            arguments: #( ) ) ] evaluateWithoutInterrupts.
    OSEventSemaphore signal! 
adjustFraming: rectangleInParent
        "Private - adjust the receiver's framing to its new size,
         rectangleInParent (parent-relative coordinates)."
    self framingBlock frameCanBeRescaled
        ifTrue: [ self framingBlock rescale: rectangleInParent for: self ]!
unorderedChildren
        "Private - Answer an OrderedCollection which contain
        the children missing in orderedChildren."
    | unorderedChildren orderedChildren |
    unorderedChildren := OrderedCollection new.
    orderedChildren := self orderedChildren.
    self children do: [ :child |
        ( orderedChildren includes: child )
            ifFalse: [ unorderedChildren add: child ] ].
    ^unorderedChildren!
searchForDefaultTextPane
        "Private - Answer the text pane that should be
         active when the window is opened.
         Subclasses can reimplement this."
    ^self propertyAt: #defaultTextPane
        ifAbsentPut: [ self allChildren detect: [ :pane | pane isTextPane ] ifNone: [ nil ] ]!  
addPane: aPane
        "Add aPane to the receiver as a child.  Added for
        VMAC compatibility."
    ^self addSubpane: aPane! 
nextTabStop: aSubPane
        "Private - Answer the first suppane following aSubPane
        which is a tab stop."
    | orderedChildren  index startIndex child|
    ( orderedChildren := self orderedChildren ) isEmpty
        ifTrue: [ ^self ].
    startIndex := orderedChildren indexOf: aSubPane.
    "Circulate through the orderedChildren
        and find the first tabstop."
    index := startIndex + 1.
    index > orderedChildren size
        ifTrue: [index := 1].
    ^(child := orderedChildren at: index) hasFocus
        ifTrue: [child]
        ifFalse: [child nextTabStop]!  
button2Down: aPoint
        "Private - right button was pressed; if the receiver
        is a drag source, start a drag drop transfer."
    ( self isLocalDragSource and: [ self isDragButton: 2 ] )
        ifTrue: [ self dragOnMove: true location: aPoint ]!  
isWindow
        "Answer true if receiver is a kind of Window."
    ^true!  
maximizingWindow
        "Private - Maximizing window.  Do nothing."!
minimizingWindow
        "Private - Window being minimized.  Do nothing."!   
showWindowAtTop
        "Private - Bring window to top without
         activating it."
    self frameWindow addStyle: WsVisible.
    self isHandleOk
        ifTrue: [ handle showWindowAtTop ]
        ifFalse: [ self whenValid: #showWindowAtTop ]! 
affectsFreeClientArea: aBoolean
    "Set whether the receiver reduces the amount of
    free client area in its parent for the receiver's siblings."

    ^self
        propertyAt: #affectsFreeClientArea
        put: ( aBoolean ifTrue: [ true ] ifFalse: [ nil ] )! 
insertSubpane: aPane
        "Add aPane to the receiver as a child window dynamically."
    self addSubpane: aPane.
    aPane recreateWindow!  
drawIndex
        "Answer the index of the item to be drawn."
    ^self ownerDrawStruct itemId + 1! 
remove: aPane interestIn: aFacet
        "Private - Do nothing as windows in general do not manage
        dependents."!
helpManager: aHelpManager
        "Private - Set the HelpManager for the receiver."
    ^self propertyAt: #helpManager put: aHelpManager!   
whenValid: selector
        "Add a message to the list of messages
         that must be sent to the receiver's host window
         after the handle is valid (the window has
         been created)."
    ^self whenValid: selector withArguments: Array new!  
isHandleOk
        "Answer whether the host window exists (has been
         created)."
    ^handle notNil and: [ handle ~= WindowHandle nullValue ]!  
parent
        "Answer the receiver's parent window."
    ^parent!  
button2Up: aPoint
        "Private - The user let up on button 2 at aPoint.
         Implemented by subclasses."
    self isLocalDragSource ifTrue: [ self dragOnMove: nil location: nil ]!
nextInGroup: aSubPane
        "Private - Answer the pane which follows aSubPane
        in the same group as aSubPane."
    | orderedChildren index |
    orderedChildren := self orderedChildren
        select: [ :pane | pane canArrowInto and: [ pane disabled not and: [ pane isHidden not ] ] ] .
    index := ( orderedChildren indexOf: aSubPane ) + 1.
    ( index > orderedChildren size or: [ ( orderedChildren at: index ) isAGroupLeader ] )
        ifFalse: [ ^orderedChildren at: index ].
    index := index - 1.
    [ index > 0 ] whileTrue:
        [ ( orderedChildren at: index ) isAGroupLeader
            ifTrue: [ ^orderedChildren at: index ].
        index := index - 1 ].
    ^orderedChildren first!
drawItem: aDrawStruct
        "Private - Draw the requested menu item.  Usually
        reimplemented by subclasses."
    self defaultDrawItem: aDrawStruct!   
isValid
        "Answer whether the host window exists (has been
         created)."
    ^handle notNil and: [ handle ~= WindowHandle nullValue ]! 
childAtId: anInteger
        "Answer the child with the id anInteger."
    children isNil ifTrue: [ ^nil ].
    ^children at: anInteger ifAbsent: [ nil ]! 
ownerDrawStruct: aDrawStruct
        "Private - set the drawing structure for
        the current drawItem request."
    self propertyAt: #ownerDrawStruct put: aDrawStruct!   
sendInputEvent: selector withArgs: argArray
        "Private - Add a Message with argArray arguments to CurrentEvents."
    [   CurrentEvents add: ( Message new
            receiver: self
            selector: selector
            arguments: argArray ) ] evaluateWithoutInterrupts.
    OSEventSemaphore signal!  
disable
        "Disable the receiver and all its children.
         A disabled window does not receive user input."
    | events |
    self isHandleOk
        ifTrue: [
            events := #( #button1Down: #button1Up: #button1DoubleClick: #button2Down: #button2Up: #button2DoubleClick: ).
            handle disable.
            Notifier remove: events for: self.
            children size > 0 ifTrue: [ children do: [ :each | Notifier remove: events for: each ] ] ]
        ifFalse: [ self whenValid: #disable ]
!  
activate
        "Send activate message to children."
    children notNil ifTrue: [
        children do: [ :i | i activate ] ]!
isBeingEdited
        "Answer whether the receiver is being edited."
	^self propertyAt: #isBeingEdited ifAbsent: [ false ]! 
owner: anObject
        "Set the owner of the receiver to anObject."
    owner := anObject.!
disableUpdate
        "Disable update of the receiver and all its children."
    self isHandleOk ifTrue: [ handle disableUpdate ]!  
rectangleAttribute
        "Private - answer the rectangle instance variable of
        the receiver."
    ^rectangle! 
startTimer: idInteger period: millisecondsInteger
        "Start a timer identified by anInteger. A #wmTimer:with:
        message will be sent to the receiver every millisecondsInteger."
    self isHandleOk
        ifTrue: [ Time startTimer: idInteger period: millisecondsInteger forWindow: self ]
        ifFalse: [
            self
                whenValid: #startTimer:period:
                withArguments: ( Array with: idInteger with: millisecondsInteger ) ]!   
stopReceivingMessages
        "Private - Stop the receiver from receiving host OS messages"
    Notifier remove: self!  
framingBlock
        "Private - Answer the framingBlock for the receiver; reimplemented
        in subclasses (TopPane, SubPane)."
    ^nil!   
properties
        "Private - Answer the properties Dictionary."
    ^properties!   
itemSize: aPoint
        "Set the size of the menu item for which a #measureItem:
        event handler is being executed."
    self propertyAt: #itemSize put: aPoint!
freeClientArea
    "Answer the remaining visible area after children
    affecting the available free client area have
    their rectangles removed from the receiver's
    rectangle."

    ^self entireClientArea!
orderedChildren: anOrderedCollection
        "Private - Set the OrderedCollection which is the
        ordering of the children for tab and arrow keys."
    self propertyAt: #orderedChildren put: anOrderedCollection asOrderedCollection!   
children
        "Answer the collection of the receiver's children."
    children isNil ifTrue: [ ^IdentityDictionary new ].
    ^children!
helpContext: anAssociation
        "Private - Set the receiver's help context"
    self propertyAt: #helpContext put: anAssociation!
entireClientArea
    "Answer the entire client area available for children
    relative to origin 0@0"

    ^0 @ 0 extent: self extent!   
childrenInBuildOrder
        "Private - answer the child panes in the order they should be built."
    ^self orderedChildren , self unorderedChildren!  
gettingFocus
        "Private - The receiver is getting the input focus.
         Implemented by subclasses.
         Default is do nothing."! 
subclassWndProc
        "Private - subclass this instance of the window
         to use the Smalltalk WndProc and the original
         WndProc is called for default cases."
    self isHandleOk 
		ifTrue: [ handle subclass ]
		ifFalse: [ self whenValid: #subclassWndProc ]!   
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process the F9 (cycle) key."
    self basicKeyboardInput: aKeyboardInputEvent!  
deactivate
        "Send deactivate message to children."
    children notNil ifTrue: [
        children do: [ :i | i deactivate ] ]!  
sendDeferredEvent: selector
        "Private - Add a Message to DeferredRequests."
    ( Message new
        receiver: self
        selector: selector
        arguments: Array new ) performDeferred.
    OSEventSemaphore signal! 
isVisible
        "Answer true if the window is visible"
    self isHandleOk ifFalse: [ ^false ].
    ^self visible!   
width
        "Answer the receiver's width."
    ^self rectangle width! 
foreColor
        "Answer the foreground color of the receiver."
    ^self propertyAt: #foreColor!  
children: anIdentityDictionary
        "Private - Set the dictionary of the receiver's children."
    children := anIdentityDictionary! 
graphicsTool: aGraphicsTool
        "Private - Set the graphics tool of the receiver to aGraphicsTool."
    graphicsTool := aGraphicsTool!  
add: aPane interestIn: aFacet
        "Private - Do nothing as windows in general do not manage
        dependents.  "! 
initColors
        "Private - Actualize the colors that the window was meant to have."
    | backColor foreColor |
    ( backColor := self backColor ) isNil
		ifTrue: [ backColor := self class defaultBackColor ].
	self backColor: backColor.
    ( foreColor := self foreColor ) isNil
		ifTrue: [ foreColor := self class defaultForeColor ].
	self foreColor: foreColor!
characterInput: aCharacter
        "Private - aCharacter was typed by the user.
         Implemented by subclasses.
         Default is do nothing."!  
addTabInfoFor: aPane
        "Private - Add tabbing information for aPane to
        the receiver."
    ( aPane canTab and: [ aPane affectsFreeClientArea not ])
        ifTrue: [ self orderedChildren add: aPane ]! 
style: aStyle
        "Private - Set the window style to aStyle."
    style := aStyle!  
enable
        "Enable the receiver and all its children."
    self isHandleOk
        ifTrue: [ handle enable ]
        ifFalse: [ self whenValid: #enable ]!
display: aRect
        "Private - The receiver should display its contents. aRect is
         the bounding rectangle of the update region."
    self display!  
propertyAt: key ifAbsentPut: aBlock
        "Answer the value associated with key
        in the properties dictionary; if absent, evaluate
		aBlock, put the evaluation result at key, and
        answer the result."
    properties isNil ifTrue: [ properties := IdentityDictionary new ].
    ^properties at: key ifAbsent: [ properties at: key put: aBlock value ]!  
groupLeaders
        "Private - Answer an OrderedCollection of children
        which start a group."
    ^self orderedChildren select:
         [ :child | child isAGroupLeader ]!   
whenValid: selector with: anArgument
        "Add a message to the list of messages
         that must be sent to the receiver's host window
         after the handle is valid (the window has
         been created)."
    ^self
        whenValid: selector
        withArguments: ( Array with: anArgument )!  
showWindow
        "Make the receiver visible."
    self frameWindow addStyle: WsVisible.
    self isHandleOk ifTrue: [ self frameWindow handle showWindow ]!  
drawBox
        "Answer the bounding box of the item to be drawn."
    ^self ownerDrawStruct boundingBox!   
altKeyInput: altCharacter from: aPane
        "An alt-character was typed in <aPane> of
        the receiver.  Search for a child mnemonic.
        Answer whether the mnemonic is handled."
    | superWindow mnemonicHandler |
    children notNil ifTrue: [
        children do: [ :child |
            ( mnemonicHandler := child getMnemonicHandler: altCharacter ) notNil ifTrue: [
                mnemonicHandler
                    sendInputEvent: #mnemonic:typedIn:
                    withArgs: (Array with: altCharacter with: aPane).
                ^true ] ] ].

    ^( superWindow := self superWindow ) isWindow
        ifTrue: [ superWindow altKeyInput: altCharacter from: aPane ]
        ifFalse: [ false ]!   
getGraphicsTool
        "Private - Initialize an empty graphics tool."
    ^self graphicsToolClass for: nil medium: self!   
unknownEvent: param1 with: param2
        "Private - An unknown event from the host was received."
    ^nil!
resizeChildren
        "Private - Resize all children."
    children size = 0 ifTrue: [ ^self ].
    children do: [ :subpane | subpane resize: rectangle ]!
ownerDrawPen
        "Private - answer the pen to be used for drawing
        owner drawn items."
    ^self graphicsTool!  
receiveMessages
        "Private - Enter receiver into Notifier so
         that messages can be sent to receiver."
    Notifier add: self!
properties: aDictionary
        "Private - Set the properties Dictionary."
    properties := aDictionary!   
propertyAt: key 
        "Answer the value associated with key
        in the properties dictionary."
    properties isNil ifTrue: [ ^nil ].
    ^properties at: key ifAbsent: [ nil ]!   
stopTimer: idInteger
        "Stop the timer identified by anInteger for aWindow."
    self isHandleOk
        ifTrue: [ Time stopTimer: idInteger forWindow: self ]
        ifFalse: [ self whenValid: #stopTimer: with: idInteger ]!
pen
        "Answer the GraphicsTool associated with the receiver."
    ^self graphicsTool! 
handlersOrNil
        "Private - answer the event handlers dictionary."
    ^self propertyAt: #oldHandlers! 
propertyAt: key put: aValue
        "Set the value associated with key
        in the properties dictionary."
    properties isNil ifTrue: [ properties := IdentityDictionary new ].
    aValue isNil ifTrue: [ ^properties removeKey: key ifAbsent: [ ] ].
    ^properties at: key put: aValue! 
graphicsTool
        "Private - Answer the receiver's graphics tool."
    graphicsTool isNil ifTrue: [ graphicsTool := self getGraphicsTool ].
    ^graphicsTool!  
setName: aString
        "Set the pane name to aString
         which can be a Symbol or a String."
    self propertyAt: #myOwnName put: aString!  
deleteAllMessage
        "Private - Answer the host message for deleting all entries."
    ^LbResetcontent! 
wmCtlcolorbtn: wparam with: lparam
        "Private - Process set control color message."
    | hbrush control ctl3d |
    ( ctl3d := self class ctl3dIfEnabled ) notNil ifTrue: [
        ( ( control := Notifier findWindow: lparam ) notNil and: [ control isPushButton ] ) ifTrue: [
            ( hbrush := ctl3d current
                ctlColorEx: WmCtlcolorbtn
                wparam: wparam
                lparam: lparam ) ~= 0 ifTrue: [ ^hbrush ] ] ].
    ^self controlColor: lparam hDC: wparam!   
wmCtlcolormsgbox: wparam with: lparam
        "Private - Process set message box color message."
    ^self messageBoxColor: wparam! 
vkKeyScan: nChar
    <api: VkKeyScanA ushort short>
     ^self invalidArgument! 
backColor
        "Answer the background color of the receiver."
    ^self propertyAt: #backColor!  
leftJustified
        "Set and answer the window style for left justified text."
    self
        removeStyle: SsLeft;
        removeStyle: SsCenter;
        removeStyle: SsRight;
        addStyle: SsLeftnowordwrap.
    self setStyle: self style! 
purgeComm: hCommDevice action: action
    <api: PurgeComm ulong ulong boolean>
    ^self invalidArgument!   
pen
        "Answer the GraphicsTool for the receiver."
    self select.
    ^graphicsTool!
dragTargetDrawSeparatorEmphasis: aPoint
		"Private - draw the target emphasis for the receiver
		given the cursor location aPoint (relative to the receiver).
		Emphasis is drawn indicating spaces between existing
		items as individual targets."
	| index lastIndex rect |
	index := ( self itemIndexFromPoint: aPoint ) min: list size + 1.
		"only update if changed"
	lastIndex := self dragTargetSelection.
	index = lastIndex ifTrue: [ ^nil ].  "don't draw emphasis if already drawn."
	lastIndex notNil ifTrue: [ self dragTargetEraseSeparatorEmphasis ].
	rect := self lineToRect: index.
	self dragTargetDrawEmphasisLineFrom: rect leftTop to: rect rightTop.
	self dragTargetSelection: index!  
stringWidth: aString withDC: hDC
        "Private - Answer the pixel width of aString using
         the receiver font and device context hDC."
    | str answer |
    str := aString asExternalString.
    answer := WinPoint new.
    ( GDILibrary
        getTextExtentPoint: hDC
        string: str
        count: str size
        size: answer asParameter )
            ifFalse: [ str size > 32768 ifFalse: [ ^self osError ] ].
    ^answer x - self overHang!  
face: aString
    size: fontSize
    fixedWidth: aBoolean
    attributes: anInteger
        "Answer a Font whose characteristics most
         closely match the arguments."
    ^self
        face: aString
        size: fontSize
        fixedWidth: aBoolean
        attributes: anInteger
        graphicsMedium: Display!
defaultStyle
        "Private - Answer the default style for static text controls."
    ^SsLeftnowordwrap!  
postQuitMessage: anInteger
    <api: PostQuitMessage long none>
    ^self invalidArgument!  
charSet
        "Answer the charSet of the font.
        charSet may be one of following:
        AnsiCharset, OemCharset or SymbolCharset."
    ^self physicalFont tmCharSet!
getSystemMenu: hWnd revert: anInteger
        "Private - Answer the handle to a copy of the system menu."
    <api: GetSystemMenu ulong ulong ulongReturn>
    ^self invalidArgument!  
printOn: aStream
        "Append a text representation of the receiver
         to aStream."
    aStream nextPutAll: self class name, '{',
        self faceName, ' ', self pointSize printString.
    self bold ifTrue: [ aStream nextPutAll: ' bold' ].
    self italic ifTrue: [ aStream nextPutAll: ' italic' ].
    aStream nextPutAll: '}'!  
defaultStyle
        "Private - Answer the default style for list box."
    ^LbsNotify |
        WsBorder |
        WsVscroll |
        LbsNointegralheight |
        LbsDisablenoscroll!   
sizeInBytes
    ^16! 
style: anInteger
        "Private - Set the style field."
    self uLongAtOffset: 0 put: anInteger! 
width
        "Private - Answer the width field."
        "Ignore the y of lopnWidth."
    ^self longAtOffset: 4!  
width: anInteger
        "Set - Answer the width field."
        "Ignore the y of lopnWidth."
    self longAtOffset: 4 put: anInteger! 
style
        "Private - Answer the style field."
    ^self uLongAtOffset: 0!   
color
        "Private - Answer the color field."
    ^self uLongAtOffset: 12!  
color: anInteger
        "Private - Set the color field."
    self uLongAtOffset: 12 put: anInteger!
defaultColorClass
        "Private - answer the class of Colors which are returned by default
        when a fixed color (such as blue) is requested."
    ^self!  
red: redComponent green: greenComponent blue: blueComponent
        "Answer an instance of the receiver whose components equal
        the given <redComponent>, <greenComponent> and
        <blueComponent>."
    | color maxValue |
    color := self new.
    maxValue := self maximumComponentValue.
    color red: ( ( redComponent max: 0 ) min: maxValue ) asInteger.
    color green: ( ( greenComponent max: 0 ) min: maxValue ) asInteger.
    color blue: ( ( blueComponent max: 0 ) min: maxValue ) asInteger.
    ^color! 
buttonShadow
        "Answer the button shadow color."
    ^self getSystemColor: SystemColorButtonShadow!   
inactiveTitleBar
        "Answer the inactive title bar color."
    ^self getSystemColor: SystemColorInactiveTitleBar!  
desktop
        "Answer the desktop background color."
    ^self getSystemColor: SystemColorDesktop!
black
        "Answer an instance of the receiver representing the color black."
    ^self defaultColorNamed: #black!   
yellow
        "Answer an instance of the receiver representing the color yellow."
    ^self defaultColorNamed: #yellow!
getSystemColor: aColorIndex
        "Answer an RGBColor for the given desktop element."
    | aColor anInteger |
    ^SystemColors
        at: aColorIndex
        ifAbsent: [
            anInteger := OperatingSystem getSystemColor: aColorIndex.
            aColor := RGBColor fromInteger: anInteger.
            SystemColors at: aColorIndex put: aColor ]
    
!   
buttonText
        "Answer the button text color."
    ^self getSystemColor: SystemColorButtonText! 
darkCyan
        "Answer an instance of the receiver representing the color dark cyan."
    ^self defaultColorNamed: #darkCyan! 
darkGray
        "Answer an instance of the receiver representing the color dark gray."
    ^self defaultColorNamed: #darkGray! 
windowBorder
        "Answer the window border color."
    ^self getSystemColor: SystemColorWindowBorder!   
red: redComponent green: greenComponent blue: blueComponent
        "Answer an instance of the receiver whose components equal
        the given <redComponent>, <greenComponent> and
        <blueComponent>."
    ^RGBColor red: redComponent green: greenComponent blue: blueComponent!
initialize
        "Private - initialize the class."
    SystemColors := Dictionary new!
highlightBackground
        "Answer the highlight background color."
    ^self getSystemColor: SystemColorHighlightBackground!  
windowText
        "Answer the window text color."
    ^self getSystemColor: SystemColorWindowText! 
gray
        "Answer an instance of the receiver representing the color dark gray."
    ^self defaultColorNamed: #gray! 
activeTitleBar
        "Answer the active title bar color."
    ^self getSystemColor: SystemColorActiveTitleBar!
invalidIntensity: intensity
        "Private - an attempt has been made to specify an instance of the receiver
        as a percentage of the maximum value for some or all of the components,
        but the percentage is not valid."
    self error: 'Invalid intensity'! 
menuText
        "Answer the menu text color."
    ^self getSystemColor: SystemColorMenuText!   
highlightText
        "Answer the highlight text color."
    ^self getSystemColor: SystemColorHighlightText!
scrollBar
        "Answer the scroll bar color."
    ^self getSystemColor: SystemColorScrollBar!
buttonHighlight
        "Answer the button highlight color."
    ^self getSystemColor: SystemColorButtonHighlight!  
red
        "Answer an instance of the receiver representing the color red."
    ^self defaultColorNamed: #red! 
buttonFace
        "Answer the button face color."
    ^self getSystemColor: SystemColorButtonFace! 
darkRed
        "Answer an instance of the receiver representing the color dark red."
    ^self defaultColorNamed: #darkRed!
defaultColorClass
        "Private - answer the class of Colors which are returned by default
        when a fixed color (such as blue) is requested."
    ^IndexedColor!  
cyan
        "Answer an instance of the receiver representing the color cyan."
    ^self defaultColorNamed: #cyan!  
menuBackground
        "Answer the menu background color."
    ^self getSystemColor: SystemColorMenuBackground! 
green
        "Answer an instance of the receiver representing the color green."
    ^self defaultColorNamed: #green!   
windowBackground
        "Answer the window background color."
    ^self getSystemColor: SystemColorWindowBackground!   
inactiveWindowBorder
        "Answer the inactive window border color."
    ^self getSystemColor: SystemColorInactiveWindowBorder!  
darkBlue
        "Answer an instance of the receiver representing the color dark blue."
    ^self defaultColorNamed: #darkBlue! 
darkGreen
        "Answer an instance of the receiver representing the color dark green."
    ^self defaultColorNamed: #darkGreen!  
blue
        "Answer an instance of the receiver representing the color blue."
    ^self defaultColorNamed: #blue!  
defaultColorNamed: aSymbol
        "Private - answer a Color whose name is aSymbol."
    ^self defaultColorClass defaultColors at: aSymbol! 
defaultColors
        "Private - answer an IdentityDictionary mapping between default
        colors names (Symbols) and their color values."
    ^defaultColors!  
pickAColor
        "Answer a color selected from the hosts color-picking dialog."
    ^self pickAColor: 'Pick a color' initialColor: self black!
activeWindowBorder
        "Answer the active window border color."
    ^self getSystemColor: SystemColorActiveWindowBorder!
white
        "Answer an instance of the receiver representing the color white."
    ^self defaultColorNamed: #white!   
darkPink
        "Answer an instance of the receiver representing the color dark pink."
    ^self defaultColorNamed: #darkPink! 
new
		"Answer a new instance of the receiver."
	^super new initialize!  
halfComponentValue
        "Answer half of the maximum value allowed for any component of
        instances of the receiver."
    ^16r80!  
pink
        "Answer an instance of the receiver representing the color pink."
    ^self defaultColorNamed: #pink!  
index: anInteger
        "Answer an IndexedColor with the given palette index."
    ^IndexedColor index: anInteger! 
titleBarText
        "Answer the title bar text color."
    ^self getSystemColor: SystemColorTitleBarText!  
maximumComponentValue
        "Answer the maximum value allowed for any component of
        instances of the receiver."
    ^16rFF!   
brown
        "Answer an instance of the receiver representing the color brown."
    ^self defaultColorNamed: #brown!   
boundingBox
        "Answer the bounding box of the receiver."
    ^0 @ 0 extent: self extent!  
setPosition
        "Private - Set the position of the host control."
    ( UserLibrary
        setScrollPos: handle
        bar: SbCtl
        position: value
        redraw: true ) = 0
            ifTrue: [ self osNotification ]!
cursorForOperation: operationName scroll: aBoolean
        "Private - answer a standard Cursor to use for the given operation and scroll."
    operationName = #move ifTrue: [
		^aBoolean ifTrue: [ CursorManager dragDropMoveScroll ] ifFalse: [ CursorManager dragDropMove ] ].
    operationName = #copy ifTrue: [
		^aBoolean ifTrue: [ CursorManager dragDropCopyScroll ] ifFalse: [ CursorManager dragDropCopy ] ].
    operationName = #link ifTrue: [
		^aBoolean ifTrue: [ CursorManager dragDropLinkScroll ] ifFalse: [ CursorManager dragDropLink ] ].
    ^CursorManager dragDropNone!   
changeSize: extent
		"Change the size of the receiver to extent."
	| clone |
	clone := self clone.
	self release.
	self width: extent x
		height: extent y
		planes: self planes
		bitCount: self bitCount.
	self pen
		copyBitmap: clone
		from: clone boundingBox
		to: self boundingBox.
	clone release!  
characterCoordinate: aPoint
        "Private - Convert the bit position aPoint within
         the pane to a character position in the receiver."
    | x y offsetY line |
    y := ( aPoint y // self font height ) + 1.
	offsetY := UserLibrary
		sendMessageInt: handle
		msg: EmGetfirstvisibleline
		wparam: 0
		lparam: 0.
	y := y + offsetY.
	line := self lineAt: y.
	x := 1.
	self doGraphics: [ x := self pen indexOf: line at: aPoint x ].
	^( x - 1 ) @ y
!
stockObjects
        "Private - Answer all the stock objects used."
    ^StockObjects!  
dragTargetEraseItemEmphasis
		"Private - erase the previously drawn item emphasis."
	| lastIndex rect |
	lastIndex := self dragTargetSelection.
	rect := self lineToRect: lastIndex.
	self dragTargetDrawEmphasisRectangle: rect!
wmPaint: wordInteger with: longInteger
        "Private - Process the paint message."
    | displayContext paintStructure oldDC result rect |
    self graphicsTool isGraphicsTool ifFalse: [ ^nil ].
        "must copy to nonST memory because BeginPaint generates WM_ERASEBKGRND"
    paintStructure := ExternalAddress allocateMemory: WinPaintStructure sizeInBytes.
    result := UserLibrary
        beginPaint: handle
        paintStructure: paintStructure asParameter.
    displayContext := DeviceContext fromInteger: result.
    oldDC := graphicsTool privateHandle.
    self graphicsTool setHandle: displayContext.
    rect := ( ( WinPaintStructure fromAddress: paintStructure ) rectangle ) asRectangle.
    self display: rect.
    self graphicsTool handle: oldDC.

    ( UserLibrary
        endPaint: handle
        paintStructure: paintStructure asParameter )
            ifFalse: [ ^self osError ].
    paintStructure free.
    ^1!   
destroy
        "Destroy the receiver window."
    ( UserLibrary destroyWindow: self )
        ifFalse: [ ^self osNotification ]
!
isToggleKey: virtualKey
        "Answer whether the specified virtualKey corresponds to a toggle key."
    ^virtualKey = ControlKey or: [ virtualKey = AltKey or: [ virtualKey = ShiftKey ] ]!  
fromStockFont: fontName
        "Private - Answer a new Font object which
         is the stock font object with fontName."
    | newFont aHandle |
    newFont := self new.
    newFont
        fontHandle: (GraphicsTool getStockObject: fontName);
        extractStockFontInfo.
    aHandle := FontHandleTable at: newFont logicalFont contents
        ifAbsent: [
            FontHandleTable at: newFont logicalFont contents
                put: newFont originalHandle.
            ^newFont].
    newFont fontHandle: aHandle.
    ^newFont! 
uncheckItem: item
        "Remove the check mark from an item.
         item can be the label or the selector."
    | mi |
    ( self isThere: item ) ifFalse: [ ^nil ].
    mi := self getMenuItem: item.
    mi attribute: ( mi attribute bitAnd: ( MfChecked bitXor: 16rFFFF ) ) | MfUnchecked.
    self updateItem: mi!
centered
        "Set and answer the window style for centered text."
    self
        removeStyle: SsLeft;
        removeStyle: SsLeftnowordwrap;
        removeStyle: SsRight;
        addStyle: SsCenter.
    self setStyle: self style!
open: toFindString replace: replaceString
        "Private - Open the Find/Replace dialog with toFindString
         and replaceString as the initial values.
         Answer an instance of FindReplaceDialog."
    ^(self new) open: toFindString replace: replaceString!   
charHeight
        "Answer the character height in dialog units."
    ^8!   
platformDefaultFont
        "Answer the font which is traditionally used for dialog
        windows on this host platform; this font is not automatically
        applied to dialogs unless a client sends 'self mainView font:
        self class platformDefaultFont' from within a WindowDialog."
    ^DialogTopPane platformDefaultFont! 
entryHeight
        "Answer the entry field height in dialog units"
    ^12!
inDialogUnits: aPoint
        "Convert the point (or rectangle) in pixel units into dialogUnits."
    | divisor |
    divisor := self dialogUnit / self unitMultiplier.
    ^aPoint isRectangle
        ifFalse: [ aPoint // divisor ]
        ifTrue: [
            aPoint
                leftTop: aPoint leftTop // divisor
                rightBottom: aPoint rightBottom // divisor ]! 
unitMultiplier
        "Answer the dialog base unit multiplier as a Point.
         To specify a dialog extent, use
            (columns @ rows) * WindowDialog unitMultiplier."
    ^self charWidth @ self charHeight!   
icon
        "Answer the icon for instances of the receiver."
    | icon |
    icon := Icon fromModule: self iconModule id: self iconId.
    icon isNil ifTrue: [ ^Icon fromModule: self resourceFileName id: 1 ].
    ^icon!
new
		"Answer a new instance of the receiver."
	^super new initialize!  
iconId
        "Answer the icon id for the receiver."
    ^1!   
resourceFileName
        "Private - answer the filename of the module (DLL or EXE) containing
        host resources for an object of this class.  Reimplemented by subclasses."
    ^VirtualMachineLibrary class fileName  "so default runtime icon used."!   
iconModule
        "Answer the module name for the icons."
    ^self resourceFileName!  
initWindowSize
        "Private - Answer the default window size."
    ^46 @ 14 * self class unitMultiplier!
forward
        "Private - Answer true if the user selected forward,
         false if backward."
    ^forward!
createView
        "Private - create the subpanes of the receiver"
    | multiplier topPane font pane |
    multiplier := self class unitMultiplier.
    font := self class platformDefaultFont.
    topPane := self mainView
        owner: self;
        font: font;
        yourself.
    self
        addView: topPane;
        labelWithoutPrefix: 'Find/Replace';
        addSubpane: ( StaticText new
            contents: 'Find:';
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 1@(1/2) * multiplier )
                    extentFromLeftTop: 10 @ 1 * multiplier ] );
        addSubpane: ( EntryField new
            setName: #findField;
            setTextLimit: 256;
            contents: toFind;
            selectFrom: 1 to: toFind asExternalString size;
            setFocus;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 1@2 * multiplier )
                    extentFromLeftTop: 44 @ (3/2) * multiplier ] );
        addSubpane: ( StaticText new
            contents: 'Replace With:';
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 1@4 * multiplier )
                    extentFromLeftTop: 15 @ 1 * multiplier ] );
        addSubpane: ( EntryField new
            setName: #replaceField;
            setTextLimit: 256;
            contents: replaceWith;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 1@(11/2) * multiplier )
                    extentFromLeftTop: 44 @ (3/2) * multiplier ] );

        addSubpane: ( CheckBox new
            setName: #caseSensitive;
            contents: 'Case sensitive';
            selection: caseSensitive;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 1@8 * multiplier )
                    extentFromLeftTop: 15 @ 1 * multiplier ] );
        addSubpane: ( CheckBox new
            setName: #confirm;
            contents: 'Confirm';
            selection: confirm;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 1@(19/2) * multiplier )
                    extentFromLeftTop: 15 @ 1 * multiplier ] );

        addSubpane: ( GroupBox new
            contents: 'Direction';
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 20@(15/2) * multiplier )
                    extentFromLeftTop: 25 @ 3 * multiplier ] );
        addSubpane: ( RadioButton new
            setName: #forward;
            contents: 'Fo\urward' replaceEscapeCharacters;
            selection: forward;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 21@9 * multiplier )
                    extentFromLeftTop: 11 @ 1 * multiplier ] );
        addSubpane: ( RadioButton new
            setName: #backward;
            contents: '\uBackward' replaceEscapeCharacters;
            selection: forward not;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 32@9 * multiplier )
                    extentFromLeftTop: 11 @ 1 * multiplier ] );

        addSubpane: ( ( pane := Button new )
            setName: #find;
            defaultPushButton;
            contents: '\uFind' replaceEscapeCharacters;
            when: #clicked send: #findButton: to: self with: pane;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 1@(23/2) * multiplier )
                    extentFromLeftTop: 10@2 * multiplier ] );
        addSubpane: ( ( pane := Button new )
            contents: 'Replace \uAll' replaceEscapeCharacters;
            when: #clicked send: #replaceAllButton: to: self with: pane;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 12@(23/2) * multiplier )
                    extentFromLeftTop: 12@2 * multiplier ] );
        addSubpane: ( ( pane := Button new )
            setName: #cancel;
            contents: '\uCancel' replaceEscapeCharacters;
            when: #clicked send: #cancel: to: self with: pane;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: 25@(23/2) * multiplier )
                    extentFromLeftTop: 10@2 * multiplier ] )!
open: toFindString replace: replaceString
        "Private - Open the Find/Replace dialog with toFindString
         and replaceString as the initial values."
    ^self
        open: toFindString
        replace: replaceString
        forward: true
        caseSensitive: true!  
replaceAllButton: aButton
        "Private - The user pressed the replace all button."
    confirm := ( self paneAt: #confirm ) selection.
    caseSensitive := ( self paneAt: #caseSensitive ) selection.
    forward := ( self paneAt: #forward ) selection.
    replaceWith := ( self paneAt: #replaceField ) contents.
    toFind :=  ( self paneAt: #findField ) contents.
    command := confirm
        ifTrue: [ #queryReplaceAtPattern ]
        ifFalse: [ #replaceAtPattern ].
    ^self close!  
caseSensitive
        "Private - Answer true if the user selected caseSensitive."
    ^caseSensitive!   
confirm
        "Private - Answer true if the user selected confirm."
    ^confirm! 
toFind
        "Private - Answer the string to find entered by
         the user."
    ^toFind!
cancel: aButton
        "Private - The user pressed the cancel button."
    confirm := nil.
    caseSensitive := nil.
    forward := nil.
    replaceWith := nil.
    toFind := nil.
    command := nil.
    ^self close! 
open: toFindString replace: replaceString
    forward: isForward caseSensitive: isSensitive
        "Private - Open the Find/Replace dialog with toFindString
         and replaceString as the initial values."
    toFind := toFindString.
    replaceWith := replaceString.
    caseSensitive := isSensitive.
    forward := isForward.
    confirm := false.
    self createView.
    self createHostFeatures.
    self openWindow!
command
        "Private - Answer the selector for the command
         the user chose."
    ^command! 
findButton: aButton
        "Private - The user selected the find button."
    confirm := nil.
    caseSensitive := ( self paneAt: #caseSensitive ) selection.
    forward := ( self paneAt: #forward ) selection.
    replaceWith := nil.
    toFind := ( self paneAt: #findField ) contents.
    command := forward
        ifTrue: [ #searchOld ]
        ifFalse: [ #searchBackOld ].
    ^self close!  
replaceWith
        "Private - Answer the replace string entered
         by the user."
    ^replaceWith!  
initWindowSize
        "Private - Answer the default window size."
    ^150 @ 100!  
openModal: ownerTopPane
        "Open the dialog box modal to ownerTopPane."
    self mainView openModal: ownerTopPane! 
processInput
        "Private - Make the receiver modal to its owner window.
         This method doesn't return until close has been
         sent to the receiver."
    Processor currentProcessIsRecursive ifFalse: [
        self mainView processInput].!   
close
        "Close all the views."
    self mainView close!   
query: aName
        "Answer the value of the control
         identified by aName."
    | aPane |
    ^(aPane := self paneAt: aName) notNil
        ifTrue: [aPane getValue]
        ifFalse: [nil]!   
query: aName with: aSelector
        "Answer the result of sending
         aSelector to the control
         identified by aName."
    | aPane |
    ^(aPane := self paneAt: aName) notNil
        ifTrue: [aPane perform: aSelector]
        ifFalse: [nil]! 
openModeless
        "Open the dialog box as a modeless window."
    self mainView openModeless!
openWindow
        "Open the dialog box modal to the
         current active window."
    self mainView open!  
topPaneClass
        "Private - Answer the default top pane class."
    ^DialogTopPane! 
textModified
        "Answer true if the first view was modified and
        the user does not want to save it or throw it away.
        Implemented for compatibility."
    ^self mainView textModified! 
noSmalltalkMenuBar
        "Does not create the default Smalltalk menu bar (File,
        Edit, Smalltalk menus).  By sending this message,
        the owner takes the responsibility for creating the
        menu bar upon reception of #menuBuilt event.
        Menu specific to SubPanes, (built with #getMenu event)
        will not be added to the MenuBar but will only be added
        to the popup menu."
    ^self mainView noSmalltalkMenuBar!
asParameter
        "Answer the receiver in a form suitable for
         passing as a parameter to a host API call."
    ^self mainView handle!
sendInputEvent: selector with: argument
        "Private - Add a Message with argument to CurrentEvents."
    [   CurrentEvents add: ( Message new
            receiver: self
            selector: selector
            arguments: ( Array with: argument ) ) ] evaluateWithoutInterrupts.
    OSEventSemaphore signal!
addSubpane: aPane
        "Add aPane to the first view as a subpane.  This
         method is implemented to maintain compatibility
         with the previous system."
    aPane owner isNil ifTrue: [
        aPane owner: self].
    ^self mainView addSubpane: aPane!   
backColor: aColor
        "Make aColor the background color of the first view.  This
         method is implemented to maintain compatibility
         with the previous system."
    ^self mainView backColor: aColor!   
printSetup
        "The user selected Print Setup... from the File menu."
    self mainView printSetup! 
foreColor: aColor
        "Make aColor the foreground color of the first view.  This
         method is implemented to maintain compatibility
         with the previous system."
    ^self mainView foreColor: aColor!   
changed: aFacet with: firstParameter
        "Something has changed related to the views
         of the receiver.  Resend the same message
         with firstParameter to all the views."
    views do: [:each |
        each changed: aFacet with: firstParameter]!   
editMenu
        "Answer the Edit menu."
    ^self mainView menuTitled: 'Edit'! 
initMenu
        "Private - Initialize the menu."
    ^nil! 
paneAt: paneSymbol
        "Answer the first pane with the name paneSymbol."
    | allPanes |
    allPanes := self panesAt: paneSymbol.
    allPanes size > 0
        ifTrue: [^allPanes at: 1]
        ifFalse: [^nil]!
parent: aWindow
        "Set the parent of the receiver to be aWindow.  This
         method is implemented to maintain compatibility
         with the previous system."
    ^self mainView parent: aWindow! 
zoom
        "The user selected Zoom from the Options menu."
    self mainView zoom!
style: aStyle
        "Make aStyle the style of the first view.  This
         method is implemented to maintain compatibility
         with the previous system."
    ^self mainView style: aStyle!  
addView: aView
        "Add aView to the view manager."
    views add: aView!   
setBackgroundColor
        "The user selected Color/Background... from the Options menu."
    self mainView setBackgroundColor! 
setForegroundColor
        "The user selected Color/Foreground... from the Options menu."
    self mainView setForegroundColor! 
initialize
        "Private - Initialize the receiver."
    views := OrderedCollection new: 1!  
menuTitled: aString
        "Answer the menu from the first view's menu bar
         whose title is aString.  Case is ignored
         and aString can include $& / $~ or not."
    ^self mainView menuWindow menuTitled: aString!
modifiedPanes: paneSymbol
        "Answer an Array of panes which have the name paneSymbol
         and their changes have not been saved."
    ^(self panesAt: paneSymbol)
        select: [:p | p modified]!
label: aString
        "Make aString the label of the first view.  This
         method is implemented to maintain compatibility
         with the previous system."
    ^self mainView label: aString!   
toggleWrap
        "Word wrap was selected from the Options menu; pass on the
        request to the active TextPane (TextPaneControl)."
    self mainView toggleWrap! 
textModifiedIn: paneSymbol
        "Answer true if any pane with the name paneSymbol was
         modified and the user does not want to save it or
         throw it away. Else answer false."
    | answer panes |
    panes := self modifiedPanes: paneSymbol.
    panes size < 1 ifTrue: [^false].
    answer := MessageBox new
        title: 'Unsaved Changes';
        message: 'Save them?';
        iconQuestion;
        yesNoCancel;
        defaultButton: 3;
        open.
    answer isNil ifTrue: [ ^true ].
    answer ifTrue: [
        panes do: [ :p | p accept ].
        ^( self modifiedPanes: paneSymbol ) > 0 ].
    ^false!
menuWindow
        "Private - Answer the menu bar of the first view,
         retained for compatibility."
    ^self mainView menuWindow!  
openWindow
        "Open all the views."
    views do: [:each |
        (each respondsTo: #openWindow)
            ifTrue: [each openWindow]]!
model: anObject
        "Make anObject the owner of the first view.  This
         method is implemented to maintain compatibility
         with the previous system."
    self owner: anObject!  
changed: aFacet with: firstParameter with: secondParameter
        "Something has changed related to the views
         of the receiver.  Resend the same message
         with firstParameter and secondParameter to all the views."
    views do: [:each |
        each changed: aFacet with: firstParameter with: secondParameter]!   
panesAt: paneSymbol
        "Answer a Collection of panes with the name paneSymbol."
    | panes allPanes |
    allPanes := OrderedCollection new.
    views do: [:v |
        panes := v dependents at: paneSymbol ifAbsent: [Array new].
        allPanes addAll: panes].
    ^allPanes! 
icon: anIcon
        "Set the icon for the main view to anIcon."
    ^self mainView icon: anIcon!   
openIn: aRectangle
        "Open the receiver's mainView (TopPane) in aRectangle."
    self mainView openIn: aRectangle!
labelWithoutPrefix: aString
        "Make aString the label with out the WindowLabelPrefix
         of the first view.  This method is implemented to maintain
        compatibility with the previous system."
    ^self mainView labelWithoutPrefix: aString!   
owner
        "Answer the owner of the receiver's view"
    views size < 1 ifTrue: [ ^nil ].
    ^( views at: 1 ) owner!   
owner: anObject
        "Make anObject the owner of the first view.  This
         method is implemented to maintain compatibility
         with the previous system."
    ^self mainView owner: anObject!
setFonts
        "The user selected Font... from the Options menu."
    self mainView setFonts! 
print
        "The user selected Print from the File menu."
    self mainView print!
windowPolicyClass
        "Answer the class which is used to define menu bar
         menus for this type of window."
    ^StandardWindowPolicy!   
fileMenu
        "Answer the File menu."
    ^self mainView menuTitled: 'File'! 
changed: aFacet
        "Something has changed related to the views
         of the receiver.  Resend the same message
         to all the views."
    views do: [:each |
        each changed: aFacet]! 
handle
        "Private - Answer the host system handle for
         the first view, retained for compatibility."
    ^self mainView handle!   
openFile
        "The user selected Open... from the File menu."
    self mainView openFile!
sendInputEvent: selector
        "Private - Add a Message to CurrentEvents."
    [   CurrentEvents add: ( Message new
            receiver: self
            selector: selector
            arguments: #( ) ) ] evaluateWithoutInterrupts.
    OSEventSemaphore signal! 
accept
        "Private - The user selected 'Save' menu item.
         Pass it on to the active TextPane."
    self mainView accept!   
close
        "Close all the views."
    views do: [:v | v close ]! 
addPane: aPane
        "Add aPane to the receiver as a child.  Added for
        VMAC compatibility."
    ^self addSubpane: aPane! 
menuTitled: aString inView: viewName
        "Answer the menu from the view viewName's menu bar
         whose title is aString.  Case is ignored
         and aString can include $& / $~ or not."
    | view |
    view := views detect: [ :v | v name = viewName ] ifNone: [ ^nil ].
    ^view menuWindow menuTitled: aString!   
clearTextModified
        "Clear text modified flag for all the views."
    views do: [:each |
        each clearTextModified]!
mainView
        "Answer the first view."
    views size < 1 ifTrue: [
        self addView: ( self topPaneClass new owner: self) ].
    ^views at: 1!
updateItem: aMenuItem attributes: attributesMask
        "Private - Send a message to aMenuItem to set its attributes."
    window isNil ifTrue: [^self].
    attributesMask = ( MfChecked | MfUnchecked )
        ifTrue: [
            ^UserLibrary
                checkMenuItem: window handle
                item: aMenuItem id
                flags: aMenuItem attribute | MfBycommand ].
    attributesMask = MfGrayed
        ifTrue: [
            ^UserLibrary
                enableMenuItem: window handle
                item: aMenuItem id
                flags: aMenuItem attribute | MfBycommand ]! 
postMessage: aWindowHandle
        msg: msgInteger
        wparam: wordInteger
        lparamStruct: struct
    <api: PostMessageA ulong ulong ulong struct boolean>
    ^self invalidArgument!  
buildControl: parentWindow
        "Private - Create the control for the receiver."
    self wrap ifTrue: [ self enableWordWrapFlags ].
    ( super buildControl: parentWindow ) isNil ifTrue:[ ^nil ].!   
captureMouseInput
        "Send all mouse input to the receiver until
         clearMouseCapture is executed."
    UserLibrary setCapture: self asParameter!   
windowClass
        "Private - Answer the window class for list box."
    ^'LISTBOX'!   
sizeInBytes
         "Private - Answer the default size in bytes."
   ^24!  
bitsPixel
        "Private - Answer bits per pixel."
    ^self uShortAtOffset: 18!  
bitsPixel: anInteger
        "Private - Set bits per pixel."
    self uShortAtOffset: 18 put: anInteger!
height: anInteger
        "Private - Set the number of raster lines."
    self longAtOffset: 8 put: anInteger!  
planes
        "Private - Answer the number of color planes."
    ^self uShortAtOffset: 16! 
bmType: anInteger
        "Private - Set bitmap type."
    self longAtOffset: 0 put: anInteger! 
width
        "Private - Answer the width in pixels."
    ^self longAtOffset: 4!
planes: anInteger
        "Private - Set the number of color planes."
    self uShortAtOffset: 16 put: anInteger!   
width: anInteger
        "Private - Set the width in pixels."
    self longAtOffset: 4 put: anInteger!  
height
        "Private - Answer the number of raster lines."
    ^self longAtOffset: 8!
bmType
    ^self longAtOffset: 0!
byteWidth: anInteger
        "Private - Set the bytes per raster line."
    self longAtOffset: 12 put: anInteger!   
byteWidth
        "Private - Answer bytes per raster line."
    ^self longAtOffset:12!  
boundingBox
        "Answer a rectangle which bounds the receiver."
    (graphicsMedium isWindow)
        ifTrue: [^graphicsMedium boundingBox]
        ifFalse: [^(0 @ 0 extent: self extent)]!  
wmCtlcoloredit: wparam with: lparam
        "Private - Process set control color message."
    | hbrush ctl3d |
    ( ctl3d := self class ctl3dIfEnabled ) notNil ifTrue: [
        ( hbrush := ctl3d current
            ctlColorEx: WmCtlcoloredit
            wparam: wparam
            lparam: lparam ) ~= 0 ifTrue: [ ^hbrush ] ].
    ^self controlColor: lparam hDC: wparam!  
getSubMenu: hWnd pos: anInteger
    <api: GetSubMenu ulong long ulongReturn>
    ^self invalidArgument! 
pointSize
        "Answer the point size of the Font.
         Font's point size indicates the height 
         of the characters in 1/72 inch."
    ^pointSize!  
abortProc: hDC error: errorCode
        "Private - handle requests from the Print Manager
         to cancel a spooling print job; answer true to
         continue printing, false to cancel the job"
    ^false!
invalidateRect: aWindowHandle rectangle: aWinRectangle erase: aBoolean
    <api: InvalidateRect ulong struct boolean boolean>
    ^self invalidArgument!
drawFocus: aDrawStruct
        "Private - Draw focus on the item."
    self triggerEvent: #drawFocus:
        withArguments: ( Array with: self drawIndex )
        ifNotHandled: [ super drawFocus: aDrawStruct ]!   
startUp
        "Private - Initialize dialog proc instance."
    DialogProcInstance := ExternalAddress usingBytes: OperatingSystem dialogProc!  
getGraphicsTool
        "Private - Initialize an empty graphics tool."
    ^self graphicsToolClass for: deviceContext medium: self! 
displayAt: aPoint with: aGraphicsTool
        "Display the receiver through aGraphicsTool."
    | origin extent oldMapMode oldWindowOrg oldViewportOrg oldViewportExt unitsPerInch medium |
    medium := aGraphicsTool graphicsMedium.
    medium isWindow ifTrue: [ medium := Display ].
    unitsPerInch := medium horizontalPixelsPerInch @ medium verticalPixelsPerInch.
    origin := apmHeader isNil
        ifTrue: [ 0@0 ]
        ifFalse: [ ( apmHeader bbox origin / apmHeader inch * unitsPerInch ) truncated ].
    extent := apmHeader isNil
        ifTrue: [ medium boundingBox extent ]
        ifFalse: [ ( apmHeader bbox extent / apmHeader inch * unitsPerInch ) truncated ].
    oldMapMode := aGraphicsTool getMapMode.
    oldWindowOrg := aGraphicsTool getWindowOrg.
    oldViewportOrg := aGraphicsTool getViewportOrg.
    oldViewportExt := aGraphicsTool getViewportExt.
    aGraphicsTool
        setMapMode: MmAnisotropic;
        setWindowOrg: 0@0;
        setViewportOrg: aPoint;
        setViewportExt: extent.
    self privateDisplayWith: aGraphicsTool.
    aGraphicsTool
        setMapMode: oldMapMode;
        setWindowOrg: oldWindowOrg;
        setViewportOrg: oldViewportOrg;
        setViewportExt: oldViewportExt!   
displayIn: aRectangle with: aGraphicsTool
        "Display the receiver using aGraphicsTool at the given
         location."
    | origin extent oldMapMode oldWindowOrg oldViewportOrg oldViewportExt medium unitsPerInch |
    medium := aGraphicsTool graphicsMedium.
    medium isWindow ifTrue: [ medium := Display ].
    unitsPerInch := medium horizontalPixelsPerInch @ medium verticalPixelsPerInch.
    origin := apmHeader isNil
        ifTrue: [ 0@0 ]
        ifFalse: [ ( apmHeader bbox origin / apmHeader inch * unitsPerInch ) truncated ].
    extent := apmHeader isNil
        ifTrue: [ medium boundingBox extent ]
        ifFalse: [ ( apmHeader bbox extent / apmHeader inch * unitsPerInch ) truncated ].

    oldMapMode := aGraphicsTool getMapMode.
    oldWindowOrg := aGraphicsTool getWindowOrg.
    oldViewportOrg := aGraphicsTool getViewportOrg.
    oldViewportExt := aGraphicsTool getViewportExt.
    aGraphicsTool
        setMapMode: MmAnisotropic;
        setWindowOrg: 0@0;
        setViewportOrg: aRectangle origin;
        setViewportExt: aRectangle extent.
    self privateDisplayWith: aGraphicsTool.
    aGraphicsTool
        setMapMode: oldMapMode;
        setWindowOrg: oldWindowOrg;
        setViewportOrg: oldViewportOrg;
        setViewportExt: oldViewportExt! 
startRecording
        "Create a device context and a graphicsTool for
        the receiver, and create the receiver in memory."
    ( deviceContext := GDILibrary createMetaFile: nil ) = 0
        ifTrue: [ ^self osError ].
    graphicsTool := self getGraphicsTool!
stopRecording
        "Close the receiver."
    ( hMetaFile := GDILibrary closeMetaFile: deviceContext ) = 0 ifTrue: [
        self osWorkaround.
        "too often, error results are returned from the OS which appear to be
        'false positives' - so pass them on, but as notifications only."
        self osNotification ]! 
release
        "Delete the receiver from the system thus freeing
         the system resources associated with the receiver."
    ( GDILibrary deleteMetaFile: self handle )
        ifFalse: [ self osWarning ].
    hMetaFile := nil! 
fromFile: aFileName
        "Load a metafile from aFileName."
    | file key bits metaHeader |
    file := ( File fromPath: aFileName ) binaryReadStream.
    key := file nextULong.
    file skip: -4.
    key = WinMetafileheader key
        ifTrue: [
            apmHeader := WinMetafileheader from: file.
            metaHeader := WinMetaheader from: file.
            file position: 22.
            bits := ByteArray new: metaHeader fileSize * 2.
            file getBytesFor: bits.
            file close.
            hMetaFile := GDILibrary setMetaFileBitsEx: bits size buffer: bits ]
        ifFalse: [          "standard metafile format"
            file close.
            hMetaFile := GDILibrary getMetaFile: aFileName asParameter].
    hMetaFile = 0 ifTrue: [ ^self osError ]!
outputToFile: aFileName
        "Save the receiver in aFileName."
    ( GDILibrary
        copyMetaFile: self handle
        fileName: aFileName asParameter ) = 0
            ifTrue: [ ^self osError ]!
pen
        "Answer the graphics tool associated with the receiver."
    ^self graphicsTool!
pen: aGraphicsTool
        "Set the graphicsTool for the receiver to aGraphicsTool."
    self graphicsTool: aGraphicsTool!  
boundingBox
        "Answer the bounding rectangle of the receiver."
    ^graphicsTool boundingBox! 
verticalPixelsPerMeter
        "Answer vertical pixels per inch
        on the screen."
    ^self verticalPixelsPerInch * 39.3700787!  
drawUsing: aRecordingPen
        "Use aRecordingPen to draw its contents
         on the receiver."
    | oldDC |
    oldDC := aRecordingPen handle.
    aRecordingPen handle: deviceContext.
    aRecordingPen drawChain.
    aRecordingPen handle: oldDC.!   
width
        "Answer the width of the receiver."
    ^graphicsTool width!  
height
        "Answer the height of the receiver."
    ^graphicsTool height!   
deviceContext
        "Private - Answer the device context of the receiver."
    ^deviceContext!
deviceContext: aDeviceContext
        "Private - Set the device context of the receiver to
         aDeviceContext."
    deviceContext := aDeviceContext!  
graphicsTool: aGraphicsTool
        "Private - Set the graphics tool of the receiver to aGraphicsTool."
    graphicsTool := aGraphicsTool!  
extent
         "Answer a Point which is the receiver's extent."
    ^self width @ self height! 
graphicsTool
        "Answer the graphics tool associated with
         the receiver."
    ^graphicsTool!  
horizontalPixelsPerMeter
        "Answer horizontal pixels per meter
        on the screen."
    ^self horizontalPixelsPerInch  * 39.3700787!  
statusPane
        "Answer the receiver's statusPane"
    parent isNil
        ifTrue: [ ^nil ].
    ^parent statusPane.! 
getClipboardData: aCfConstant
    <api: GetClipboardData ulong ulongReturn>
    ^self invalidArgument!  
getHelpWindowHandle: hwnd
        "Private - given the initial window hwnd, answer the
         window handle of the window that should receive
         the help message"
    | hwndTemp hwndParent done isChild style |
    hwndTemp := 0.
    hwndParent := hwnd.
    done := false.
    [ hwndParent ~= 0 and: [ done not ] ] whileTrue: [
        hwndTemp := hwndParent.
        style := UserLibrary getWindowLong: hwndTemp index: GwlStyle.
        ( isChild := style & WsChild = WsChild )
            ifTrue: [ hwndParent := UserLibrary getWindowLong: hwndParent index: GwlHwndparent ]
            ifFalse: [ done := true ]
        ].
    ^hwndTemp! 
clearSelection
        "Make no list items selected"
    value := nil.
    self isHandleOk ifFalse: [ ^self ].
    UserLibrary
        sendMessage: handle
        msg: self selectMessage
        wparam: self class listEnd
        lparam: 0!  
prestoChangoSelector: sourceSelector destinationSelector: destinationSelector
    <api: PrestoChangoSelector ushort ushort ushort>
    ^self invalidArgument!   
fromFile: fileName
		"Answer an instance of Bitmap copied from fileName.
		 fileName must have a '.ico' extension."
	| file icon |
    file := ( File fromPath: fileName ) binaryReadStream.
	icon := self fromFileStream: file.
	file close.
	^icon!  
deviceToLogical: aPen
        "Answer a new Point which is the receiver mapped from device
         to logical units."
    ^self dpToLp: aPen handle!  
hideSelection
        "Private - Hide the selection."
    selectFlag ifFalse: [^self].
    self isGap ifTrue: [^self].
    selectFlag := false.
    self showSelection: begin to: end with: #normal:!
contextForPopup:anInteger
        "Private- Answer aString for preview help.
        anInteger is a key in the dictionary provided by the menu's owner"
    | h m title |
    h := WindowHandle fromInteger: anInteger.
    m := self findWindow: h.
    m isNil ifTrue: [ ^nil ].
    title := m title reject: [ :c | c = $& | ( c = $~ ) ].
    ^Association key: title value: m owner! 
initGraphics
        "Private - Initialize the graphics tool for the receiver"
    self isHandleOk ifFalse: [ ^nil ].
    ( graphicsTool := self getGraphicsTool ) font: self font.
    self graphicsToolForeColor: self foreColor;
        graphicsToolBackColor: self backColor!   
getFocus
    <api: GetFocus ulongReturn>
    ^self invalidArgument! 
destroyMenu: aMenuHandle
    <api: DestroyMenu ulong boolean>
    ^self invalidArgument!
useTabStops
        "Add the use tab stops style."
    ^self addStyle: LbsUsetabstops!  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        remove: #menuBarBuilt ;
        remove: #validated ;
        yourself!
doDragDropAt: aPoint button: buttonIndex
        "Private - start a drag drop transfer with the receiver as the source."
    | sessionClass result |
    ( sessionClass := self dragSessionClass ) isNil
        ifTrue: [ sessionClass := DragDropSession defaultClass ].
    result := ( sessionClass source: self ) doDragDropAt: aPoint button: buttonIndex.
    self dragSourceSelection: nil.
    ^result!   
for: aWindow title: aString file: aFileName
        "Answer an instance of the receiver initialized
         for aWindow with aString as its title and whose
         help file is in aFileName (a .HLP file)."
    ^self 
        for: aWindow
        title: aString
        file: aFileName
        dialogs: nil 
        aboutDlgClass: nil! 
scrollVerticalCharacters: anInteger
        "Private - Scroll the pane up by anInteger
         number of characters (if positive) or down by
         the absolute value of anInteger (if negative)."
    UserLibrary
        sendMessageInt: handle
        msg: EmLinescroll
        wparam: 0
        lparam: anInteger negated!  
stretchBlt: destDC
    x: x1
    y: y1
    dWidth: dWidth
    dHeight: dHeight
    srcDC: srcDC
    xSrc: x2
    ySrc: y2
    sWidth: sWidth
    sHeight: sHeight
    rop: aRopConstant
        "Private - Call GDI StretchBlt function."
    ( segmentIsOpen not or: [ drawingMode = DrawingModeDraw ] )
        ifTrue: [
            ( GDILibrary
                stretchBlt: destDC
                x: x1
                y: y1
                dWidth: dWidth
                dHeight: dHeight
                srcDC: srcDC
                xSrc: x2
                ySrc: y2
                sWidth: sWidth
                sHeight: sHeight
                rop: aRopConstant )
                    ifFalse: [ ^self osError ].
            ^self ].
    drawingMode = DrawingModeDrawAndRetain
        ifTrue: [
            ( GDILibrary
                stretchBlt: destDC
                x: x1
                y: y1
                 dWidth: dWidth
                dHeight: dHeight
                srcDC: srcDC
                xSrc: x2
                ySrc: y2
                sWidth: sWidth
                sHeight: sHeight
                rop: aRopConstant )
                    ifFalse: [ ^self osError ] ].
    ( GDILibrary
         stretchBlt: self currentSegment deviceContext
         x: x1
         y: y1
         dWidth: dWidth
         dHeight: dHeight
         srcDC: srcDC
         xSrc: x2
         ySrc: y2
         sWidth: sWidth
         sHeight: sHeight
         rop: aRopConstant )
            ifFalse: [ ^self osError ]!
bindProgressDialog
    "Private - Answer the binding progress dialog."

    | dialog |
    ( dialog := self bindProgress ) isNil ifTrue: [ ^nil ].
    dialog == true ifTrue: [    "==true because it may not be a Boolean"
        dialog := ProgressIndicatorDialog new
            hidePercent ;
            noCancel ;
            open: 'Binding Libraries...' message: ''.
        self bindProgress: dialog.
        self when: #libraryBound: send: #bindLibsProgress: to: self ].
    ^dialog!   
dragTargetDrawItemEmphasis: aPoint
		"Private - draw the target emphasis for the receiver
		given the cursor location aPoint (relative to the receiver).
		Emphasis is drawn indicating individual list items as
		individual targets."
	| index lastIndex rect |
	index := ( self itemIndexFromPoint: aPoint ) min: list size.
		"only update if changed"
	lastIndex := self dragTargetSelection.
	index = lastIndex ifTrue: [ ^nil ].  "don't draw emphasis if already drawn."
	lastIndex notNil ifTrue: [ self dragTargetEraseItemEmphasis ].
	rect := self lineToRect: index.
	self dragTargetDrawEmphasisRectangle: rect.
	self dragTargetSelection: index! 
nonAuto
        "Create an instance of a non-auto radio button."
    ^self new radioButton; yourself!   
auto
        "Create an instance of an auto radio button."
    ^self new autoRadioButton; yourself! 
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #turnedOn ;
        add: #turnedOff ;
        yourself!  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        remove: #clicked ;
        add: #clicked: ;
        yourself! 
defaultFont
        "Private - Answer the default font for the pane."
    ^ButtonFont!  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #clicked ;
        yourself!  
notifications
        "Private - answer a Dictionary mapping between host control
        notification codes and corresponding Smalltalk event notifications."
    notifications isNil ifTrue: [ self initializeNotifications ].
    ^notifications!  
notifications: aDictionary
        "Private - set the Dictionary mapping between host control
        notification codes and corresponding Smalltalk event notifications
        to aDictionary."
    notifications := aDictionary!   
initializeNotifications
        "Private - initialize the mapping between host control
        notification codes and corresponding Smalltalk event
        notifications."
    self notifications: self constructNotifications!  
constructNotifications
        "Private - answer the mapping between host control
        notification codes and corresponding Smalltalk event
        notifications."
    ^Dictionary new!   
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #display ;
        add: #gettingFocus ;
        add: #help ;
        add: #losingFocus ;
        add: #mouseMoved: ;
        add: #needsContents ;
        add: #needsMenu ;
        add: #needsPopupMenu ;
        add: #needsSelection ;
        add: #rightClicked ;
        add: #tabbed ;
        add: #backTabbed ;
        add: #resized ;
        yourself!   
rightButtonScrollTimerId
        "Private - answer the ID of the timer to use to process right button scrolling."
    ^2!   
rightButtonScrollInterval
        "Private - answer the interval (in milliseconds) for the timer used
		to process right button scrolling."
    ^30!   
tabGroupMembers
        "Answer the members of the tab group
        that the receiver belongs to."
    | orderedChildren radioGroupLeader index groupLeader group size |
    self tabScope isNil   "New window initializing controls (no parent yet)."
        ifTrue: [ ^OrderedCollection new.].
    orderedChildren := self tabScope orderedChildren.
    orderedChildren size = 0
        ifTrue: [ ^orderedChildren ].  " shouldn't happen... "
    radioGroupLeader := 1.
    groupLeader := 1.
    index := 0.
    orderedChildren do: [ :child |
        index := index + 1.
        child isAGroupLeader
            ifTrue: [ groupLeader := index ].
        child == self
            ifTrue: [ radioGroupLeader := groupLeader ] ].

    group := OrderedCollection new.
    group add: ( orderedChildren at: radioGroupLeader ).
    index := radioGroupLeader + 1.
    size := orderedChildren size.
    [  index <= size and:
        [ ( orderedChildren at: index ) isAGroupLeader not ] ]
    whileTrue: [
        group add: ( orderedChildren at: index ).
        index := index + 1 ].

    ^group!  
isRadioButton
        "Answer whether the receiver is a radio button. "
    ^true!  
autoRadioButton
        "Set and answer the automatic radio button window style."
	self removeStyle: BsRadiobutton.
    ^self addStyle: BsAutoradiobutton! 
turnOff
        "Set the receiver's state to off (false).
        Trigger changed event. "
    self setValue: false!   
turnOn
        "Set the receiver's state to on (true).
        Trigger changed event. "
    self setValue: true!   
click
        "Programatically click the button.
        Note: RadioButton>>setFocus already does a click,
        as well as setting the focus."
    self setFocus!  
changedEventFor: aBoolean
        "Private - answer the event to trigger for state aBoolean."
    ^aBoolean ifTrue: [ #turnedOn ] ifFalse: [ #turnedOff ]!  
triggerClickedEvent
        "Private - trigger clicked event."
    self event: #clicked.
    self
        triggerEvent: #clicked: with: label;
        triggerEvent: #turnedOn!  
radioButton
        "Set and answer the radio button window style."
    self removeStyle: BsAutoradiobutton.
    ^self addStyle: BsRadiobutton!
isATabStop
        "Private - Answer true if the receiver is a tabstop"
    ^self selection!
selection: aBoolean
        "If this button is turned on, turn off the other radio buttons in the group."
    aBoolean
        ifTrue: [
            self tabGroupMembers do: [ :aPane |
                ( aPane ~= self and: [ aPane isRadioButton ] )
                    ifTrue: [ aPane turnOff ] ] ].
    ^super selection: aBoolean! 
selection: aBoolean
        "Set the check state of the receiver to aBoolean."
    value := aBoolean.
    self isHandleOk
        ifTrue: [ self setValue ]!  
update
        "Private - The window is created or changed."
    self selection: value.
    ^super update! 
isDefaultPushButton
        "Private - Can never be a push button."
    ^false! 
initialize
        "Private - Initialize the receiver."
    value := false.
    super initialize!  
gettingFocus
        "Private - The receiver is getting the input focus."
    self subPaneWithFocus: self.
    self triggerGettingFocus!   
defaultStyle
        "Private - Answer the default window style for the receiver."
    self implementedBySubclass!  
isTransparent
		"Private - answer whether the receiver's background
		should be painted with the same background color
		as its parent pane."
    ^true!  
value
        "Answer the value of the receiver as a boolean."
    ^self getValue!  
changedEventFor: aBoolean
        "Private - answer the event to trigger for state aBoolean."
    self implementedBySubclass!   
losingFocus
        "Private - The receiver is losing focus."
    self triggerLosingFocus!  
isPushButton
        "Answer whether the receiver is an instance of a push button"
	^false! 
setValue: aBoolean
        "Set the state of the receiver to aBoolean.  Trigger
        changed event if the value has changed. Answer aBoolean."
    aBoolean ~= self getValue ifTrue: [  "use getValue instead of value here, because of Parts subclass"
        self selection: aBoolean.
        self triggerEvent: ( self changedEventFor: aBoolean ) ].
    ^aBoolean!
triggerClickedEvent
        "Private - trigger clicked event."
    self getValue.
    self event: #clicked.
    self triggerEvent: #clicked: with: value.
    self triggerEvent: ( self changedEventFor: value )!
update: aBoolean
        "Private - Change the receiver's value to aBoolean."
    aBoolean isBoolean
        ifTrue: [ self selection: aBoolean ]
        ifFalse: [ super update: aBoolean ]!
value: aBoolean
        "Set the state of the receiver to aBoolean. "
    self selection: aBoolean! 
selection
        "Answer the receiver's current selection.
        For buttons, the selection is its value -
        true if the button is on, false if off.
        ThreeStateButtons return nil if indeterminate."
     ^self getValue!   
setLabel: aString
        "Set the label of the receiver to aString.  Answer aString."
    | newLabel |
    newLabel := ( aString isString
        ifTrue: [ aString ]
        ifFalse: [ aString isNil ifTrue: [ '' ] ifFalse: [ aString asString ] ] ).
    self label: newLabel.
    ^aString!  
characterInput: aCharacter
        "This control does not capture keyboard input, so it
        can translate to a mnemonic without the alt key down.
        Try to match with a mnemonic character in a sibling."
    ( self superWindow altKeyInput: aCharacter from: self )
        ifTrue: [ ^self ].  "character handled"
    ^super characterInput: aCharacter!  
enable
        "Enable the receiver and all its children."
    super enable.
    self removeStyle: WsDisabled! 
getMnemonicHandler: char
        "Private - Check if this control handles this mnemonic.
        Answer the receiver if it does, else nil."
    | index |
    ( label isNil or: [ self disabled or: [ self isHidden ] ] ) ifTrue: [ ^nil ].
    ^( ( index := ( label indexOf: '\u' replaceEscapeCharacters first ) ) ~= 0
        and: [ ( label at: index + 1 ) asLowerCase == char asLowerCase ] )
		ifTrue: [ self ]
		ifFalse: [ nil ]!  
isButton
        " Answer whether the receiver is a button. "
    ^true!
label
        "Answer the text label of the receiver."
    ^self contents!  
label: aString
        "Set the label of the receiver to aString."
    self contents: aString!  
notifyDoubleClicked: aParameter
        "Private - the host signaled a double-clicked event."
    self triggerClickedEvent! 
click
        "Programatically click the button."
    self isHandleOk ifTrue: [ self setFocus ].
    self hasFocus  "May have cancelled focus change"
        ifFalse: [ ^nil ].
    "Send asynchronously to be queued after losing focus
    behavior from above setFocus, in order to mimic
    a mouse click on the receiver"
    self sendInputEvent: #notifyClicked: with: nil!  
disable
        "Disable the receiver and all its children.
         A disabled window does not receive user input."
    super disable.
    self addStyle: WsDisabled!
losingFocus
        "Private - If the button was not a defaultPushButton before
        getting the focus, then it stops being a defaultPushButton
        after losing the focus."
    self restoreDefaultPushButton.
    super losingFocus!
buttonFont: aFont
        "Private - Set receiver's font to aFont."
    self font: aFont!   
notifyClicked: aParameter
        "Private - the host signaled a clicked event."
    self triggerClickedEvent!  
restoreDefaultPushButton
        "Private - If the button was not the original default
        push button, then restore the default push button style
        to the original."
    | originalDefaultButton |
    originalDefaultButton := self mainWindow defaultPushButton.
    originalDefaultButton ~~ self
        ifTrue: [ self pushButton; setDefault: false ].
    originalDefaultButton notNil
        ifTrue: [ originalDefaultButton defaultPushButton; setDefault: true ]! 
name
        "Answer the pane name."
    | n |
    ^( n := super name ) isNil
        ifTrue: [ label ]
        ifFalse: [ n ]!  
triggerClickedEvent
        "Private - trigger clicked event."
    self event: #clicked.
    self triggerEvent: #clicked!  
validate
        "Private - The host window for the receiver was
         just created or recreated."
    | mainWindow |
    ( self isDefaultPushButton and: [ ( mainWindow := self mainWindow ) ~~ self ] )
        ifTrue: [ mainWindow defaultPushButton: self ].
    super validate!
close
        "Private - Close the receiver.  Restore
        the default push button style in case the
        receiver's window is opened again."
    self isDefaultPushButton
        ifTrue: [ self restoreDefaultPushButton ].
    super close!
gettingFocus
        "Private - If the receiver is not originally a default push button,
        turn it to THE default push button while it has the focus."
    | originalDefaultButton |
    originalDefaultButton := self mainWindow defaultPushButton.
    ( originalDefaultButton notNil and: [ originalDefaultButton ~= self ] ) ifTrue: [
        originalDefaultButton isDefaultPushButton
			ifTrue: [ originalDefaultButton pushButton; setDefault: false ] ].
    self defaultPushButton; setDefault: true.
    super gettingFocus!   
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process cursor keys."
    | virtualKey |
    ( virtualKey := aKeyboardInputEvent virtualKey ) notNil ifTrue: [
        ( virtualKey == UpKey or: [ virtualKey == LeftKey ] )
            ifTrue: [ ( self tabScope previousInGroup: self ) setFocus ].
        ( virtualKey == DownKey  or: [ virtualKey == RightKey ] )
            ifTrue: [ ( self tabScope nextInGroup: self ) setFocus ].
        ( virtualKey == TabKey or: [ virtualKey == BacktabKey ] )
            ifTrue: [ self tabKeyInput: aKeyboardInputEvent ] ].

    ( aKeyboardInputEvent character == Cr
		and: [ self isPushButton
		and: [ self mainWindow isDialogTopPane not ]] )
        ifTrue: [ ^self click ].

    super keyboardInput: aKeyboardInputEvent! 
mnemonic: char typedIn: aPane
        "The receiver's mnemonic was typed in the
        sibling <aPane>.  Perform a programmatic button click."
    self click.
    super mnemonic: char typedIn: aPane!  
isPushButton
        "Answer whether the receiver is an instance of a push button"
	^true!  
isControlPane
        "Answer whether the receiver is a kind of ControlPane."
    ^true!
valueAttribute
        "Private - answer the receiver's value attribute"
    ^value!
initialTopCorner
        "Private - answer the initial value of topCorner."
    ^nil!   
getValue
        "Answer the value of the receiver.
         This should be reimplemented by
         the subclasses in order to get the
         up to date value."
    ^value! 
initColors
        "Private - Actualize the colors that the window was meant to have.
        ControlPanes assume that the default color specified by
        defaultBackColor need not be applied (as it is the system default)."
    | backColor foreColor |
    ( backColor := self backColor ) notNil
		ifTrue: [ self backColor: backColor ].
    ( foreColor := self foreColor ) notNil
		ifTrue: [ self foreColor: foreColor ]!
updateVerticalSlider
        "Private - don't need to update scrollbars, since host controls
        do it themselves."!
contents: aString
        "Set the String associated with this control."
    label := aString.
    ( self isHandleOk and: [ self windowText ~= aString ] )
        ifTrue: [ self setWindowText: aString ]!   
subclassRecursively
        "Private - subclass the receiver and its children."
	self subclassWndProc.
    super subclassRecursively!  
button2Up: aPoint
        "Private - do popup menu."
    self isLocalDragSource ifTrue: [ self dragOnMove: nil location: nil ].
    self triggerEvent: #rightClicked
        ifNotHandled: [ self doPopupMenuAt: aPoint ]!
syncControlEvent: anEvent with: aParameter
        "Private - Process anEvent produced
         by the host system. The default is to
         requeue the operation for deferred handling."
    self sendInputEvent: #asyncControlEvent:with:
		withArgs: ( Array with: anEvent with: aParameter )! 
scrollVertical: anInteger
        "Private - Do nothing for control panes."! 
initialText
        "Private - Answer the receiver's initial text string"
    ^label!   
updateHorizontalSlider
        "Private - don't need to update scrollbars, since host controls
        do it themselves."!  
asyncControlEvent: msg with: aParameter
        "Private - Process a host control notification as an event."
    | selector |
    selector := self class notifications at: msg ifAbsent: [ ^nil ].
    self perform: selector with: aParameter!   
label
        "Answer the receiver's label"
    ^label! 
scrollHorizontal: anInteger
        "Private - Do nothing for control panes."!   
labelAttribute: aString
        "Private - set the receiver's label attribute"
    label := aString!
receiveAllWindowMessages
        "Subclass the host control for the receiver so
         that all host messages will be received."
    self propertyAt: #subclass put: true.
    self subclassWndProc!
valueAttribute: aString
        "Private - set the receiver's value attribute"
    value := aString!
wmPaint: param1 with: param2
        "Private - Process the paint message."
    ^nil!   
button2Move: aPoint
        "Private - if the receiver is a local drag source, check to see
        if movement indicates drag onset."
    | sourceLocation |
    ( self isLocalDragSource and: [ self dragOnMove and: [ self isDragSourceInitiation: aPoint ] ] ) ifTrue: [
        sourceLocation := self dragSourceLocation.
        self dragOnMove: nil location: nil.
        self doDragDropAt: sourceLocation button: 2 ]! 
updateSliders
        "Private - don't need to update scrollbars, since host controls
        do it themselves."!   
contents
        "Answer the label of the receiver."
    ^label!
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process the F9 (cycle) key."
        "Process alt char for mnemonics"
    | defaultPushButton |
    ( aKeyboardInputEvent character == Cr
    and: [ ( defaultPushButton := self mainWindow defaultPushButton ) notNil
    and: [ self mainWindow isDialogTopPane not ] ] )
        ifTrue: [ defaultPushButton click ].

    self basicKeyboardInput: aKeyboardInputEvent!  
mnemonic: char typedIn: aPane
        "The receiver's mnemonic was typed in the
        sibling <aPane>.  Perform appropriate behavior.
        Default is to do nothing."!
button2Down: aPoint
        "Private - right button was pressed; if the receiver
        is a drag source, start a drag drop transfer."
    ( self isLocalDragSource and: [ self isDragButton: 2 ] )
        ifTrue: [ self dragOnMove: true location: aPoint ]!  
labelAttribute
        "Private - answer the receiver's label attribute.  In contrast to #label,
        this always answers the label inst var, whereas subclasses may override
        the meaning of #label."
    ^label!  
amountToScrollLeft
        "Private - Answer the number of pixels
        for horizontal line scrolling."
    ^8 min: self font width! 
topCornerAttribute: aPoint
        "Private - set the topCorner attribute of the receiver to aPoint."
    topCorner := aPoint!  
resizeSiblings
    "Private - Resize the receiver's siblings."

    self superWindow resizeChildren!   
popup
        "Answer the popup instance variable."
    ^popup! 
losingFocus
        "Private - the receiver is losing the input focus."
    super losingFocus.
    self triggerLosingFocus!
update
        "Private - Refresh the contents from the
         owner and display it."
    self event: #getContents.
    self triggerEvent: #needsContents!  
noGroupLeader
        "Make the receiver not be a group leader.  By default
        every subpane is not a group leader."
    self removeStyle: WsGroup!   
topCorner
        "Private - Answer the receiver's topCorner."
    ^topCorner!  
mouseMove: aPoint
        "Private - Mouse has moved to aPoint.
         Let the owner process the event."
    self
        event: #mouseMove;
        triggerEvent: #mouseMoved: with: aPoint.! 
invalidate
        "Repaint the receiver"
    self isHandleOk ifTrue: [ self invalidateRect: rectangle ]!   
validateGroupLeader
        "Private - Set the receiver to be a tab stop or a
        group leader based on its attributes."
    self tabScope groupLeaders add: self.!
modified
        "Answer true if the receiver has been modified.
         Implemented by subclasses."
    children size = 0
        ifTrue: [ ^false ]
        ifFalse: [ children detect: [ :c | c modified ] ifNone: [ ^false ] ].
    ^true! 
performMenuItem: anInteger
        "Private - Perform the menu item whose id is anInteger."
    self popup notNil ifTrue: [ self popup performMenuItem: anInteger ]!
isTransparent
		"Private - answer whether the receiver's background
		should be painted with the same background color
		as its parent pane."
    ^false! 
amountToPageLeft
        "Private - Answer the number of pixels for
        horizontal page scrolling."
    ^rectangle width // 2! 
popupMenu
        "Private - Answer the popup Menu for the pane."
    self popup notNil ifTrue: [ ^self popup ].
    self event: #getPopupMenu.
    self triggerEvent: #needsPopupMenu.
    ^self popup isNil
        ifTrue: [ menu isNil ifTrue: [ nil ] ifFalse: [ menu asPopupMenu ] ]
        ifFalse: [ self popup ]!
triggerLosingFocus
        "Private -  Trigger the losingFocus events. "
    self event: #losingFocus.
    self triggerEvent: #losingFocus!
fontAttribute: aFont
        "Set the font attribute to aFont."
    curFont := aFont!   
layoutFrame: aLayoutFrame
    "Set the receiver's layout frame to <aLayoutFrame>."

    self framingBlock: aLayoutFrame asLayout!  
isAGroupLeader
        "Private - Answer true if the receiver is a tabstop."
    ^self hasStyle: WsGroup!   
startGroup
        "Make the control pane be the start of a group of
        dialog items.  Arrow keys will cycle within a group of
        dialog items which starts from this pane up to (but not
        including) the next pane which this message has been
        sent to.  This message has an effect only if the control
        pane is a part of a dialog window."
    self addStyle: WsGroup!  
isOkToChange
        "Private - answer whether it is OK to change.
        Triggers the veto-able #aboutToChange event."
    [ self triggerAboutToChange ] on: VetoAction do: [ ^false ].
    ^true!  
scrollVerticalCharacters: anInteger
        "Private - Scroll the pane up by anInteger
         number of characters or down by
         the absolute value of anInteger (if negative)."
    self scrollVertical: anInteger * self amountToScrollUp!  
subclassRecursively
        "Private - Smalltalk implemented panes
		always receive all operating system messages.  Propagate
		the message to children."
    children size > 0 ifTrue: [
        children do: [ :child | child subclassRecursively ] ]! 
escapeKeyInput: aKeyboardInputEvent
        "Private - Respond to the esc keystroke; by default
        pass it on to the receiver's main window."
    self mainWindow escapeKeyInput: aKeyboardInputEvent!
scrollVertical: anInteger
        "Private - Scroll the pane up by anInteger
         number of pixels (if positive) or down by
         the absolute value of anInteger (if negative)."
    ( self topCorner y = 1 and: [ anInteger positive ] )
        ifFalse: [ self scrollTopCorner: 0 @ anInteger ]

!  
subPaneWithFocus: aSubPane
        "Private - pass the subpane with focus up to parent"
	| mainWindow |
	( mainWindow := self mainWindow ) ~~ self
		ifTrue: [ mainWindow subPaneWithFocus: aSubPane ]!   
curFont: aFont
        "Private - set the curFont instance variable."
    self fontAttribute: aFont!
handlersAttribute
        "Private - answer the event handlers instance variable."
    ^handlers!   
destroy
        "Private - Destroy the whole window and
        release all the resources back to system."
    super destroy.
    self destroyPopup!  
scrollHorizontal: anInteger
        "Private - Scroll the pane left by anInteger
         number of pixels (if positive) or right by
         the absolute value of anInteger (if negative)."
    self implementedBySubclass! 
setFocus
        "Set the current input focus to be the receiver."
    ( self disabled or: [ self isHidden ] ) ifFalse: [
        self subPaneWithFocus: self.
        super setFocus ]!  
isATabStop
        "Private - Answer true if the receiver is a tabstop"
    ^(self propertyAt: #noTabStop) ~= true! 
selection: aSelection
        "Set the receiver's current selection.
         Usually implemented by subclasses."!  
menu
        "Private - Answer the menu for the pane."
    | m |
    self event: #getMenu.
    self triggerEvent: #needsMenu.
    ( m := self menuAttribute ) isNil ifTrue: [ ^nil ].
    m owner isNil
        ifTrue: [ m owner: owner ].
    ^m!   
scrollHorizontalCharacters: anInteger
        "Private - Scroll the pane left by anInteger
         number of characters (if positive) or right by
         the absolute value of anInteger (if negative)."
    self scrollHorizontal: anInteger * self amountToScrollLeft!   
setPopupMenu: aMenu
        "Set the receiver's popup menu to aMenu."
    popup := aMenu!   
helpTopic
        "Private - Answer the context sensitive help panel name
        for the receiver.  When writing the help file, use the pane
        name to identify the help panel for a subpane.  In Smalltalk,
        you need to use #setName: message to set the name of the
        subpane, so it can be used for context sensitive help."
    ^self name!
updateSelection
    "The receiver's selection has changed, update it."

    self triggerEvent: #needsSelection!
updateSliders
        "Private - Update the slider boxes in the scrollbars."
    self isHandleOk ifFalse: [ ^self ].
    self doGraphics: [
        self updateVerticalSlider.
        self updateHorizontalSlider ]!
setMenu: aMenu
        "Set the receiver's menu to aMenu."
    menu := aMenu!   
amountToPageUp
        "Private - Answer the number of pixels for
        vertical page scrolling."
    ^self charsInColumn - 1 * self font height!
font
        "Answer the font for the receiver."
    ^curFont!  
initialTopCorner
        "Private - answer the initial value of topCorner."
    ^1@1!   
getValue
        "Answer the value of the receiver."

    ^self contents!  
scrollTopCornerTo: aNewCorner
        "Private - Scroll the top left corner of the pane to aNewCorner.
        Display the contents of the new area."
    self implementedBySubclass!  
initialText
        "Private - Answer the receiver's initial text string"
    ^String new!  
previousTabStop
        "Private - Answer the subpane which is the previous
        tabstop starting from self."
    ^( self isATabStop and: [ self disabled not and: [ self isHidden not ] ] )
        ifTrue: [ self ]
        ifFalse: [ self tabScope previousTabStop: self ]!   
isSubPane
        "Answer whether the receiver is a kind of SubPane."
    ^true!
framingBlock
        "Answer the framingBlock."
    ^framingBlock!  
scrollTopCorner: aPoint
        "Private - Move the contents of the receiver
        pane by extent aPoint.  Do nothing, reimplemented
        in subclasses that support scrolling."! 
eventTableForEdit
        "Private - answer the table of event handlers for the receiver.
        Allocate if necessary so that updates can be stored."
    ^handlers := self eventTable!  
canArrowInto
        "Private - Answer true if user can move the focus
        into the receiver by using the arrow keys."
    ^true!  
amountToScrollUp
        "Private - Answer the number of
        pixels for vertical line scrolling."
    ^self font height!   
gettingFocus
        "Private - the receiver is getting the input focus."
    super gettingFocus.
    self subPaneWithFocus: self.
    self triggerGettingFocus!  
destroyPopup
        "Private - Destroy popup menu."
    self popup notNil ifTrue: [
        self popup destroy.
        self setPopupMenu: nil ]!
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process cursor keys."
    | virtualKey defaultPushButton |
    ( virtualKey := aKeyboardInputEvent virtualKey ) isNil ifTrue: [ ^nil ].
    virtualKey == UpKey ifTrue: [ self scrollVertical: self amountToScrollUp ].
    virtualKey == DownKey ifTrue: [ self scrollVertical: self amountToScrollUp negated ].
    virtualKey == PageUpKey ifTrue: [ self scrollVertical: self amountToPageUp ].
    virtualKey == PageDownKey ifTrue: [ self scrollVertical: self amountToPageUp negated ].
    virtualKey == LeftKey ifTrue: [ self scrollHorizontal: self amountToScrollLeft ].
    virtualKey == RightKey ifTrue: [ self scrollHorizontal: self amountToScrollLeft negated ].
    self updateSliders.

    ( aKeyboardInputEvent character == Cr 
    and: [ ( defaultPushButton := self mainWindow defaultPushButton ) notNil
    and: [ self mainWindow isDialogTopPane not ] ] )
        ifTrue: [ defaultPushButton click ].

    ^super keyboardInput: aKeyboardInputEvent!  
triggerGettingFocus
        "Private -  Trigger the gettingFocus events. "
    self event: #gettingFocus.
    self triggerEvent: #gettingFocus!
open
        "Private - Open the subpane."
    self font isNil ifTrue: [ self fontAttribute: self defaultFont ].
    children size ~= 0
        ifTrue: [
            children do: [ :each |
                each isApplicationWindow  "TopPane open is different"
                    ifFalse: [ each open ] ] ].

    self triggerEvent: #needsContents.
    self event: #getContents.!   
popupFromMenu: aMenu
        "Private - answer a popup menu which is copied from aMenu, with
        accelerator text stripped off of item labels."
    | popupMenu miCopy newLabel tabIndex |
    aMenu isNil ifTrue: [ ^nil ].
    popupMenu := Menu new.
    popupMenu owner: aMenu owner.
	popupMenu title: aMenu title.
    aMenu items do: [ :mi |
        miCopy := mi copy.
        miCopy label notNil ifTrue: [
            newLabel := miCopy label.
            ( tabIndex := newLabel indexOf: Tab ) ~= 0
                ifTrue: [ newLabel := newLabel copyFrom: 1 to: tabIndex - 1 ].
            miCopy label: newLabel.
            miCopy submenu notNil ifTrue: [ miCopy submenu: ( self popupFromMenu: miCopy submenu ) ] ].
        popupMenu items add: miCopy ].
    ^popupMenu! 
update: aSymbol with: anObject
        "Private - Sent as the result of the owner
         sending changed:with:with:."
    self perform: aSymbol with: anObject!  
layoutFrame
    "Answer the receiver's layout frame."

    ^self framingBlock! 
menuAttribute
        "Private - Answer the menu attribute of the receiver."
    ^menu! 
tabKeyInput: aKeyboardInputEvent
        "Private - Respond to the tab keystroke."
    aKeyboardInputEvent isShiftKeyDown
        ifFalse: [
            self
                triggerEvent: #tabbed
                ifNotHandled: [
                    [( self tabScope nextTabStop: self ) setFocus ]
                        on: Error
                        do: [ :e | ^self  "Stack overflow because no valid tab stop " ] ] ]
        ifTrue:  [
            self
                triggerEvent: #backTabbed
                ifNotHandled: [
                    [( self tabScope previousTabStop: self ) setFocus ]
                        on: Error
                        do: [ :e | ^self ] ] ]! 
id: anInteger
        "Private - set the id of the receiver to anInteger."
    id := anInteger! 
freeClientArea: box
        "Private - Set the client area left over."
    | myRect |
    self isVisible ifFalse: [ ^box ].
    self initSize: box.
    myRect := self rectangleAttribute.
    ( myRect leftBottom = box leftBottom and: [ myRect rightBottom = box rightBottom ] )
        ifTrue: [ box leftBottom: ( box leftBottom up: myRect height ). ^box ].
    ( myRect leftBottom = box leftBottom and: [ myRect leftTop = box leftTop ] )
        ifTrue: [ box leftBottom: ( box leftBottom right: myRect width ). ^box ].
    ( myRect rightBottom = box rightBottom and: [ myRect rightTop = box rightTop ] )
        ifTrue: [ box rightTop: ( box rightTop left: myRect width ). ^box ].
    ( myRect leftTop = box leftTop and: [ myRect rightTop = box rightTop ] )
        ifTrue: [ box leftTop: ( box leftTop down: myRect height ). ^box ].
    ^box! 
releaseEventTable
        "Private - Break all connections to event handlers."
    handlers := nil! 
update: aSymbol
        "Private - Sent as the result of the owner
         sending changed:with:."
    self perform: aSymbol! 
id
        "Answer the id of the receiver."
    ^id!
triggerAboutToChange
        "Private - trigger the aboutToChange event."
    self triggerEvent: #aboutToChange.!   
framingBlock: aBlock
        "Initialize the framingBlock to the one
        argument block aBlock which, when executed,
        yields the pane frame rectangle."
    framingBlock := aBlock!
framingRatio: aRectangle
        "Initialize the framingBlock to a one argument
        block which, when executed, yields the pane
        frame rectangle proportional with the ratios
        specified by aRectangle."
    self framingBlock: [ :box | box scaleTo: aRectangle ]!
handlersAttribute: eventHandlers
        "Private - set the handlers instance variable."
    handlers := eventHandlers! 
abortChange
        "Veto the change which is about to occur."
    VetoAction signal!   
tabStop
        "Make the dialog item receive the focus when the user
        presses the TAB key.  By default every subpane which
        can be a tabstop is a tabstop"
    self propertyAt: #noTabStop put: nil!   
selection
        "Answer the receiver's current selection.
         Usually implemented by subclasses."
    ^nil! 
nextTabStop
        "Private - Answer the subpane which has the next
        tabstop starting from self."
    ^( self isATabStop and: [ self disabled not and: [ self isHidden not ] ] )
        ifTrue: [ self ]
        ifFalse: [ self tabScope nextTabStop: self ]!  
eventTable
        "Private - answer the table of event handlers for the receiver."
    handlers isNil ifTrue: [ ^self eventTableCreate ].
    ^handlers!  
noTabStop
        "Make the receiver not be a tabstop.  By default
        every subpane which can be a tabstop is a tabstop.
        Send this message if you want to make it not be a tabstop."
    self propertyAt: #noTabStop put: true!  
mdiSelected
        "Private - Answer whether the MDI document has focus.
        Default is the answer false."
    ^false!
initialize
        "Private - initialize the class."
    SelfDefinedStructure
        define: 'OS2BITMAPCOREHEADER'
        withFields: ( IdentityDictionary new
            at: #size put: #( 0 #ulong #yourself );
            at: #width put: #( 4 #ushort #yourself );
            at: #height put: #( 6 #ushort #yourself );
            at: #planes put: #( 8 #ushort #yourself );
            at: #bitCount put: #( 10 #ushort #yourself );
            yourself )!  
isFont
        "Answer whether the receiver is a kind of Font."
    ^false! 
asParameter
        "Answer the receiver in a form suitable for passing as
         a parameter to a host procedure call."
    ^lpfnInstanceProc asParameter!  
printOn: aStream
        "Append a text representation of the receiver to aStream."
    aStream nextPutAll: self class name, '('.
    stMessage notNil ifTrue: [
        stMessage receiver isNil
            ifTrue: [ aStream nextPutAll: '???' ]
            ifFalse: [ aStream nextPutAll: stMessage receiver class name ].
        aStream nextPutAll: '>>'.
        stMessage selector isNil
            ifTrue: [ aStream nextPutAll: '???' ]
            ifFalse: [ aStream nextPutAll: stMessage selector ] ].
    aStream nextPutAll: ')'!   
generateCallbackPrologueIn: anAddress
        "Private - create the machine code instructions for the
         prolog to a CallBack entry starting at anAddress"
    ^self
        generateCallbackProloguePrim: anAddress asParameter
        slotNumber: slotNumber
        sysWindow: SystemWindow current handle asInteger
        callingConvention: ( self class callingConventions at: ccType )
        argsSize: self argsSize!   
argsSize
        "Private - Answer the byte size of the arguments"
    ^typeArray inject: 0 into: [ :total :type |
        total + ( ( self class atSelectors at: type ) at: 1 ) ]!
generateCallbackProloguePrim: anAddress
    slotNumber: slot
    sysWindow: windowHandle
    callingConvention: anInteger1
    argsSize: anInteger2
        "Private - Primitive which generates machine code for the callback entry point."
    <primitive: 166>!  
allocateSlot: anInteger
        "Private - allocate host memory for the callback entry prologue."
    ^ExternalAddress allocateMemory: self class slotSize! 
release
        "Release the CallBack object."
    lpfnInstanceProc notNil ifTrue: [ lpfnInstanceProc free ].
    lpfnInstanceProc := nil.
    [ self class callBackTable at: slotNumber put: nil ] evaluateWithoutInterrupts!
performWithArgs: argsStruct
        "Private - Perform the Smalltalk message associated with
         this CallBack using argsStruct."
    | argsArray offset value sizeSelector |
    argsArray := Array new: typeArray size.
    offset := 0.
    ccType = #c
        ifTrue: [
            typeArray size to: 1 by: -1 do: [ :index |
                sizeSelector := self class atSelectors at: ( typeArray at: index ).
                value := argsStruct perform: ( sizeSelector at: 2 ) with: offset.
                argsArray at: index put: value.
                offset := offset + ( sizeSelector at: 1 ) ] ]
        ifFalse: [  "#stdcall or #api"
            1 to: typeArray size do: [ :index |
                sizeSelector := self class atSelectors at: ( typeArray at: index ).
                value := argsStruct perform: ( sizeSelector at: 2 ) with: offset.
                argsArray at: index put: value.
                offset := offset + ( sizeSelector at: 1 ) ] ].

    stMessage arguments: argsArray.
    ^stMessage perform!
registerMessage: aSTMessage
    parameterTypes: aParameterTypeArray
    returnType: aReturnType
    callingConvention: aCCType
        "Private - Answer an instance of CallBack object for stMessage
         of ccType calling convention.  Currently, returnType is not
         needed.  Currently, CallBack object returns a double word
         to the caller.  The caller can then choose to either assume
         the return type is a word or double word."
    | aCallbackAddress |
    slotNumber := self class findEmptySlot.
    stMessage := aSTMessage.
    typeArray := aParameterTypeArray.
    ccType := aCCType.
    returnType := aReturnType.
    [ self class callBackTable at: slotNumber put: self ] evaluateWithoutInterrupts.

    aCallbackAddress := self allocateSlot: slotNumber.
    self generateCallbackPrologueIn: aCallbackAddress.
    lpfnInstanceProc := aCallbackAddress.
    ^self! 
sizeInBytes
        "Private - Answer the default size in bytes."
    ^14!  
bfType: aString
        "Private - Set the bitmap file type to aString. aString must be 'BM'."
    self byteAtOffset: 0 put: $B asciiValue;
        byteAtOffset: 1 put: $M asciiValue!
offBits
    ^self uLongAtOffset: 10! 
offBits: anOffset
        "Private - Set the offset of the bitmap from
         the header."
    self uLongAtOffset: 10 put: anOffset! 
bfSize: fileSize
        "Private - Set the size of the file."
    self uLongAtOffset: 2 put: fileSize! 
reserved1
    ^self uShortAtOffset: 6!   
reserved1: anInt
        "Private - Reserved."
    self uShortAtOffset: 6 put: anInt!   
bfSize
    ^self uLongAtOffset: 2!   
bfType
        "Private - Answer the type of the file."
    ^(String with: (self byteAtOffset: 0) asCharacter
         with: (self byteAtOffset: 1) asCharacter)!  
reserved2
    ^self uShortAtOffset: 8!   
reserved2: anInt
        "Private - Reserved."
    self uShortAtOffset: 8 put: anInt!   
initialize
        "Private - Initialize the receiver."
    super initialize.
    currentId := 0.
    segments := Dictionary new.
    segmentIsOpen := false.
    drawingMode := DrawingModeDrawAndRetain!  
fromHandle: handle style: style
        "Private - answer a new instance of the receiver class or one
        of its subclasses, based on the given window handle and style."
    | class |
    ( style & EsMultiline = EsMultiline )
        ifTrue: [ class := TextEdit ]
        ifFalse: [ class := self ].
    ^class handle: ( WindowHandle fromInteger: handle )!   
dragTargetScrollElapsed
		"Private - answer the number of milliseconds that have elapsed
		since the mouse moved over the drag scrolling region of
		the receiver."
    ^self propertyAt: #dragTargetScrollElapsed ifAbsent: [ 0 ]!   
removeSubpane: aWindow
        "Remove aWindow from the receiver."
    children notNil ifTrue: [ children removeKey: aWindow id ifAbsent: [ nil ] ].
    aWindow close.
    self mainWindow remove: aWindow interestIn: aWindow name! 
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^Set with: #changed  "from Object"!  
constructNotifications
        "Private - answer the mapping between host control
        notification codes and corresponding Smalltalk event
        notifications."
    ^Dictionary new
        at: EnChange put: #notifyTextChanged: ;
        yourself!
defaultFont
        "Answer the default font for the receiver."
    ^TextFont!  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #aboutToChangeTo: ;
        add: #changed: ;
        add: #entered: ;
        add: #textChanged: ;
        yourself!   
patternFill: aRectangle rule: aRopConstant
        "Private - Fill aRectangle with the current brush pattern
         using aRopConstant."
    self allHandles do: [ :h |
        ( GDILibrary
            patBlt: h
            x: aRectangle origin x
            y: aRectangle origin y
            width: aRectangle width
            height: aRectangle height
            rop: aRopConstant )
                ifFalse: [ ^self osNotification ] ]!  
fromHandle: handle style: style
        "Private - answer a new instance of the receiver class or one
        of its subclasses, baed on the given window handle and style."
    | class |
    ( style & LbsMultiplesel = LbsMultiplesel ) |
    ( style & LbsExtendedsel = LbsExtendedsel )
        ifTrue: [ class := MultipleSelectListBox ]
        ifFalse: [ class := self ].

    ^class handle: ( WindowHandle fromInteger: handle )!
canvasBox
        "Private - Answer a rectangle which is the total
         drawable area."
    ^graphicsMedium isGraphPane
        ifTrue: [ graphicsMedium scrollingRectangle ]
        ifFalse: [ self boundingBox ]! 
wmInitdialog: wparam with: lparam
        "Private - Process the init dialog message."
    ^true!   
updateItem: aMenuItem
        "Private - Send a message to aMenuItem to update itself."
    | pos posFlag miFlags |
    window isNil ifTrue: [ ^self ].
    aMenuItem style & MfPopup = MfPopup
        ifTrue: [
            posFlag := MfByposition.
            pos := aMenuItem position ]
        ifFalse: [
            posFlag := MfBycommand.
            pos := aMenuItem id ].
    miFlags := aMenuItem style | aMenuItem attribute.
    ( UserLibrary
        modifyMenu: window handle
        position: pos
        flags: miFlags | posFlag
        newId: pos
        newContents: aMenuItem label asParameter )
            ifFalse: [ self osWarning ]!
wmCharResultFor: aCharacter
        "Private - Answer the value to return to the host operating system
       character input message when aCharacter is being entered."
    ^( aCharacter = Tab or: [ aCharacter = Cr ] )
        ifTrue: [ 1 ]
        ifFalse: [ nil ]!   
defaultStyle
        "Private - Answer the default style for text edit control."
    ^EsAutovscroll |
        EsMultiline |
        EsWantreturn |
        EsNohidesel |
        ( self wrap ifTrue: [ 0 ] ifFalse: [ WsHscroll ] ) |
        WsVscroll |
        WsBorder!   
callDefaultProc: msg with:wordInteger with: longInteger
        "Private - call the default window procedure."
    | result |
    result := UserLibrary
        defWindowProc: self handle
        msg: msg
        wparam: wordInteger
        lparam: longInteger.
    ^ExternalLong fromBytes: result! 
dragTargetDoScroll
        "Private - scroll the receiver in response to item being
        dragged in the drag scrolling hot zone."
    | direction session |
    self dragTargetScrollElapsed: self dragTargetScrollElapsed + self class dragTargetScrollInterval.
    self dragTargetScrollElapsed < self class dragTargetScrollDelay ifTrue: [ ^nil ].

    direction := self dragTargetScrollDirection.
    session := DragDropSession current.
    session isNil ifTrue: [ ^self dragTargetStopScrollTimer ].
    session setLocation.
    self dragTargetStopScrollTimer.
    direction notNil
        ifTrue: [ session targetEraseEmphasis ].
    direction = #up ifTrue: [ self scrollVerticalCharacters: 1; updateVerticalSlider ].
    direction = #down ifTrue: [ self scrollVerticalCharacters: -1; updateVerticalSlider ].
    direction = #right ifTrue: [ self scrollHorizontalCharacters: -1; updateHorizontalSlider ].
    direction = #left ifTrue: [ self scrollHorizontalCharacters: 1; updateHorizontalSlider ].
    direction notNil ifTrue: [ session targetDrawEmphasis ].
    self dragTargetStartScrollTimer: direction!   
topCorner
        "Private - Answer the receiver's topCorner."
    | result |
    result := UserLibrary
        sendMessageInt: handle
        msg: EmGetfirstvisibleline
        wparam: 0
        lparam: 0.
    ^1 @ ( result + 1 )!   
listEnd
        "Private - Answer the list end constant."
    ^-1!  
= anRGBColor
        "Answer whether the receiver and anRGBColor are equal.  Two RGBColors
        are equal if they have equal component values."
    anRGBColor isRGBColor ifFalse: [ ^false ].
    ^self red = anRGBColor red
        and: [ self green = anRGBColor green
            and: [ self blue = anRGBColor blue ] ]!   
blue
        "Answer the value of the blue component."
    ^blue!   
isRGBColor
        "Answer whether the receiver is an RGBColor."
    ^true! 
red
        "Answer the value of the red component."
    ^red!  
red: componentValue
        "Set the value of the red component to the given <componentValue>."
    red := componentValue!  
printOn: aStream
        "Print a textual description of the receiver on <aStream>."
    aStream
        nextPutAll: self class name;
        nextPutAll: ' (';
        nextPutAll: self red printString;
        nextPutAll: ', ';
        nextPutAll: self green printString;
        nextPutAll: ', ';
        nextPutAll: self blue printString;
        nextPut: $)!   
initialize
        "Private -initialize the receiver to a valid color."
    super initialize.
    self red: 0.
    self green: 0.
    self blue: 0!  
asInteger
        "Answer the receiver as an RGB integer."
    ^( ( self blue bitShift: 16 ) bitOr: ( self green bitShift: 8 ) ) bitOr: self red!   
blue: componentValue
        "Set the value of the blue component to the given <componentValue>."
    blue := componentValue!   
asRGBColor
        "Answer the RGB equivalent of the receiver."
    ^self!  
green
        "Answer the value of the green component."
    ^green!
green: componentValue
        "Set the value of the green component to the given <componentValue>."
    green := componentValue!
hash
        "Answer an integer hash value for the receiver.  The hash value of an object
        must be constant over time, and two objects that compare equal must have
        equal hash values."
    ^( self red hash bitXor: self green hash ) bitXor: self blue hash! 
storeOn: aStream
        "Print a Smalltalk expression on <aStream> which, when evaluated, will create an object equal to the receiver."
    aStream
        nextPut: $(;
        nextPutAll: self class name;
        nextPutAll: ' red: ';
        nextPutAll: self red printString;
        nextPutAll: ' green: ';
        nextPutAll: self green printString;
        nextPutAll: ' blue: ';
        nextPutAll: self blue printString;
        nextPut: $)!  
asIndexedColor
        "Answer the palette index for the color closest to the receiver,
        using the system palette."
    ^self implementedBySubclass!
asRGBColor
        "Answer the RGB equivalent of the receiver."
    ^self implementedBySubclass!
asParameter
        "Answer the receiver in a form suitable
        for passing to an API call."
    ^self implementedBySubclass!  
isColor
        "Answer whether the receiver is a Color."
    ^true!
wmCtlcolordlg: wparam with: lparam
        "Private - Process set dialog box color message."
    ^nil!  
getScrollRange: hWnd bar: barID lpMinPos: lpMinPos lpMaxPos: lpMaxPos
   <api: GetScrollRange ulong long struct struct boolean>
    ^self invalidArgument!  
windowUnderCursor
        "Answer the window that is currently
         under the mouse cursor, or nil if not
         a Smalltalk window."
    ^Window windowUnderPoint: Cursor sense!   
setWindowExt: anExtent
        "Set the window extent to anExtent."
    self allHandles do: [ :h |
        ( GDILibrary
            setWindowExtEx: h
            x: anExtent x
            y: anExtent y
            oldExtent: nil )
                ifFalse: [ ^self osError ] ]!  
initialize
        "Private - First time initialization. Creates the SelfDefinedStructure "
    | d |
    d := Dictionary new.
    d
        at: #lStructSize put: #(0 #ulong #yourself);
        at: #hwndOwner put: #(4 #handle #yourself);
        at: #hDevMode put: #(8 #ulong #yourself);
        at: #hDevNames put: #(12 #ulong #yourself);
        at: #hDC put: #(16 #ulong #yourself);
        at: #flags put: #(20 #ulong #yourself);
        at: #nFromPage put: #(24 #ushort #yourself);
        at: #nToPage put: #(26 #ushort #yourself);
        at: #nMinPage put: #(28 #ushort #yourself);
        at: #nMaxPage put: #(30 #ushort #yourself);
        at: #nCopies put: #(32 #ushort #yourself);
        at: #hInstance put: #(34 #handle #yourself);
        at: #lCustData put: #(38 #ulong #yourself);
        at: #lpfnPrintHook put: #(42 #ulong #yourself);
        at: #lpfnSetupHook put: #(46 #ulong #yourself);
        at: #lpPrintTemplateName put: #(50 #ulong #yourself);
        at: #lpSetupTemplateName put: #(54 #ulong #yourself);
        at: #hPrintTemplate put: #(58 #ulong #yourself);
        at: #hSetupTemplate put: #(62 #ulong #yourself);
        yourself.
    SelfDefinedStructure define: 'PRINTDLG' withFields: d.

    d := Dictionary new.
    d
        at: #wDriverOffset put: #(0 #ushort #yourself);
        at: #wDeviceOffset put: #(2 #ushort #yourself);
        at: #wOutputOffset put: #(4 #ushort #yourself);
        at: #wDefault put: #(6 #ushort #yourself);
        at: #dnDriver put: #(0 0 #asString);
        at: #dnDevice put: #(0 0 #asString);
        at: #dnOutput put: #(0 0 #asString);
        yourself.
    SelfDefinedStructure define: 'DEVNAMES' withFields: d.

    d := Dictionary new.
    d
        at: #dmDeviceName put: #(0 32 #asString);
        at: #dmSpecVersion put: #(32 #ushort #yourself);
        at: #dmDriverVersion put: #(34 #ushort #yourself);
        at: #dmSize put: #(36 #ushort #yourself);
        at: #dmDriverExtra put: #(38 #ushort #yourself);
        at: #dmFields put: #(40 #ulong #yourself);
        at: #dmOrientation put: #(44 #short #yourself);
        at: #dmPaperSize put: #(46 #short #yourself);
        at: #dmPaperLength put: #(48 #short #yourself);
        at: #dmPaperWidth put: #(50 #short #yourself);
        at: #dmScale put: #(52 #short #yourself);
        at: #dmCopies put: #(54 #short #yourself);
        at: #dmDefaultSource put: #(56 #short #yourself);
        at: #dmPrintQuality put: #(58 #short #yourself);
        at: #dmColor put: #(60 #short #yourself);
        at: #dmDuplex put: #(62 #short #yourself);
        at: #dmYResolution put: #(64 #short #yourself);
        at: #dmTTOption put: #(66 #short #yourself);
        at: #dmCollate put: #(68 #short #yourself);
        at: #dmFormName put: #(70 102 #asString);
        at: #dmUnusedPadding put: #(102 #ushort #yourself);
        at: #dmBitsPerPel put: #(104 #ushort #yourself);
        at: #dmPelsWidth put: #(106 #ulong #yourself);
        at: #dmPelsHeight put: #(110 #ulong #yourself);
        at: #dmDisplayFlags put: #(114 #ulong #yourself);
        at: #dmDisplayFrequency put: #(118 #ulong #yourself);
        at: #dmDriverData put: #(122 0 #yourself);
        yourself.
    SelfDefinedStructure define: 'DEVMODE' withFields: d!  
shiftState: anInteger
        "Private - set the integer value which describes the state of the
        shift keys when the receiver event occurred (a combination
        of AfShift, AfAlt, AfControl) to anInteger."
    shiftState := anInteger!  
characterValue
        "Answer the integer value of the character for the receiver."
    ^characterValue!   
shiftState
        "Answer an integer value which describes the state of the
        shift keys when the receiver event occurred (a combination
        of AfShift, AfAlt, AfControl)."
    ^shiftState!  
isAltKeyDown
        "Answer whether the Alt key was depressed when
        the receiver event occurred."
    ^( self shiftState bitAnd: AfAlt ) ~= 0! 
isCursorKey
        "Answer whether the receiver corresponds to a cursor key click."
    ^CursorKeys includes: self virtualKey! 
character
        "Answer the character for the receiver (if any)."
    self characterValue isNil ifTrue: [ ^nil ].
    ^self getCharacter!
printOn: aStream
        "Private - print a texttual description of the receiver on aStream."
    | virtualKeyName |
    ( self shiftState bitAnd: AfShift ) ~= 0 ifTrue: [ aStream nextPutAll: ' Shift' ].
    ( self shiftState bitAnd: AfControl ) ~= 0 ifTrue: [ aStream nextPutAll: ' Control' ].
    ( self shiftState bitAnd: AfAlt ) ~= 0 ifTrue: [ aStream nextPutAll: ' Alt' ].
    self characterValue notNil ifTrue: [
        aStream nextPutAll: ' character = ', self characterValue printString, ' ( ', self character asString, ' )' ].
    self scanCode notNil ifTrue: [
        aStream nextPutAll: ' scanCode = ', self scanCode printString ].
    self virtualKey notNil ifTrue: [
        aStream nextPutAll: ' virtualKey = ', self virtualKey printString.
        ( Smalltalk isRunTime not and: [ ( virtualKeyName := self virtualKeyName ) notNil ] )
            ifTrue: [ aStream nextPutAll: ' ( ', virtualKeyName , ' )' ] ]!   
isShiftKeyDown
        "Answer whether the Shift key was depressed when
        the receiver event occurred."
    ^( self shiftState bitAnd: AfShift ) ~= 0!   
scanCode
        "Answer the scan code corresponding to the receiver."
    ^scanCode!   
isControlKeyDown
        "Answer whether the Control key was depressed when
        the receiver event occurred."
    ^( self shiftState bitAnd: AfControl ) ~= 0! 
altCharacter
        "Answer the character for the receiver if the ALT key
        is down, nil otherwise."
    ( self characterValue isNil or: [ self isAltKeyDown not ] ) ifTrue: [ ^nil ].
    ^self getCharacter! 
characterValue: anInteger
        "Private - set the integer value of the character for
        the receiver to anInteger."
    characterValue := anInteger!   
isToggleKey
        "Answer whether the receiver corresponds to a toggle key."
    ^self class isToggleKey: self virtualKey!
virtualKey
        "Answer an integer value which describes the virtual key of the
        keystroke corresponding to the receiver (BackspaceKey, F1Key, etc.)."
    ^virtualKey!  
virtualKey: anInteger
        "Private - set the integer value which describes the virtual key of the
        keystroke corresponding to the receiver (BackspaceKey, F1Key, etc.)."
    virtualKey := anInteger!   
scanCode: anInteger
        "Private - set the integer value of the scan code for
        the receiver to anInteger."
    scanCode := anInteger!   
basicStyle
        "Private - Answer an Integer with appropriate
         bits for basic control style."
    ^WsChild | WsVisible | WsGroup!   
button2Down: aPoint
        "Private - Capture mouse input in preparation for
         right button scrolling."
    ( self isLocalDragSource and: [ self isDragButton: 2 ] )
        ifTrue: [ self dragOnMove: true location: aPoint. ^self ].
    Margin := 0.
    self captureMouseInput.
    self startTimer: self class rightButtonScrollTimerId period: self class rightButtonScrollInterval!
hasExtendedStyle: aStyle
        "Answer whether the receiver has the specified bits set in
        its extendedStyle flag."
    | flags |
    flags := self extendedStyle isNil ifTrue: [ self defaultExtendedStyle ] ifFalse: [ self extendedStyle ].
    ^( flags bitAnd: aStyle ) = aStyle!  
insertMenu: aMenuHandle
    position: positionInteger
    flags: anInteger
    id: idInteger
    contentsStruct: aString
        "Private - Perform the Win InsertMenu function.  This
         api call only handles strings."
    <api: InsertMenuA ulong ulong ulong ulong struct boolean>
    ^self invalidArgument!  
asRGBColor
        "Answer the RGB equivalent of the receiver,
        using the system palette."
    | hPalette |
    hPalette := GDILibrary getStockObject: DefaultPalette.
    ^self asRGBColorForPalette: hPalette
!
disableNoScroll
        "Add the disable no scroll style."
    ^self addStyle: LbsDisablenoscroll!  
addTitleBarStyle
        "Add the title bar style."
    ^self addStyle: WsCaption!  
queryItemText: itemId
        "Answer a string containing the text of the
         item whose id is itemId."
    | length answer |
    answer := String new: 256.
    self isHandleOk ifFalse: [ ^answer ].
    ( length := UserLibrary
        getDlgItemText: handle
        item: itemId
        text: answer
        maxCount: answer size ) = 0
            ifTrue: [ self osWarning. ^String new ].
    ^( answer copyFrom: 1 to: length ) asNormalizedString!  
setTextLimit: itemId to: anInt
        "Set the text limit for the item whose id is itemId
         to anInt."
    self sendMessage: EmLimittext item: itemId wparam: anInt lparam: 0! 
querySelectionInListBox: itemId
        "Answer the selected item in the list box whose
         id is itemId."
    ^self sendMessage: LbGetcursel item: itemId wparam: 0 lparam: 0!   
hideItem: itemId
        "Hide the item whose id is itemId."
    | hItem |
    ( hItem := UserLibrary getDlgItem: handle item: itemId ) = 0
        ifTrue: [ ^self osError ].
    ^UserLibrary showWindow: hItem command: SwHide!   
fromModule: aModuleHandle id: id
        "Open the dialog box whose id is anInteger
         contained in the module identified by
         aModuleHandle.  id may be a String or an Integer
         that identifies the dialog template."
    | hModule hwndDialog opened |
    hModule := ( opened := aModuleHandle isString )
        ifTrue: [ hModule := DynamicLinkLibrary open: aModuleHandle ]
        ifFalse: [ aModuleHandle ].
    owner isNil ifTrue: [
        owner := Notifier findWindow: WindowHandle queryActive ].

    NotificationManager newWindow: self.
    hModule asInteger >= 32 ifTrue: [
        id isString
            ifTrue: [ "id is a String."
                hwndDialog := UserLibrary
                    createDialog: hModule asInteger
                    templateName: id asParameter
                    parent: owner asParameter
                    dialogFunction: DialogProcInstance asParameter ]
            ifFalse: [ "id is an integer."
                hwndDialog := UserLibrary
                    createDialog: hModule asInteger
                    id: id
                    parent: owner asParameter
                    dialogFunction: DialogProcInstance asParameter ].
        hwndDialog = 0 ifTrue: [ NotificationManager newWindow: nil. ^self osError ].
        hwndDialog := WindowHandle fromInteger: hwndDialog.
        self handle: hwndDialog ].
    NotificationManager newWindow: nil.
    opened ifTrue: [ hModule close ].

    self isHandleOk ifFalse: [ self error: 'Could not create Dialog Box: ', id printString ].

    PoppedModelessWindows add: handle.
    self receiveMessages! 
wmChar: mp1Param with: mp2Param
        "Private - Process the character input message."!
select: itemNumber inListBox: itemId
        "Select itemNumber in the list box whose id is itemId."
    self sendMessage: LbSetcursel item: itemId wparam: itemNumber lparam: 0!   
add: aString toListBox: itemId at: anInteger
        "Add aString at anInteger to the list box whose
         id is itemId.  anInteger is either the zero-based
         index of the new item or a constant beginning
         with 'Lit' from the OperatingSystemConstants pool dictionary."
    self sendMessage: LbInsertstring item: itemId wparam: anInteger lparamStruct: aString asParameter!
wmCommand: wordInteger with: longInteger
        "Private - Handle a command message
         by performing the selector for the item."
    | selector |
	wParam := wordInteger.
	lParam := longInteger.
    selector := self itemIds at: wordInteger lowWord ifAbsent: [ nil ].
    selector notNil
        ifTrue: [ self sendInputEvent: selector ]
        ifFalse: [
            self sendInputEvent: #controlEvent:id:
                withArgs:( Array with: wordInteger highWord with: wordInteger lowWord ) ].
    ^0!   
queryButton: itemId
        "Answer a boolean indicating the 'checked' state of
         the button whose id is itemId."
    ^(UserLibrary
        isDlgButtonChecked: handle
        buttonID: itemId) = 1! 
setValue: anInteger forItem: itemNumber inListBox: itemId
        "Set the value of itemNumber to anInteger in the list box
         whose id is itemId."
    self sendMessage: LbSetitemdata item: itemId wparam: itemNumber lparam: anInteger!   
close
        "Close the receiver."
    self stopReceivingMessages.
    owner notNil ifTrue: [ owner enable ].
    PoppedModelessWindows remove: handle ifAbsent: [ ].
    self destroy.

    hLibrary notNil ifTrue: [
        ( KernelLibrary freeLibrary: hLibrary )
            ifFalse: [ ^self osError ].
        hLibrary := nil ].

   sem notNil ifTrue: [
        sem signal.
        sem := nil.
        Processor suspendActive ]! 
setItemText: itemId string: aString
        "Set the text of the item whose id is itemId to aString."
    ( UserLibrary
        setDlgItemText: handle
        item: itemId
        text: aString asParameter )
            ifFalse: [ ^self osError ]! 
deleteAllItemsInListBox: itemId
        "Delete all the items in the list box whose id is itemId."
    self sendMessage: LbResetcontent item: itemId wparam: 0 lparam: 0!   
queryValue: itemNumber inListBox: itemId
        "Get the value of itemNumber in the list box
         whose id is itemId."
    ^self sendMessage: LbGetitemdata item: itemId wparam: itemNumber lparam: 0!
setButton: itemId value: aBoolean
        "Set the 'checked' state of a radio button or check box
         to aBoolean."
    | result |
    ( result := UserLibrary
        checkDlgButton: handle
        item: itemId
        checkIt: aBoolean asParameter )
            ifFalse: [ self osNotification ].
    ^result!   
winClassMap
        "Private - answer the class variable that maps between
        host control classes and Smalltalk classes."
    WinClassMap isNil ifTrue: [ self initializeWinClassMap ].
    ^WinClassMap!   
noRedraw: aBoolean
        "Private - Stop the receiver from
         repainting itself."
    UserLibrary
        sendMessage: self
        msg: WmSetredraw
        wparam: aBoolean not asParameter
        lparam: nil! 
getClientRect: aWindowHandle rectangle: aByteArray
    <api: GetClientRect ulong struct boolean>
    ^self invalidArgument! 
drawFocus: aDrawStruct
        "Private - Draw the focus for the requested menu item.  Usually
        reimplemented by subclasses."
    self defaultDrawFocus: aDrawStruct!   
createBitmap: width
    height: height
    planes: planes
    bitCount: bitCount
    bits: bits
        "Private - call the CreateBitmap API."
    | hBitmap |
    ( hBitmap := GDILibrary
        createBitmap: width
        height: height
        planes: planes
        bitCount: bitCount
        bits: bits ) = 0
            ifTrue: [ ^self osError ].
    ^hBitmap!   
triggerChanged
        "Private - trigger the changed event."
    self triggerEvent: #changed: with: self value!
notifyTextChanged: aParameter
		"Private - the host signaled that the text has changed."
    self textChanged!  
getValue
        "Private - Answer the contents."
    ^self contents!   
previousValue
        "Answer the previous value of the receiver.
        The previous value is the value prior to any
        user changes (when there is a #changed: handler)
        or the last time previousValue was sent."
    ^self propertyAt: #previousValue ifAbsent: [ '' ]! 
previousValue: aValue
        "Set the previous value of the receiver."
    ^self propertyAt: #previousValue put: aValue!   
contents: aString
        "Set the receiver's contents to aString."
    value := aString.
    self isHandleOk ifTrue: [ self setContents ]!
clear
        "Clear the contents of the receiver."
    self setValue: ''!  
setValue: aValue
        "Set the text contents of the receiver to the string representing
        aValue.  First set the value, with a possiblity that it may be undone.
        Then, trigger aboutToChangeTo:, where the value may be restored
        to the previous value, or it may be set to an entirly new value.
        At the end, if the final value is different from the beginning value,
        trigger the changed event if the value is changed.
        Answer the final value."
    | newValue |
    newValue := ( aValue isString
        ifTrue: [ aValue ]
        ifFalse: [ aValue isNil ifTrue: [ '' ] ifFalse: [ aValue asString ] ] ).

    newValue ~= value ifTrue: [
        self
            value: newValue;
            triggerAboutToChangeTo: newValue.

        value ~= self previousValue ifTrue: [
            self
                triggerChanged;
                previousValue: value ] ].
    ^value!  
readWrite
        "Clear the readonly property of the receiver."
    self readOnly: false!  
modified: aBoolean
        "Set whether the field has been modified."
    modified := aBoolean.
    self setModifiedPrivate!   
isOkToChangeTo: newValue
        "Private - answer whether it is OK to change.
        Triggers the veto-able #aboutToChangeTo: event."
    [ self triggerAboutToChangeTo: newValue ] on: VetoAction do: [ ^false ].
    ^true!   
initialize
        "Private - Initialize the receiver."
    value := String new.
    modified := false.
    ^super initialize!
initialText
        "Private - Answer the receiver's initial text string."
    ^value!  
isReadOnly
        "Answer whether the receiver is readonly."
    ^self hasStyle: EsReadonly!   
insertSelectedText: aString at: anInteger
        "Insert aString into the receiver immediately before
        index anInteger and have the newly inserted text selected."
    | contents newContents |
    contents := self contents.
    newContents := (contents copyFrom: 1 to: anInteger - 1), aString,
        (contents copyFrom: anInteger to: contents size).
    self
        contents: newContents;
        selectFrom: anInteger
            to: anInteger + aString asExternalString size - 1;
        setFocus!  
getTextLength
        "Private - Get the current text length in the host control."
        "Assumes 'handle = NullHandle' is false."
    ^self windowTextLength!   
losingFocus
        "Private - The receiver is losing focus. "
    self isReadOnly ifFalse: [
        ( self value ~= self previousValue ) ifTrue: [
            ( self isOkToChangeTo: self value ) ifFalse: [ ^self ].
            ( self hasActionForEvent: #changed: )
                ifTrue: [ self triggerChanged ].
            self previousValue: self value ] ] .
    ^super losingFocus
!
abortChange
        "Reject the new value, and restore to what was present
        before the user started typing."
    self value: self previousValue.
    ^super abortChange!   
selectAll
        "Select the entire text of the  receiver."
    self mainWindow activeTextPane: self.
    self isHandleOk
        ifTrue: [ self selectFrom: 1 to: self windowTextLength + 1 ]
        ifFalse: [ self whenValid: #selectAll ]! 
readOnly
        "Set the readonly property of the receiver."
    self readOnly: true!  
readOnly: aBoolean
        "Set the readonly property of the receiver to aBoolean."
    aBoolean
        ifTrue: [ self addStyle: EsReadonly ]
        ifFalse: [ self removeStyle: EsReadonly ].
    self isHandleOk
        ifTrue: [ self setReadOnly ]! 
retryChange
        "Stop the change process, and set the focus back to allow the user
        to modify the receiver and try again."
    super abortChange.
    self sendInputEvent: #setFocus!  
textChanged
        "Private - handle the changing of text contents."
    self event: #textChanged.
    ( self hasActionForEvent: #textChanged: )
        ifTrue: [ self triggerEvent: #textChanged: with: self contents ]!   
deleteSelection
        "Private - Delete the selected text."    
    self clearSelection!  
valueSetAsInitialText
        "Private - answer whether the receiver's text
        is set via initialText (otherwise, it is set during
        validate via contents:)."
    ^true!  
setContents
        "Set the value of the entryfield.
        Assumes 'handle = NullHandle' is false."
    self setWindowText: value.
    self modified.
    self modified: false!   
selection
        "Answer a Point describing the current selection."
    self getSelection.
    ^selection!
modified
        "Answer true if the receiver has been modified."
    self isHandleOk ifFalse: [ ^false ].
    ^modified := modified | self getModified!   
nextPutAll: aString
        "Add aString at the end of the text in the pane."
    self getText.
    value := value, aString.
    self setContents.
    ^aString! 
setTextLimit: anInteger
        "Set the maximum number of characters
         that the receiver can hold to anInteger."
    self textLimit: anInteger.
    self isHandleOk
        ifTrue: [ self setTextLimit ]
        ifFalse: [ self whenValid: #setTextLimit: with: anInteger ]!  
textLimit
        "Private - answer the text limit of the receiver."
    ^self propertyAt: #textLimit!  
textLimit: anInteger
        "Private - set the text limit property of the receiver.."
    self propertyAt: #textLimit put: anInteger!  
triggerAboutToChangeTo: newValue
        "Private - trigger the aboutToChangeTo: event."
    self triggerEvent: #aboutToChangeTo: with: newValue!   
contents
        "Answer the String contained in the receiver."
    self isHandleOk ifTrue: [ self getText ].
    ^value!  
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process enter key."
    | character virtualKey |
    ( ( virtualKey := aKeyboardInputEvent virtualKey ) notNil and: [
        ( virtualKey == TabKey or: [ virtualKey == BacktabKey ] ) ] )
            ifTrue: [ self tabKeyInput: aKeyboardInputEvent ].

    character := aKeyboardInputEvent character.
    character == Cr ifTrue: [
        value := self contents.
        self triggerEvent: #entered: with: self value ].  " must send self for subclasses "
    ^super keyboardInput: aKeyboardInputEvent!   
value
        "Answer the text contents of the receiver."
    ^self contents!   
getText
        "Set the value instance variable from the host control's value.
        Assumes 'handle = NullHandle' is false."
    ^value := self windowText!
value: aString
        "Set the text contents of the receiver to aString."
    self
        contents: aString;
        modified: false!   
selectFrom: aStartIndex to: anEndIndex
        "Select the specified range of text."
    selection isNil ifTrue: [ selection := Point new ].
    selection x: aStartIndex; y: anEndIndex.
    self isHandleOk ifTrue: [ self setSelection ]!  
nextPut: aCharacter
        "Add a character at the end of the text in the pane."
    self getText.
    value := value, ( value class with: aCharacter ).
    self setContents.
    ^aCharacter! 
close
        "Private - Close the receiver."
    self popup notNil ifTrue: [ self destroyPopup ].
    self isGlobalDragTarget ifTrue: [ self revokeDragDrop ].
    ^super close! 
scrollingRectangle
        "Private - Answer the rectangle expanded by
         its own extent for scrolling purpose."
    ^rectangle expandBy: rectangle extent!  
isIcon
        "Answer whether the receiver is a kind of Icon."
    ^true!  
isCursor
        "Answer true if receiver is a kind of CursorManager."
    ^false!  
getKeyState: nVirtKey
    <api: GetKeyState long short>
    ^self invalidArgument!  
asRectangleParameter
        "Answer the receiver in a form suitable for passing
         as a parameter to a host system procedure call.
         Use this method when the parameter must be a
         rectangle, and cannot be nil"
    ^( WinRectangle fromRectangle: self ) asParameter!
addClipchildrenStyle
        "Add the clip children style to the receiver."
    ^self addStyle: WsClipchildren! 
destroyCaret
        "Private - Destroy the cursor."
    self isGap ifTrue: [ selectFlag := false ].
    UserLibrary destroyCaret ifFalse: [ self osNotification ]!
close
        "Private - Do nothing."!   
wmSetcursor: wParam with: lParam
        "Private - Process the set cursor message."
    | currentCursor |
    ( self helpManager notNil and: [ self mainWindow helpManager helpMode ] )
        ifTrue: [ self mainWindow helpManager setHelpCursor. ^1 ].
    lParam lowWord = Htclient ifTrue: [
        ( currentCursor := self currentCursor ) isNil ifTrue: [ ^nil ].
        currentCursor setCursor.
        ^1 ].
    ^nil! 
setCursorPos: xInteger y: yInteger
    <api: SetCursorPos long long boolean>
    ^self invalidArgument! 
wmErasebkgnd: wordInteger with: longInteger
        "Private - Process the erase background message."
    | backColor aColor oldDC |
    (backColor := self backColor) notNil
        ifTrue: [aColor := backColor]
        ifFalse: [aColor := Color windowBackground ].
    oldDC := graphicsTool privateHandle.
    graphicsTool handle: wordInteger.
    graphicsTool fill: (0 @ 0 extent: self extent)
                color: aColor.
    graphicsTool handle: oldDC.
    ^1! 
fillRect: aDisplayHandle rectangle: aByteArray brush: aHandle
    <api: FillRect ulong struct ulong long>
    ^self invalidArgument!
createDialogIndirectParam: hInstance dialogTemplate: lpDialogTemplate parent: hwndParent dialogFunction: lpDialogFunc initParam: anInteger
    <api: CreateDialogIndirectParamA ulong struct ulong ulong ulong ulongReturn>
    ^self invalidArgument!  
getDlgItemText: hDlg item: nIDDlgItem text: lpString maxCount: nMaxCount
    <api: GetDlgItemTextA ulong long struct long ulongReturn>
    ^self invalidArgument!   
pieFilled: major minor: minor angles: aPoint
        "Draw a pie wedge whose major axis is major and minor
         axis is minor. aPoint x
         is the starting angle of the arc in degrees. aPoint y is the
         sweeping angle between the starting angle and ending
         angle which goes clockwise if positive and counter-clockwise
         if negative.
         The interior of the pie is filled with the current brush."
    | startPoint endPoint boundingBox points |
    boundingBox := (self location leftAndUp: major @ minor) corner: (
        self location rightAndDown: major @ minor).
    points := self getArcPoints: major minor: minor angles: aPoint.
    startPoint := points at: 1.
    endPoint := points at: 2.
    ^self pie: boundingBox
        start: startPoint
        end: endPoint!
getDlgItem: hDlg item: nIDDlgItem
    <api: GetDlgItem ulong long ulongReturn>
    ^self invalidArgument!   
dragTargetStartScrollTimer: scroll
        "Private - start the drag scroll timer; save the scrolling direction."
    self dragTargetScrollDirection: scroll.
    self dragTargetScrollElapsed: 0.
    Time
        startTimer: self class dragTargetScrollTimerId
        period: self class dragTargetScrollInterval
        forWindow: self!
setParent: hwndChild to: hwndParent
    <api: SetParent ulong ulong ulongReturn>
    ^self invalidArgument! 
verticalScrollPos
        "Private - Answer the vertical scrollbar's position"
    | pos |
    ( pos := UserLibrary getScrollPos: self handle asParameter bar: SbVert ) = 0
        ifTrue: [ self osWarning ].
    ^pos!
selectObject: anObject
        "Select anObject into the device context and answer
          the previously selected object."
    | hPrevious |
    anObject isNil
        ifTrue: [ ^nil ]
        ifFalse: [
           self allHandles do: [ :h |
                hPrevious := GDILibrary selectObject: h with: anObject ] ].
    ^drawingMode = DrawingModeRetain
        ifTrue: [ nil ]
        ifFalse: [ hPrevious ]!  
dragTargetFormats
        "Private - answer the formats of drag objects that the receiver will accept."
    ^self propertyAt: #dragTargetFormats!   
dragSourceSelection
		"Private - answer the drag selection."
    ^self propertyAt: #dragSourceSelection!
nullEventWin
        "Private - Decode a null event.
         Answer the event type."
    | message |
    PendingEvents isEmpty
        ifFalse: [ OSEventSemaphore signal ].
    PendingEvents isEmpty
        ifTrue: [ ^self ].
    [ message := PendingEvents removeFirst ] evaluateWithoutInterrupts.
    self perform: message selector withArguments: message arguments.
    ^self!  
on: aMainWindow
        "Answer an instance of the receiver class initialized
        to refer to aMainWindow as its focus."
    ^self new
        window: aMainWindow!   
addMenus
        "Private - add the menus to the menu bar.
        Do nothing."!
addStandardRightMenus
        "Private - add any menus that should appear
        right-most in the menu bar."! 
addSystemMenus
        "Add system-specific menus to the menubar."!  
addMenus
        "Private - add the menus for the window to the
        menu bar."
    ( window propertyAt: #noSmalltalkMenuBar ) notNil
        ifTrue: [ ^self ].
    self
        addSystemMenus;
        addStandardLeftMenus;
        addApplicationMenus;
        addStandardRightMenus!   
window: aMainWindow
        "Private - set the window which this instance administrates
        policy for to aMainWindow."
    window := aMainWindow! 
addApplicationMenus
        "Private - add menus to the menu bar which should appear
        between standard left menus and standard right menus."!
addMenusTo: aWindow
        "Private - add the menus for the window <aWindow>
        to the menu bar <aMenuBar>."
    window := aWindow.
    self addMenus!  
addStandardLeftMenus
        "Private - add the menus that are to be located
        on the menu bar before any application-specific
        menus."!  
tabStop
        "Make the dialog item recieve the focus when the user
        presses the TAB key."
    self addStyle: WsTabstop!  
isOwnerDrawn
        "Answer whether the receiver is owner drawn."
    ^( self hasStyle: LbsOwnerdrawfixed )
        or: [ self hasStyle: LbsOwnerdrawvariable ]!  
selectToAuxDC
        "Private - Select the receiver into the auxiliary
        device context; answer the handle of the previously
        selected Bitmap."
    self deselect.
    self validate.
    palette notNil ifTrue: [
        ( GDILibrary
            selectPalette: AuxiliaryDC
            with: palette asParameter
            forceBackground: false ) = 0
                ifTrue: [ ^self osError ].
        ( GDILibrary realizePalette: AuxiliaryDC ) = 16rFFFFFFFF
            ifTrue: [ ^self osError ] ].
    bitmapHandle notNil
        ifTrue: [ ^GDILibrary selectObject: AuxiliaryDC with: self handle ]!  
drawFocus: aDrawStruct
        "Private - Draw the focus for an owner-drawn menu item."
    | menu |
    menu := menuWindow menuWithItemId: aDrawStruct itemId.
    menu triggerEvent: #drawFocus:
        withArguments: ( Array with: self drawIndex )
        ifNotHandled: [ super drawFocus: aDrawStruct ]!
addMinimizeButtonStyle
        "Add the minimize button style."
    ^self addStyle: WsMinimizebox!  
mainWindow
        "Answer the receiver's main window.  For example,
         if the receiver is a subpane, the main window will be an
         instance of TopPane."
    ^parent isWindow
        ifTrue: [ parent mainWindow ]
        ifFalse: [ self ]! 
location
        "Answer a Point which represents the current
         position of the pen."
    ^drawingMode = DrawingModeRetain
        ifTrue: [ location ]
        ifFalse: [ super location ]!  
dragSourceNeedsObject: dragSession
        "Private - retrieve the object to be dragged."
    | itemIndex |
    itemIndex := self itemIndexFromPoint: ( dragSession screenLocation mapToWindow: self ).
    self dragSourceSelection: itemIndex.
    ^super dragSourceNeedsObject: dragSession!  
printWith: aRecordingPen
        "Print the contents of aRecordingPen on
         the system printer."
    self new drawUsing: aRecordingPen!  
screenExtent: aPoint
        "Private - Initialize the receiver with extent aPoint."
    ^self screenWidth: aPoint x height: aPoint y!  
red: red green: green blue: blue
        "Answer an Integer which is the RGB value for
        the given amounts of red, green and blue.
        red, green and blue are Integers in the
        range 0 to 255."
    ^(blue \\ 16r100 * 16r10000) +
         (green \\ 16r100 * 16r100)  +
             (red \\ 16r100)!  
for: aDeviceContext medium: aGraphicsMedium
        "Answer a new instance of the receiver
         with aDeviceContext and associated with
         aGraphicsMedium."
    ^self forDC: aDeviceContext medium: aGraphicsMedium!   
setBackgroundMode: aBackgroundMix
        "Set the background drawing mode to aBackgroundMix,
         where aBackgroundMix is a BackgroundMixXXX
         value from GraphicsConstants."
    ^self setBackMode: aBackgroundMix!  
setForegroundMode: aMixRule
        "Set the foreground drawing mode to aMixRule,
         where aMixRule is a MixRuleXXX value from
         GraphicsConstants."
    ^self setRop2: aMixRule!
emptyRegion
        "Create an empty region and answer its handle."
    | hRgn |
    ( hRgn := GDILibrary createRectRgnX1: 0 y1: 0 x2: 0 y2: 0 ) = 0
        ifTrue: [ ^self osError ].
    ^hRgn!   
backColor: aColor
        "Set the background color of the receiver to aColor."
    | color |
    backColor := aColor.
    color := backColor isNil ifTrue: [ Color windowBackground ] ifFalse: [ backColor ].
    deviceContext notNil ifTrue: [
        self allHandles do: [ :h |
            ( GDILibrary setBkColor: h with: color asParameter ) = 16rFFFFFFFF
                ifTrue: [ ^self osError ] ] ]!
execute: aBlock clipRect: aRect
        "Set the clipping region to aRect, execute
          aBlock. Set the clipping region to nil."
    | region |
    region := self setClipRect: aRect.
    aBlock value.
    self destroyRegion: region!   
fill: aRectangle color: aColor
        "Fill aRectangle with aColor. aColor can be an RGB
        value or an index to the color palette."
    self fill: aRectangle rule: Patcopy color: aColor!  
foreColor
        "Answer the foreground color of the receiver."
    ^foreColor!
foreColor: aColor 
        "Implemented by subclass. Default is do nothing."!
extent
        "Answer aPoint which describes the width and height
         of the receiver."
    ^width @ height! 
setClipRegion: hRgn
        "Select hRgn as the current clipping region in
        the receiver."
    self allHandles do: [ :h |
        ( GDILibrary selectClipRgn: h rgn: hRgn ) = 0
            ifTrue: [ self osNotification ] ]!
handle: aDeviceContext
        "Private - Set the receiver's device context."
    deviceContext := aDeviceContext.! 
getPixelColor: aPoint
        "Answer the color value of the pixel at aPoint."
    ^GDILibrary
        getPixel: self handle
        x: aPoint x
        y: aPoint y!
addRegion: region1Handle to: region2Handle
        "Answer region2Handle with region1Handle added
         to it."
    ( GDILibrary combineRgn: region2Handle
        srcRgn1: region1Handle
        srcRgn2: region2Handle
        mode: RgnOr ) = 0
            ifTrue: [ ^self osError ].
    ^region2Handle!  
destroyRegion: aHrgn
        "Delete the region identified by aHrgn."
    self setClipRegion: nil.
    self deleteObject: aHrgn!   
initialize
        "Private - Initialize the receiver."
    location := 0 @ 0.
    width := 0.
    height := 0!   
copyBitmapFlippedHorizontally: aBitmap
        "Copy aBitmap into the receiver's medium, flipping the
        bits over horizontally."
    | srcRect destRect destinationDC isMemDC hPrevious |
    srcRect := destRect := aBitmap boundingBox.
    destinationDC := self handle.
    ( isMemDC := ( ( graphicsMedium isBitmap ) and: [
        graphicsMedium deviceContext = Bitmap memoryContext ] ) )
        ifTrue: [
            destinationDC := Bitmap auxiliaryDC.
            hPrevious := graphicsMedium selectToAuxDC ].
    aBitmap select.
    self
        stretchBlt: destinationDC
        x: destRect extent x
        y: destRect origin y
        dWidth: destRect width negated
        dHeight: destRect height
        srcDC: aBitmap deviceContext
        xSrc: srcRect origin x
        ySrc: srcRect origin y
        sWidth: srcRect width
        sHeight: srcRect height
        rop: Srccopy.
    aBitmap deselect.
    isMemDC ifTrue: [ graphicsMedium deselectFromAuxDC: hPrevious ]! 
copyBitmapFlippedVertically: aBitmap
        "Copy aBitmap into the receiver's medium, flipping the
        bits over vertically."
    | srcRect destRect destinationDC isMemDC hPrevious |
    srcRect := destRect := aBitmap boundingBox.
    destinationDC := self handle.
    ( isMemDC := ( ( graphicsMedium isBitmap ) and: [
        graphicsMedium deviceContext = Bitmap memoryContext ] ) )
        ifTrue: [
            destinationDC := Bitmap auxiliaryDC.
            hPrevious := graphicsMedium selectToAuxDC ].
    aBitmap select.
    self
        stretchBlt: destinationDC
        x: destRect origin x
        y: destRect extent y
        dWidth: destRect width
        dHeight: destRect height negated
        srcDC: aBitmap deviceContext
        xSrc: srcRect origin x
        ySrc: srcRect origin y
        sWidth: srcRect width
        sHeight: srcRect height
        rop: Srccopy.
    aBitmap deselect.
    isMemDC ifTrue: [ graphicsMedium deselectFromAuxDC: hPrevious ]! 
fill: aRectangle rule: aRopConstant color: aColor
        "Fill aRectangle in the receiver medium with aColor
         using aRopConstant. "
    | oldBrush newBrush color |
    color := aColor isNil ifTrue: [ Color windowBackground ] ifFalse: [ aColor ].
    ( newBrush :=  GDILibrary createSolidBrush: color asParameter ) = 0
        ifTrue: [ ^self osError ].
    oldBrush := self selectObject: newBrush.
    self patternFill: aRectangle
        rule: aRopConstant.
    self selectObject: oldBrush.
    self deleteObject: newBrush!  
floodFill: aPoint color: aColor fillType: floodFillType
        "Fill an area bounded by aColor at aPoint with the current brush.
        The floodFillType is a FloodFill value from GraphicsConstants."
    GDILibrary extFloodFill: self handle
        x: aPoint x
        y: aPoint y
        color: aColor asParameter
        fillType: floodFillType!  
erase
        "Fill the receiver with the background color."
    self fill: backColor!  
copyBitmap: aBitmap from: srcRect at: destPoint 
        "Copy srcRect from aBitmap to destPoint in the 
          receiver medium." 
    ^self copyBitmap: aBitmap 
         from: srcRect 
         at: destPoint 
         rule: Srccopy!
copyBitmap: aBitmap from: srcRect to: destRect
        "Copy srcRect from aBitmap to destRect in the receiver
        medium. Data will be compressed or stretched if
        the two rectangles are not the same extent."
    ^self
        copyBitmap: aBitmap
        from: srcRect
        to: destRect
        rule: Srccopy!
destroy
        "Delete the receiver and free all resources associated
         with the receiver."
    self release!  
line: aPoint
        "Private - Draw a line from the current location
        to aPoint.  Answer the new location."
    self allHandles do: [ :h |
        ( GDILibrary lineTo: h x: aPoint x y: aPoint y )
            ifFalse: [ ^self osError ] ].
    ^location := aPoint rounded!  
place: aPoint
        "Position the pen at aPoint."
    location := aPoint rounded.
    self allHandles do: [ :h |
        ( GDILibrary
            moveToEx: h
            x: location x
            y: location y
            oldPosition: nil )
                ifFalse: [ ^self osError ] ]! 
setPixel: aPoint color: aColor
        "Set the color value of the pixel at aPoint to aColor."
    GDILibrary
        setPixelV: self handle
        x: aPoint x
        y: aPoint y
        color: aColor asParameter
!   
copy: srcPen from: aRectangle at: aPoint 
        "Copy aRectangle from the scrPen medium to the 
         receiver medium at aPoint." 
     ^self copy: srcPen
          from: aRectangle
          at: aPoint
          rule: Srccopy!
copy: srcPen from: sRectangle to: dRectangle
        "Copy sRectangle from the scrPen medium to the
         receiver medium in dRectangle. Data will be stretched
         or compressed if the two rectangles are not the same
         extent."
    self
        copy: srcPen
        from: sRectangle
        to: dRectangle
        rule: Srccopy!  
copyBitmap: aBitmap from: srcRect at: destPoint rule: aRopConstant
        "Copy srcRect from aBitmap to destPoint in the
          receiver medium using aRopConstant. aRopConstant
          defines how the source is combined with the destination."
    | destinationDC isMemDC hPrevious |
    destinationDC := self handle.
    ( isMemDC := ( ( graphicsMedium isBitmap ) and: [
        graphicsMedium deviceContext = Bitmap memoryContext ] ) )
        ifTrue: [
            destinationDC := Bitmap auxiliaryDC.
            hPrevious := graphicsMedium selectToAuxDC ].
    aBitmap select.
    Bitmap
         bitBlt: destinationDC
         x: destPoint  x
         y: destPoint y
         width: srcRect width
         height: srcRect height
         srcDC: aBitmap deviceContext
         xSrc: srcRect origin x
         ySrc: srcRect origin y
         rop: aRopConstant.
    aBitmap deselect.
    isMemDC ifTrue: [ graphicsMedium deselectFromAuxDC: hPrevious ]!   
copyBitmap: aBitmap from: srcRect to: destRect rule: aRopConstant
        "Copy srcRect from aBitmap to destRect in the receiver
        medium using aRopConstant. aRopConstant defines how
        the source is combined with the destination. Data will be
        compressed or stretched if the two rectangles are not the
        same extent."
    | destinationDC isMemDC hPrevious |
    destinationDC := self handle.
    ( isMemDC := ( ( graphicsMedium isBitmap ) and: [
        graphicsMedium deviceContext = Bitmap memoryContext ] ) )
        ifTrue: [
            destinationDC := Bitmap auxiliaryDC.
            hPrevious := graphicsMedium selectToAuxDC ].
    aBitmap select.
    self
        stretchBlt: destinationDC
        x: destRect origin x
        y: destRect origin y
        dWidth: destRect width
        dHeight: destRect height
        srcDC: aBitmap deviceContext
        xSrc: srcRect origin x
        ySrc: srcRect origin y
        sWidth: srcRect width
        sHeight: srcRect height
        rop: aRopConstant.
    aBitmap deselect.
    isMemDC ifTrue: [ graphicsMedium deselectFromAuxDC: hPrevious ]!   
createRegion: aRectangle
        "Create a rectangular region from aRectangle and
          answer its handle."
    | hRgn |
    ( hRgn := GDILibrary
        createRectRgnX1: aRectangle origin x
        y1: aRectangle origin y
        x2: aRectangle corner x
        y2: aRectangle corner y ) = 0
            ifTrue: [ ^self osError ].
    ^hRgn!  
privateHandle
        "Private - Answer the receiver's deviceContext handle."
    ^deviceContext.!  
release
        "Delete the receiver and free all resources associated
         with the receiver."
    (deviceContext notNil) ifTrue: [
        self releaseAllObjects.
        (graphicsMedium isWindow)
            ifTrue: [graphicsMedium releaseDC: deviceContext]].
    deviceContext := nil!   
reverse: aRectangle 
        "Reverse the color of aRectangle." 
    ^self patternFill: aRectangle rule: Dstinvert! 
ifNilHandle: aBlock
        "If the receiver's handle is nil set it to the value of
        aBlock.  Answer whether the receiver's handle was nil."
    | int answer |
    int :=Process enableInterrupts: false.
    (answer := deviceContext isNil) ifTrue: [
        self setHandle: aBlock value].
    Process enableInterrupts: int.
    ^answer.!   
handle
        "Answer the receiver's deviceContext handle."
    deviceContext isNil
        ifTrue: [
            graphicsMedium isWindow
                ifTrue: [ self setHandle: graphicsMedium getDC ]
                ifFalse: [
                    graphicsMedium isBitmap
                        ifTrue: [ self setHandle: Bitmap memoryContext ] ] ].
    ^deviceContext.!
location
        "Answer a Point which represents the current
         position of the pen."
    | winPoint |
    graphicsMedium isStoredPicture
        ifTrue: [ ^location ].
    winPoint := WinPoint new.
    ( GDILibrary
        getCurrentPositionEx: self handle
        point: winPoint asParameter )
            ifFalse: [ ^self osError ].
   ^winPoint x @ winPoint y!
copy: srcPen from: sRectangle to: dRectangle rule: aRopConstant
        "Copy sRectangle from the scrPen medium to the
         receiver medium in dRectangle using aRopConstant.
         aRopConstant defines how the source is combined with
         the destination. Data will be stretched or compressed if
         the two rectangles are not the same extent."
    | destinationDC isMemDC hPrevious |
    destinationDC := self handle.
    ( isMemDC := ( graphicsMedium isBitmap and: [
        graphicsMedium deviceContext = Bitmap memoryContext ] ) )
        ifTrue: [
            destinationDC := Bitmap auxiliaryDC.
            hPrevious := graphicsMedium selectToAuxDC ].
    srcPen graphicsMedium isBitmap
        ifTrue: [ srcPen graphicsMedium select ].
    self
        stretchBlt: destinationDC
        x: dRectangle origin x
        y: dRectangle origin y
        dWidth: dRectangle width
        dHeight: dRectangle height
        srcDC: srcPen handle
        xSrc: sRectangle origin x
        ySrc: sRectangle origin y
        sWidth: sRectangle width
        sHeight: sRectangle height
        rop: aRopConstant.
    srcPen graphicsMedium isBitmap
        ifTrue: [ srcPen graphicsMedium deselect ].
    isMemDC
        ifTrue: [ graphicsMedium deselectFromAuxDC: hPrevious ]! 
copy: srcPen from: aRectangle at: aPoint rule: aRopConstant
        "Copy aRectangle from the scrPen medium to the
         receiver medium at aPoint using aRopConstant.
         aRopConstant defines how the source is combined with
         the destination."
    | destinationDC isMemDC hPrevious |
    destinationDC := self handle.
    ( isMemDC := ( graphicsMedium isBitmap and: [
        graphicsMedium deviceContext = Bitmap memoryContext ] ) )
        ifTrue: [
            destinationDC := Bitmap auxiliaryDC.
            hPrevious := graphicsMedium selectToAuxDC ].
    srcPen graphicsMedium isBitmap
        ifTrue: [ srcPen graphicsMedium select ].
    Bitmap
        bitBlt: destinationDC
        x: aPoint x
        y: aPoint y
        width: aRectangle width
        height: aRectangle height
        srcDC: srcPen handle
        xSrc: aRectangle origin x
        ySrc: aRectangle origin y
        rop: aRopConstant.
    srcPen graphicsMedium isBitmap
        ifTrue: [ srcPen graphicsMedium deselect ].
    isMemDC ifTrue: [ graphicsMedium deselectFromAuxDC: hPrevious ]!
dragSourceSelection: anObject
		"Private - set the drag selection to anObject.  Used to keep track of the
		originally dragged selection when cut event comes around."
    self propertyAt: #dragSourceSelection put: anObject!
disableItem: item
        "Disable an item.  item can be the label or the selector."
    | mi |
    ( self isThere: item ) ifFalse: [ ^self ].
    mi := self getMenuItem: item.
    mi hasSubmenu
        ifTrue: [ ^mi submenu disableAll ].
    ( self isDisabled: item ) ifTrue: [ ^self ].
    mi attribute: mi attribute | MfGrayed.
    self updateItem: mi attributes: MfGrayed! 
flip
        "Answer a new Bitmap which is the
         receiver flipped over vertically."
	^self flipVertically!  
dragTargetDefaultEmphasis
		"Private - answer the type of target emphasis that should be employed
		if not otherwise specified."
	^'separator'!
stretchBlt: destDC
    x: x1
    y: y1
    dWidth: dWidth
    dHeight: dHeight
    srcDC: srcDC
    xSrc: x2
    ySrc: y2
    sWidth: sWidth
    sHeight: sHeight
    rop: aRopConstant
        "Private - Call GDI stretchBlt function."
    ( GDILibrary
         stretchBlt: destDC
         x: x1
         y: y1
         dWidth: dWidth
         dHeight: dHeight
         srcDC: srcDC
         xSrc: x2
         ySrc: y2
         sWidth: sWidth
         sHeight: sHeight
         rop: aRopConstant )
            ifFalse: [ ^self osError ]!   
button1UpShift: aPoint
        "Private - The user let up on button 1 at aPoint, while the Shift key was depressed."
    self isDragSource ifTrue: [ self dragOnMove: nil location: nil ]!  
container: anOleContainerObject
        "Set the OLE Container of the receiver to <anOleContainerObject>."

    ( self container notNil and: [ anOleContainerObject notNil ] )
        ifTrue: [ self error: 'previous container not released' ].

    self propertyAt: #container put: anOleContainerObject.
    anOleContainerObject notNil
        ifTrue: [ anOleContainerObject window: self ]!  
loadBitmap: hInstance name: name
    name isString
        ifTrue: [^self loadBitmap: hInstance nameString: name]
        ifFalse: [^self loadBitmap: hInstance nameInteger: name]!
drawSegment: id
     "Draw the segment identified by id."
    self saveDC.
    (segments at: id ifAbsent: [self restoreDC. ^self])
        privateDisplayWith: self.
    self restoreDC! 
dragTargetDrawSeparatorEmphasis: aPoint
		"Private - draw the target emphasis for the receiver
		given the cursor location aPoint (relative to the receiver).
		Emphasis is drawn indicating spaces between existing
		items as individual targets."
	| index lastIndex rect |
	index := ( self itemIndexFromPoint: aPoint ) min: list size + 1.
		"only update if changed"
	lastIndex := self dragTargetSelection.
	index = lastIndex ifTrue: [ ^nil ].  "don't draw emphasis if already drawn."
	lastIndex notNil ifTrue: [ self dragTargetEraseSeparatorEmphasis ].
	rect := self lineToRect: index.
	self
		dragTargetDrawEmphasisLineFrom: rect leftTop
		to: rect rightTop.
	self dragTargetSelection: index!
subclass
        "Private - Subclass the receiver window class
         to use the Smalltalk win proc and the original
         win proc is used as the default."
    | originalProc newProc classStruct |
    classStruct := WinWindowClass new.
    ( UserLibrary
        getClassInfo: OperatingSystem hInstanceExe
        className: OperatingSystem winClassName asParameter
        wndClass: classStruct asParameter )
            ifFalse: [ ^self osError ].
    newProc := classStruct windProc.

    originalProc := UserLibrary
        getWindowLongString: self index: GwlWndproc.
    newProc = ( ExternalAddress fromString: originalProc ) asInteger
        ifTrue: [ ^originalProc ]. "already subclassed"
    UserLibrary setWindowLong: self index: GwlWndproc long: newProc.
    self propertyAt: 'oldProc' put: originalProc.
    ^originalProc!   
start
        "Start the receiver going."
    | timers nextId |
    timers := self class timers.
    nextId := 1.
    [ timers includesKey: nextId ] whileTrue: [ nextId := nextId + 1 ].
    timers at: nextId put: self.
    self id: nextId.
    ( UserLibrary
        setTimer: SystemWindow current handle
        idEvent: nextId
        elapsedTime: period
        timerFunc: nil ) = 0
            ifTrue: [ timers removeKey: nextId. self id: nil. ^self osError ]!  
saveDC
        "Save the current state of the device context."
    self allHandles do: [ :h |
        ( GDILibrary saveDC: h ) = 0 ifTrue: [ ^self osError ] ]!
wmSyskeydown: wordInteger with: longInteger
        "Private - Process the system key down message.  WM_SYSKEYDOWN is
        generated when a key is pressed while the ALT key IS DOWN."
    | event |
	( event := KeyboardInputEvent fromWmSyskeydown: wordInteger with: longInteger ) isNil ifTrue: [ ^nil ].
	self sendInputEvent: #keyboardInput: with: event.
    ^nil!   
turnOnHelpMode
        "Private - The user has clicked Shift - F1
        Turn Help Mode on and set the help cursor"
    helpMode := true.
    self setHelpCursor.!   
leftJustifiedWordWrap
        "Set and answer the window style for left justified text
		with word wrapping."
    self
        removeStyle: SsLeftnowordwrap;
        removeStyle: SsCenter;
        removeStyle: SsRight;
        addStyle: SsLeft.
    self setStyle: self style!   
circle: r
        "Draw a circle of radius r at the current location.
        The interior of the circle is not filled."
    | boundingBox hOldBrush |
    boundingBox := self location - r corner: (
        self location + r).
    hOldBrush :=
        self selectStockObject: NullBrush.
    self ellipse: boundingBox.
    self selectObject: hOldBrush!   
down
        "Set the pen down."
    downState := true.
    self selectObject: logicalTool handle! 
ellipse: major minor: minor
        "Draw an ellipse. major is half the horizontal axis and
         minor is half the vertical axis. The interior of the ellipse
         is not filled."
    | boundingBox hOldBrush |
    boundingBox := self location - (major @ minor) corner: (
        self location + (major @ minor)).
    hOldBrush := self selectStockObject: NullBrush.
    self ellipse: boundingBox.
    self selectObject: hOldBrush! 
up
        "Lift the pen up."
    downState := false.
    self selectStockObject: NullPen! 
circleFilled: r
        "Draw a circle of radius r at the current location.
        The interior of the circle is filled with the current brush."
    | boundingBox |
    boundingBox := self location - r corner: (
        self location + r).
    self ellipse: boundingBox! 
mandala: sInteger diameter: dInteger
        "Draw a mandala with sInteger number
         of sides and dInteger as the diameter."
    | vertices radius center angle |
    center := self location.
    vertices := Array new: sInteger.
    radius := dInteger // 2.
    angle := 360 // sInteger.
    self direction: 270.
    self up.
   1 to: sInteger do: [ :i |
        vertices at: i put: (self place: center; go: radius).
        self turn: angle].
   self down.
    1 to: sInteger - 1 do: [ :j |
        j + 1 to: sInteger do: [ :i |
            self
                foreColor: (GraphicsTool paletteIndex: (j  \\ 8 + 1));
                place: (vertices at: j);
                goto: (vertices at: i)]].! 
box: aPoint
        "Draw a box using the current location as one corner
          and aPoint as the opposite corner. The box is not
          filled."
    | currentPosition  |
    currentPosition := self location.
    self rectangle: (currentPosition corner: aPoint)!
dragon: anInteger
        "Draw a dragon pattern where anInteger
          is the recursion factor."
    | length |
    length := height // 100.
    anInteger = 0
        ifTrue: [
            self foreColor: (GraphicsTool paletteIndex: (
                   (ColorCount := ColorCount + 1 \\ 1600)
                         // 80 \\ 7)).
            self go: length]
        ifFalse: [
            anInteger > 0
                   ifTrue: [
                         self dragon: anInteger - 1.
                         self turn: 90.
                         self dragon: 1 - anInteger]
                    ifFalse: [
                         self dragon: -1 - anInteger.
                         self turn: -90.
                         self dragon: 1 + anInteger]]! 
box: aPoint filled: boolean1 outlined: boolean2 roundCorner: aPoint2
        "Draw a box using the current location as one corner
        and aPoint as the opposite corner. The box is filled if
        boolean1 is true and is outlined if boolean2 is true.
        aPoint2 describes the major and minor
        axes of an ellipse which defines the shape of the corners
        of the box."
    | currentPosition hOldBrush hOldPen |
    currentPosition := self location.
    boolean1
        ifFalse: [
            hOldBrush := self selectStockObject: NullBrush].
    boolean2
        ifFalse: [
            hOldPen := self selectStockObject: NullPen].
    aPoint2 isNil
        ifTrue: [
            self rectangleFilled: (currentPosition corner: aPoint)]
        ifFalse: [
            self roundRect: (currentPosition corner: aPoint)
                corner: aPoint2].
    boolean1 ifFalse: [self selectObject: hOldBrush].
    boolean2 ifFalse: [self selectObject: hOldPen]!  
setLineWidth: anInteger
        "Set the line width of the receiver to anInteger.
          Note - pens with a physical width greater than one
          pixel can only have either null or solid style
          (If the pen style is PsInsideframe then it will
          be dithered.)"
    logicalTool := WinLogicalPen
         style: logicalTool style
         color: foreColor
         width: anInteger.
    downState ifTrue: [self selectObject: logicalTool handle]!   
initialize
        "Private - Initialize the receiver."
    super initialize.
    logicalTool := WinLogicalPen
        style: nil
        color: nil
        width: nil.
    compatibleDirection := true.
    self north.
    downState := true! 
polygon: anArrayOfPoints
        "Draw the polygon whose vertices are defined by
        anArrayOfPoints.  The interior of the polygon
         is not filled."
    | hOldBrush |
    hOldBrush := self selectStockObject: NullBrush.
    self polygonFilled: anArrayOfPoints.
    self selectObject: hOldBrush.!  
ellipseFilled: major minor: minor
        "Draw an ellipse. major is half the horizontal axis and
         minor is half the vertical axis. The interior of the ellipse
         is filled with the current brush."
    | boundingBox  |
    boundingBox := self location - (major @ minor) corner: (
        self location + (major @ minor)).
    self ellipse: boundingBox! 
north
        "Set the direction of the receiver to north; if
        compatibleDirection is true (the default), use the Smalltalk
        for OS/2 sense of North = 90; otherwise use North = 270
        (which is compatible with Smalltalk for Windows 2.0
        and earlier)."
    direction := compatibleDirection ifTrue: [ 90 ] ifFalse: [ 270 ]! 
polyline: anArrayOfPoints
        "Draw a polyline."
    | array |
    array := self winPointList: anArrayOfPoints.
    ( GDILibrary
        polyline: self handle
        lpPoints: array asParameter
        count: anArrayOfPoints size )
            ifFalse: [ self osNotification ]!
go: anInteger
        "Move the pen anInteger number
         of pixels in the current direction."
    | x y roundX roundY loc |
    x := direction integerCos * anInteger.
    y := direction integerSin * anInteger.
    roundX := x + 50 // 100.
    roundY := y + 50 // 100.
    loc := self location.
    compatibleDirection
        ifTrue: [ self line: ( loc := ( loc x + roundX ) @ ( loc y - roundY ) ) ]
        ifFalse: [ self line: ( loc := ( loc x +  roundX ) @  ( loc y + roundY ) ) ].
    ^loc!  
setFillColor: aColorConstant
        "Set the background/fill color to aColorConstant."
   self setSolidBrush: aColorConstant!  
rectangle: aRectangle
        "Call GDI rectangle function."
    | hOldBrush |
    hOldBrush := self selectStockObject: NullBrush.
    self rectangleFilled: aRectangle.
    self selectObject: hOldBrush!   
south
        "Set the direction of the receiver to south; if
        compatibleDirection is true (the default), use the Smalltalk
        for OS/2 sense of South = 270; otherwise use South = 90
        (which is compatible with Smalltalk for Windows 2.0
        and earlier)."
    direction := self compatibleDirection ifTrue: [ 270 ] ifFalse: [ 90 ]!
lineWidth
        "Answer the receiver's line width."
    ^logicalTool width!   
direction
        "Answer the direction of the receiver, a number of degrees
        from 0 to 359. If compatibleDirection is true East = 0,
        South = 270; otherwise East = 0, South = 90."
    ^direction!
direction: anInteger
        "Set the direction of the receiver to anInteger number of
        degrees. If compatibleDirection is true East = 0,
        South = 270; otherwise East = 0, South = 90."
    direction := anInteger \\ 360! 
partialArc: major minor: minor angles: aPoint
        "Draw an elliptical arc. major is the width and minor is
         the height of the rectangle which bounds the arc. aPoint x
         is the starting angle of the arc in degrees. aPoint y is the
         sweeping angle between the starting angle and ending
         angle which goes clockwise if positive and counter-clockwise
         if negative."
    | startPoint endPoint boundingBox points |
    boundingBox := (self location leftAndUp: major @ minor) corner: (
        self location rightAndDown: major @ minor).
    points := self getArcPoints: major minor: minor angles: aPoint.
    startPoint := points at: 1.
    endPoint := points at: 2.
    ^self arc: boundingBox
        start: startPoint
        end: endPoint! 
goto: aPoint
        "Move the pen to aPoint."
    self line: aPoint!   
turn: anInteger
        "Change the direction of the pen anInteger number of degrees.
        If compatibleDirection is true (the default), then a positive value
        for anInteger turns counter-clockwise, a negative value turns
        clockwise; otherwise, a positive value for anInteger turns
        clockwise, a negative value turns counter-clockwise."
    direction := direction + anInteger \\ 360! 
rectangleFilled: aRect
        "Draw aRect. The interior of aRect is filled with
         the current color."
    self allHandles do: [ :h |
        ( GDILibrary rectangle: h
            x1: aRect origin x
            y1: aRect origin y
            x2: aRect corner x
            y2: aRect corner y )
                ifFalse: [ ^self osError ] ]!   
polygonFilled: anArrayOfPoints
        "Draw the polygon whose vertices are defined by
        anArrayOfPoints.  The interior of the polygon
         is filled with the current brush."
    | winPointList nPoints |
    winPointList := self winPointList: anArrayOfPoints.
    nPoints := anArrayOfPoints size.
    self allHandles do: [ :h |
        ( GDILibrary
            polygon: h
            lpPoints: winPointList asParameter
            nCount: nPoints )
                ifFalse: [ self osNotification ] ]!
setLineType: aPSConstant
        "Set the line type of the receiver to aPSConstant.
          aPSConstant can be one of the following:
          PsSolid, PsDash, PsDot, PsDashdot, PsDashdotdot,
          PsNull, PsInsideframe."
    logicalTool := WinLogicalPen
         style: aPSConstant
         color:  foreColor
         width: logicalTool width.
    downState ifTrue: [
        self selectObject: logicalTool handle]!  
font 
        "Answer the current font of the receiver." 
    ^font!
displayAll: collection from: begin to: end at: anIndex
        "Private - Display the strings from begin to end
         in collection.  The strings are displayed at anIndex
         number of characters beyond the left edge of the
         receiver medium."
    | newPoint string frame |
    frame :=  (0@0 extent: width @ height).
    self blank: (0@0 extent: width @ height).
    newPoint := (1 - anIndex * font width) @ (frame top down: font basePoint y).
    begin to: end do: [:i |
        self displayText: (string := collection at: i)
            at: newPoint.
        newPoint y: (newPoint y down: font height)]! 
align: aString at: aPoint showFrom: anInteger
        "Private - Align the beginning of aString at aPoint on the
         receiver medium, and starting from the character indexed
         by anInteger, display the rest of aString."
    | newX |
    " find the position of the starting character"
    anInteger = 1
        ifTrue: [newX := aPoint x]
        ifFalse: [
            newX := aPoint x +
                (self stringWidthOf: aString
                    at: anInteger - 1)].
    self
        lineDisplay: aString
        from: anInteger
        at: newX @ aPoint y!
displayAll: collection in: aRect 
        "Private - Display the strings in collection 
         within the boundary of aRect." 
    | newPoint string | 
    newPoint := aRect origin x @ 
        (aRect corner y - font basePoint y). 
    1 to: collection size do: [:i | 
        self displayText: (string := collection at: i) 
            at: newPoint. 
        newPoint y: newPoint y - font height]! 
stringWidthOf: aString
        "Return the width of aString
         when written using the current font."
    ^self
        stringWidthOf: aString
        at: aString size.!   
lineDisplay: aString from: index at: aPoint 
        "Display aString (starting from index) 
         at aPoint and blank rest of line." 
    index > aString size ifTrue: [ 
        self lineDisplay: '' at: aPoint. 
        ^self]. 
    self lineDisplay: (aString copyFrom: index to: aString size) 
         at: aPoint!
selfCopyToX: xInteger Y: yInteger
        "Private - Copy the contents of the receiver to
         xInteger @ yInteger.
         Normally this is used in scrolling."
    self copy: self
         from: ( 0 @ 0 extent: width @ height)
         at: xInteger @ yInteger!  
centerText: aString 
        "Write aString centered at the current location." 
    self centerText: aString at: self location! 
fontsLoaded: aDictionary
        "Private - Set the dictionary of loaded fonts."
    fontsLoaded := aDictionary!
displayText: aString from: start to: stop at: aPoint 
        "Display aString from start to stop at aPoint." 
    self displayText: (aString copyFrom: start to: ( aString size min: stop)) 
        at: aPoint!  
nextPut: aCharacter
        "Display aCharacter at the current location."
    self location x > self width ifTrue: [self cr].
    self displayText: (String with: aCharacter)! 
button2Up: aPoint
        "Private - Finish right button scroll or do popup menu."
    super button2Up: aPoint.
    self clearMouseCapture.
    self stopTimer: self class rightButtonScrollTimerId.
    Margin = 0 ifTrue: [
        self triggerEvent: #rightClicked
            ifNotHandled: [ self doPopupMenuAt: aPoint ] ]! 
dragTargetScrollDirection: aSymbol
		"Private - save the direction that scrolling is occurring."
    self propertyAt: #dragTargetScrollDirection put: aSymbol!  
oemConvert
        "Add the OEM convert style."
    ^self addStyle: EsOemconvert!   
colorChange
        "Private - Window's color has changed."
    self invalidateRect: self rectangle.
    children size ~= 0
        ifTrue: [
            children do: [:each |
                each colorChange]]! 
select: itemNumber inComboBox: itemId
        "Select itemNumber in the combo box whose id
         is itemId."
    self sendMessage: CbSetcursel item: itemId wparam: itemNumber lparam: 0!   
mapScreenToClient: aWindow
        "Map the receiver from screen coordinates to
         client-area coordinates in aWindow."
    | winPoint |
    winPoint := WinPoint fromPoint: self.
    ( UserLibrary
        screenToClient: aWindow asParameter
        point: winPoint asParameter )
            ifFalse: [ ^self osError ].
    ^winPoint asPoint.! 
setHandle: aDeviceContext
        "Set the receiver's device context
         and reset its attributes to the original ones."
    self handle: aDeviceContext.
    deviceContext notNil
            ifTrue: [self resetAttributes]!  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #changed: ;
        add: #nextLine ;
        add: #previousLine ;
        yourself! 
position
        "Answer the position of the slider on the scrollbar control."
    ^self value! 
triggerChanged
        "Private - the scroll bar position has changed."
    self triggerEvent: #changed: with: self position!   
decrementPosition
        "Decrement the current position by the current line increment."
    self position: self position - self lineIncrement!
setValue: anInteger
        "Set the position of the slider on the scrollbar control to anInteger.
        Trigger the changed event.  Answer anInteger."
    | newValue |
    newValue := anInteger isNumber
        ifTrue: [ anInteger ]
        ifFalse: [
            [ anInteger asInteger ] on: MessageNotUnderstood do: [ :e | value ] ].
    newValue := ( newValue max: self minimum ) min: self maximum.
    ( anInteger ~= self value ) ifTrue: [
        self
            position: newValue;
            triggerChanged ].
    ^anInteger! 
incrementPosition
        "Increment the current position by the current line increment."
    self position: self position + self lineIncrement!
setPosition
        "Private - Set the position of the host control."
    self implementedBySubclass!   
syncControlEvent: anEvent with: aParameter
        "Private - Process anEvent produced by the host system.
        Process events immediately to provide synchronous
        thumb movement feedback."
    | selector |
    selector := self class notifications at: anEvent ifAbsent: [ ^nil ].
    self perform: selector with: aParameter!   
minimum: minimumValue maximum: maximumValue
        "Set the minimum and maximum values (range)."
    self minimumAttribute: minimumValue.
    self maximumAttribute: maximumValue.
    self isHandleOk ifTrue: [ self setRange ]!
setRange
        "Private - update the host control's range (minimum and maximum)."
    self setMinimum; setMaximum!
initialize
        "Private - Initialize the receiver."
    super initialize.
    self
        valueAttribute: 0;
        minimumAttribute: 0;
        maximumAttribute: 100;
        lineIncrement: 1!
decrementPositionBy: anInteger
        "Decrement the current position by anInteger."
    self position: self position - anInteger! 
lineIncrement
        "Answer the line increment."
    ^lineIncrement!  
incrementPositionBy: anInteger
        "Increment the current position by anInteger."
    self position: self position + anInteger! 
lineIncrement: anInteger
        "Set the line increment to be anInteger."
    lineIncrement := anInteger!  
minimum: minimumValue maximum: maximumValue position: positionValue
        "Set the minimum and maximum values (range) and position."
    self minimumAttribute: minimumValue.
    self maximumAttribute: maximumValue.
    self valueAttribute: positionValue.
    self isHandleOk ifTrue: [ self setPositionAndRange ]!   
setMaximum
        "Private - update the host control's maximum value."
    self implementedBySubclass! 
validate
        "Private - The host window for the receiver was
         just created or recreated."
    super validate.
    self setPositionAndRange!   
maximumAttribute: anInteger
        "Private - set the maximum attribute of the receiver to anInteger."
    max := anInteger asInteger! 
minimumAttribute: anInteger
        "Private - set the minimum attribute of the receiver to anInteger."
    min := anInteger asInteger! 
position: anInteger
        "Set the position of the slider on the scrollbar control.
        Answer whether the position change was successful."
    self value: ( ( anInteger asInteger min: self maximum ) max: self minimum )! 
maximum
        "Answer the maximal value associated with the scrollbar."
    ^max! 
maximum: anInteger
        "Set the maximal value associated with the scrollbar."
    self maximumAttribute: anInteger.
    self isHandleOk ifTrue: [ self setMaximum ]!   
minimum
        "Answer the minimal value associated with the scrollbar."
    ^min! 
minimum: anInteger
        "Set the minimal value associated with the scrollbar."
    self minimumAttribute: anInteger.
    self isHandleOk ifTrue: [ self setMinimum ]!   
setMinimum
        "Private - update the host control's minimum value."
    self implementedBySubclass! 
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process tab keys."
    | virtualKey |
    ( ( virtualKey := aKeyboardInputEvent virtualKey ) notNil and: [
        ( virtualKey == TabKey or: [ virtualKey == BacktabKey ] ) ] )
            ifTrue: [ self tabKeyInput: aKeyboardInputEvent ].
    ^super keyboardInput: aKeyboardInputEvent!  
value
        "Answer the position of the slider on the scrollbar control."
    ^self valueAttribute!   
value: anInteger
        "Set the position of the slider on the scrollbar control to anInteger."
"    ( anInteger between: self minimum and: self maximum ) ifFalse: [ ^false ]."
    self valueAttribute: anInteger.
    self isHandleOk ifTrue: [ self setPosition ].
    ^true!   
setPositionAndRange
        "Private - Set the scrollbar position and range."
    self setRange.
    self setPosition! 
wmCtlcolorlistbox: wparam with: lparam
        "Private - Process set control color message;
        override implementation in Window class so that
        the listbox part's colors are set regardless of whether
        the listbox part is in the Notifier."
    ^self controlColor: wparam!   
defaultStyle
        "Answer the default group box style."
    ^BsGroupbox! 
wmChar: wordInteger with: longInteger
        "Private - Process the character input message."
    super wmChar: wordInteger with: longInteger.
    ^self wmCharResultFor: wordInteger asCharacter!
saveSegments
        "Private - Save all the segments of the receiver.
         This is done when saving the image."
    self closeSegment.
    archive := Array new: segments size.
    segments keysDo: [ :segId |
        archive at: segId put: (self getData: segId) ]!
queryText: text inListBox: itemId
        "Find the first string in the list box which matches the
        text and returns the index.  Index is 0 relative."
    ^ self
        queryText: text
        inListBox: itemId
        startingAt: -1.! 
foreColor: aColor
        "Set the foreground color of the receiver to aColor."
    foreColor := aColor.
    deviceContext notNil
        ifTrue: [^self setTextColor:
            (foreColor isNil
                ifTrue: [ Color windowText ]
                ifFalse: [foreColor])]!   
for: aWindow title: aString file: aFileName dialogs: aCollection aboutDlgClass: aboutDlg
        "Answer an instance of the receiver initialized
         for aWindow with aString as its title and whose
         help file is in aFileName (a .HLP file).  aCollection
         must contain the dialog box ids for the application.
         aboutDlg is a class which implements an open instance
         method creating the about dialog."
    ^self new
        for: aWindow
        title: aString
        file: aFileName
        dialogs: aCollection
        aboutDlgClass: aboutDlg! 
queryReplaceAtPattern
        "Private - search for the next occurrence of SearchString,
        and replace it with NewString, prompting for
        confirmation before each replace operation."
    self replace: true!
setValue: anInteger forItem: itemNumber inComboBox: itemId
        "Set the value of itemNumber to anInteger in the combo box
         whose id is itemId."
    self sendMessage: CbSetitemdata item: itemId wparam: itemNumber lparam: anInteger! 
stopTimer: anInteger forWindow: aWindow
        "Stop the timer identified by anInteger for aWindow."
    ( UserLibrary killTimer: aWindow handle idEvent: anInteger ) = 0
        ifTrue: [ ^self osError ]!  
wmHelp: wordInteger with: longInteger
        "Private - Process the Smalltalk help message."
    | focusWindow id name cParent |
    self helpManager isNil ifTrue: [ ^nil ].
    focusWindow := longInteger \\ 65536.

        "get the id of the control; if not a child of the dialog
         (e.g. the entry field in a ComboBox), get its parent"
    ( cParent := UserLibrary getParent: focusWindow ) ~= handle asInteger
        ifTrue: [ focusWindow := cParent ].
    id := UserLibrary getWindowLong: focusWindow index: GwlId.

    wordInteger = MsgfMenu
        ifTrue:[ ^super wmHelp: wordInteger with: longInteger ].
    wordInteger = MsgfDialogbox ifTrue: [
        name := self itemIds at: id ifAbsent: [ nil ].
        self helpManager displayHelp: name ]! 
isDialogTopPane
        "Answer whether the receiver is a kind of DialogTopPane."
    ^false!   
dlgDirList: hDlg
        pathName: lpPathSpec
        listboxId: nIDListBox
        staticPathId: nIDStaticPath
        fileType: wFiletype
    <api: DlgDirListA ulong ulong long long ulong long>
    ^self invalidArgument!  
dragTargetIsScrollable
        "Private - answer whether instances of the receiver are scrollable as a drag target."
    ^true! 
validate
        "Private - The host window for the receiver was
         just created or recreated."
    | aPoint |
	super validate.
    self setTabStop.
    ( aPoint := self propertyAt: #topCorner ) notNil
        ifTrue: [ self topCorner: aPoint ]!
visible
        "Answer true if the window is visible"
     ^UserLibrary isWindowVisible: self handle!  
wmNotify: wordInteger with: longInteger
        "Private - Process the WM_NOTIFY message."
    | control |
    ( control := self childAtId: wordInteger ) notNil ifTrue: [
        ^control notify: longInteger ].
    ^nil! 
printer
        "Answer a Printer whose device context has all
        the attributes selected in the print dialog."
    ^Printer fromDC: self hDCPrinter! 
open
        "Brings up a printer setup dialog. If user chose OK hDCPrinter contains a
         printer device context which should be deleted by the caller "
    | error |
    hLibrary := CommonDialogDLL current.
    self copyStruct.
    parent isWindow ifFalse: [
        parent := Notifier findWindow: WindowHandle queryActive.
        printDlgStruct hwndOwner: parent asParameter ].
    style notNil ifTrue: [ printDlgStruct flags: style ].
    ( hLibrary printDlg: printDlgStruct asParameter )
        ifTrue: [ self checkFlags ]
        ifFalse: [
            error := ( ExternalLong fromString: hLibrary commDlgExtendedError ) asInteger.
            error ~= 0 ifTrue: [
                self cleanUp.
                error = 4104  "PDERR_NODEFAULTPRN"
                    ifTrue: [ ^self ].
                ^self osError: error ].
            ( hDevMode ~= printDlgStruct hDevMode )
                ifTrue: [ self checkFlags.  hDCPrinter = 0 ifTrue: [ hDCPrinter := nil ] ] ].
    self cleanUp.!   
wmHelp: helpType with: hwnd
        "Private - Process the Smalltalk help message."
    ( self handlesEvent: #help ) ifTrue: [ self event: #help. ^nil ].
    ( self hasActionForEvent: #help ) ifTrue: [ self triggerEvent: #help. ^nil ].
	^super wmHelp: helpType with: hwnd!  
getMenuItemId: anInteger position: posInteger
    <api: GetMenuItemID ulong long ulongReturn>
    ^self invalidArgument!
isDlgButtonChecked: hDlg buttonID: nIDButton
    <api: IsDlgButtonChecked ulong long ulongReturn>
    ^self invalidArgument!
initializeSystemCursors
        "Private - initialize the stock system cursors."
    | constants |
    constants := OrderedCollection new
        add: ( Association key: 'HourGlass' value: IdcWait );
        add: ( Association key: 'Arrow' value: IdcArrow );
        add: ( Association key: 'Text' value: IdcIbeam );
        add: ( Association key: 'CrossHair' value: IdcCross );
        add: ( Association key: 'Origin' value: IdcSizenesw );
        add: ( Association key: 'SizeWe' value: IdcSizewe );
        add: ( Association key: 'SizeNs' value: IdcSizens );
        add: ( Association key: 'SizeNesw' value: IdcSizenesw );
        add: ( Association key: 'SizeNwse' value: IdcSizenwse );
        yourself.
    constants do: [ :assoc |
        CursorConstants
            at: assoc key
            put: ( self new handle: ( self getWinCursor: assoc value asParameter ) ) ].
    CursorConstants at: 'Normal' put: self new.
    Cursor := Normal!  
sizeLeftTop
        "Return the northwest and southeast cursor."
    ^SizeNwse! 
sizeRightTop
        "Return the northeast and southwest cursor."
    ^SizeNesw!
text 
        "Answer the i-beam cursor." 
   ^Text!
dragDropLink
        "Answer the instance of the receiver class used
        to indicate a drag-drop link."
    ^DragDropLink! 
dragDropMove
        "Answer the instance of the receiver class used
        to indicate a drag-drop move."
    ^DragDropMove! 
dragDropNone
        "Answer the instance of the receiver class used for
        signaling an invalid drag-drop target."
    ^DragDropNone!
sizeVertical
        "Return the north and south cursor."
    ^SizeNs!  
arrow 
        "Answer the arrow cursor." 
    ^Arrow!  
origin 
        "Answer the origin cursor." 
    ^Origin!   
dragDropCopy
        "Answer the instance of the receiver class used
        to indicate a drag-drop copy."
    ^DragDropCopy! 
startUp
        "Private - Fill the Cursors dictionary with available cursors."
    self
        initializeSystemCursors;
        initializeSmalltalkCursors! 
execute 
        "Answer the hour glass cursor." 
    ^HourGlass!   
normal
        "Answer the default cursor."
   ^Normal! 
sizeHorizontal
        "Return the west and east cursor."
    ^SizeWe!  
current
        "Answer the current instance of the receiver class."
    ^Cursor!   
current: aCursorManager
        "Set the current instance of the receiver class to aCursorManager."
    Cursor := aCursorManager!   
write
        "Answer a cursor to display when writing data to disk;
        for VMAC compatibility."
    ^self execute!   
handle
        "Private - Answer the receiver's system handle."
    ^handle!
hide
        "Hide the cursor from the screen; 
        answer the hide/show level of the cursor."
    ^self showCursor: false!
isCursor
        "Answer true if receiver is a kind of CursorManager."
    ^true!   
display
        "Display the receiver on the screen; answer the
        hide/show level of the cursor."
    ^self showCursor: true!
change
        "Change the current Cursor to be the receiver."
    Cursor hide.
    Cursor := self.
    self setCursor.
    Cursor display!  
handle: aHandle
        "Private - Set the receiver's handle to aHandle."
    handle := aHandle!
offset
        "Answer the current mouse position.
         Retained for compatibility."
    ^self sense!  
sense
        "Answer the current mouse cursor position."
    ^self class cursorPosition!   
changeFor: aBlock
        "Change the current Cursor to the receiver
         for the duration of the executing aBlock."
    | old |
    Cursor == self ifTrue: [ ^aBlock value ].
    old := Cursor.
    Cursor := self.
    self setCursor.
    aBlock ensure: [
        Cursor := old.
        old setCursor ]!  
deleteObject: gdiObject
        "Delete the gdiObject from memory thus freeing all
         system storage associated with the gdiObject."
    gdiObject isNil ifTrue: [ ^self ].
    ( StockObjects includes: gdiObject ) ifFalse: [
        ( GDILibrary deleteObject: gdiObject ) ifFalse: [ ^self osError ] ]!   
forceSelectionOntoDisplay
        "Force the beginning of the selection to
         appear on the display screen."
    | lineIndex topLineIndex bottomLineIndex middleIndex |
    lineIndex := ( self pointFromIndex: selection x ) y.
    topLineIndex := self topCorner y.
    bottomLineIndex := topLineIndex + self charsInColumn - 1.
    ( lineIndex < topLineIndex or: [ lineIndex > bottomLineIndex ] )
        ifTrue: [
            middleIndex := lineIndex - ( self charsInColumn // 2 ).
            self topCorner: 1 @ middleIndex ]!
drawControl: aDrawStruct
        "Private - Process a request to draw a user
         drawn menu item."
    | return pen oldDC |
    return := 0.
    pen := self ownerDrawPen.
    oldDC := pen privateHandle.
    pen handle: aDrawStruct hDC.
    self ownerDrawStruct: aDrawStruct.
    aDrawStruct itemActionDrawEntireItem ifTrue: [
        self drawItem: aDrawStruct.
        aDrawStruct itemIsSelected
            ifTrue: [ self drawHighlight: aDrawStruct ].
        aDrawStruct itemHasFocus
            ifTrue: [ self drawFocus: aDrawStruct ].
        return := 1 ].
    aDrawStruct itemActionSelect ifTrue: [
        aDrawStruct itemIsSelected
            ifTrue: [ self drawHighlight: aDrawStruct ]
            ifFalse: [ self drawItem: aDrawStruct ].
        return := 1 ].
    aDrawStruct itemActionFocus ifTrue: [
        self drawFocus: aDrawStruct.
        return := 1 ].
    self ownerDrawStruct: nil.
    pen handle: oldDC.
    ^return!  
defaultForeColor
        "Answer the default foreground color for windows of
         this class."
    ^Color windowText!  
hidePrintToFile
        "Hides the dialog's Print to file check box ."
    self style: ( self style | PdHideprinttofile )!  
dragTargetEraseSeparatorEmphasis
		"Private - erase the previously drawn separator emphasis."
	| lastIndex pt |
	lastIndex := self dragTargetSelection.
	pt := selection bitCoordinate: lastIndex.
	self dragTargetDrawEmphasisCaretFrom: pt to: ( pt down: self font height )!  
contextForPopup: anInteger
        "Private - answer nil because DialogBoxes do not have
        a menu bar."
    ^nil!
dragSourceCutDefault: dragSession
        "Private - provide default source cut if no handler is provided
        by removing the selected element from contents."
    | c selectedIndex cutIndex topIndex |
	topIndex := self topCorner y.
	cutIndex := self dragSourceSelection.
	c := self contents asOrderedCollection.
    c removeIndex: cutIndex.
    self contents: c asArray.
	dragSession target == self
		ifTrue: [
			selectedIndex := self selection.
			cutIndex < selectedIndex ifTrue: [ selectedIndex := selectedIndex - 1 ].
			self selection: selectedIndex ]
		ifFalse: [ self selection: nil ].
	self topCorner: self topCorner x @ topIndex!
basicStyle
        "Private - Answer an Integer with appropriate
         constants combination for basic control style."
    ^WsChild | WsVisible!
sizeInBytes
    ^28! 
hwnd: anInteger
    self uLongAtOffset: 0 put: anInteger!
lparam
    ^self longAtOffset: 12!   
hwnd
    ^self uLongAtOffset: 0! 
time
    ^self uLongAtOffset: 16!
msg
    ^self uLongAtOffset: 4!  
msg: anInteger
    self uLongAtOffset: 4 put: anInteger! 
scanCode
    ^self byteAtOffset: 14! 
wparam
    ^self uLongAtOffset: 8!   
pt
    ^WinPoint usingBytes: ( self bytesAtOffset: 20 count: WinPoint sizeInBytes )! 
lparam: anInteger
    self longAtOffset: 12 put: anInteger!  
wparam: anInteger
    self uLongAtOffset: 8 put: anInteger!  
initialize
        "Private - Initialize the receiver.  Set the default
        framing block to all of the outer frame."
    super initialize.
    self framingBlock: [ :frame | frame ].
    topCorner := self initialTopCorner!   
removeBorderStyle
        "Remove the border style from the receiver."
    ^self removeStyle: WsBorder! 
insertMenu: aMenuHandle
    position: positionInteger
    flags: anInteger
    id: idInteger
    contentsInt: aBitmapHandle
        "Private - Perform the Win InsertMenu function.  This
         api call only handles bitmap handles."
    <api: InsertMenuA ulong ulong ulong ulong ulong boolean>
    ^self invalidArgument! 
asIndexedColor
        "Answer the palette index for the color closest to the receiver,
        using the system palette."
    | hPalette |
    hPalette := GDILibrary getStockObject: DefaultPalette.
    ^self asIndexedColorForPalette: hPalette! 
setFocus
        "Set the focus to the receiver; to emulate behavior of the
        Dialog Manager, which selects a radio button when the focus
        is received (such as when navigated into via keyboard),
        simulate clicking in the receiver."
    ( self disabled or: [ self isHidden ] )  ifTrue: [ ^self ].
    self value
		ifTrue: [ super setFocus ]
		ifFalse: [
            UserLibrary sendMessage: handle msg: WmLbuttondown wparam: 0 lparam: 0.
            UserLibrary sendMessage: handle msg: WmLbuttonup wparam: 0 lparam: 0 ]!
registerClipboardFormat: formatName
    <api: RegisterClipboardFormatA struct ulongReturn>
    ^self invalidArgument!   
smallExtent
        "Answer the extent (a Point) of a small icon."
    ^OperatingSystem smallIconSize!  
handle
        "Private - Answer the metafile handle."
    ^hMetaFile!  
getWindowLong: aWindowHandle index: anInteger
    <api: GetWindowLongA ulong long long>
    ^self invalidArgument!  
dragSourceCut: dragSession
        "Private - the drag drop transfer that was just completed
        requires that the source object be cut (move operation)."
	self isDragSource ifFalse: [ ^nil ].
    self
        triggerEvent: #dragSourceCut:
        withArguments: ( Array with: dragSession )
        ifNotHandled: [ self dragSourceCutDefault: dragSession ]!   
defaultStyle
        "Private - Answer an Integer with appropriate styles in it."
    ^WsBorder |
        WsVscroll |
        WsClipsiblings! 
sizeInBytes
    ^4!  
accelArray: aChar accelBits: afBits
        "Private - Answer the accelerator array for aChar with afBits."
    ( aChar isCharacter )
        ifTrue: [ ^Array
            with: ( UserLibrary vkKeyScan: aChar asciiValue ) \\ 256
            with: afBits ]
        ifFalse: [ ^Array with: aChar with: afBits ]!
iconInformation
        "Specify an information icon."
    style := style | MbIconinformation!  
sizeInBytes
         "Private - Answer the default size in bytes."
    ^48! 
itemData
        "Private - Answer the item data."
    ^self uLongAtOffset: 44! 
itemActionDrawEntireItem
        " Answer whether this is a request to draw the
        entire item, with selection and focus. "
    ^(self itemAction & OdaDrawentire) = OdaDrawentire!   
itemHasFocus
        "Answer whether the item has the input focus."
    ^(self itemState & OdsFocus) = OdsFocus!
ctlType
        "Private - Answer the control type."
    ^self uLongAtOffset: 0!
itemIsSelected
        " Answer whether the item is selected. "
    ^(self itemState & OdsSelected) = OdsSelected!  
boundingBox
        "Private - Answer a Rectangle delimiting item area."
    ^self rcItem asRectangle!  
itemState
        "Private - Answer the item state."
    ^self uLongAtOffset: 16!   
hDC
        "Private - Answer a display context for the control to be drawn."
    ^self uLongAtOffset: 24!  
hwndItem
        "Private - Answer the item handle."
    ^self uLongAtOffset: 20!   
itemIsDisabled
        " Answer whether the item is disabled. "
    ^(self itemState & OdsDisabled) = OdsDisabled!  
rcItem
        "Private - Answer a WinRectangle delimiting item area."
    ^WinRectangle usingBytes:
        ( self bytesAtOffset: 28 count: WinRectangle sizeInBytes )!   
rcItemLeft
        "Private - Answer the frame left."
    ^self rcItem xLeft!   
itemId
        "Private - Answer the item id."
    ^self uLongAtOffset: 8!  
rcItemRight
        "Private - Answer the frame right."
    ^self rcItem xRight!
rcItemTop
        "Private - Answer the frame top."
    ^self rcItem yTop!  
ctlId
        "Private - Answer the control id of the control to be drawn."
    ^self uLongAtOffset: 4! 
rcItemBottom
        "Private - Answer the frame bottom."
    ^self rcItem yBottom! 
itemAction
        "Private - Answer the item action."
    ^self uLongAtOffset: 12! 
itemActionFocus
        " Answer whether the item action is focus. "
    ^(self itemAction & OdaFocus) = OdaFocus!  
itemActionSelect
        " Answer whether the item action is select. "
    ^(self itemAction & OdaSelect) = OdaSelect!  
defaultDrawFocus: aDrawStruct
        "Private - Default is to do nothing"!  
insertMenu: aMenuHandle
    position: positionInteger
    flags: anInteger
    id: idInteger
    contents: stringOrBitmapHandle
        "Private - Perform the Win InsertMenu function."
    ^stringOrBitmapHandle isInteger
        ifTrue: [ self insertMenu: aMenuHandle position: positionInteger flags: anInteger id: idInteger contentsInt: stringOrBitmapHandle ]
        ifFalse: [ self insertMenu: aMenuHandle position: positionInteger flags: anInteger id: idInteger contentsStruct: stringOrBitmapHandle ]! 
refreshAll
        "Private - Make the entire pane to be
         the pending change."
    rectangle isNil ifTrue: [^self].
    changedArea := TextSelection
        origin: topCorner
        corner: (rectangle extent //
            self font charSize + topCorner
                max: textHolder extent).!  
devNamesFromAddress: anExternalAddress
        "Private - answer the DEVNAMES SelfDefinedStructure"
    | struct devNames defs value offset |
    struct := SelfDefinedStructure named: 'DEVNAMES' atAddress: anExternalAddress.
    devNames := SelfDefinedStructure named: 'DEVNAMES'.
    devNames definition: ( defs := devNames definition copy ).

    "update the structure definition to handle variable size fields."

    value := ( defs at: #dnDriver ) copy.
    value at: 1 put: ( offset := struct wDriverOffset ).
    value at: 2 put: ( String fromAddress: anExternalAddress + offset ) size.
    defs at: #dnDriver put: value.
    defs at: #dnDriver, ':' asSymbol put: value.

    value := ( defs at: #dnDevice ) copy.
    value at: 1 put: ( offset := struct wDeviceOffset ).
    value at: 2 put: ( String fromAddress: anExternalAddress + offset ) size.
    defs at: #dnDevice put: value.
    defs at: #dnDevice, ':' asSymbol put: value.

    value := ( defs at: #dnOutput ) copy.
    value at: 1 put: ( offset := struct wOutputOffset ).
    value at: 2 put: ( String fromAddress: anExternalAddress + offset ) size.
    defs at: #dnOutput put: value.
    defs at: #dnOutput, ':' asSymbol put: value.

    defs at: #sizeInBytes put: ( value at: 1 ) + ( value at: 2 ) + 1.
    devNames contents: ( ByteArray new: ( defs at: #sizeInBytes )).
    ^devNames fillFromAddress: anExternalAddress.!   
fileName
        "Answer the receiver's file name."
    ^'GDI32'!   
getCurrent
        "Private - get (open) an instance of the receiver."
    ^GDILibrary! 
createCompatibleDC: aDeviceContext
        "Private - call the CreateCompatibleDC API."
    | hDC |
    ( hDC := GDILibrary createCompatibleDC: aDeviceContext ) = 0
        ifTrue: [ ^self osError ].
    ^hDC!
getDC: aWindowHandle
    <api: GetDC ulong ulongReturn>
    ^self invalidArgument!  
windowClass
        "Private - Answer the window class of GraphPane."
    | className wndClass address answer |

    className := 'VGraph'.
    wndClass := WinWindowClass new.
    answer := UserLibrary getClassInfo: OperatingSystem hInstanceExe
        className: className asParameter
        wndClass: wndClass asParameter.
    answer ifTrue: [ ^className ].
    UserLibrary getClassInfo: OperatingSystem hInstanceExe
        className: Window windowClass asParameter
        wndClass: wndClass asParameter.
    address := ExternalAddress copyToNonSmalltalkMemoryZ: className.
    wndClass style: CsOwndc | CsDblclks | CsVredraw | CsHredraw;
        className: address asParameter;
        hIcon: 0;
        hBrush: 0.
    ( UserLibrary registerClass: wndClass asParameter ) = 0
        ifTrue: [ ^self osError ].
    address free.
    ^className!
windowClass
        "Private - Answer the receiver's window class."
    ^'BUTTON'!  
wmStcallback
        "Private - answer the message number for the WM_STCALLBACK
        message."
    | id |
    WmStcallback isNil ifTrue: [
        ( id := UserLibrary registerWindowMessage: 'WM_STCALLBACK' asParameter ) = 0
            ifTrue: [ ^self osError ].
        WmStcallback := id ].
    ^WmStcallback!
asWindowHandle
        "Answer the receiver as a WindowHandle.  This is
         typically used on a return value from an API call,
         which is a 4 byte String."
    ^WindowHandle fromBytes: self!
doWithNoMessageProcessing: aBlock
        "Evaluate aBlock without allowing any messages from Windows
         to be processed. Ctrl-Break will NOT work during evaluation."
    | oldCount |
    oldCount := Notifier setPeekCount: -1.
    aBlock ensure: [ Notifier setPeekCount: oldCount ]! 
releaseReadOnly
        "Private - Release the receiver from memory."

    hLibrary notNil ifTrue: [
        ( KernelLibrary freeLibrary: hLibrary asParameter )
            ifFalse: [ ^self osError ] ].
    hIcon := nil.
    hLibrary:=nil.!   
dragTargetDrop: dragSession
        "Private - handle the drop of a dragged object."
    self isDragTarget ifFalse: [ ^nil ].
    self dragTargetStopScrollTimer.
    dragSession targetEraseEmphasis.
    self
        triggerEvent: #dragTargetDrop:
        withArguments: ( Array with: dragSession )
        ifNotHandled: [ self dragTargetDropDefault: dragSession ]!  
charWidth: aCharacter
        "Answer the width of aCharacter."
    ^self charWidth: aCharacter 
		graphicsTool: graphicsMedium pen!   
disable
        "Enable the receiver and all its children.  Reimplemented
        here to support proper disabled ui behavior."
    super disable.
    self isHandleOk ifFalse: [ ^self ].
    self propertyAt: #enabledColor put: graphicsTool foreColor.
    graphicsTool foreColor: Color buttonShadow.
    self display!   
display
        "Private - Display the receiver pane contents."
    firstTime
        ifTrue: [
            self update.
            firstTime := false ]
        ifFalse: [ self displayWindow ]!  
showHorizontalScrollBar: aBoolean
        " Hide or show the horizontal scroll bar on the receiver,
        according to aBoolean. "
    UserLibrary
        showScrollBar: self handle asParameter
        bar: SbHorz
        show: aBoolean! 
wmCommand: wordInteger with: longInteger
        "Private - Process the command message."
    | control |
    ( self helpModeCommand: wordInteger ) notNil ifTrue: [ ^0 ].
    ( longInteger > 0 or: [ self isDialogTopPane ] )
        ifTrue: [                    "= 0 for 'enter' key"
            ( wordInteger == Idcancel and: [ longInteger == 0 ] )
                ifTrue: [ self sendInputEvent: #close. ^nil ].  "cancel"
            control :=  self childAtId: wordInteger lowWord.
            control notNil
                ifTrue: [ control syncControlEvent: wordInteger highWord with: longInteger ] ]
        ifFalse: [
            self sendInputEvent: #performMenuItem:
                with: wordInteger lowWord ].
    ^nil!   
new
		"Answer a new instance of the receiver."
	^super new initialize!  
button1Move: aPoint
        "Private - The user moved the mouse to aPoint
         while holding down button 1."
    | sourceLocation |
    ( self isDragSource and: [ self dragOnMove and: [ self isDragSourceInitiation: aPoint ] ] ) ifTrue: [
        "commit the current selection before drag clients are notified."
        self notifySelected: 0.  "parameter ignored"
        "start the drag-drop"
        sourceLocation := self dragSourceLocation.
        self dragOnMove: nil location: nil.
        self doDragDropAt: sourceLocation button: 1 ]! 
addBorderStyle
        "Add the border style to the receiver."
    ^self addStyle: WsBorder!
defaultColorClass
        "Private - answer the class of Colors which are returned by default
        when a fixed color (such as blue) is requested."
    ^self!  
index: anInteger
        "Answer an instance of the receiver class with the given index."
    ^self new index: anInteger!   
enableMenuItem: hMenu item: uItem flags: fuFlags
    <api: EnableMenuItem ulong ulong ulong boolean>
    ^self invalidArgument! 
asIndexedColor
        "Answer an instance of IndexedColor created from the receiver."
    ^IndexedColor index: self!   
id
        "Private - Answer the receiver's menu handle"
    ^nil!  
wmParentnotify: wordInteger with: longInteger
        "Private - process the WM_PARENTNOTIFY message."
    | point |
    self container isNil ifTrue: [ ^super wmParentnotify: wordInteger with: longInteger ].
    ( wordInteger bitAnd: WmLbuttondown ) = WmLbuttondown ifTrue: [
        point := Point fromInteger: longInteger.
        Notifier postInputEvent: ( Message new
            receiver: self container;
            selector: #deactivateInPlaceObject: ;
            arguments: ( Array with: point ) ) ].
    ^nil! 
wmDrawitem: wparam with: lparam
        "Private - Render the requested control and/or item."
    | aStruct receiver |
    aStruct := WinDrawItemStruct atAddress:
        ( ExternalAddress fromInteger: lparam ).
    receiver := aStruct ctlType = OdtMenu
        ifTrue: [ self ] ifFalse: [ self childAtId: aStruct ctlId ].
    ^receiver drawControl: aStruct! 
extent: aPoint
        "Answer a Bitmap with extent aPoint."
    ^self new extent: aPoint!  
sendMessageInt: aWindowHandle
        msg: msgInteger
        wparam: wordInteger
        lparamStruct: longInteger
    <api: SendMessageA ulong ulong ulong struct long>
    ^self invalidArgument! 
ownerDrawVariable
        "Set and answer the owner draw variable item height style for list box."
    ^self addStyle:
        WsVscroll | WsBorder | LbsNointegralheight |
        LbsHasstrings | LbsOwnerdrawvariable | LbsNotify! 
dragTargetEmphasis
		"Private - answer the type of target emphasis that should be employed.
		anEmphasisType may be either 'pane', 'item', or 'separator'."
	^self propertyAt: #dragTargetEmphasis ifAbsent: [ self dragTargetDefaultEmphasis ]!   
releaseCapture
    <api: ReleaseCapture boolean>
    ^self invalidArgument! 
getWindowPlacement: aWindowHandle placement: aByteArray
    <api: GetWindowPlacement ulong struct boolean>
    ^self invalidArgument!   
enumWindows: callback lparam: lparam
    <api: EnumWindows ulong long boolean>
    ^self invalidArgument!   
createDialogIndirect: hInstance dialogTemplate: lpDialogTemplate parent: hwndParent dialogFunction: lpDialogFunc
    ^self createDialogIndirectParam: hInstance dialogTemplate: lpDialogTemplate parent: hwndParent dialogFunction: lpDialogFunc initParam: 0!   
ownerDraw
        "Answer an instance of the receiver where
         the owner will be notified to draw each item."
    ^self new ownerDrawFixed; yourself!
defaultFont
        "Answer the default font for the receiver."
    ^ListFont!  
cutSelection
        "Copy current selection to the clipboard then
        delete it from the text."
    self resetUndo.
    self isHandleOk ifTrue: [ 
        UserLibrary
            sendMessage: handle
            msg: WmCut
            wparam: 0
            lparam: 0 ]!
searchBackOld
        "Private - Search backward for the previous
        occurrence of the search string.  Select the
        new occurrence."
    self search!  
setBrushStyle: aStyle color: aColor hatch: hatch
        "Set the background brush to requested attributes.
         aStyle can be BsDibpattern, BsHatched, BsHollow,
         BsPattern, or BsSolid (default when nil).
         aColor is the brush color.
         If aStyle is BsHatched, then hatch can be HsBdiagonal,
         HsCross, HsDiagcross, HsFdiagonal, HsHorizontal,
         or HsVertical.`"
    ^self selectObject: (logicalBrush :=
        WinLogicalBrush style: aStyle color: aColor hatch: hatch)
            handle! 
topPaneClass
        "Private - Answer the default top pane class."
    ( Smalltalk includesKey: #MDISystem ) ifFalse: [ ^TopPane ].
    Smalltalk isRunTime ifFalse: [
        ( Smalltalk at: #MDISystem ) isActive
            ifTrue:[ ^Smalltalk at: #MDIChild ] ].
    ^TopPane!  
fromHandle: handle style: style
        "Private - answer a new instance of the receiver class or one
        of its subclasses, based on the given window handle and style."
    | class |
    ( style & SsIcon = SsIcon )
        ifTrue: [ class := StaticGraphic ]
        ifFalse: [
            ( style & SsWhiterect = SsWhiterect ) |
            ( style & SsWhiteframe = SsWhiteframe ) |
            ( style & SsGrayrect = SsGrayrect ) |
            ( style & SsGrayframe = SsGrayframe ) |
            ( style & SsBlackrect = SsBlackrect ) |
            ( style & SsBlackframe = SsBlackframe )
                ifTrue: [ class := StaticBox ]
                ifFalse: [ class := StaticText ] ].

    ^class handle: ( WindowHandle fromInteger: handle )!
dragTargetSelection: anObject
		"Private - set the last selection over which the mouse was dragged
		during a drag-drop transfer to anObject."
	self propertyAt: #dragTargetSelection put: anObject!   
dragTargetSetScrollDefault: dragSession
        "Private - set the drag scrolling state in response to
        the mouse being moved over the receiver."
    | rect pos scroll lastTime |
    dragSession supportsScrolling ifFalse: [ ^nil ].
    self class dragTargetIsScrollable ifFalse: [ dragSession scroll: false. ^nil ].
    pos := dragSession targetLocation.
    rect := self dragTargetNoScrollRectangle.
        "set the scroll code for visual feedback"
    ( pos x isLeftOf: rect left ) ifTrue: [ scroll := #left ].
    ( pos x isRightOf: rect right ) ifTrue: [ scroll := #right ].
    ( pos y isAbove: rect top ) ifTrue: [ scroll := #up ].
    ( pos y isBelow: rect bottom ) ifTrue: [ scroll := #down ].
    dragSession scroll: scroll notNil.
        "setup the receiver for drag scrolling (after timer elapses)"
    scroll isNil
        ifTrue: [
            dragSession isLocalDragDropSession
                ifTrue: [ self dragTargetStopScrollTimer ]
                ifFalse: [
                    self dragTargetScrollDirection: nil.
                    self dragTargetScrollElapsed: nil ] ]
        ifFalse: [
            dragSession isLocalDragDropSession
                ifTrue: [ self dragTargetStartScrollTimer: scroll ]
                ifFalse: [
                    lastTime := self dragTargetScrollElapsed.
                    ( lastTime isNil or: [ lastTime = 0 ] )
                        ifTrue: [
                            self dragTargetScrollDirection: scroll.
                            self dragTargetScrollElapsed: Time millisecondClockValue ]
                        ifFalse: [
                            Time millisecondClockValue - lastTime > self class dragTargetScrollDelay
                                ifTrue: [ self dragTargetDoGlobalScroll: dragSession ] ] ] ]!  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #aboutToSave ;
        add: #changed: ;
        add: #controlTabbed ;
        add: #saved ;
        yourself!  
leftButtonScrollInterval
        "Private - answer the interval (in milliseconds) for the timer used
		to process left button scrolling."
    ^30! 
defaultFont
        "Private - Answer the default font for the pane."
    ^TextFont!
leftButtonScrollTimerId
        "Private - answer the ID of the timer to use to process left button scrolling."
    ^1! 
searchString: aString
        "Set the search string to aString."
    SearchString := aString.
    Forward := true.
    PriorCommand := #searchOld!   
evaluating
        "Private - answer whether the current compilation is an evaluation."
    ^self propertyAt: #evaluate ifAbsent: [ false ]!
initMenu
        "Private - Initialize the edit menu."
    | editMenu bracketMenu |
    self mainWindow menuWindow isNil ifTrue: [ ^self ].
    ( editMenu := self mainWindow menuWindow menuTitled: 'Edit' ) isNil
        ifTrue: [ ^self ].
    ( editMenu isThere: 'Brackets' )
        ifTrue: [ bracketMenu := ( editMenu getMenuItem: 'Brackets' ) submenu ].
    ( Clipboard containsText and: [ self isReadOnly not ] )
        ifTrue: [ editMenu enableItem: #pasteSelection ]
        ifFalse: [ editMenu disableItem: #pasteSelection ].
    self isReadOnly
        ifTrue: [
            editMenu
                disableItem: #undo;
                disableItem: #restore.
            bracketMenu notNil
                ifTrue: [ bracketMenu disableAll; enableItem: #matchBracketChars ] ]
        ifFalse: [
            editMenu
                enableItem: #undo;
                enableItem: #restore.
            bracketMenu notNil ifTrue: [ bracketMenu enableAll ] ].
    ( self selectedString size > 0 and: [ self isReadOnly not ] )
        ifTrue: [
            editMenu
                enableItem: #cutSelection;
                enableItem: #clearSelection ]
        ifFalse: [
            editMenu
                disableItem: #cutSelection;
                disableItem: #clearSelection ].
    self selectedString size > 0
        ifTrue: [ editMenu enableItem: #copySelection ]
        ifFalse: [ editMenu disableItem: #copySelection ]!  
selectBefore: pointOrInteger
        "Place the gap selection before pointOrInteger."
    ^pointOrInteger isInteger
        ifTrue: [ self selectFrom: pointOrInteger to: pointOrInteger - 1. selection ]
        ifFalse: [ selection selectBefore: pointOrInteger ]!
noChanges
        "Private - Set pending changes to nil."
    changedArea := nil!   
search
        "Private - Search for the selected
         string or prompted string if the
         selection is a gap selection.
         Answer the selection containing
         the string."
    PriorCommand := #searchOld.
    self searchInit isNil
        ifTrue: [^selection].
    ^newSelection := self searchOld!   
textFont: aFont
        "Set the receiver's font and the text pane
        font of all children to aFont."
    self font: aFont.
    super textFont: aFont.
    self invalidateRect: nil!
cursorUpKeyInput: aKeyboardInputEvent
        "Private - process an up arrow keystroke."
    | new |
    new := selection origin.
    new y = 1 ifTrue: [ ^new ].
    self font fixedWidth
        ifTrue: [ new := new - ( 1 @ 1 ) ]
        ifFalse: [
            new := selection bitCoordinate: new.
            new := new leftAndUp: ( 0 @ self font height ).
            new := self stringCoordinate: new.
            new := new - ( 1 @ 0 ) ].
    ^new!  
searchBack
        "Private - Search backwards for the
         selected string or prompted string
         if the selection is a gap selection.
         Answer the selection containing the
         string."
    PriorCommand := #searchBackOld.
    self searchInit isNil
        ifTrue: [^selection].
    ^newSelection := self searchBackOld! 
losingFocus
        "Private - The receiver is losing focus. "
    | value |
    ( self hasActionForEvent: #changed: )
        ifTrue: [
            value := self value.
            value ~= self previousValue
                ifTrue: [
                    self
                        triggerChanged;
                        previousValue: value ].
            ^self ].
    ^super losingFocus! 
update
        "Refresh the receiver from its owner and redisplay."
    self doGraphics: [self reinitialize]!   
currentCursor
        "Private - Answer the mouse cursor that's
         appropriate for the receiver window."
    ^( self isDragSource and: [ self selectionIncludesPoint: ( self characterCoordinate: ( Cursor sense mapToWindow: self ) ) ] )
		ifTrue: [ CursorManager arrow ]
		ifFalse: [ super currentCursor ]!   
defaultCursor
        "Private - Answer the default CursorManager for the receiver."
    ^CursorManager text!   
button1UpShift: aPoint
        "Private - The user let up on button1 with the shift key down."
    super button1UpShift: aPoint.
    self clearMouseCapture!   
cursorPageUpKeyInput: aKeyboardInputEvent
        "Private - process a page up keystroke."
    | offset |
    offset := selection origin - self topCorner.
    self scrollVertical: self amountToPageUp.
    selection selectBefore: self topCorner + offset; displayGap.
    self displayChanges!  
insertAndSelect: aString
        "Insert aString at current location, replacing
        selection if present, and select aString."
    self
        cutSelection;
        insertAfterSelection: aString! 
makeVisible: aPoint
        "Private - Force aPoint (relative to text)
         to appear inside the pane."
    | width corner pelX pelY |
    width := self doGraphics: [
        graphicsTool
            stringWidthOf: (textHolder lineAt: aPoint y)
            at: aPoint x - 1 ].
    pelX := width - ((topCorner x - 1) * self font width).
    pelY := rectangle height - (aPoint y -
         topCorner y + 1 * self font height) + 1.
    (rectangle containsPoint: pelX @ pelY)
        ifTrue: [^self].
    corner := topCorner copy.
    (pelY between: 0 and: rectangle height)
        ifFalse: [
            pelY < 0
                ifTrue: [ corner y: (aPoint y - ( rectangle height // self font height ) + 1) ]
                ifFalse: [ corner y: aPoint y ] ].
    (pelX between: 0 and: rectangle width)
        ifFalse: [
            corner x: (width // self font width -
                (rectangle width // self font width // 2) )].
    self topCorner: (corner max: (1@1)).
    self updateSliders!  
modified
        "Answer true if the text has been modified
         since the last save, else answer false."
    ^modified!   
cancel
        "Private - Restore the last saved
         version of the text."
    modified := false.
    CursorManager execute changeFor: [
        owner isString
            ifTrue: [ textHolder string: owner ]
            ifFalse: [
                ( owner respondsTo: #cancel )
                    ifTrue: [ ^owner cancel ]
                    ifFalse: [
                        self event: #getContents.
                        self triggerEvent: #needsContents ] ].
        self
            topCorner: 1@1;
            refreshAll;
            selectAfter: 0@1;
            forceSelectionOntoDisplay ]! 
getCopyBuffer
        "Private - Answer the contents of the clipboard."
    | string |
    string := Clipboard getString.
    string := string replaceCharacter: Tab from: 1 to: string size withString: ( ( String new: 4 ) atAllPut: $ ).
    ^string! 
close
        "Private - The pane is closing."
    super close.
    selection := TextSelection new pane: self.
    selection selectBefore: 1@1.!  
selectWordAt: aPoint
        "Private - Select the word which contains
         the current selection."
    | answer |
    answer := textHolder scanForWordAt: aPoint.
    self selectFrom: answer origin to: answer corner! 
fillCopyBuffer
        "Private - Put the selected text into the
         copy buffer and the clipboard."
    | aString |
    self selectedStringSize > 16rFFF0 ifTrue: [
        ^(MessageBox confirm: 'String is too big to fit into the Clipboard.  Do you wish to continue anyway?')].
    aString := self selectedString.
    ( Clipboard clear; setString: aString ) isNil ifTrue: [ ^false ].
    ^true!   
replaceString: aString
        "Private - Answer a String by replacing
         all wild card characters in aString
         with the selected string."
    | index answer |
    answer := aString.
    [true] whileTrue: [
        index := answer indexOf: Pattern wildcardChar
            ifAbsent: [^answer].
        answer :=
            (answer copyFrom: 1 to: index - 1),
            self selectedString,
            (answer copyFrom: index + 1 to: answer size)]!  
value: aString
        "Set the text contents of the receiver to aString."
    self
        contents: aString;
        modified: false!   
selectFrom: start to: end
        "Set the selection described by start and end.  start and end can
        be either (character in line, line) pairs or character positions from
        beginning of the text."
    self isHandleOk
        ifTrue: [
            start isPoint
                ifTrue: [
					selection origin: start corner: end.
					self showSelection ]
                ifFalse: [ self showSelectionFrom: start to: end + 1 ] ]
        ifFalse: [ self whenValid: #selectFrom:to: withArguments: ( Array with: start with: end ) ]!  
backspace: toClipboard
        "Private - Delete a non-gap selection or the
         preceding character of a gap selection."
    | temp |
    self hideSelection.
    temp := priorSelection.
    priorSelection := selection.
    self isGapSelection
        ifTrue: [priorSelection origin > (1@0)
            ifTrue: [priorSelection
                        origin: priorSelection corner
                        corner: priorSelection corner]
            ifFalse: [self backspaceSelection]].
    toClipboard ifTrue: [self fillCopyBuffer ifFalse: [
        priorSelection := temp.
        self showSelection.
        ^self]].
    newSelection := priorSelection origin
        corner: priorSelection origin - (1@0).
    self replaceWithText: nil.
    modified := true.
    self
        selectAfter: newSelection corner;
        makeSelectionVisible!   
popupMenu
        "Private - Answer the popup Menu for the receiver."
    | m otherMenu editMenu smalltalkMenu editTitle |
    m := super popupMenu.
    m isNil
        ifTrue: [
            m := Menu new
                appendItem: 'Cu\ut' replaceEscapeCharacters selector: #cutSelection ;
                appendItem: '\uCopy' replaceEscapeCharacters selector: #copySelection;
                appendItem: '\uPaste' replaceEscapeCharacters selector: #pasteSelection.
            Smalltalk isRunTime ifFalse: [
                m appendSeparator ;
                appendItem: '\uDo It' replaceEscapeCharacters selector: #doIt  ;
                appendItem: '\uShow It' replaceEscapeCharacters selector: #printIt ].
            m appendSeparator ;
                appendItem: '\uSave' replaceEscapeCharacters selector: #accept ;
                appendItem: 'A\ugain' replaceEscapeCharacters selector: #again.

            "retrieve the Edit/Smalltalk menus from the main window's window policy"
            editMenu := [ self mainWindow windowPolicy class editMenu ]
                on: MessageNotUnderstood do: [ nil ].
            editMenu notNil ifTrue: [ m appendSubMenu: ( editMenu allOwners: self ) ].
            Smalltalk isRunTime ifFalse: [
                smalltalkMenu := [ self mainWindow windowPolicy class smalltalkMenu: true ]
                    on: MessageNotUnderstood do: [ nil ].
                smalltalkMenu notNil ifTrue: [ m appendSubMenu: ( smalltalkMenu allOwners: self mainWindow owner ) ] ].

            m owner: self;
                title: 'TextPanePopup' ]
        ifFalse: [
            " if the popup is not the Edit menu, return it "
            editTitle := '\uEdit' replaceEscapeCharacters.
            ( m title ~= editTitle and: [ ( m isThere: editTitle ) not ] ) ifTrue: [ ^m ].

            editMenu :=
                ( m title = editTitle )
                    ifTrue: [ m ] "The entire popup is the edit menu."
                    ifFalse: [ m subMenuTitled: editTitle ] ]. "popup has a edit subitem."

        " copy popup menu attributes for File menu "
        m getIndex: #accept ifAbsent: [^m]. "Check to be sure the item is there."
        ( otherMenu := self mainWindow menuTitled: '\uFile' replaceEscapeCharacters ) isNil
            ifFalse: [ m copyItemAttributes: #accept from: otherMenu ].

        " copy popup menu attributes for Edit menu "

        ( otherMenu := self mainWindow menuTitled: '\uEdit' replaceEscapeCharacters ) isNil
            ifFalse: [
                otherMenu owner initMenu.
                ( Array with: m with: editMenu ) do: [ :mm |
                    mm copyItemAttributes: #copySelection from: otherMenu;
                        copyItemAttributes: #cutSelection from: otherMenu;
                        copyItemAttributes: #pasteSelection from: otherMenu ].
                editMenu copyItemAttributes: #clearSelection from: otherMenu ].

    ^self popupFromMenu: m! 
fileOutOn: aFileStream
        "Write the pane data out on aFileStream."
    aFileStream close.
    File remove: aFileStream pathName ifAbsent: [].
    aFileStream file open.
    aFileStream
        setCollection: aFileStream file;
        setLimits.
    textHolder fileOutOn: aFileStream.
    aFileStream flush! 
searchInit
        "Private - Prompt for and initialize the
         string to be searched for."
    | aString |
    selection isGap
        ifTrue: [
            aString := Prompter
                promptWithBlanks:  'String to be searched:'
                default: SearchString]
        ifFalse: [aString := self selectedString].
    aString isNil
        ifTrue: [^nil]
        ifFalse: [^SearchString := aString]!
selectedItem
        "Answer a String containing the
         text currently selected."
    ^textHolder stringIn: selection!   
previousValue
        "Answer the previous value of the receiver.
        The previous value is the value prior to any
        user changes (when there is a #changed: handler)
        or the last time previousValue was sent."
    ^self propertyAt: #previousValue ifAbsent: [ '' ]! 
replaceAtPattern
        "Private - Replace all occurrences of
         SearchString with NewString.  Answer a
         TextSelection over the last replaced
         NewString."
    | aPattern changed |
    changed := false.
    aPattern := Pattern new: SearchString.
    [(textHolder
        searchFrom: selection
        for: aPattern
        caseSensitive: CaseSensitive) isNil]
        whileFalse: [
            self replaceWithText:
                (self replaceString:NewString).
            changed := true].
    self modified: changed.
    self forceSelectionOntoDisplay.
    ^selection! 
cursorHomeKeyInput: aKeyboardInputEvent
        "Private - process a home keystroke."
    ^aKeyboardInputEvent isControlKeyDown
        ifTrue: [ 0 @ 0 ]
        ifFalse: [ 0 @ selection corner y ]!
cursorKeyInput: aKeyboardInputEvent
        "Private - Process cursor keys."
    | virtualKey new |
    virtualKey := aKeyboardInputEvent virtualKey.
    virtualKey == RightKey ifTrue: [ new := self cursorRightKeyInput: aKeyboardInputEvent ].
    virtualKey == LeftKey ifTrue: [ new := self cursorLeftKeyInput: aKeyboardInputEvent ].
    virtualKey == UpKey ifTrue: [ new := self cursorUpKeyInput: aKeyboardInputEvent ].
    virtualKey == DownKey ifTrue: [ new := self cursorDownKeyInput: aKeyboardInputEvent ].
    virtualKey == HomeKey ifTrue: [ new := self cursorHomeKeyInput: aKeyboardInputEvent ].
    virtualKey == EndKey ifTrue: [ new := self cursorEndKeyInput: aKeyboardInputEvent ].
    virtualKey == PageUpKey ifTrue: [ self cursorPageUpKeyInput: aKeyboardInputEvent ].
    virtualKey == PageDownKey ifTrue: [ self cursorPageDownKeyInput: aKeyboardInputEvent ].
    new isNil ifTrue: [ ^nil ].  "ignore PageUpKey, PageDownKey"
    aKeyboardInputEvent isShiftKeyDown
        ifTrue: [
            selection selectTo: ( new max: 0 @ 1 ).
            self hideSelection ]
        ifFalse: [ self selectAfter: ( new max: 0 @ 1 ) ].
    self
        makeSelectionVisible;
        displayChanges;
        showSelection!  
display: aString reverseFrom: startInteger to: endInteger
        "Private - Display aString and select characters between
         startInteger and endInteger."
    | origin corner box |
    selection hide.
    box := self replaceWithText:
        (aString copyFrom: 1 to: startInteger - 1).
    origin := box corner + (1@0).
    selection selectBefore: origin.
    box := self replaceWithText:
        (aString
            copyFrom: startInteger
            to: endInteger - 1).
    corner := box corner.
    selection selectAfter: corner.
    self
        replaceWithText:
            (aString
                copyFrom: endInteger
                to: aString size ).
    selection origin: origin corner: corner.
    self forceSelectionOntoDisplay!   
displayChanges
        "Private - Update the screen with all pending changes."
    self displayChangesForCharInput.
    self updateSliders.!   
setValue: aValue
        "Set the text contents of the receiver to the string representing
        aValue.  Trigger the changed event if the value is changed.
        Answer aValue."
    | newValue |
    newValue := ( aValue isString
        ifTrue: [ aValue ]
        ifFalse: [ aValue isNil ifTrue: [ '' ] ifFalse: [ aValue asString ] ] ).
    newValue ~= self value ifTrue: [
        self
            value: newValue;
            triggerChanged;
            previousValue: newValue ].
    ^aValue! 
selectionIncludesPoint: aPoint
        "Private - answer whether aPoint is within the bounds of the
        current selection."
    | sel start end |
    sel := self selection.
    start := sel origin.
    end := sel corner.
    sel isGap ifTrue: [ ^false ].  "no selection, just a caret."
    ( aPoint y > start y and: [ aPoint y < end y ] ) ifTrue: [ ^true ].
    start y = end y ifTrue: [ ^aPoint y = start y and: [ ( aPoint x between: start x and: end x ) ] ].
    ( aPoint y = start y and: [ aPoint x > start x ] ) ifTrue: [ ^true ].
    ( aPoint y = end y and: [ aPoint x < end x ] ) ifTrue: [ ^true ].
    ^false!  
lineAt: index
        "Private - Answer the index'th line of text in the receiver."
    ^textHolder lineAt: index!  
selectTo: aPoint
        "Private - Extend the selection to aPoint either
         before or after the original one."
    selection hide.
    ^selection selectTo: aPoint!
modified: aBoolean
        "Change modified to aBoolean."
    modified := aBoolean! 
selectLines: indexInteger height: hInteger
        "Private - Answer the selection area from
         the line at indexInteger spanning
         hInteger lines."
    | lastLine |
    lastLine := (indexInteger + hInteger).
    ^TextSelection new
        origin: 1 @ indexInteger
        corner: (textHolder lineAt: lastLine) size
            @ lastLine! 
initialize
        "Private - Initialize the receiver."
    super initialize.
    topCorner := 1@1.
    selection := TextSelection new pane: self.
    selection selectBefore: 1@1.
    textHolder := StringModel for: ''.
    textHolder textPane: self.
    priorSelection := nil.
    priorText := nil.
    newSelection := nil.
    modified := false! 
forceEndOntoDisplay
        "Force the end of the text to appear on
        the display screen."
    | total height |
    height := rectangle height // self font height.
    total := textHolder totalLength.
    ( ( total - topCorner y ) >  height or: [ total < topCorner y ] )
        ifTrue: [ self topCorner: 1 @ ( total - ( height // 2 ) ) ].
    self doGraphics: [ self displayChanges ]!   
isReadOnly
        "Answer true if the control is user read only."
    ^( self propertyAt: #readOnly ) notNil!  
forceSelectionOntoDisplay
        "Force the origin of the selection to
         appear on the display screen."
    self
        makeSelectionVisible;
        displayChanges.
    selection display!   
display
        "Private - Display the contents of
         the receiver."
    rectangle isNil ifTrue: [ ^self ].
    selection hideSelection.
    textHolder displayAll.
    changedArea := nil.
    selection displaySelection!  
resize: aRectangle
        "Private - The receiver's size was changed."
	self isHandleOk ifFalse: [ ^nil ].
    super resize: aRectangle.
    textHolder
        scanner: graphicsTool;
        frame: rectangle;
        topCorner: topCorner!
cursorDownKeyInput: aKeyboardInputEvent
        "Private - process a down arrow keystroke."
    | new |
    new := selection corner.
    new y >= self totalLength ifTrue: [ ^new ].
    self font fixedWidth
        ifFalse: [
            new := selection bitCoordinate: new.
            new := new down: self font height.
            new := self stringCoordinate: new.
            selection corner x = 0 ifTrue: [ new := new - (1@0) ] ]
        ifTrue: [ new := new + ( 0 @ 1 ) ].
    ^new! 
searchBackOld
        "Private - Search backwards for the
         previous search string.  Answer the
         selection containing the string."
    CursorManager execute changeFor: [
        ( textHolder
            searchBack: selection
            for: ( Pattern new: SearchString )
            caseSensitive: CaseSensitive ) isNil
                ifTrue: [ ^MessageBox notify: 'Find / Replace' withText: 'Search string not found' ].
        self forceSelectionOntoDisplay ].
    ^selection!
button1DownShift: aPoint
        "Private - The user pressed down button1 while
         holding down a shift key."
    self captureMouseInput.
    self mainWindow activeTextPane: self.
    self selectToShifted: aPoint.
    self
        displayChanges;
        showSelection.!  
characterCoordinate: aPoint
        "Private - Convert the bit position aPoint within
         the pane to a character position in the TextHolder."
    | column row |
    graphicsTool isNil ifTrue: [ ^1@1 ].
    row := ( rectangle top down: aPoint y ) // self font height + topCorner y.
    column := 1.
    self doGraphics: [
        column := graphicsTool
            indexOf: (textHolder lineAt: row)
            at: (aPoint x right: (topCorner x - 1 * self font width))].
    ^column @ row! 
cursorPageDownKeyInput: aKeyboardInputEvent
        "Private - process a page down keystroke."
    | offset |
    offset := selection origin - self topCorner.
    self scrollVertical: self amountToPageUp negated.
    selection selectBefore: self topCorner + offset; displayGap.
    self displayChanges!  
fileInFrom: aFileStream
        "Refresh the pane data with the current
         contents of aFileStream."
    | intState |
    aFileStream reset.
    textHolder fileInFrom: aFileStream.
    intState := Process enableInterrupts: false.
    topCorner := nil.
    self
        topCorner: 1@1.
    selection
        selectAfter: 0 @ 1.
    Process enableInterrupts: intState.
    self displayChanges.!   
readOnly
        "Make the control a read only control."
    self propertyAt: #readOnly put: true!  
selectDoubleAtCursor: aPoint
        "Private - Place the gap selection at
         the cursor position."
    | new |
    new := (self stringCoordinate: aPoint).
    new x > ( self lineAt: new y ) size ifTrue: [ ^self ].
    (new = (self stringCoordinate: 0 @ aPoint y) or: [
        ( ( self lineAt: new y ) copyFrom: 1 to: new x - 1 ) trimBlanks isEmpty ] )
        ifTrue: [self selectLineAtCurrentSelection]
        ifFalse: [self selectWordAtCurrentSelection]!
cursorLeftKeyInput: aKeyboardInputEvent
        "Private - process a left arrow keystroke.  If the control key is down,
        move to the beginning of the previous word on the current line."
    | new rest offset offset2 |
    new := selection origin.
    aKeyboardInputEvent isControlKeyDown
        ifTrue: [
            ( rest := textHolder leftPartBefore: new ) isEmpty ifFalse: [
                rest last isSeparator
                    ifTrue: [
                        ( offset := rest size - ( rest findLast: [ :c | c isSeparator not ] ifAbsent: [ -1 ] ) ) = rest size ifFalse: [
                            rest := rest copyFrom: 1 to: rest size - offset.
                            offset2 := rest size - ( rest findLast: [ :c | c isSeparator ] ifAbsent: [ rest size ] ) + 1.
                            offset := offset + offset2 ] ]
                   ifFalse: [
                        offset := rest size - ( rest findLast: [ :c | c isSeparator ] ifAbsent: [ rest size ] ) + 1 ].
                new := new left: offset ] ]
        ifFalse: [
            ( ( new x = 1 ) and: [ new y > 1 ] )
                ifTrue: [ new := ( self endOfLine: new y - 1 ) @ ( new y - 1 ) ]
                ifFalse: [
                    aKeyboardInputEvent isShiftKeyDown
                        ifTrue: [ new := new - ( 1 @ 0 ) ]
                        ifFalse: [ new := new - ( 2 @ 0 ) ] ] ].
    ^new!
button1DoubleClick: aPoint
        "Private - The user double clicked at aPoint."
    | char charPoint |
    charPoint := self characterCoordinate: aPoint.
    char := textHolder charAt: charPoint.
    ( ( ( RightBrackets, LeftBrackets ) includes: char ) and: [ Smalltalk isRunTime not ] )
        ifTrue: [
            self
                selectFrom: charPoint  to: charPoint;
                matchBracketChars ]
        ifFalse: [
            self
                selectDoubleAtCursor: aPoint;
                displayChanges;
                showSelection ]!   
scrollHorizontal: anInteger
        "Private - Scroll the text anInteger number
         of characters to the left (if anInteger is
         positive) or to the right (if negative)."
    | maxLine |
    maxLine := self totalWidth * self font width.
    (anInteger < 0 and: [
        (maxLine  <= (rectangle width - 24))])
        ifFalse: [
            self moveTopCornerBy: (anInteger @ 0)]! 
nextPutAll: aString
        "Add aString at the end of the
         text in the pane."
    | anInteger in char |
    (aString == nil or: [aString isEmpty])
        ifTrue: [^self].
    in := ReadStream on: aString.
    anInteger := 1.
    [in atEnd] whileFalse: [
        ((char := in next) == Cr or: [char == Lf])
            ifTrue: [
                self appendText:
                    (aString copyFrom: anInteger to: in position - 1).
                self cr.
                char == Cr ifTrue: [
                    in peekFor: Lf].
                anInteger := in position + 1]].
    self appendText:
        (aString copyFrom: anInteger to: aString size)!
scrollHorizontalCharacters: anInteger
        "Private - Scroll the text anInteger number
         of characters to the left (if anInteger is
         positive) or to the right (if negative)."
    self scrollHorizontal: anInteger!
selectAtCursor: aPoint
        "Private - Place the gap selection at
         the cursor position."
    | new |
    aPoint y negative ifTrue: [ ^self ].  "ignore out-of-bounds notifications"
    new := (self stringCoordinate: aPoint).
    ^selection selectBefore: new; displayGap!
backspaceSelection
        "Private - Extend the selection
         backwards by one character."
    ^selection
        origin: (textHolder adjustPoint:
            selection origin - (1 @ 0))!
selectedString
        "Private - Answer a String containing the
         text currently selected. Retained for compatibility."
    ^self selectedItem!
searchForDefaultTextPane
        "Private - Answer the receiver."
    ^self!
accept
        "Private - Save the modified text."
    self triggerEvent: #aboutToSave.
    Smalltalk isRunTime ifFalse: [ self setEvaluate: false ].
    modified ifTrue: [
        CursorManager execute changeFor: [
            self name == #yourself
                ifTrue: [
                    owner := textHolder string.
                    modified := false].
            self event: #save.
            self triggerEvent: #saved ] ]! 
isGapSelection
        "Private - Answer true if the
         selection is a gap, else answer false."
    ^selection isGap!
replaceWithChar: aCharacter
        "Private - Replace the selected text
         with aCharacter.  Answer the position
         of the new character."
    | s |
    (s := self selectedString) notEmpty ifTrue: [
        UndoBuffer := s].
    ^selection corner:
        (textHolder
            replace: selection
            withChar: aCharacter).! 
pasteSelection
        "Private - Replace the selected text with
         the copy buffer contents."
    self hideSelection.
    priorText := self selectedString.
    priorSelection := selection.
    newSelection := self replaceWithText: (self getCopyBuffer).
    modified := true.
    self
        selectAfter: newSelection corner;
        forceSelectionOntoDisplay! 
makeSelectionVisible
        "Private - Force the origin of the selection to
         appear inside the pane."
    self makeVisible: selection origin! 
cutSelection
        "Private - Remove the selected text and
         place it in copy buffer."
    | toCut |
    toCut := ( self propertyAt: #dragSourceSelection ifAbsent: [ selection ] ).
    self fillCopyBuffer ifFalse: [^self].
    self hideSelection.
    priorSelection := selection.
    newSelection := priorSelection origin
        corner: priorSelection origin - (1@0).
    self selectFrom: toCut origin to: toCut corner.
    self replaceWithText: nil.
    modified := true.
    self
        selectAfter: newSelection corner;
        forceSelectionOntoDisplay!   
showSelection
        "Private - Make the selection visible."
    selection display!
moveTopCornerBy: extent
        "Private - Move top corner by extent and
        display changes."
    ( topCorner x <= 1 and: [ extent x >= 1] ) ifTrue: [ ^self ].
    selection hideScroll.
    self
        topCorner: topCorner - extent ;
        displayChangesForCharInput.
    selection display!
replaceWithText: aString
        "Private - Replace the selected text
         with aString.  Answer the position
         of the last character of aString in
         the new text."
    | s |
    (s := self selectedString) notEmpty ifTrue: [
        UndoBuffer := s].
    ^selection corner:
        (textHolder
            replace: selection
            withText: aString)! 
tab
        "Write a tab character to the receiver."
    self nextPut: Tab! 
areaOnFormOf: aRectangle
        "Private - Answer the portion of aRectangle
         which intersects the pane."
    | origin corner |
    origin := aRectangle origin y max: topCorner y.
    corner := aRectangle corner y min:
        (topCorner y + (rectangle height // self font height)).
    ^(aRectangle origin x @ origin) corner:
        (aRectangle corner x @ corner)!
readWrite
        "Make the control a read and write control."
    self propertyAt: #readOnly put: nil! 
cr
        "Append a line-feed to the end
         of the  text in the pane."
    self
        appendChar: Lf;
        forceEndOntoDisplay!  
searchFor: aString
        "Private - Search forward for aString."
    | result |
    SearchString := aString.
    [ result := self searchOld ] on: Warning do: [ :e | ].  "suppress message"
    ^result!   
totalLength
        "Private - Answer the total number of
         lines in the text."
    ^textHolder totalLength!
isTextPane
        "Answer true if receiver is a kind of TextPane."
    ^true!  
cursorEndKeyInput: aKeyboardInputEvent
        "Private - process an end keystroke."
    ^aKeyboardInputEvent isControlKeyDown
        ifTrue: [ ( self endOfLine: self totalLength ) @ self totalLength ]
        ifFalse: [ ( self endOfLine: selection corner y ) @ selection corner y ]!  
selectWordAtCurrentSelection
        "Private - Select the word which contains
         the current selection."
    self selectWordAt: selection origin!   
searchOld
        "Private - Search forward for the previous search string.
        Answer the selection containing the string."
    CursorManager execute changeFor: [
        ( textHolder
            searchFrom: selection
            for: ( Pattern new: SearchString )
            caseSensitive: CaseSensitive ) isNil
                ifTrue: [ ^Warning signal: 'Search string not found' ].
        self forceSelectionOntoDisplay ].
    ^selection!
cursorRightKeyInput: aKeyboardInputEvent
        "Private - process a right arrow keystroke.  If the Control key is down,
        move to the beginning of the next word on the current line."
    | new rest offset |
    new := selection corner.
    aKeyboardInputEvent isControlKeyDown
        ifTrue: [
            ( rest := textHolder rightPartAfter: new ) isEmpty ifFalse: [
                rest first isSeparator
                    ifTrue: [ offset := ( rest findFirst: [ :c | c isSeparator not ] ifAbsent: [ rest size ] ) - 1 ]
                    ifFalse: [
                        offset := rest findFirst: [ :c | c isSeparator ] ifAbsent: [ rest size + 1 ].
                        rest := rest copyFrom: offset to: rest size.
                        offset := offset + ( rest findFirst: [ :c | c isSeparator not ] ifAbsent: [ rest size + 1 ] ) - 2 ].
                new := new right: offset ] ]
        ifFalse: [
            new x >= ( self endOfLine: new y )
                ifTrue: [ new := 0 @ ( new y + 1 ) ]
                ifFalse: [ new := new + ( 1 @ 0 ) ] ].
    ^new!   
activate
		"Private - the receiver has been activated,
		make it the active text pane (owns the edit
		menu)."
    ( self mainWindow isActive and: [ self isVisible ] ) ifFalse: [ ^self ].
    self mainWindow activeTextPaneNoSetFocus: self.
    ^super activate!
displayChangesForCharInput
        "Private - Update the screen with all pending changes.
         Do not update the sliders."
    changedArea isNil
        ifFalse: [
            textHolder display:
                (self areaOnFormOf: changedArea)].
    self noChanges! 
findReplace
        "Private - User selected the Find/Replace menu item."
    | dialog s label |
    s := self selectedString.
    ( s includes: Lf ) ifTrue: [ s := SearchString := '' ].
    ( s isNil or: [ s isEmpty ] ) ifTrue: [ s := SearchString ].
    self setFocus.
    dialog := FindReplaceDialog new
        open: s
        replace: NewString
        forward: Forward
        caseSensitive: CaseSensitive.
    dialog command isNil ifTrue: [ ^self ].
    PriorCommand := dialog command.
    label := ( PriorCommand == #searchOld or: [ PriorCommand == #searchBackOld ] )
        ifTrue: [ 'Find A\ugain\tCtrl+G' replaceEscapeCharacters ]
		ifFalse: [ 'Replace A\ugain\tCtrl+G' replaceEscapeCharacters ].
    ( self mainWindow menuTitled: '\uEdit' replaceEscapeCharacters )
        changeItem: #again label: label.
    SearchString := dialog toFind.
    NewString := dialog replaceWith.
    CaseSensitive := dialog caseSensitive.
    Forward := dialog forward.
    ^newSelection := self perform: PriorCommand!  
endOfLine: anInt
        "Private - Answer the x string coordinate of the last character
         in line anInt."
    ^(self lineAt: anInt) size!  
topCorner: aPoint
        "Change the top-left corner
         of the receiver pane to aPoint which
         causes the text located below aPoint
         to be displayed."
    | oldCorner |
    oldCorner := topCorner.
    topCorner := (1 max: aPoint x) @
        (1 max: (aPoint y min: textHolder extent y)).
    oldCorner = topCorner
        ifFalse: [self refreshAll]! 
selectedStringSize
        "Private - Answer the approximate size
         of the selection in characters."
    | answer |
    answer := 0.
    (textHolder linesIn: selection) do: [ :line |
        answer := answer + line size].
    ^answer!  
selectAfter: pointOrInteger
        "Place the selection after pointOrInteger."
    ^pointOrInteger isInteger
        ifTrue: [ self selectFrom: pointOrInteger + 1 to: pointOrInteger. selection ]
        ifFalse: [ selection selectAfter: pointOrInteger ]!   
totalWidth
        "Private - Answer the widest line in characters."
    self totalLength = 0 ifTrue: [^0].
    graphicsTool isNil ifTrue: [^40].
    ^(self doGraphics: [graphicsTool stringWidthOf:
        (textHolder maxLineBetween: topCorner y
            and: topCorner y + (rectangle height // self font height))])
                // self font width + 1! 
undo
        "Private - Insert the UndoBuffer at the current
         selection."
    (UndoBuffer size = 0)
        ifTrue: [self pasteSelection]
        ifFalse: [
            self hideSelection.
            priorSelection := selection.
            newSelection := self replaceWithText: UndoBuffer.
            modified := true.
            self
                selectAfter: newSelection corner;
                forceSelectionOntoDisplay]!  
contents
        "Answer the string contents of the receiver."
    ^textHolder string!  
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process backspace, tab, carriage return."
    | virtualKey character |
    ( virtualKey := aKeyboardInputEvent virtualKey ) notNil ifTrue: [
        ( virtualKey == TabKey or: [ virtualKey == BacktabKey ] )
            ifTrue: [ self tabKeyInput: aKeyboardInputEvent ].
        virtualKey == EscapeKey ifTrue: [ ^nil ].  "eat the escape character"
        aKeyboardInputEvent isCursorKey ifTrue: [ ^self cursorKeyInput: aKeyboardInputEvent ].
        self isReadOnly ifTrue: [ ^nil ].
        virtualKey == BackspaceKey ifTrue: [ self backspace ].
        virtualKey == DeleteKey ifTrue: [
            selection isGap ifTrue: [
                aKeyboardInputEvent virtualKey: RightKey.  "input event modified - don't use here anymore"
                self cursorKeyInput: aKeyboardInputEvent ].
            self backspace: false ].
        self displayChanges; updateSliders; showSelection ].

    self isReadOnly ifTrue: [ ^self ].
    character := aKeyboardInputEvent character.
    character == Cr ifTrue: [ character := Lf ].
    ( character notNil and: [ character ~~ Bs ] ) ifTrue: [
        self isGapSelection
            ifFalse: [ self hideSelection ].
        newSelection := self replaceWithChar: character.
        modified := true.
        self
            selectAfter: newSelection corner;
            makeSelectionVisible;
            displayChangesForCharInput;
            showSelection ].

    self basicKeyboardInput: aKeyboardInputEvent! 
value
        "Answer the text contents of the receiver."
    ^self contents!   
nextPut: aCharacter
        "Add aCharacter at the end of the
         text in the pane."
    self appendChar: aCharacter! 
open
        "Private - Open the pane."
    super open.
    self getText.
    selection pane: self.
    self topCorner: 1@1.
    selection selectAfter: 0@1.
    textHolder
        scanner: graphicsTool;
        frame: rectangle;
        topCorner: topCorner!  
backspace
        "Private - Delete a non-gap selection or the
         preceding character of a gap selection."
    self backspace: false!
selectAtEnd
        "Place the gap selection at
         the end of the text."
    ^selection selectAfter: textHolder extent!  
triggerChanged
        "Private - trigger the changed event."
    self triggerEvent: #changed: with: self value!
appendChar: aCharacter
        "Private - Append aCharacter to the end of the text."
    textHolder appendChar: aCharacter! 
appendText: aString
        "Private - Append aString to the end of the text."
    textHolder appendText: aString!  
restore
        "Restore the contents of the receiver to the previously set
        contents."
    self cancel!
previousValue: aValue
        "Set the previous value of the receiver."
    ^self propertyAt: #previousValue put: aValue!   
tabKeyInput: aKeyboardInputEvent
        "Private - Respond to the tab keystroke."
    aKeyboardInputEvent isControlKeyDown ifFalse: [ ^nil ].
    self triggerEvent: #controlTabbed
        ifNotHandled: [
            aKeyboardInputEvent isShiftKeyDown
                ifTrue: [
                    [( self tabScope previousTabStop: self ) setFocus ]
                        on: Error
                        do: [ :e | ^self  "Stack overflow because no valid tab stop " ] ]
                ifFalse:  [
                    [( self tabScope nextTabStop: self ) setFocus ]
                        on: [ :e | ^self ] ] ]! 
insert: aString
        "Insert aString at current location replacing
        selection if present."
    self hideSelection.
    priorText := self selectedString.
    priorSelection := selection.
    newSelection := self replaceWithText: aString.
    modified := true.
    self
        selectAfter: newSelection corner;
        forceSelectionOntoDisplay!  
showSelectionFrom: beginIndex to: endIndex
        "Private - Show selection containing the
         characters from beginIndex to endIndex,
         treating the lines as one string."
    self hideSelection.
    selection :=
        textHolder getSelectionFrom: beginIndex
             to: endIndex - 1.
    selection pane: self.
    self doGraphics: [
        self makeVisible: selection corner;
            displayChanges.
        selection display].!
selectAll
        "Select the entire text of the pane."
    self mainWindow activeTextPane: self.
    ^selection
        origin: 1@1 corner: textHolder extent;
        displaySelection!
again
        "Private - Redo the prior find or replace command."
    self setFocus.
    CursorManager execute changeFor: [
        self perform: PriorCommand ]! 
insertAfterSelection: aString
        "Insert aString after the current selection
        and select it."
    | stringToInsert pt |
    stringToInsert := aString asExternalString.
    pt := selection corner.
    self selectAfter: pt.
    self insert: stringToInsert.
    self
        selectFrom: pt x + 1 @ pt y
        to: pt x + stringToInsert size @ pt y!  
queryReplaceAtPattern
        "Private - Replace all occurrences of SearchString with
         NewString.  Answer a TextSelection over
         the last replaced NewString."
    | aPattern  done answer |
    done := false.
    aPattern := Pattern new: SearchString.
    [done or: [(textHolder
        searchFrom: selection
        for: aPattern
        caseSensitive: CaseSensitive) isNil]]
        whileFalse: [
            self forceSelectionOntoDisplay.
            answer := MessageBox new
                title: 'Replace All';
                message: 'Replace "', SearchString,'"?';
                iconQuestion;
                yesNoCancel;
                open.

            answer == true ifTrue: [
                self replaceWithText: (self replaceString: NewString).
                    self modified:true].
            answer isNil ifTrue: [done := true]].
    self forceSelectionOntoDisplay.
    ^selection!
selection
        "Answer a TextSelection describing
         the current selection."
    ^selection!  
reinitialize
        "Private - Reinitialize the receiver."
    priorSelection := nil.
    priorText := nil.
    newSelection := nil.
    modified := false.
    self cancel.!  
textHolder
        "Private - Answer the StringModel for the receiver."
    ^textHolder!
clearSelection
        "Private - Remove the selected text."
    | event |
    event := KeyboardInputEvent new
        virtualKey: DeleteKey;
        yourself.
    self keyboardInput: event!  
copySelection
        "Private - Place the selected
         text in the copy buffer."
    self fillCopyBuffer!
getText
        "Private - Restore the last saved
         version of the text."
    modified := false.
    self name == #yourself
        ifTrue: [ textHolder string: owner ]
        ifFalse: [
            ( owner respondsTo: #cancel )
                ifTrue: [ ^owner cancel ]
                ifFalse: [
                    self event: #getContents.
                    self triggerEvent: #needsContents ] ]! 
hideSelection
        "Private - Hide the visual cue of the selection."
    selection hide! 
horizontalScrollPos
        "Private - Answer the horizontal scrollbar's position"
    | pos |
    ( pos := UserLibrary getScrollPos: self handle asParameter bar: SbHorz ) = 0
        ifTrue: [ self osWarning ].
    ^pos!
validate
        "Private - The host window for the receiver was
         just created or recreated."
    super validate.
    self
        setTextLimit;
        setSelection.
    self font:
        ( self font notNil ifTrue: [ self font ] ifFalse: [ self defaultFont ] ).
    ( self hasActionForEvent: #changed: )
        ifTrue: [ self previousValue: self value ]!   
loadCursor: instanceHandle nameInteger: anInteger
    <api: LoadCursorA ulong ulong ulongReturn>
    ^self invalidArgument! 
dragTargetFormats: formats
        "Private - set the formats of drag objects that the receiver will accept."
    self propertyAt: #dragTargetFormats put: formats! 
blue
	^self byteAtOffset: 2! 
red
	^self byteAtOffset: 0!  
red: aByte
	self byteAtOffset: 0 put: aByte! 
blue: aByte
	self byteAtOffset: 2 put: aByte!
flags
	^self byteAtOffset: 3!
flags: aByte
	self byteAtOffset: 3 put: aByte!   
green
	^self byteAtOffset: 1!
green: aByte
	self byteAtOffset: 1 put: aByte!   
canApplyStyle
        "Private - answer whether the receiver's style can change
        after it has been created."
    ^false!
deleteAll
        "Delete the whole list."
    list := Array new.
    value := nil.
    self isHandleOk ifTrue: [
        self deleteAllFromControl ]!   
dragTargetDropDefault: dragSession
		"Private - provide default drop implementation if no handler is provided.
		Reimplemented by subclasses."
!   
wmGetdlgcode: wparam with: lparam
        "Private - ignore WM_GETDLGCODE message."
    ^ nil!  
from: aFileStream
    | header |
    header := self new.
    aFileStream getBytesFor: header contents.
    ^header!   
sizeInBytes
    ^18! 
maxRecord
    ^self uLongAtOffset: 12!   
maxRecord: anInteger
    self uLongAtOffset: 12 put: anInteger!  
noParameters: anInteger
    self uShortAtOffset: 16 put: anInteger!  
version
    ^self uShortAtOffset: 4! 
version: anInteger
    self uShortAtOffset: 4 put: anInteger!
noObjects
    ^self uShortAtOffset: 10!  
noObjects: anInteger
    self uShortAtOffset: 10 put: anInteger! 
headerSize: anInteger
    self uShortAtOffset: 2 put: anInteger! 
fileSize: anInteger
    self uLongAtOffset: 6 put: anInteger!
noParameters
    ^self uShortAtOffset: 16!   
type: anInteger
    self uShortAtOffset: 0 put: anInteger!   
type
    ^self uShortAtOffset: 0!
fileSize
    ^self uLongAtOffset: 6! 
headerSize
    ^self uShortAtOffset: 2!  
wmSyscommand: wordInteger with: longInteger
        "Private - Close the dropdown list
        of the combobox, if the focus window
        is the combobox"
    | focusWindow |
    focusWindow := Notifier getFocusWindow.
    focusWindow isDropDownList ifTrue: [
        focusWindow showDropdown: false ].
     ^super wmSyscommand: wordInteger with: longInteger! 
initialize
        "Private - Initialize the receiver."
    super initialize.
    children := IdentityDictionary new.
    self label: String new.
    menuWindow := MenuWindow new!  
lineDisplayHighlighted: aString at: aPoint
        "Display aString at aPoint and blank rest of line, using the current
        system settings for highlight background & foreground colors."
    | ascender descender oldForeColor oldBackColor |
    ascender := font basePoint y.
	descender := font descender.
    oldForeColor := self foreColor.
    oldBackColor := self backColor.
    self
        foreColor: Color highlightText;
        backColor: Color highlightBackground;
		blank: ( aPoint x @ ( aPoint y  - ascender ) corner: ( width @ ( aPoint y + descender ) ) );
        displayText: aString at: aPoint;
        foreColor: oldForeColor;
        backColor: oldBackColor!
accel: aChar afBits: theAfBits
        "Private - Allows a window to intercept character input
         before it is processed either by the menu or the child
         window.  Answer true to ignore character input from here
         on, otherwise false."
    | hm |
    hm := self helpManager.
    aChar = VkF1 ifTrue: [
        theAfBits = 0
            ifTrue: [ self helpRequest. ^true ].
        ( theAfBits = AfShift and: [ hm notNil ] )
            ifTrue: [ hm turnOnHelpMode.^true ] ].
    ( aChar = Esc asciiValue and: [ hm notNil ] )
        ifTrue: [ hm turnOffHelpMode.^true ].
    ^false!  
isOffScreen
        "Answer true if any part of the receiver is off the screen."
    | hDC clipRectangle |
    hDC := self getDC.
    clipRectangle := WinRectangle new.
    GDILibrary
        getClipBox: hDC
        rectangle: clipRectangle asParameter.
    self releaseDC: hDC.
    clipRectangle := clipRectangle asRectangle.
    ^clipRectangle ~= self rectangle!
noPrintToFile
        "Disables the dialog's Print to file check box ."
    self style: ( self style | PdDisableprinttofile )!  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #changing: ;
        add: #end ;
        add: #home ;
        add: #nextPage ;
        add: #previousPage ;
        yourself! 
triggerChanging
        "Private - the receiver's position is changing."
    self triggerEvent: #changing: with: self position! 
pageIncrement
        "Answer the page increment."
    ^pageIncrement!  
initialize
        "Private - Initialize the receiver."
    super initialize.
    self
        pageIncrement: 10! 
pageIncrement: anInteger
        "Set the page increment to be anInteger."
    pageIncrement := anInteger!  
isStoredPicture
        "Answer whether the receiver is an instance of class
         StoredPicture or one of its subclasses."
    ^false! 
dragSourceNeedsObject: dragSession
        "Private - retrieve the object to be dragged."
    | itemIndex |
    itemIndex := self itemIndexFromPoint: ( dragSession screenLocation mapToWindow: self ).
    self dragSourceSelection: itemIndex.
    ^super dragSourceNeedsObject: dragSession!  
asString
        "Answer the String value of the receiver."
    | size aString |
    self asInteger = 0 ifTrue: [ ^nil ].
    aString := String new: 256.
    size := KernelLibrary
        globalGetAtomName: self asParameter
        buffer: aString
        size: aString size.
    ^size = 0
        ifTrue: [
            self osWarning.
            nil ]
        ifFalse: [ (aString copyFrom: 1 to: size) asNormalizedString ]!
dragTargetOperations: operations
        "Private - set the operations that the receiver can accept."
    self propertyAt: #dragTargetOperations put: operations!   
new
        "Answer the default printer."
    ^self default!
messageBoxEx: hWndParent
        withText: lpText
        titled: lpCaption
        style: wType
        language: wLanguageId
    <api: MessageBoxExA ulong struct struct ulong long long>! 
updateHorizontalSliderTo: anInteger
        "Private - Set the slider box in the scrollbar to integer."
    | current |
    current := UserLibrary getScrollPos: self asParameter bar: SbHorz.
    current = anInteger ifTrue: [ ^self ].
    UserLibrary
        setScrollPos: self asParameter
        bar: SbHorz
        position: anInteger
        redraw: true!   
enable: aBoolean
        "Enable the receiver and all its children."
    UserLibrary enableWindow: self enable: aBoolean!   
open
        "Open the clipboard."
    ^Open := UserLibrary openClipboard: UserLibrary getDesktopWindow!
stringToAtom: aString
        "Answer an Integer identifier for the atom named aString.
        Obsolete, maintained for backward compatibility."
    ^( Atom fromString: aString ) asInteger! 
bringWindowToTop: aWindowHandle
    <api: BringWindowToTop ulong boolean>
    ^self invalidArgument!
bitCount
        "Answer the bits per pixel of the receiver."
    ^bitmapInfo bitCount! 
moveCaret: aPoint
        "Private - Move the cursor to aPoint."
    ( UserLibrary setCaretPos: aPoint x y: aPoint y )
        ifFalse: [ self osNotification ]!   
dragTargetDefaultEmphasis
		"Private - answer the type of target emphasis that should be employed
		if not otherwise specified."
	^'separator'!
deselectIndexPrivate: itemIndex
        "Private - deselect the item at itemIndex."
    | index |
    value isNil ifFalse: [ value remove: itemIndex ifAbsent: [ nil ] ].
    self isHandleOk ifFalse: [ ^self ].
    index := ( itemIndex isNil or: [ itemIndex < 1 or: [ itemIndex > list size ] ] )
        ifTrue: [ self class listEnd ]
        ifFalse: [ itemIndex - 1 ].
    UserLibrary
        sendMessage: handle
        msg: LbSetsel
        wparam: 0
        lparam: index!  
getArcPoints: major minor: minor angles: aPoint
        "Private - Answer an array of two elements: first is the starting
         point and second is the ending point of an elliptical arc.
         major is the width and minor is
         the height of the rectangle which bounds the arc. aPoint x
         is the starting angle of the arc in degrees. aPoint y is the
         sweeping angle between the starting angle and ending
         angle which goes clockwise if positive and counter-clockwise
         if negative. "
    | startPoint endPoint boundingBox startAngle endAngle |
    boundingBox := (self location leftAndUp: major @ minor)
        corner: (self location rightAndDown: major @ minor).
    aPoint y > 0
        ifTrue: ["clockwise"
            startAngle := (aPoint x + aPoint y) \\ 360.
            endAngle := aPoint x]
        ifFalse: ["counter clockwise"
            startAngle := aPoint x.
            endAngle := (aPoint x + aPoint y) \\ 360].
    startPoint := major * startAngle integerCos @ (minor* startAngle integerSin).
    endPoint := major * endAngle integerCos @ (minor * endAngle integerSin).
    ^Array with: startPoint with: endPoint!
allHandles
        "Private - Answer an array of all device contexts used
         by the receiver."
    ^(Array with: self handle)!   
sizeInBytes
         "Private - Answer the default size in bytes."
    ^24! 
ctlType
        "Private - Answer the control type."
    ^self uLongAtOffset: 0!
ctlType: anInteger
        "Private - Set the control type."
    self uLongAtOffset: 0 put: anInteger!  
itemWidth
        "Private - Answer the item width."
    ^self uLongAtOffset: 12!   
itemWidth: anInteger
        "Private - Set the item width."
    self uLongAtOffset: 12 put: anInteger! 
itemHeight
        "Private - Answer the height of an individual item."
    ^self uLongAtOffset: 16!
itemId
        "Private - Answer the item id."
    ^self uLongAtOffset: 8!  
ctlId
        "Private - Answer the control id of the control to be measured."
    ^self uLongAtOffset: 4!  
ctlId: anInteger
        "Private - Set the control id of the control to be measured."
    self uLongAtOffset: 4 put: anInteger!
itemData: anInteger
        "Private - Set the item value."
    self uLongAtOffset: 20 put: anInteger!  
itemData
        "Private - Answer the item value."
    ^self uLongAtOffset: 20!
itemHeight: anInteger
        "Private - Set the height of the item."
    self uLongAtOffset: 16 put: anInteger!
itemId: anInteger
        "Private - Set the item id."
    self uLongAtOffset: 8 put: anInteger!
setDefault: aBoolean
		"Private - if aBoolean is true, make the receiver a default
		pushbutton, otherwise remove the default status if set."
	UserLibrary
		sendMessage: self handle
		msg: BmSetstyle
		wparam: ( aBoolean ifTrue: [ BsDefpushbutton ] ifFalse: [ BsPushbutton ] )
		lparam: true asParameter "redraw"!  
= anIndexedColor
        "Answer whether the receiver and anIndexedColor are equal.  Two IndexedColors
        are equal if they have equal indices."
    anIndexedColor isIndexedColor ifFalse: [ ^false ].
    ^self index = anIndexedColor index!  
asParameter
        "Answer the receiver in a form suitable
        for passing to an API call."
    ^index!   
printOn: aStream
        "Append the ASCII representation of
         the receiver to aStream."
    aStream nextPutAll: self class name, ' (', self index printString, ')'!
asIndexedColor
        "Answer the receiver as an IndexedColor."
    ^self! 
asInteger
        "Answer the receiver's integer index value."
    ^self index! 
index
        "Answer the color index of the receiver."
    ^index! 
index: anInteger
        "Set the color index of the receiver to anInteger."
    index := anInteger!
isIndexedColor
        "Answer whether the receiver is an IndexedColor."
    ^true! 
hash
        "Answer an integer hash value for the receiver.  The hash value of an object
        must be constant over time, and two objects that compare equal must have
        equal hash values."
    ^self index hash!  
showGap
        "Private - Toggle the display
         of the gap selector."
    self moveCaret: ( self bitCoordinate: begin ).
    self showCaret: true! 
dragTargetEraseItemEmphasis
		"Private - erase the previously drawn item emphasis."
	| lastIndex rect |
	lastIndex := self dragTargetSelection.
	rect := self lineToRect: lastIndex.
	self dragTargetDrawEmphasisRectangle: rect!
recursiveMessage
        "Private - Smalltalk has been recursively
         called back from the window proc."
    Notifier recursiveMessage!  
setMapMode: mapMode
        "Set the current mapping mode to mapMode. mapMode
         can be one of the following:
         MmText, MmLometric, MmHimetric, MmLoenglish,
         MmHienglish, MmTwips, MmIsotropic, MmAnisotropic"
    self allHandles do: [ :h |
        ( GDILibrary setMapMode: h mode: mapMode ) = 0
            ifTrue: [ ^self osError ] ]!
nonAuto
        "Create an instance of a non-auto check box."
    ^self new checkBox; yourself! 
auto
        "Create an instance of an auto check box."
    ^self new autoCheckBox; yourself!   
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #checked ;
        add: #unchecked ;
        yourself!   
loadAccelerators: hInstance name: resourceName
    <api: LoadAcceleratorsA ulong struct ulongReturn>
    ^self invalidArgument! 
rgbToPalette: aColor
        "Answer the index of the default palette whose
         color is nearest to RGB color aColor."
    | index |
    ( index := GDILibrary
        getNearestPaletteIndex: ( self getStockObject: DefaultPalette )
        color: aColor asParameter ) = 16rFFFFFFFF
            ifTrue: [ ^self osError ].
    ^self paletteIndex: index!   
dragTargetScrollElapsed: anInteger
		"Private - set the number of milliseconds that have elapsed
		since the mouse moved over the drag scrolling region of
		the receiver."
    self propertyAt: #dragTargetScrollElapsed put: anInteger! 
wmCtlcoloredit: wparam with: lparam
        "Private - Process set control color message;
        override implementation in Window class so that
        the edit part's colors are set regardless of whether
        the edit part is in the Notifier."
    ^self controlColor: wparam!
graphicsToolClass
        "Private - Answer the graphics tool class used by the receiver."
    ^Pen!
drawChain
        "Draw all the segments in their id order."
    1 to: currentId do: [: id |
        self drawSegment: id]!
replace: confirm
        "Private - search for the next occurrence of SearchString,
        and replace it with NewString."
    | found point replace result |
    found := false.
    [
        ( point := self findSearchString ) isNil ifFalse: [
            found := true.
			self selectIndexFrom: point x - 1 to: point y.
            replace := true.
            confirm ifTrue: [
                result := MessageBox
                    titled: 'Find / Replace'
                    withText: 'Replace text?'
                    style: MbYesnocancel.
                result = Idcancel ifTrue: [ ^nil ].
                replace := result = Idyes ].
            replace ifTrue: [ self insert: NewString ] ].
        point notNil
    ] whileTrue: [ ].
    found ifFalse: [
        ^MessageBox notify: 'Find / Replace' withText: 'Search string not found' ]!
selectCharFrom: beginIndex to: endIndex
        "Select from the character beginIndex
        to character endIndex.  The indices
        correspond to indices of characters
        in the string answered by #contents."

    self selectIndexFrom: beginIndex - 1 to: endIndex - 1! 
dragTargetErasePaneEmphasis
        "Private - erase the target emphasis for the receiver
        (where the emphasis indicates the entire pane)."
    "don't erase if no emphasis currently drawn."
    self dragTargetSelection isNil ifTrue: [ ^nil ].
    self dragTargetSelection: nil.
    self dragTargetDrawEmphasisRectangle: self drawingRectangle!   
displayIn: aRect with: aPen
        "Display the receiver in aRect using aPen."
    aPen copyBitmap: self
        from: self boundingBox
        to: aRect!   
addStyle: styleBits
        "Private - if style is nil, initialize it appropriately:
         if #noDefaultStyle was previously sent to the receiver,
         set it to 0, otherwise set it to defaultStyle; then add the
         given style bits to the flag.  Answer the added styleBits."
    style isNil ifTrue: [ style := self getStyle ].
    style := style | styleBits.
    ^style!
callingConventions
        "Private - answer the Dictionary mapping symbolic calling
        convention names with their corresponding integer
        identifiers."
    ^callingConventions! 
callBackTable
        "Private - answer the table of registered callbacks."
    ^callBackTable! 
performSlot: aSlotNumber withArgs: argsStruct
        "Private - Perform the CallBack object at aSlotNumber
         using argsStruct. "
    aSlotNumber > self callBackTable size
        ifTrue: [ ^self error: 'Could not find CallBack object' ].
    ^( self callBackTable at: aSlotNumber )
        performWithArgs: argsStruct!  
slotSize
        "Private - Answer the size of each slot in bytes."
    <primitive: 167>!   
atSelectors
        "Private - answer the Dictionary mapping parameter
        types (symbols) with their corresponding argument sizes
        (in bytes) and extraction methods."
    ^atSelectors!  
atSelectors: aDictionary
        "Private - set the Dictionary mapping parameter
        types (symbols) with their corresponding argument sizes
        (in bytes) and extraction methods to aDictionary."
    atSelectors := aDictionary!   
findEmptySlot
        "Private - Find the next available slot number: if there
         is a free slot, reuse it; otherwise grow the callback table."
    | index |
    [ index := self callBackTable
        indexOf: nil
        ifAbsent: [
            self callBackTable add: nil.
            index := self callBackTable size ] ] evaluateWithoutInterrupts.
    index >= self maxNumCallBack
        ifTrue: [ ^self error: 'CallBack table is full' ].
    ^index!
maxNumCallBack
        "Private - Answer the maximum number of 32-bit callbacks
        allowed per instance of Smalltalk."
    ^4096! 
callingConventions: aDictionary
        "Private - set the Dictionary mapping symbolic calling
        convention names with their corresponding integer
        identifiers to aDictionary"
    callingConventions := aDictionary!   
initializeAtSelectors
        "Private - Initialize atSelectors class instance variable."
    self atSelectors: ( Dictionary new
        at: #short put: ( Array with: 4 with: #shortAtOffset: );
        at: #ushort put: ( Array with: 4 with: #uShortAtOffset: );
        at: #long put: ( Array with: 4 with: #longAtOffset: );
        at: #ulong put: ( Array with: 4 with: #uLongAtOffset: );
        at: #handle put: ( Array with: 4 with: #handleAtOffset: );
        yourself )!   
registerMessage: stMessage
    parameterTypes: aParameterTypeArray
    returnType: aReturnType
    callingConvention: aCcType
        "Answer an instance of CallBack object for stMessage of
         ccType calling convention: stMessage is a CallBack instance
         method; aParameterTypeArray is an array of types expected
         in the callback; a type can be one of the following: #ushort
         #short #ulong #long or #handle.  First argument is the first
         element in the array regardless of the calling convention.
         aReturnType is the type expected to be returned by the
         callback function.  aCCType describes the calling convention
         of the callback.  It can be one of following: #api, #stdcall, #c
         (#api represents the default calling convention of the host
         operating system, which is a synonym for #stdcall)."
    ^self new
        registerMessage: stMessage
        parameterTypes: aParameterTypeArray
        returnType: aReturnType
        callingConvention: aCcType!  
callBackTable: anOrderedCollection
        "Private - set the table of registered callbacks to anOrderedCollection."
    callBackTable := anOrderedCollection!  
setWindowOrg: aPoint
        "Set the window origin of the graphicsMedium associated
          with the receiver."
    self allHandles do: [ :h |
        ( GDILibrary
            setWindowOrgEx: h
            x: aPoint x
            y: aPoint y
            oldOrigin: nil )
                ifFalse: [ ^self osError ] ]!  
asLayout
    "Answer a layout equivalent to the receiver."

    ^((self left between: 0 and: 1)
            and: [(self right between: 0 and: 1)
            and: [(self top between: 0 and: 1)
            and: [self bottom between: 0 and: 1]]])
        ifTrue: [self asLayoutRatio]
        ifFalse: [self asLayoutInset]!   
setHelpCursor
        "Private - Set the cursor for Help Mode"
    HelpCursor setCursor!
noPrefix
        "Add the no prefix style."
    ^self addStyle: SsNoprefix! 
button2Move: aPoint
        "Private - Do right button scrolling."
    | sourceLocation |
    ( self isLocalDragSource and: [ self dragOnMove ] ) ifTrue: [
        ( self isDragSourceInitiation: aPoint ) ifTrue: [
            sourceLocation := self dragSourceLocation.
            self dragOnMove: nil location: nil.
            self doDragDropAt: sourceLocation button: 2 ].
        ^self ].

    self captureMouseInput.
    self rightButtonScroll: aPoint!  
initialize
        "Private - First time initialization. Creates the SelfDefinedStructure "
    | d |
    d := Dictionary new.
    d
        at: #lStructSize put: #(0 #ulong #yourself);
        at: #hwndOwner put: #(4 #handle #yourself);
        at: #hDC put: #(8 #ulong #yourself);
        at: #lpLogFont put: #(12 #ulong #yourself);
        at: #iPointSize put: #(16 #long #yourself);
        at: #flags put: #(20 #ulong #yourself);
        at: #rgbColors put: #(24 #ulong #yourself);
        at: #lCustData put: #(28 #ulong #yourself);
        at: #lpfnHook put: #(32 #ulong #yourself);
        at: #lpstrTemplateName put: #(36 #ulong #yourself);
        at: #hInstance put: #(40 #handle #yourself);
        at: #lpszStyle put: #(44 #ulong #yourself);
        at: #nFontType put: #(48 #ushort #yourself);
        at: #nSizeMin put: #(52 #long #yourself);
        at: #nSizeMax put: #(56 #long #yourself);
        yourself.
    SelfDefinedStructure define: 'CHOOSEFONT' withFields: d!   
new
		"Answer a new instance of the receiver."
	^super new initialize!  
origin: beginPoint corner: endPoint
        "Answer an instance of the receiver whose
         origin is beginPoint and corner is endPoint."
    ^self new origin: beginPoint
        corner: endPoint!   
selectToBit: aPoint
        "Private - Extend the selection to aPoint (pixels) either
         before or after the original one."
    | bPoint |
    bPoint := pane stringCoordinate: aPoint.
    self isGap
        ifTrue: [
            bPoint = extendOrigin ifTrue: [^self].
            self hideGap.
            extendOrigin := begin]
        ifFalse: [
            bPoint = extendOrigin ifTrue: [
                self hide.
                begin := extendOrigin.
                end := begin - (1@0).
                ^self]].
    (bPoint isBefore: extendOrigin)
        ifFalse: [ "forewards"
            bPoint := bPoint - (1@0)].
    self selectTo: bPoint!
isGap
        "Answer true if the selection is a gap."
    ^end isBefore: begin!
merge: aTextSelection
        "Answer a TextSelection, the receiver
         merged with aTextSelection."
    ^self class
        origin: (begin min: aTextSelection origin)
        corner: (end max: aTextSelection corner)!   
height
        "Private - Answer the number of lines
         of the receiver."
    ^end y - begin y + 1!  
extent
        "Private - Answer a Point whose coordinates are the
         number of characters and the number of lines
         in the selection respectively."
    ^end - begin + (1@1)!   
selectBefore: aPoint
        "Place the selection before aPoint."
   self hide.
    begin := aPoint.
    end := aPoint - (1 @ 0).
    extendOrigin := begin! 
selectTo: aPoint
        "Extend the selection to aPoint either
         before or after the original one."
    self isGap
        ifTrue: [
            self hideGap.
            extendOrigin := begin].
    extendOrigin isNil ifTrue: [extendOrigin := begin].
    selectFlag := true.
    (aPoint isBefore: extendOrigin)
        ifTrue: [ "backward"
            (end isBefore: extendOrigin)
                ifFalse: [ "get rid of tail"
                    self
                        hideSelection: extendOrigin
                        to: end.
                    end := extendOrigin - (1@0)].
            (aPoint isBefore: begin)
                ifTrue: [
                    self
                        showSelection: aPoint
                        to: begin - (1@0)]
                ifFalse: [
                    self
                        hideSelection: begin
                        to: aPoint - (1@0)].
            begin := aPoint max: (1 @ 1)]
        ifFalse: [ "forward"
            (begin isBefore: extendOrigin)
                ifTrue: [ "get rid of head"
                    self
                        hideSelection: begin
                        to: extendOrigin - (1@0).
                    begin := extendOrigin].
            aPoint = end
                ifFalse: [
                    (aPoint isBefore: end)
                        ifTrue: [
                            self
                                hideSelection: aPoint + (1@0)
                                to: end]
                        ifFalse: [
                            self
                                showSelection: end + (1@0)
                                to: aPoint]].
            end := aPoint max: (0 @ 1)].
    self isGap ifTrue: [self showGap]!
displaySelection
        "Private - Display the non-gap selection."
    selectFlag ifTrue: [^self]. "already shown"
    self isGap ifTrue: [^self].
    selectFlag := true.
    self showSelection: begin to: end!   
showSelection: beginPoint to: endPoint
        "Private - Toggle the display of the selection."
    self
        showSelection: beginPoint
        to: endPoint
        with: #reverse:! 
origin
        "Private - Answer the origin of the receiver."
    ^begin!   
displayGap
        "Private - Display the gap selector."
    selectFlag ifTrue: [^self]. "already shown"
    self isGap ifFalse: [^self].
    selectFlag := true.
    self showGap!  
origin: aPoint
        "Private - Change the origin of the receiver to aPoint."
    self hide.
    begin := aPoint!
initialize
        "Private - Initialize the receiver."
    begin := end := 0@0.
    selectFlag := false!  
top
        "Private - Answer the y-coordinate of
         the origin of the receiver."
    ^begin y!  
display
        "Display the gap selector or the selection."
    pane pen isNil ifTrue: [^self].
    self isGap
        ifTrue: [self displayGap]
        ifFalse: [self displaySelection]!  
corner: aPoint
        "Private - Change the end point of
         the receiver to aPoint."
    self hide.
    end := aPoint! 
extendOrigin: aPoint
        "Private - Change the origin of the receiver to aPoint."
    ^extendOrigin := aPoint!  
pane: aPane
        "Private - Change the pane of the receiver."
    pane := aPane! 
hide
        "Hide the gap selector or the selection."
    self isGap
        ifTrue: [self hideGap]
        ifFalse: [self hideSelection]!   
hideGapFlag
        "Private - Hide the gap selector flag without
         reversing it."
    self isGap ifTrue: [
        selectFlag := false]!  
isTextSelection
        "Answer true if receiver is a kind of TextSelection."
    ^true!
selectAfter: aPoint
        "Place the selection after aPoint."
    self hide.
    begin := aPoint + (1 @ 0).
    end := aPoint!  
displayPatch: aRectangle
        "Private - Display the part of the receiver
         intersecting aRectangle."
    | box |
    self isGap ifTrue: [^self].
    selectFlag ifFalse: [^self]. "not to be shown"
    box := self intersect: aRectangle.
    box isNil ifFalse: [
        self showSelection: box origin
            to: box corner]!   
intersect: aTextSelection
        "Answer a Rectangle, the intersection
         of the receiver and aTextSelection."
    | origin corner |
    origin := begin y max: aTextSelection origin y.
    corner := end y min: aTextSelection corner y.
    origin > corner ifTrue: [^nil].
    origin <= begin y
        ifTrue: [origin := begin]
        ifFalse: [origin := 1 @ origin].
    corner >= end y
        ifTrue: [corner := end]
        ifFalse: [corner :=
            0 @ (corner + 1)].
    ^origin corner: corner!   
hideScroll
        "Hide the gap selector or the selection."
    self isGap
        ifTrue: [self hideGap]
        ifFalse: [self hideSelectionScroll]!   
origin: beginPoint corner: endPoint
        "Change the origin and corner of the receiver
         to beginPoint and endPoint respectively."
    self hide.
    begin := extendOrigin := beginPoint.
    end := endPoint!
hideSelectionScroll
        "Private - Hide the selection."
    selectFlag ifFalse: [^self].
    self isGap ifTrue: [^self].
    selectFlag := false.!
corner
        "Private - Answer the end Point of the receiver."
    ^end!  
hideGap
        "Private - Hide the gap selector."
    selectFlag ifFalse: [^self].
    self isGap ifFalse: [^self].
    selectFlag := false.
    self showCaret: false! 
asParameter
        "Answer the receiver in a form suitable for passing
         as a parameter to a host procedure call."
    ^self handle!   
wmErasebkgnd: wordInteger with: longInteger
        "Private - Process the erase background message."
    ^nil! 
deleteMessage
        "Private - Answer OS delete message for the receiver."
    ^LbDeletestring!   
noHideSelection
        "Add the no hide selection style."
    ^self addStyle: EsNohidesel! 
containsPicture
        "Answer whether the clipboard contains a stored picture."
    ^self containsFormat: CfMetafilepict! 
dragTargetScrollDirection
		"Private - answer the direction scrolling was occurring last."
    ^self propertyAt: #dragTargetScrollDirection!
ownDCScreenWidth: w height: h
        "Create a screen compatible bitmap with width w height h.
         The bitmap has its own device context."
    | hOldBitmap aDC bitsPixel planes bitCount |
    aDC := self class createCompatibleDC: Display deviceContext.
    bitsPixel := GDILibrary getDeviceCaps: Display deviceContext
        index: Bitspixel.
    planes := GDILibrary getDeviceCaps: Display deviceContext
        index: Planes.
    bitCount := bitsPixel * planes.
    self initPenWidth: w
        height: h
        planes: 1
        bitCount: bitCount
        forDC: aDC.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: w @ h)
        rule: Whiteness.
    graphicsTool selectObject: hOldBitmap!  
dialogUnit
        "Answer the dialog base unit as a Point.
         This is the average system font char size."
    | long |
    long := UserLibrary getDialogBaseUnits.
    ^(long \\ 16r10000) @ (long // 16r10000)!  
setFocusOnControl
        "Set the focus on receiver.  This is different
         than 'setFocus' in that this also changes
         the border of the control."
    self isHandleOk
        ifTrue: [
            parent notNil ifTrue: [
                UserLibrary
                    sendMessage: self parent handle
                    msg: WmNextdlgctl
                    wparam: handle
                    lparam: 1 ] ]
        ifFalse: [ self whenValid: #setFocusOnControl ]!
paneAt: aSymbol
        "Answer a ControlPane subclass instance corresponding
         to the dialog control with the name (ItemIds key) or id
         (integer) aSymbol; retrieve the object from the children
         instance variable, or create it if not yet present"
    | id controlHandle control |
    ( id := aSymbol ) isInteger ifFalse: [
        id := self itemIds at: aSymbol
            ifAbsent: [ self error: 'undefined control, id = ', id printString ] ].

    children isNil
        ifTrue: [ children := IdentityDictionary new ]
        ifFalse: [
            ( children includesKey: id )
                ifTrue: [ ^children at: id ] ].

    ( controlHandle := UserLibrary getDlgItem: handle item: id ) = 0
        ifTrue: [ ^self osError ].
    control := ( ControlPane fromHandle: controlHandle )
        owner: self.
    children at: id put: control.
    ^control!   
getBitmap
        "Open the clipboard and answer
         an instance of Bitmap from the clipboard."
    | hBitmap bitmap |
    self containsBitmap ifFalse: [ ^nil ].
    self open ifFalse: [ ^nil ].
    ( hBitmap := UserLibrary getClipboardData: CfBitmap ) = 0 ifTrue: [
        self osWarning.
        self close.
        ^nil ].
    bitmap := Bitmap fromHandle: hBitmap.
    self close.
    ^bitmap!
sizeOfSelection: aTextSelection
        "Private - Answer the approximate size in bytes of
         selected text."
    | tally line i aCollection |
    aCollection := self linesIn: aTextSelection.
    tally := 0.
    1 to: aCollection size do: [ :index |
        line := aCollection at: index.
        (line isEmpty or: [line last ~= $ ])
            ifFalse: [
                i := line size - 1.
                [i > 0 and: [(line at: i) == $ ]]
                    whileTrue: [i := i - 1].
                (i > 0 and: [(line at: i) == $$])
                    ifTrue: [i := i + 1].
                line := line copyFrom: 1 to: i.
                aCollection at: index put: line].
        tally := tally + line size + 2].            "2 for Cr-Lf"
    ^tally!   
defaultObjects
        "Private - Answer default graphics objects."
    ^DefaultObjects!
sizeInBytes
    ^12! 
restoreSegments: hdc
        "Private - Recreate the segments in the receiver
         from the saved graphics data with hdc as
         the new device context handle.  This is done
         when restarting a saved image."
    | hMetafile |
    self handle: hdc.
    segments keysDo: [ :segId |
        hMetafile := self putData: ( archive at: segId ).
        ( segments at: segId ) handle: hMetafile ]! 
extent: aPoint
        "Private - Initialize the receiver with extent aPoint."
    ^self width: aPoint x height: aPoint y!  
displayText: aString in: aRectangle wordWrap: wordWrapBoolean
        "Private - display aString within the bounds of aRectangle; if
        wordWrapBoolean is true, text will be word wrapped, otherwise
        it will just be clipped within aRectangle."
    | lines |
    lines := self
        asArrayOfLines: aString
        in: aRectangle
        wordWrap: wordWrapBoolean.
    self displayLines: lines in: aRectangle!
delete
        "Delete the Windows atom corresponding to the receiver."
    ( KernelLibrary globalDeleteAtom: self asParameter ) = 0
        ifFalse: [ ^self osError ].
    self uLongAtOffset: 0 put: 0!
fromWmKeyup: wparam with: lparam
        "Private - answer an instance of the receiver class corresponding to
        the host WM_KEYUP message described by the arguments, for those
        messages that should be processed via WM_KEYUP."
    | event shiftState scanCode |
    ( wparam = EscapeKey or: [ self isToggleKey: wparam ] ) ifFalse: [ ^nil ].
    event := self new.
    shiftState := 0.
    ( Notifier isShiftKeyDown ) ifTrue: [ shiftState := shiftState bitOr: AfShift ].
    ( Notifier isControlKeyDown ) ifTrue: [ shiftState := shiftState bitOr: AfControl ].
    ( Notifier isAltKeyDown ) ifTrue: [ shiftState := shiftState bitOr: AfAlt ].
    event shiftState: shiftState.
    event virtualKey: wparam.
    scanCode := ( lparam bitShift: -16 ) bitAnd: 16rFF. "byte 3 is scan code"
    event scanCode: scanCode.
    ^event! 
isWindow: aWindowHandle
    <api: IsWindow ulong boolean>
    ^self invalidArgument!
print
        "Private - Open a PrintDialog to permit printing of the contents or selection
        of the receiver."
    | dialog hDCPrinter printer string |
    dialog := PrintDialog new
        noPages.
    self selectedItem isEmpty ifTrue: [ dialog noSelection ].
    dialog open.

    ( hDCPrinter := dialog hDCPrinter ) isNil ifTrue: [ ^nil ].
    printer := Printer fromDC: hDCPrinter.
    string := dialog selection ifTrue: [ self selectedItem ] ifFalse: [ self contents ].
    [ printer
        print: string
        font: self font
        title: nil
        collate: dialog collate
        copies: dialog copies
        wordWrap: self isWordWrapEnabled
        marginsRect: nil ] forkAt: 3!  
contextForItem: anInteger
        "Private - answer nil because a DialogBox does not
        have a menu bar."
    ^nil!   
lineDisplay: aString at: aPoint
        "Display aString at aPoint and blank rest of line."
    | ascender |
    ascender := font basePoint y.
    self blank: (aPoint x @ (aPoint y  - font basePoint y " - (font height - ascender)")
            corner: ( width @ (aPoint y + font descender "+ font height" "ascender"))).
    self displayText: aString at: aPoint!   
showSelection: beginPoint to: endPoint with: aSelector
        "Private - Toggle the display of the selection."
    | pen foreColor backColor |
    pen := pane pen.
    aSelector = #reverse:
        ifTrue: [
            pane doGraphics: [
                foreColor := pen foreColor.
                backColor := pen backColor.
                pen
                    foreColor: Color highlightText;
                    backColor: Color highlightBackground.
                pane textHolder
                    displaySelection: (beginPoint corner: endPoint).
                pen
                    foreColor: foreColor;
                    backColor: backColor]]
        ifFalse: [
            pane doGraphics: [
                pane textHolder
                    displaySelection: (beginPoint corner: endPoint)]].! 
startTimer: anInteger period: milliSeconds forWindow: aWindow
        "Start a timer identified by anInteger. A wmTimer
        message will be sent to aWindow every milliSeconds."
    ( UserLibrary
        setTimer: aWindow handle
        idEvent: anInteger
        elapsedTime: milliSeconds
        timerFunc: nil ) = 0
            ifTrue: [ ^self osError ]!  
allHandles
        "Private - Answer all handles to be used in GDI functions."
    | segDC |
    ( segmentIsOpen not or: [ drawingMode = DrawingModeDraw ] )
        ifTrue: [ ^super allHandles ].
    ( GDILibrary
        moveToEx: ( segDC := self currentSegment deviceContext )
        x: location x
        y: location y
        oldPosition: nil )
            ifFalse: [ self osNotification ].
    drawingMode = DrawingModeRetain ifTrue: [ ^Array with: segDC ].
    ^Array
        with: segDC
        with: self handle!
buildMenuBar
        "Private - Create the menus that make up the menu bar."
    | textPane eachMenu menuBuilder |
    menuWindow addMenu: ( self fileMenu allOwners: self ).
    ( self respondsTo: #saveAs ) ifFalse: [
        ( eachMenu := menuWindow menuTitled: '&File' ) notNil
            ifTrue: [ eachMenu disableItem: #saveAs ] ].
    textPane := self searchForDefaultTextPane.

    textPane notNil ifTrue: [
        menuBuilder := Smalltalk isRunTime
            ifTrue: [ StandardWindowPolicy ]
            ifFalse: [ Smalltalk at: #SmalltalkWindowPolicy ].
        menuWindow addMenu: ( menuBuilder editMenu allOwners: textPane ).
        Smalltalk isRunTime ifFalse: [
            menuWindow addMenu: ( ( menuBuilder smalltalkMenu: true ) allOwners: textPane ) ] ].

    self allChildrenInBuildOrderDo: [ :subpane |
        ( eachMenu := subpane menu ) notNil
            ifTrue: [ menuWindow addMenu: eachMenu ] ].
    menuWindow systemMenu
        owner: self.
    menuWindow systemMenu
        insertItem: '&Zoom    Alt+Z'
        selector: #zoom
        accelKey: $z
        accelBits: AfAlt
        after: 5.

    self helpManager notNil
        ifTrue: [self helpManager buildMenuBar]!   
dispatchMessage: aWinAddr
        "Private - Dispatch the next Windows message.
         This sends messages to our window proc."
    <api: DispatchMessageA ulong long>
    ^self invalidArgument!   
sendMessage: msg item: itemId wparam: int lparamStruct: struct
        "Private - send the given message to the given item."
    ^UserLibrary
        sendDlgItemMessageInt: handle
        item: itemId
        msg: msg
        wparam: int
        lparamStruct: struct!
dragSourceNeedsObjectDefault: dragSession
        "Private - provide default handling of request for item
        to be dragged."
    | dragDropObject |
    dragDropObject := dragSession objectClass new
        string: self selectedItem;
        yourself.
    dragSession objects: ( Array with: dragDropObject )!   
wmMenuselect: wparam with: lparam
         "Private - A menu item or outside is selected."
    | id flags text receiver context hMenu popupMenu |
    ( self helpManager isNil and: [ self statusPane isNil ] ) ifTrue:[ ^nil ].
    id := wparam lowWord.
    flags := wparam highWord.
    hMenu := lparam asUnsigned.
    lparam = 0 ifTrue: [ "menu closed"
        self statusPane notNil ifTrue: [
            self statusPane showHelp:nil ].
        ^nil ].
    receiver := self menuWindow.
    receiver isNil
        ifTrue: [    "popup menu"
            receiver := self.
            receiver popup isNil ifTrue: [^self] ]
        ifFalse: [ receiver owner notNil ifTrue: [ receiver := receiver owner ] ].
    flags & MfSysmenu > 0 ifTrue: [
        id := id // 256 * 256 + ( id \\ 256 bitShift: -4 ) ].
    popupMenu := true.
"    receiver isSubPane ifTrue: [ popupMenu := receiver isHandleForPopupMenu: hMenu ]."
    popupMenu ifFalse: [ ^nil ].
    flags & MfPopup > 0
        ifTrue: [
            hMenu := UserLibrary getSubMenu: hMenu pos: id.
            context := receiver contextForPopup: hMenu ]
        ifFalse: [ context := receiver contextForItem: id ].
    wparam lowWord >= 16rF000 ifTrue: [
        context := Association key: ( HelpManager systemContextStrings at: wparam lowWord ) value: self owner ].
    flags & MfPopup > 0 ifTrue: [
        flags & MfSysmenu > 0 ifTrue: [ receiver := self ].
        hMenu = receiver systemMenuHandle ifTrue:[
            receiver isMDIChild
                ifTrue: [ context := Association key: 'MDISysMenu' value: self owner ]
                ifFalse: [ context := Association key: 'SysMenu' value: self owner ] ] ].
    context notNil ifTrue: [
        self mainWindow helpContext: context ].
    self statusPane isNil ifTrue: [ ^nil ].
    context notNil ifTrue: [
        (context value respondsTo: #statusPaneHelp:) ifTrue:[
            text := context value statusPaneHelp: context key ] ].
    text isNil ifTrue: [ text := '' ].
    self statusPane showHelp: text .
     ^nil!  
bitmapInfo: aBitmapInfoStruct
        "Private - set the structure describing the meta information
        about the receiver to aBitmapInfoStruct."
    bitmapInfo := aBitmapInfoStruct!  
timers
        "Private - answer a map between outstanding timers ids and
        their corresponding Timer objects."
    Timers isNil ifTrue: [ Timers := IdentityDictionary new ].
    ^Timers! 
timers: anIdentityDictionary
        "Private - set the map between outstanding timers ids and
        their corresponding Timer objects to anIdentityDictionary."
    Timers := anIdentityDictionary! 
timerTicked: timerId
        "Private - the timer with the given timerId went off."
    | timer |
    timer := self timers at: timerId ifAbsent: [ ^nil ].
    timer ticked!  
constructEventsTriggered
        "Private - answer all the events which can be triggered
         by instances of the receiver. "
    ^super constructEventsTriggered
        add: #ticked ;
        yourself!   
chord: boundingBox start: startPoint end: endPoint
        "Call GDI Chord function."
    self allHandles do: [ :h |
        ( GDILibrary chord: h
            x1: boundingBox origin x
            y1: boundingBox origin y
            x2: boundingBox corner x
            y2: boundingBox corner y
            x3: startPoint x
            y3: startPoint y
            x4: endPoint x
            y4: endPoint y )
                ifFalse: [ self osNotification ] ]!  
dragTargetEmphasisTypesSupported
		"Private - answer a collection of emphasis types that the receiver can support."
	^#( 'pane' 'separator' )!  
isTextSelection
        "Answer true if receiver is a kind of TextSelection."
    ^false!   
ctl3dEnabled
        "Answer whether the Ctl3d32DLL class if present and enabled."
	| ctl3d |
	ctl3d := Smalltalk at: #Ctl3d32DLL ifAbsent: [ ^false ].
	^ctl3d enabled!  
setScale
        "Private - Set the transformation scaling according to
         the stretch instance variable."
    firstTime
        ifTrue: [originalExtent := rectangle extent]
        ifFalse: [
            stretch = 0            "no scretch"
                ifTrue: [^self]
                ifFalse: [
                    stretch = 1     "stretch but maintain aspect ratio"
                        ifTrue: [
                            graphicsTool setMapMode: MmIsotropic]
                        ifFalse: [
                            graphicsTool setMapMode: MmAnisotropic].
                    graphicsTool setWindowExt: originalExtent.
                    graphicsTool setViewportExt: rectangle extent.
                    graphicsTool width: originalExtent x;
                        height: originalExtent y]]!
setBitmap: aBitmap
        "Copy aBitmap to the clipboard."
    | clipboardBitmap handle |
    ( aBitmap isNil or: [ aBitmap handle isNil ] ) ifTrue: [ ^nil ].
    self open ifFalse: [ ^nil ].
    aBitmap deselect.
    handle := aBitmap handle.
    clipboardBitmap := Bitmap fromHandle: aBitmap handle.
    clipboardBitmap doesNotNeedFinalization.
    ( UserLibrary setClipboardData: CfBitmap hMem: clipboardBitmap handle ) = 0
        ifTrue: [ ^self osError ].
    self close! 
controlEvent: event id: controlID
        "Private - reimplemented in subclasses.  This method
        is called when there is no corresponding method in
        ItemIds for a particular event.  Also, this method
        receives an up to date control ID whereas methods
        registered with ItemIds don't"!   
searchHelpOn
        "Private - The user has clicked Search for Help on"
    self winHelp: HelpPartialkey data: ''! 
wmLbuttondblclk: wordInteger with: longInteger
        "Private - If a text pane has been modified and the
        receiver is active, return right away. Else add a
        MessageExpression to CurrentEvents and return
        right away."
    ( self mainWindow isTextModified and: [ self isActive ] ) ifTrue: [ ^nil ].
    ^super wmLbuttondblclk: wordInteger with: longInteger!  
defaultExtendedStyle
        "Private - answer the default extended style flags for the
        receiver.  Add the 3d border style."
    ^OperatingSystem versionMajor >= 4 ifTrue: [ WsExClientedge ] ifFalse: [ 0 ]! 
buildWindow: menuBar
        "Private - Build the menu for the receiver.
         Set the id field for each menu item.
         The id is two bytes. menuNumber is the number
         assigned to the menu.  We use menuNumber as
         the first byte and the ordinal number of the item
         as the second byte. Thus ensuring unique ids
         across all the menus in a window.
         Answer the MenuItem for the receiver."
    | menuNumber |
    menuNumber := menuBar newSubMenuFor: self.
    menuNumber isNil ifTrue: [ ^nil ].
    menuItem := MenuItem new
        style: MfString + MfPopup;
        attribute: 0;
        id: ( menuNumber * 256 ) + 1;
        label: 'TempText';
        submenu: self;
        yourself.
    1 to: items size do: [ :i |
        self buildItem: i menu: menuNumber parent: menuBar ].
    ^menuItem! 
defaultExtendedStyle
        "Private - answer the default extended style flags for the
        receiver.  Add the 3d border style."
    ^OperatingSystem versionMajor >= 4 ifTrue: [ WsExClientedge ] ifFalse: [ 0 ]! 
flags
        "Private - Answers the dialog box current flags.
        For compatibility reasons -> use style instead "
    ^chooseFontStruct flags!   
logicalTool
        "Answer the handle of the pen object."
    ^logicalTool!
on: anObject
    "Create a new instance whose value is <anObject>."

    ^self new value: anObject!
constructEventsTriggered
        "Private - Construct the set of events triggered by instances
        of the receiver."
    ^super constructEventsTriggered
        add: #changed: ;
        yourself!  
dragTargetEraseSeparatorEmphasis
		"Private - erase the previously drawn separator emphasis."
	| lastIndex pt |
	lastIndex := self dragTargetSelection.
	pt := self bitCoordinate: lastIndex.
	self dragTargetDrawEmphasisCaretFrom: pt to: ( pt down: self font height )!   
initialize
        "Private - initialize the SelfDefinedStructure required by the receiver."
    | d |
    ( d := Dictionary new )
        at: #cbSize put: #(0 #long #yourself);
        at: #lpszDocName put: #(4 #ulong #yourself);
        at: #lpszOutputName put: #(8 #ulong #yourself);
        yourself.
    SelfDefinedStructure define: 'DOCINFO' withFields: d.!   
buildSystemPopupMenu: menuBar
        "Private - Build the host system side of the menu for the receiver.
         Set the id field for each menu item.
         The id is two bytes. First byte is the number
         assigned to the menu.  Second byte is the
         ordinal number of the item.  Because WM_SYSCOMMAND
         reserves the right to use the first four low-order bits, the
         Second byte is shifted 4 bits.  This puts a limitation of 8 menu
         item for any given popup menu off the system menu.  However,
         There is no limitation for menu items in the system menu.
         Thus ensuring unique ids across all the menus in a window.
         Answer the MenuItem for the receiver."
    | menuNumber |
    menuNumber := menuBar newSubMenuFor: self.
    menuNumber isNil ifTrue: [^nil].
    menuItem := MenuItem new
        id: (menuNumber * 256) + 1;
        label: 'TempText';
        submenu: self;
        style: MfString + MfPopup;
        attribute: 0;
        yourself.
    1 to: items size do: [:i|
        (self buildSystemItem: i menu: menuNumber parent: menuBar) isNil ifTrue:[^nil]].
    ^menuItem! 
screenExtent: aPoint
        "Answer a Bitmap with extent aPoint and the same
         attribute (e.g. number of colors) as the current Screen."
    ^self new screenExtent: aPoint!   
dialogBox: hInstance
        templateName: aTemplateName
        parent: hWndParent
        dialogFunction: lpDialogFunc
    <api: DialogBox ulong struct ulong ulong ulongReturn>
    ^self invalidArgument!
isDialogMessage: diagHandle lpmsg: aWinAddr
        "Private - Translate and dispatch the modeless window message.
         It also processes special keyboard strokes like TAB, ENTER."
    <api: IsDialogMessage ulong ulong boolean>
    ^self invalidArgument!
queryClientRectangle
        "Private - Answer the receiver's client area rectangle
         as a WinRectangle structure."
    | rectStruct |
    rectStruct := WinRectangle new.
    self isHandleOk ifTrue: [
        ( UserLibrary
            getClientRect: self asParameter
            rectangle: rectStruct asParameter )
                ifFalse: [ ^self osError ] ].
    ^rectStruct!
dragTargetForFormats: formats operations: operations
        "Enable the receiver as a drag drop target which accepts
        the specified DragDropObject formats and drop
        operations.  If this method is used to setup a drag target
        (instead of #dragTarget), the #dragEnter: event can be left
        unhandled and a default handler will be provided."
    self dragTarget.
    self dragTargetFormats: formats.
    self dragTargetOperations: operations.!   
resumeDevelopment: oldWindows
        "Private - restore the development environment to the same state that it was
        in prior to the last image save."
    Notifier postInputEvent:
        ( Message
            receiver: Notifier
            selector: #resume:
            arguments: ( Array with: oldWindows ) )! 
activate
        "Private - The receiver was activated."
    | focusPane |
    super activate.
    ( ( ( focusPane := self subPaneWithFocus ) notNil and: [ self isActive ] ) and: [ self minimized not ] )
        ifTrue: [ Notifier getFocusWindow isSubPane ifFalse: [ focusPane setFocus ] ]!   
dragSourceCutDefault: dragSession
        "Private - handle the source cut by removing the selection
        from the receiver."
    self cutSelection!
fromRgbColor: anArrayOfRgbQuads entries: anInteger
    " Answer an instance of the receiver with at most anInteger
    of its  entries copied from aByteArray .  Note that while a
    palette entry is stored as Red-Green-Blue, the RGBquad
    data is actually stored as Blue-Green-Red.
    Look at the structure definitions for LOGPALETTE and RGBQUAD
    in windows.h."
    | logPalette aByteArray count|
    count := anArrayOfRgbQuads size.
    aByteArray  := ByteArray new: count.
    0 to: ( (count // 4) - 1 )  do:[ :i |
      aByteArray at: (i * 4 + 1) put: (anArrayOfRgbQuads at: (i * 4 + 3)).
      aByteArray at: (i * 4 + 2) put: (anArrayOfRgbQuads at: (i * 4 + 2)).
      aByteArray at: (i * 4 + 3) put: (anArrayOfRgbQuads at: (i * 4 + 1)).
      aByteArray at: (i * 4 + 4) put: 0. ].

   anInteger < ( aByteArray size  / 4 )
    ifTrue: [
        logPalette := self new: ( 4 + ( anInteger * 4 ) ).
        logPalette uShortAtOffset: 0 put: 16r300.
        logPalette  uShortAtOffset: 2 put: anInteger.
        logPalette contents replaceFrom: 5 to: ( 4 + ( anInteger * 4 ) )
                                        with: aByteArray startingAt: 1]
    ifFalse: [
        logPalette := self new: ( 4 + ( aByteArray size ) ).
        logPalette uShortAtOffset: 0 put: 16r300.
        logPalette  uShortAtOffset: 2 put:  ( ( aByteArray size) /4 ).
        logPalette bytesAtOffset: 4 put: aByteArray].

        ^logPalette! 
sizeInBytes
         "Private - Answer the default size in bytes."
    ^1028!   
fromRgbColor: aByteArray
    " Answer an instance of the receiver with its
        entries copied from aByteArray ."
    ^self fromRgbColor: aByteArray entries: (aByteArray size) // 4.!  
= aWinLogPalette
        "Answer true if the contents of the receiver are equal
         to the contents of aWinLogPalette."
    self class == aWinLogPalette class ifFalse: [ ^false ].
    ^self contents = aWinLogPalette contents!
version
    ^self uShortAtOffset: 0! 
version: anInteger
    self uShortAtOffset: 0 put: anInteger!
numEntries
    ^self uShortAtOffset: 2!  
hash
        "Answer the size of the receiver as its hash value."
    ^contents hash!   
entries
		"Answer an Array of WinPaletteEntry structures embedded in the receiver."
    | array offset |
    array := Array new: self numEntries.
    offset := 4.
    1 to: self numEntries do: [ :i |
		array at: i put: ( WinPaletteEntry usingBytes: ( self bytesAtOffset: offset count: WinPaletteEntry sizeInBytes ) ).
		offset := offset + WinPaletteEntry sizeInBytes ].
	^array
    !  
numEntries: anInteger
    self uShortAtOffset: 2 put: anInteger! 
entries: arrayOfPaletteEntries
		"Set the contents of the receiver from arrayOfPaletteEntries; assumes
        the receiver is alrteady of appropriate size (or larger)."
	| offset |
	self numEntries: arrayOfPaletteEntries size.
	offset := 4.
    arrayOfPaletteEntries do: [ :pe |
		self bytesAtOffset: offset put: pe contents ]!   
wmVScroll: wordInteger with: longInteger
        "Private - Scroll the receiver vertically.
        If the source of the message is a scroll control,
        then raise a control event."
    | w ctrlId |
    longInteger = 0 ifTrue: [ ^nil ].
    ctrlId := UserLibrary getWindowLong: longInteger index: GwlId.
    ( w := self childAtId: ctrlId ) isNil ifTrue: [ ^nil ].
    w
        syncControlEvent: wordInteger lowWord
        with: ( ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2 ).
    ^nil!  
createWindowULong: className
    nameULong: nameString
    style: styleInteger
    x: xInteger
    y: yInteger
    width: widthInteger
    height: heightInteger
    parent: parentHandle
    menu: menuHandle
    instance: instanceHandle
    paramULong: paramStructure
       "Private - This method only works for non-predefined window classes."
    ^self
        createWindowULongEx: 0
        class: className
        nameULong: nameString
        style: styleInteger
        x: xInteger
        y: yInteger
        width: widthInteger
        height: heightInteger
        parent: parentHandle
        menu: menuHandle
        instance: instanceHandle
        paramULong: paramStructure!  
initializeSmalltalkCursors
        "Private - initialize cursors defined by Smalltalk."
    | constants cursor |
    constants := OrderedCollection new
        add: ( Association key: 'HelpCursor' value: 'HelpCursor' );
        add: ( Association key: 'DragDropCopy' value: 'DragDropCopy' );
        add: ( Association key: 'DragDropCopyScroll' value: 'DragDropCopyScroll' );
        add: ( Association key: 'DragDropMove' value: 'DragDropMove' );
        add: ( Association key: 'DragDropMoveScroll' value: 'DragDropMoveScroll' );
        add: ( Association key: 'DragDropLink' value: 'DragDropLink' );
        add: ( Association key: 'DragDropLinkScroll' value: 'DragDropLinkScroll' );
        add: ( Association key: 'DragDropNone' value: 'DragDropNone' );
        yourself.
    constants do: [ :assoc |
        cursor :=  self
            fromModule: DynamicLinkLibrary runtimeResourceDLLName
            id: assoc value asParameter.
        CursorConstants at: assoc key put: cursor ]!   
containsFormat: aCfConstant
        "Answer true if the clipboard contains data in
         the format described by aCfConstant.  aCfConstant
         is a constant from the OperatingSystemConstants pool
         dictionary."
    ^UserLibrary isClipboardFormatAvailable: aCfConstant!  
hideReadonly
        "Hides the file dialog's Readonly check box. "
    self style: self style | OfnHidereadonly!   
overwritePrompt
        "Prompt if the user attempts to overwrite a file"
    self style: self style | OfnOverwriteprompt!  
fromHandle: handle style: style
        "Private - answer a new instance of the receiver class or one
        of its subclasses, baed on the given window handle and style."
    ^self handle: ( WindowHandle fromInteger: handle )!   
dragTargetDropDefault: dragSession
        "Private - provide default handling of drop if no handler
        is provided by inserting the text at the position under the mouse."
    | dragObject item dragFormats format position |
    dragObject := dragSession objects first.
    ( dragFormats := self dragTargetFormats ) isNil
        ifTrue: [ ^self error: 'dragTargetFormats: must be specified' ].
    format := dragFormats detect: [ :s | dragObject hasFormat: s ] ifNone: [ ^nil ].
    ( self dragTargetOperations includes: dragSession operation ) ifFalse: [ ^nil ].

    item := dragObject format: format.
    format = 'string' ifTrue: [
        item := item
            replaceCharacter: Tab
            from: 1
            to: item size
            withString: ( ( String new: 4 ) atAllPut: $ ) ].
    position := self characterCoordinate: dragSession targetLocation.
    self selectBefore: position.
    self
        selectTo: ( self replaceWithText: item ) corner;
        hideSelection;
        displayChanges;
        forceSelectionOntoDisplay.
    modified := true
! 
height
        "Answer the height of the font."
    | aCharSize |
    aCharSize := self charSize.
    ^aCharSize notNil
        ifTrue: [ aCharSize y ]
        ifFalse: [ nil ]!   
getClassLong: aHwnd index: anInt1
   <api: GetClassLongA ulong long ulongReturn>
   ^self invalidArgument!  
dragSourceNeedsObjectDefault: dragSession
		"Private - provide default drag object if no handler is provided."
    self implementedBySubclass!  
forceEndOntoDisplay
        "Force the end of the text to appear on
         the display screen."
    | oldSelection |
    oldSelection := selection.
    self selectAtEnd.
    self forceSelectionOntoDisplay.
    selection := oldSelection.
    self setSelection! 
wmSize: wordInteger with: longInteger
        "Private - Process the size message."
    stretch > 0
        ifTrue: [ self invalidateRect: nil ].

    ^super wmSize: wordInteger with: longInteger! 
performCallBack: slotNumber with: longInteger
        "Private - perform the CallBack with the given <slotNumber>, and arguments
        specified by the buffer pointed to by the address <longInteger>."
    ^CallBack
        performSlot: slotNumber
        withArgs: ( ExternalBuffer atAddress: ( ExternalAddress fromString: longInteger ) )!
validate
        "Private - The host window for the receiver was
         just created or recreated."
    self performWhenValids.
    self updateSliders.
    children size ~= 0
        ifTrue: [
            children do: [ :each |
                each isApplicationWindow
                    ifTrue: [ each validateShow]
                    ifFalse: [ each validate ] ] ].
    self isGlobalDragTarget ifTrue: [ self registerDragDrop ]! 
addMaximizeStyle
        "Add the maximize style."
    ^self addStyle: WsMaximize!  
removeSystemMenuStyle
        "Remove the system menu style."
    ^self removeStyle: WsSysmenu! 
defaultDrawItem: aDrawStruct
        "Private - Draw the requested control item."
    | index str bMap font |
    index := self drawIndex.
    str :=  self stringForItem: ( list at: index ).
    self bitmaps notNil ifTrue: [ bMap := self bitmaps at: index ifAbsent: [ nil ] ].
    bMap notNil
        ifTrue: [
            self graphicsTool
                blank: aDrawStruct boundingBox;
                copyBitmap: bMap
                from: bMap boundingBox
                at: self drawBox origin ]
         ifFalse: [
            font := self font isNil ifTrue: [ self defaultFont ] ifFalse: [ self font ].
            self graphicsTool
                blank: aDrawStruct boundingBox;
                setTextAlign: TaTop;
                place: ( self drawBox leftTop down: ( self itemHeight - font height ) // 2 );
                displayText: str ]!   
readWinQueue
        "Private - Read a message from host system's event queue."
    | msgId state |
    state := Process enableInterrupts: false.
    ( self peek: true )
        ifFalse: [ Process enableInterrupts: state. ^false].

        "Check for modeless dialog messages."
    PoppedModelessWindows size > 0 ifTrue: [
        PoppedModelessWindows do: [ :each |
            ( UserLibrary isDialogMessage: each lpmsg: WinMsgNS asParameter )
                ifTrue: [ Process enableInterrupts: state. ^true ] ] ].

        "Check for keystrokes which may require accelerator translation."
    msgId := WinMsgNS msg.
    ( msgId = WmKeydown or: [ msgId = WmSyskeydown ] ) ifTrue: [
        ( self translateAccelerator: WinMsgNS )
            ifTrue: [ Process enableInterrupts: state. ^true ] ].

        "Translate & dispatch other messages."
    UserLibrary translateMessage: WinMsgNS asParameter.
    UserLibrary dispatchMessage: WinMsgNS asParameter.

    Process enableInterrupts: state.
    ^true! 
drawItem: aDrawStruct
        "Private - Draw the requested menu item."
    | menu |
    menu := menuWindow menuWithItemId: aDrawStruct itemId.
    menu triggerEvent: #drawItem:
        withArguments: ( Array with: self drawIndex )
        ifNotHandled: [ super drawItem: aDrawStruct ]!  
openOwner: anOwner style: aStyle
        "Open a print dialog with anOwner as the owner
        window and aStyle initialized in the printDlgStruct.
        Maintained for backward compatibility."
    self owner: anOwner.
    self style: aStyle.
    ^self open!   
dragTargetDrawSeparatorEmphasis: aPoint
		"Private - draw the target emphasis for the receiver
		given the cursor location aPoint (relative to the receiver).
		Emphasis is drawn indicating spaces between existing
		characters as individual targets."
	| index lastIndex pt |
	index := ( self characterCoordinate: aPoint ) "min: textHolder mrrmph".
	index := ( index x min: ( self lineAt: index y ) size + 1 ) @ ( index y min: self totalLength ).  "restrict within bounds"
		"only update if changed"
	lastIndex := self dragTargetSelection.
	index = lastIndex ifTrue: [ ^nil ].  "don't draw emphasis if already drawn."
	lastIndex notNil ifTrue: [ self dragTargetEraseSeparatorEmphasis ].
	pt := selection bitCoordinate: index.
	self dragTargetDrawEmphasisCaretFrom: pt to: ( pt down: self font height ).
	self dragTargetSelection: index!  
propertyAt: name
        "Private - Answer the value at the name
         in receiver's property list."
    | value |
    value := UserLibrary getProp: self name: name asParameter.
    ^( ExternalLong integerFrom: value ) = 0
        ifTrue: [ nil ]
        ifFalse: [ value ]!  
deviceContext
        "Private - Answer the device context of the receiver.
        Added so that Window can be  polymorphic w/ GraphicsMedium."
    ^self getDC!  
fromWmSyskeydown: wparam with: lparam
        "Private - answer an instance of the receiver class corresponding to
        the host WM_CHAR message described by the arguments."
        "Only process alt key oriented sys keys."
    ( ( lparam bitAnd: 16r20000000 ) = 0 and: [ wparam ~=  F9Key ] ) ifTrue: [ ^nil ].
    ^self fromWmKeydown: wparam with: lparam!  
recursiveMessage
        "Private - Smalltalk has been recursively
         called back from the window proc."
    | stack answer |
    stack := MachineState copy.
    answer := self notifyRecursive.
    CurrentEvent
        returnFromRecursion: stack
        value: answer!
dragTargetDefaultEmphasis
		"Private - answer the type of target emphasis that should be employed
		if not otherwise specified."
	^'separator'!
createWindowsIcon
        "Private - create a Windows icon from the receiver's masks.
         Note, this method creates a monochrome icon for use in Windows 3.1."
    | bitCount planes compBitmap iconHandle |
    bitCount := GDILibrary getDeviceCaps: Display pen handle index: Bitspixel.
    planes := GDILibrary getDeviceCaps: Display deviceContext index: Planes.
    bitCount := bitCount * planes.
    bitCount = xorMask bitCount
        ifTrue: [compBitmap := xorMask]
        ifFalse: [  "create a bitmap compatible with the device."
            compBitmap := Bitmap width: xorMask width height: xorMask height planes: 1 bitCount: bitCount.
            compBitmap pen copyBitmap: xorMask
                from: xorMask boundingBox
                at: 0@0].
    iconHandle := UserLibrary
        createIcon: OperatingSystem hInstance
        width: self extent x
        height: self extent y
        planes: compBitmap planes
        bitsPixel: compBitmap bitCount
        andBits: andMask getDDBits
        xorBits: compBitmap getDDBits.
    bitCount = xorMask bitCount ifFalse: [ compBitmap release ].
    ^iconHandle!   
shareAware
        "Allows a previously opened file to be opened
         (e.g. change.log)"
    self style: self style | OfnShareaware!   
noScrollbarsFrameStyle
        "Answer an integer which is the frame style of a window
         without scroll bars."
    ^WsBorder | WsChild | WsVisible | WsClipsiblings | WsClipchildren!   
isDropDownList
        "Answer true if the receiver's host control is a drop down list
		control (as opposed to a drop down or simple list).  This
		method is used to maintain backward compatibility, and the
        class DropDownList should be used instead."
    ^self hasStyle: CbsDropdownlist! 
hostExtendedDragButtonIndex
        "Private - answer the default extended drag button index,
        or nil if not supported."
    ^2!
leftJustified
        "Answer an instance of a left justified static text control."
    ^self new leftJustified; yourself!  
centered
        "Answer an instance of a centered static text control."
    ^self new centered; yourself!  
defaultFont
        "Private - Answer the default font for the pane."
    ^TextFont!
rightJustified
        "Answer an instance of a right justified static text control."
    ^self new rightJustified; yourself!   
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #mnemonicTyped ;
        yourself!
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        remove: #tabbed ;
        yourself!
releaseDC: aDisplayContext
        "Private - Release aDisplayContext, the display
         context for the receiver."
    ( UserLibrary releaseDC: handle with: aDisplayContext ) = 0
        ifTrue: [ ^self osError ]! 
colorChange
        "Private - Window's color has changed."
    graphicsTool notNil ifTrue: [
        graphicsTool foreColor: self foreColor.
        graphicsTool backColor: self backColor ].
    children size ~= 0 ifTrue: [
        children do: [ :each |
            each colorChange ] ]!  
defaultExtent
        "Answer the extent (a Point) of a normal icon."
    ^OperatingSystem defaultIconSize! 
drawnButton
        "Set and answer the button style for user drawn buttons."
    ^self addStyle: BsOwnerdraw!  
releaseBitmaps
        "Private - Release the bitmaps of the receiver from the system."
    andMask notNil ifTrue: [andMask saveBitmap].
    xorMask notNil ifTrue: [xorMask saveBitmap]!  
displayAt: aPoint with: aPen
        "Display the receiver through aPen at the given location."
    ( UserLibrary
        drawIcon: aPen handle
        x: aPoint x
        y: aPoint y
        hIcon: self handle )
            ifFalse: [ ^self osError ]!   
extent
		"Answer the extent of the receiver."
	^self class iconSize!
handle: aHandle
        "Private - Set the receiver's handle"
    hIcon := aHandle! 
fromFileStream: stream
        "Answer an instance of Bitmap from stream."
    | type dibOffset pos |

    pos := stream position.
    type := stream nextUShort.
    "First check for OS/2 icon format"
    (#(16r4349 16r4943 16r5450 16r5043) includes: type)
        ifTrue: [                     "OS/2 single version format."
            stream skip: 12.          "skip file header."
            ^self fromFileStreamOS2: stream]
        ifFalse: [
            type = 16r4142
                ifTrue: [               "multiple versions format"
                    stream skip: 12.    "skip bitmap array file header."
                    type := stream nextUShort.
                    (#(16r4349 16r4943 16r5450 16r5043) includes: type)
                        ifTrue: [stream skip: 12]
                        ifFalse: [^self error:'Resource is not an Icon'].
                    ^self fromFileStreamOS2: stream]].

    "Now check for Windows icon format."
    (type = 0 and: [stream nextUShort = 1])
        ifFalse: [^self error:'Resource is not an Icon'].
    self findVGAImage: stream.
    dibOffset := stream nextULong.
    stream position: pos.
    stream skip: dibOffset.

    self readBitmapsFromFileStream: stream! 
createIcon
        "Private - Create an OS icon from the receiver's masks."
    readOnly ifTrue:[ ^self ].
    hIcon := OperatingSystem isWin32s
        ifTrue: [ self createWindowsIcon ]
        ifFalse: [ self createPointerIndirect: 0 @ 0 flag: false ].
    hIcon = 0 ifTrue: [ ^self osError ].
    self needsFinalization!   
createPointerIndirect: hotSpot flag: aBoolean
        "Private - Create a color pointer or icon from the
         receiver's masks. A pointer is created if aBoolean is
         true else create an icon."
    | bitmask colorMask iconInfo iconHandle |
    ( andMask isNil or: [ xorMask isNil ] ) ifTrue: [ ^nil ].
    bitmask := self andMask clone.
    colorMask := self xorMask clone.
    iconInfo := SelfDefinedStructure named: 'ICONINFO'.
    iconInfo
        fIcon: aBoolean not asParameter;
        xHotspot: hotSpot x;
        yHotspot: hotSpot y;
        hbmMask: bitmask handle asParameter;
        hbmColor: colorMask handle asParameter.
    iconHandle := UserLibrary createIconIndirect: iconInfo asParameter.
    bitmask release.
    colorMask release.
    ^iconHandle!   
finalizationRegistry
    "Private - Answer the WeakRegistry to be used for finalizing instances of the receiver."

    ^SystemWeakRegistries externalResources!
initialize
        "Private - initialize receiver."
    readOnly:=true.!
isValid
        "Answer whether the receiver has a handle or bits."
    ^self hasHandle or: [self andMask notNil]!  
aboutToExitSession
    "Private - Release the host resource."

    self release!   
outputToFileStream: aFileStream
        "Output the receiver in DIB format to aFileStream."
    | bihXorBits andBits |
    bihXorBits := xorMask getIconHeaderDIBits.
    andBits := andMask getDIBits.
    aFileStream
        nextTwoBytesPut: 0;
        nextTwoBytesPut: 1;
        nextTwoBytesPut: 1;
        nextBytePut: xorMask width;
        nextBytePut: xorMask height;
        nextBytePut: xorMask numberOfColors;
        nextBytePut: 0;
        nextTwoBytesPut: 0;
        nextTwoBytesPut: 0;
        nextFourBytesPut: bihXorBits size + andBits size ;
        nextFourBytesPut: 22;
        putBytesFrom: bihXorBits;
        putBytesFrom: andBits.!
fromModule: aFileName id: anId
        "Private - Set the receiver's dllFileName and name"
    dllFileName := aFileName.
    self name: anId!  
hasHandle
        "Answer whether the handle is valid."
    ^(hIcon notNil and: [hIcon ~= 0])!  
initHandle
        "Private - the receiver has been released, set the handle to nil."
    readOnly ifTrue: [ ^self releaseReadOnly ].
    hIcon := nil.
    self releaseBitmaps!  
privateHandle
        "Private - Answer back the receiver's handle"
    ^hIcon! 
release
        "Free the resource associated with the receiver."
    self == RuntimeIcon ifTrue: [ ^self ].  "keep this guy cached."
    readOnly ifTrue: [ ^self releaseReadOnly ].
    hIcon isNil ifTrue: [ ^self ].
    ( UserLibrary destroyIcon: hIcon )
        ifFalse: [ ^self osError ].
    self initHandle!   
validate
        "Private - Validate the receiver by recreating
          it from  the original parameters if necessary."

    hIcon notNil ifTrue:[^hIcon].
    readOnly
        ifTrue: [ hIcon :=self handleReadOnly ]
        ifFalse:[ self createIcon ].
    ^hIcon!
outputToFile: aFileName
        "Output the receiver in DIB format to aFileName."
    | file aFileStream |
    file := File fromPath: aFileName.
    file exists ifTrue: [ file remove ].
    file create.
    aFileStream := file binaryWriteStream.
    self outputToFileStream: aFileStream.
    aFileStream close.!   
handle
        "Private - Answer the receiver's handle."
    self validate.
    ^hIcon!
clone
        "Make a clone of the receiver."	
	| clone |
	( andMask isNil or: [ xorMask isNil ] ) ifTrue: [ ^self ].   "Can't clone a read only icon."
	clone := self class new.
	clone
		readOnly: false;
		andMask: andMask clone;
		xorMask: xorMask clone.
	^clone! 
startingSession
    "Private - Starting a session, clear old handle."

	self handle: nil.
	hLibrary := nil!   
restoreBitmap
        "Private - Recreate the receiver and copy the bits
         from the archive buffer. This is done upon restarting
         a saved image."
    | dc  |
    archive isNil ifTrue: [
        bitmapHandle := nil.
        ^self ].
    archive isArray ifTrue: [   "bitmap is from a dll"
        ^self fromModule: ( archive at: 1 ) id: ( archive at: 2 ) ].
    self createBitmap: archive.
    dc := ( ( deviceContext isNil or: [ deviceContext = MemoryContext ] ) or: [
        deviceContext = OldMemoryContext ] )
            ifTrue: [ self class memoryContext ]
            ifFalse: [ self class createCompatibleDC: Display deviceContext ].
    self
        deviceContext: dc;
        graphicsTool: ( Pen forDC: dc medium: self ).
    bitmapHandle notNil ifTrue: [ archive := nil ]!   
createBitmap
        "Private - Create a host bitmap for the receiver."
    | handle |
    handle := bitmapInfo bitCount = 1
        ifTrue: [
            self class
                createBitmap: self width
                height: self height
                planes: 1
                bitCount: 1
                bits: nil ]
        ifFalse: [
            self class
                createDIBitmap: Display deviceContext
                bitmapInfo: bitmapInfo
                init: nil
                bits: nil
                usage: DibRgbColors ].
    bitmapHandle := handle.
    self needsFinalization.!
finalize
    "Private - Receiver has been garbage collected,
    release the host resource."

    self release.!  
createBitmap: bits
        "Private - Create a host bitmap for the
         receiver and initialize the bitmap with bits."
    | handle hdc hPrevious |
    ( hdc := UserLibrary getDC: nil ) = 0
        ifTrue: [ ^self osError ].
    palette := self createDIBPalette.
    palette == nil ifFalse: [
        ( hPrevious := GDILibrary
            selectPalette: hdc
            with: palette asParameter
            forceBackground: false ) = 0
                ifTrue: [ ^self osError ].
            ( GDILibrary realizePalette: hdc ) = 16rFFFFFFFF
                ifTrue: [ ^self osError ] ].
    bitmapInfo bitCount = 1
        ifTrue: [
            handle := self class
                createBitmap: self width
                height: self height
                planes: 1
                bitCount: 1
                bits: nil.
            ( GDILibrary
                setDIBits: hdc
                hBitmap: handle
                startScan: 0
                scans: self height
                bitsStruct: bits asParameter
                bitsInfo: bitmapInfo asParameter
                wUsage: DibRgbColors ) = 0
                    ifTrue: [ ^self osError ] ]
        ifFalse: [
            handle := self class
                createDIBitmap: hdc
                bitmapInfo: bitmapInfo
                init: CbmInit
                bits: bits
                usage: DibRgbColors ].
    palette == nil ifFalse: [
        ( GDILibrary
            selectPalette: hdc
            with: hPrevious
            forceBackground: false ) = 0
                ifTrue: [ ^self osError ] ].
    ( UserLibrary releaseDC: nil with: hdc ) = 0
        ifTrue: [ ^self osError ].
    bitmapHandle := handle.
    self needsFinalization.!   
saveBitmap
        "Private - Save the receiver's bits in an archive buffer
        when saving image."
    bitmapHandle isNil ifTrue: [^self].
    archive isArray ifFalse: [  "not from a dll"
        archive := self getDIBits ].
    self release! 
deselect
        "Deselect the receiver from the device context."
    ( GDILibrary
        selectPalette: deviceContext
        with: DefaultPaletteHandle
        forceBackground: false ) = 0
            ifTrue: [ ^self osError ].
    ^GDILibrary selectObject: deviceContext with: DefaultBitmap!
finalizationRegistry
    "Private - Answer the WeakRegistry to be used for finalizing instances of the receiver."

    ^SystemWeakRegistries externalResources!
aboutToExitSession
    "Private - Release the host resource."

    self release!   
outputToFileStream: aFileStream
        "Output the receiver in DIB format to aFileStream."
    | fileHeader bits |
    bits := self getDIBits.
    bits isNil ifTrue: [ ^self ].
    fileHeader := WinBitmapFileHeader new.
    fileHeader bfType: 'BM';
        bfSize: 14 + bitmapInfo contents size + bits size;
        reserved1: 0;
        reserved2: 0;
        offBits: 14 + bitmapInfo contents size.
    aFileStream nextPutAll: fileHeader contents.
    aFileStream putBytesFrom: bitmapInfo contents.
    aFileStream putBytesFrom: bits! 
fromModule: aModuleName id: bitmapName
        "Private - Load the receiver from the module
        aModuleName with id bitmapName."
    | bitmapStruct hLibrary |
    aModuleName notNil ifTrue: [
        ( hLibrary := KernelLibrary loadLibrary: aModuleName asParameter ) = 0
            ifTrue: [ ^self osError ] ].
    ( bitmapHandle := UserLibrary
        loadBitmap: hLibrary asParameter
        name: bitmapName asParameter ) = 0
            ifTrue: [ ^self osError ].
    hLibrary notNil ifTrue: [
        ( KernelLibrary freeLibrary: hLibrary )
            ifFalse: [ ^self osError ] ].

    "use archive to save dll name and id."
    archive := Array with: aModuleName with: bitmapName.
    GDILibrary
        getObject: bitmapHandle
        count: WinBitmapStruct sizeInBytes
        lpObject: ( bitmapStruct :=  WinBitmapStruct new ) asParameter.
    bitmapInfo := WinBitmapInfo
        width: bitmapStruct width
        height: bitmapStruct height
        planes: 1
        bitCount: bitmapStruct planes * bitmapStruct bitsPixel.
    deviceContext := self class memoryContext.
    graphicsTool := Pen forDC: deviceContext medium: self.
    graphicsTool
        width: bitmapInfo width;
        height: bitmapInfo height.
    self needsFinalization! 
width: w height: h
        "Private - Initialize the receiver with w and h
         as its width and height."
    | hOldBitmap |
    self initPenWidth: w
        height: h
        planes: 1
        bitCount: 1.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap!
getDIBits
        "Answer a ByteArray which contains the bits
         of the receiver in device independent format."
    | bits bytes hPrevious hdc |
    self validate.      "make sure handle is valid."
    ( hdc := UserLibrary getDC: nil ) = 0
        ifTrue: [ ^self osError ].
    palette == nil ifFalse: [
        ( hPrevious := GDILibrary
            selectPalette: hdc
            with: palette asParameter
            forceBackground: false ) = 0
                ifTrue: [ ^self osError ].
        ( GDILibrary realizePalette: hdc ) = 16rFFFFFFFF
            ifTrue: [ ^self osError ] ].

    "call GetDIBits with nil to fill in the rest of bitmapInfo."
    GDILibrary
        getDIBits: hdc
        hBitmap: self handle
        startScan: 0
        scans: self height
        bits: nil
        bitsInfo: bitmapInfo asParameter
        wUsage: DibRgbColors.

    bytes := self sizeInBytes.
    bits := ByteArray new: bytes.
    ( GDILibrary
        getDIBits: hdc
        hBitmap: self handle
        startScan: 0
        scans: self height
        bitsStruct: bits asParameter
        bitsInfo: bitmapInfo asParameter
        wUsage: DibRgbColors ) = 0
            ifTrue: [ ^self osError ].

    palette  == nil ifFalse: [
        ( GDILibrary
            selectPalette: hdc
            with: hPrevious
            forceBackground: false ) = 0
                ifTrue: [ ^self osError ] ].
    ( UserLibrary releaseDC: nil with: hdc ) = 0
        ifTrue: [ ^self osError ].
    ^bits!   
width: w height: h planes: planes bitCount: bitsPixel
        "Private - initialize the receiver with w and h
         as its width and height."
    | bitCount hOldBitmap |
    bitCount := planes * bitsPixel.
    self initPenWidth: w
        height: h
        planes: 1
        bitCount: bitCount.
    bitmapInfo bitCount: bitCount.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap!
initHandle
        "Private - the receiver has been released, set the handle to nil."

    graphicsTool := nil.
    bitmapHandle := nil.
    palette := nil.
        "set variable to indicate type of device context to restore."
    deviceContext :=
        ( deviceContext isNil or: [ deviceContext  = MemoryContext ] )
            ifTrue: [ nil ]
            ifFalse: [ DeviceContext new ]!  
initPenWidth: width height: height planes: planes bitCount: bitCount
        "Private - Initialize the receiver's pen."
    self initPenWidth: width
        height: height
        planes: planes
        bitCount: bitCount
        forDC: MemoryContext! 
outputToPrinter
        "Print the receiver on the printer selected by the user."
    | dialog printer hDCPrinter |
    dialog := PrintDialog new noPages; noSelection.
    dialog open.
    ( hDCPrinter := dialog hDCPrinter ) isNil ifTrue: [ ^nil ].
    printer := Printer fromDC: hDCPrinter.
    self outputToPrinter: printer! 
outputToPrinter: printerOrName
        "Output the receiver to the printer specified by printerOrName,
        which may be either an instance of Printer, or a String specifying
        a printer name, or nil (in which case the default printer is selected)."
    | aPrinter controlPrintJob |
    aPrinter := ( printerOrName isString or: [ printerOrName isNil ] )
        ifTrue: [ Printer named: printerOrName ]
        ifFalse: [ printerOrName ].
    CursorManager execute changeFor: [
        ( controlPrintJob := aPrinter jobid isNil ) ifTrue: [ aPrinter startPrintJob ].
        aPrinter pen
            copyBitmap: self
            from: self boundingBox
            to: (self boundingBox scaleBy: (
                    (aPrinter pen width // Display width) min: (
                     aPrinter pen height // Display height))).
        controlPrintJob ifTrue: [ aPrinter endPrintJob ] ]!  
width: w height: h bits: aByteArray
        "Private - initialize the receiver with width w and
          height h, and bits in aByteArray."
    self initPenWidth: w
        height: h
        planes: 1
        bitCount: 1.
    bitmapInfo colorTable: (
        (ByteArray with: 0 with: 0 with: 0 with: 0) , (
        ByteArray with: 255 with: 255 with: 255 with: 0)).
    self createBitmap: aByteArray!   
select
        "Private - Select the receiver into the device context."
    self validate.
    ( deviceContext = MemoryContext and: [ graphicsTool notNil ] )
        ifTrue: [ graphicsTool resetAttributes ].
    palette notNil ifTrue: [
        ( GDILibrary selectPalette: deviceContext
            with: palette asParameter
            forceBackground: false ) = 0
                ifTrue: [ ^self osError ].
        ( GDILibrary realizePalette: deviceContext ) = 16rFFFFFFFF
            ifTrue: [ ^self osError ] ].
    bitmapHandle notNil
        ifTrue: [ GDILibrary selectObject: deviceContext with: bitmapHandle ]!  
release
        "Delete the receiver from the device context. Freeing
        up all system storage associated with the receiver."
    bitmapHandle isNil ifTrue: [ ^self ].
    self deselect.
    deviceContext = MemoryContext
        ifFalse: [ graphicsTool deleteDC ].
    ( GDILibrary deleteObject: bitmapHandle )
        ifFalse: [ self osWarning ].
    self initHandle!
validate
        "Private - Restore from archive if necessary."
    | state |
    state := Process enableInterrupts: false.

    ((bitmapHandle isNil 
        or: [bitmapHandle = NullHandle])
        and: [archive notNil]) ifTrue: [
           bitmapHandle := ExternalHandle new.
           self restoreBitmap].

    Process enableInterrupts: state!  
sizeInBytes
        "Answer the size of the receiver in bytes."
    bitmapInfo sizeImage = 0
        ifTrue: [^(((bitmapInfo bitCount * bitmapInfo width) + 31) // 32) *
            4 * bitmapInfo height]
        ifFalse: [^bitmapInfo sizeImage]!
outputToFile: aFileName
        "Output the receiver in DIB format to aFileName."
    | aFileStream |
    aFileStream := ( File fromPath: aFileName ) binaryWriteStream.
    self outputToFileStream: aFileStream.
    aFileStream close!
handle
        "Private - Answer the handle."
    self validate.
    ^bitmapHandle!
screenWidth: w height: h
        "Private - Initialize the receiver with w and h
         as its width and height."
    | bitsPixel planes bitCount hOldBitmap |
    bitsPixel := GDILibrary getDeviceCaps: Display deviceContext
        index: Bitspixel.
    planes := GDILibrary getDeviceCaps: Display deviceContext
        index: Planes.
    bitCount := bitsPixel * planes.
    self initPenWidth: w
        height: h
        planes: 1
        bitCount: bitCount.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap!
clone
        "Answer a new bitmap which has the same
         attributes as the receiver."
    | clone bits dc |
    archive isArray ifTrue: [   "can't clone a bitmap from a dll."
        ^self ].
    clone := self class new.
    bits := ( archive isNil                  "must be done before copying bitmapInfo to"
            ifTrue: [ self getDIBits ]    "ensure the color table is created."
            ifFalse: [ archive ] ).
    clone bitmapInfo: bitmapInfo deepCopy.
    dc := ( ( deviceContext isNil or: [ deviceContext = MemoryContext ] ) or: [
        deviceContext = OldMemoryContext ] )
            ifTrue: [ self class memoryContext ]
            ifFalse: [ self class createCompatibleDC: Display deviceContext ].
    clone
        deviceContext: dc ;
        graphicsTool: ( Pen for: dc medium: clone ).
    clone createBitmap: bits.
    ^clone!
colorTable
        "Answer aByteArray which is the color table
         of the structure."
    ^self contents
        copyFrom: (WinBitmapInfoHeader sizeInBytes + 1)
        to: self size! 
colorTable: aByteArray
        "Set the color table of the structure to be aByteArray."
    self contents
        replaceFrom: (WinBitmapInfoHeader sizeInBytes + 1)
        to: self size
        with: aByteArray! 
clrImportant
        "Private - Answer the number of color indexes that
         are important for displaying the bitmap."
    ^self longAtOffset: 36! 
height: anInteger
        "Private - Set the height in pixels."
    self uLongAtOffset: 8 put: anInteger!   
planes
        "Private - Answer the number of planes
         for the target device."
    ^self uShortAtOffset: 12!   
biSize: bmInfoSize
        "Private - Set the number of bytes in the receiver."
    self uLongAtOffset: 0 put: bmInfoSize!  
sizeImage
        "Private - Answer the size in bytes of the image."
    ^self uLongAtOffset: 20!   
planes: anInteger
        "Private - Set the number of planes
         for the target device."
    self uShortAtOffset: 12 put: anInteger! 
sizeImage: anInteger
        "Private - Set the size in bytes of the image."
    ^self uLongAtOffset: 20 put: anInteger!
width
        "Private - Answer the width of the bitmap in pixels."
    ^self uLongAtOffset: 4! 
width: anInteger
        "Private - Set the width of the bitmap in pixels."
    self uLongAtOffset: 4 put: anInteger!   
height
        "Private - Answer the height in pixels."
    ^self uLongAtOffset: 8! 
xPelsPerMeter
        "Private - Answer the horizontal resolution in pixels per meter."
    ^self longAtOffset: 24! 
bitCount
        "Private - Answer the number of bits per pixel."
    ^self uShortAtOffset: 14! 
biSize
    ^self uLongAtOffset: 0!   
xPelsPerMeter: anInteger
        "Private - Set the horizontal resolution in pixels per meter."
    self uLongAtOffset: 24 put: anInteger!  
yPelsPerMeter
    ^self uLongAtOffset: 28!   
yPelsPerMeter: anInteger
        "Private - Set the vertical resolution in pixels per meter."
    self uLongAtOffset: 28 put: anInteger!
clrUsed
    ^self uLongAtOffset: 32! 
clrUsed: anInteger
        "Private - Set the number of color indexes
         used in the bitmap."
    self uLongAtOffset: 32 put: anInteger! 
compression
    ^self uLongAtOffset: 16! 
compression: biType
        "Private - Set the compression type."
    self uLongAtOffset: 16 put: biType!   
bitCount: anInteger
        "Private - Set the number of bits per pixel."
    self uShortAtOffset: 14 put: anInteger!   
clrImportant: anInteger
        "Private - Answer the number of color indexes that
         are important for displaying the bitmap."
    self uLongAtOffset: 36 put: anInteger!   
registerClass: wndClassStruct
    <api: RegisterClassA struct short>
    ^self invalidArgument! 
wmQueryendsession: wordInteger with: longInteger
        "Private - Process query end session message."
    ^ nil!  
getWindow: aWindowHandle relationship: relFlag
    <api: GetWindow ulong ulong ulongReturn>
    ^self invalidArgument!  
period
        "Answer the period for the receiver, in milliseconds."
    ^period!  
printOn: aStream
        "Append a textual representation of the receiver to aStream."
    aStream nextPutAll: self class name, ' { id = ', self id printString, ' period = ', self period printString, ' } '!  
ticked
        "Private - the receiver ticked, notify any interested handlers."
    self triggerEvent: #ticked! 
period: milliseconds
        "Set the receiver's period in milliseconds."
    period := milliseconds!   
id: anInteger
        "Private - set the integer id of the receiver (host timer id)."
    id := anInteger!  
id
        "Private - answer the integer id of the receiver (host timer id)."
    ^id!  
wmDevicechange: wparam with: lparam
        "Private - handle device changes."
    ^nil!
setWindowsHookEx: nFilterType proc: pfnFilterProc module: hModule thread: threadID
    <api: SetWindowsHookExA long ulong ulong ulong ulongReturn>
    ^self invalidArgument!   
forDC: aDeviceContext medium: aGraphicsMedium
        "Answer a new instance of the receiver
         with aDeviceContext and associated with
         aGraphicsMedium."
    ^self new
        initialize;
        setHandle: aDeviceContext;
        graphicsMedium: aGraphicsMedium! 
fileName
        "Answer the receiver's file name."
    ^'comctl32'!
getCurrent
    | dll |
    dll := super getCurrent.
    dll initCommonControls.
    ^dll! 
initCommonControls
    <api: InitCommonControls none>
    ^self invalidArgument!
defaultExtendedStyle
        "Private - answer the default extended style flags for the
        receiver.  Add the 3d border style."
    ^OperatingSystem versionMajor >= 4 ifTrue: [ WsExClientedge ] ifFalse: [ 0 ]! 
isClipboardFormatAvailable: aCfConstant
    <api: IsClipboardFormatAvailable ulong boolean>
     ^self invalidArgument! 
isGraphicsTool
        "Answer whether the receiver is a kind of GraphicsTool."
    ^false
!   
initialText
        "Private - Answer the receiver's initial text string"
    ^'vwin'.! 
directory: aDirectory
        "Sets the initial directory."
    aDirectory valid ifTrue: [ DirName := aDirectory ].!
wmErasebkgnd: wordInteger with: longInteger
        "Private - Process the erase background message."
    | oldDC backColor |
    self minimized ifTrue: [ ^1 ].     "Do not erase background while minimized"
    self graphicsTool isNil ifTrue: [ ^nil ].
    oldDC := graphicsTool privateHandle.
    graphicsTool handle: wordInteger.
    ( backColor := self backColor ) isNil
        ifTrue: [ backColor := self defaultBackColor ].
    graphicsTool backColor: backColor.
    graphicsTool erase.
    graphicsTool handle: oldDC.
    ^1!  
printOn: aStream
    "Append the print representation of the receiver to <aStream>."

    super printOn: aStream.
    aStream nextPutAll: ' on: '.
    self value printOn: aStream!  
valueOutOf: aPane
    "Set the receiver's value to the contents of <aPane>."

    self setValue: aPane contents!   
value: anObject
    "Set the value to <anObject>."

    value := anObject! 
value
    "Answer the value."

    ^value! 
setValue: anObject
    "Set the value to <anObject> then generate a changed: event."

    value := anObject.
    self triggerEvent: #changed: with: anObject! 
valueInto: aPane
    "Set the contents of <aPane> to the receiver's value."

    aPane contents: self value!   
sampleFont
        "Answer the font of the sample string."
    ^self
        propertyAt: #sampleFont
        ifAbsent: [ self class defaultSampleFont ]!  
checkFlags
        "Private - check user action and get the filename"
    | temp |
    self style: self flags.
    fileName:= String fromAddress:
        ( ExternalHeapAddress fromInteger: openFileNameStruct lpstrFile ).
        "set DirName to the directory selected by the user."
    temp := fileName copyFrom: 1 to: openFileNameStruct nFileOffset.
    DirName := Directory pathName: temp.!  
setClassWord: hwnd index: integer newWord: aWord
        "Private - Set the window class word at index integer to aWord.
        Answer the previous word."
    <api: SetClassWord ulong long ushort ushort>
    ^self invalidArgument!   
getResult: hostResult
        "Private - convert the host-specific result value to
        normalized result; save this result & symbolic result
        for later access."
    resultSymbol := ResultSymbols
        at: hostResult
        ifAbsent: [ self error: 'Unexpected MessageBox result' ].
    hostResult = Idok ifTrue: [ ^result := true ].
    hostResult = Idyes ifTrue: [ ^result := true ].
    hostResult = Idno ifTrue: [ ^result := false ].
    hostResult = Idabort ifTrue: [ ^result := true ].
    hostResult = Idignore ifTrue: [ ^result := nil ].
    hostResult = Idcancel ifTrue: [
        ( style & MbTypemask ) = MbOkcancel
            ifTrue: [ ^result := false ]
            ifFalse: [ ^result := nil ] ].
    hostResult = Idretry ifTrue: [
        ( style & MbTypemask ) = MbRetrycancel
            ifTrue: [ ^result := true ]
            ifFalse: [ ^result := false ] ]!   
winStruct
        "Private - Answer the host structure for receiver."
    ^WinLogPalette new!   
fromWinLogPalette: aWinLogPalette
        "Answer a logical palette created from aWinLogPalette
         structure."
    ^self anchorDictionary
        at: aWinLogPalette
        ifAbsent: [
            self fromStruct: aWinLogPalette]!
startUp
        "Private - Initialize class variables.
         WinLogicalPalette initialize."
    self anchorDictionary: Dictionary new.
    self threshold: 16.
    self stockObject: DefaultPalette.
    self allInstancesPrim do: [ :each | each initHandle ]!  
fromStruct: aWinLogPalette
        "Private - Answer a new logical palette."
    ^self new
        fromStruct: aWinLogPalette! 
stockObject: constant
        "Private - Answer a windows logical object
         with attributes in anArray."
    | aHandle struc |
    aHandle := GDILibrary getStockObject: constant.
    struc := self winStruct.
    "GDILibrary
        getObject: aHandle
        count: struc size
        lpObject: struc asParameter."
    ^(self new
        stockObject: constant;
        fromStruct: struc)!
threshold
        "Private - answer the maximum number of objects of the receiver class
        which can be cached at once."
    ^threshold!  
threshold: anInteger
        "Private - set the maximum number of objects of the receiver class
        which can be cached at once to anInteger."
    threshold := anInteger! 
destroyAllHandles
        "Private - Destroy all handles of objects if they
         are not selected.  Answer the keys of destroyed
         ones."
    | keys obj |
    keys := OrderedCollection new.
    self anchorDictionary associationsDo: [:assoc |
        obj := assoc value.
        (obj privateHandle notNil and: [obj isStockObject not])
            ifTrue: [
                (GDILibrary deleteObject: obj privateHandle) = 0
                    ifFalse: [keys add: assoc key]]].
    ^keys!  
anchorDictionary
        "Private - answer a Dictionary mapping between object attributes and
        cached logical object."
    ^anchorDictionary!   
destroyAll
        "Private - Destroy all handles of
         instances of subclasses."
    self subclasses do: [:each | each destroyAllHandles]!  
anchorDictionary: aDictionary
        "Private - set the Dictionary mapping between object attributes and
        cached logical objects to aDictionary."
    anchorDictionary := aDictionary! 
stockObject: constant
        "Private - Answer a windows logical object
         with attributes in anArray."
    | aHandle struc |
    aHandle := GDILibrary getStockObject: constant.
    struc := self winStruct.
    GDILibrary
        getObject: aHandle
        count: struc size
        lpObject: struc asParameter.
    ^(self new
        stockObject: constant;
        fromStruct: struc)!  
deleteObjects: keys
        "Private - Delete objects from the anchor dictionary
         when its dictionary key is in keys."
    | dict |
    dict := self anchorDictionary.
    keys do: [:k |
        dict removeKey: k].
    self allInstancesPrim do: [:each | each initHandle]. "This
        also resets objects not deleted, but its OK"!
objectWithAttributes: anArray
        "Private - Answer a windows logical object
         with attributes in anArray."
    ^self anchorDictionary
        at: anArray
        ifAbsent: [ self fromAttributes: anArray ]!
startUp
        "Private - Initialize class state of subclasses."
    WinLogicalBrush startUp.
    WinLogicalPalette startUp.
    WinLogicalPen startUp!  
getHandle
        "Private - Answer handle after creating
         the windows object."
    | aHandle |
    stockObject notNil ifTrue: [ ^GraphicsTool getStockObject: stockObject ].
    ( aHandle := GDILibrary createPalette: logPalette asParameter ) = 0
        ifTrue: [ ^self osError ].
    ^aHandle! 
attributeArray
        "Private - Answer attributes as an array."
    ^logPalette!  
fromStruct: struc
        "Private - Answer an instance with attributes
         specified in anArray."
    logPalette := struc.
    self createObject!   
handle
        "Private - Answer handle and create one if nil."
    handle isNil
        ifTrue: [self createObject].
    ^handle!
asParameter
        "Answer the receiver in a form suitable for passing
         as a parameter to a host system procedure call."
    ^self handle!
createObject
        "Private - Create the windows logical object."
    | attrib obj dict |
    attrib := self attributeArray.
    dict := self class anchorDictionary.
    obj := dict at: attrib ifAbsent: [nil].
    obj isNil ifTrue: [
        dict size > self class threshold
            ifTrue: [
                self class deleteObjects:
                    (self class destroyAllHandles)].
        obj := self.
        dict at: attrib put: self].
    obj privateHandle isNil ifTrue: [
        obj handle: obj getHandle]!
initHandle
        "Private - Set handle to nil."
    handle := nil!
stockObject: constant
        "Private - Set stockObject to constant."
    stockObject := constant! 
privateHandle
        "Private - Answer handle."
    ^handle!   
isStockObject
        "Private - Answer true if receiver is a stock object."
    ^stockObject notNil!   
handle: aHandle
        "Private - Set handle."
    handle := aHandle!  
centered
        "Add the centered style."
    self
        removeStyle: EsLeft;
        removeStyle: EsRight;
        addStyle: EsCenter.
    self setStyle: self style!   
packDDElParam: msg low: lowWord high: highWord
    <api: PackDDElParam ulong ulong ulong long>
    ^self invalidArgument!   
releaseAllHandles
        "Private - Delete all font handles from the system."
    self allInstancesPrim do: [ :f | f clearFontHandle ].
    FontHandleTable do: [ :h |
        ( GDILibrary deleteObject: h ) ifFalse: [ self osWarning ] ].
    FontHandleTable := Dictionary new! 
dragDropLinkScroll
        "Answer the instance of the receiver class used
        to indicate a drag-drop link with drag target scrolling."
    ^DragDropLinkScroll!  
wmDevicechange: wparam with: lparam
        "Private - handle device changes."
    | pDevData devBroadcastHdr devType eventType deviceType |
    wparam = "DbtDevicearrival" 16r8000 ifTrue: [ eventType := 'arrived' ].
    wparam = "DbtDevicequeryremove" 16r8001 ifTrue: [ eventType := 'remove request' ].
    wparam = "DbtDevicequeryremovefailed" 16r8002 ifTrue: [ eventType := 'remove request failed' ].
    wparam = "DbtDeviceremovepending" 16r8003 ifTrue: [ eventType := 'remove pending' ].
    wparam = "DbtDeviceremovecomplete" 16r8004 ifTrue: [ eventType := 'removed' ].

    wparam = "DbtConfigchanged" 16r18 ifTrue: [ eventType := 'configuration changed' ].
    wparam = "DbtNodiskspace" 16r47 ifTrue: [ eventType := 'out of disk space' ].

    "supply the device type, for those event notifications where it is supplied."
    ( #( 16r8000 16r8001 16r8002 16r8003 16r8004 ) includes: wparam ) ifTrue: [
        pDevData := ExternalAddress fromInteger: lparam.
        devBroadcastHdr := ExternalBuffer basicNew contents: pDevData; yourself.
        devType := devBroadcastHdr uLongAtOffset: 4.

        devType = "DbtDevtypOem" 0 ifTrue: [ deviceType := 'oem' ].
        devType = "DbtDevtypDevnode" 1 ifTrue: [ deviceType := 'devnode' ].
        devType = "DbtDevtypVolume" 2 ifTrue: [ deviceType := 'volume' ].
        devType = "DbtDevtypPort" 3 ifTrue: [ deviceType := 'port' ].
        devType = "DbtDevtypNet" 4 ifTrue: [ deviceType := 'net' ] ].

    SessionModel current
        triggerEvent: #device:change:
        withArguments: ( Array with: deviceType with: eventType ).

    ^nil! 
sort
        "Add the sort style."
    ^self addStyle: LbsSort! 
label
        "Answer the window label of the receiver."
    ^label!
label: aString
       "Set the window label of the receiver to aString."
    label := aString!  
selectMessage
        "Private - Answer the host message for selecting an item."
    ^CbSetcursel!  
deleteAllMessage
        "Private - Answer the host message for deleting all entries."
    ^CbResetcontent! 
controlColor: hWnd hDC: hDC
        "Private - set the control color for the control window with
        handle = hWnd, using the given hDC."
    | control |
    ( control :=  Notifier findWindow: hWnd ) isNil ifTrue: [ ^nil ].
    ^control controlColor: hDC!  
setRange
        "Private - update the host control's range (minimum and maximum)."
    ( UserLibrary
        setScrollRange: self handle
        bar: SbCtl
        min: self minimum
        max: self maximum
        redraw: true )
            ifFalse: [ ^self osError ]!   
atomToString: anInteger
        "Answer a String for the atom anInteger.  Obsolete,
        maintained for backward compatibility."
    ^( Atom fromInteger: anInteger ) asString! 
dragTargetEmphasisItem
		"Set the type of target emphasis to be employed to
		be item based."
	self dragTargetEmphasis: 'item'!
arc: boundingBox start: startPoint end: endPoint
        "Call GDI Arc function."
    self allHandles do: [ :h |
        ( GDILibrary arc: h
            x1: boundingBox origin x
            y1: boundingBox origin y
            x2: boundingBox corner x
            y2: boundingBox corner y
            x3: startPoint x
            y3: startPoint y
            x4: endPoint x
            y4: endPoint y )
                ifFalse: [ ^self osError ] ]!  
createWindow: className
    name: nameString
    style: styleInteger
    extendedStyle: extendedStyleInteger
    x: xInteger
    y: yInteger
    width: widthInteger
    height: heightInteger
    parent: parentHandle
    menu: menuHandle
    instance: instanceHandle
    param: paramStructure
       "Private - This method only works for non-predefined window classes."
    ( nameString isByteArray or: [ className isByteArray ] )
        ifTrue: [
            ^self
                createWindowULongEx: extendedStyleInteger
                class: className
                nameULong: nameString
                style: styleInteger
                x: xInteger
                y: yInteger
                width: widthInteger
                height: heightInteger
                parent: parentHandle
                menu: menuHandle
                instance: instanceHandle
                paramULong: paramStructure ]
        ifFalse: [
            ^self
                createWindowStructEx: extendedStyleInteger
                class: className
                nameStruct: nameString
                style: styleInteger
                x: xInteger
                y: yInteger
                width: widthInteger
                height: heightInteger
                parent: parentHandle
                menu: menuHandle
                instance: instanceHandle
                param: paramStructure ]!   
position: anInteger
        "Private - Set the position of the menu item."
    position := anInteger!   
isSubmenu
        "Answer true if the receiver is a submenu."
    ^self hasSubmenu! 
position
        "Answer the position of the menu item."
    ^position! 
style
        "Answer the style of the menu item."
    ^style!  
printOn: aStream
        "Append a text representation of the receiver
         to aStream."
    aStream nextPutAll: self class name, '{', label printString, '}'! 
style: anInteger
        "Private - Set the style of the menu item."
    style := anInteger!
label
        "Private - Answer the label of the receiver.
        The label is what is displayed for the receiver
        (bitmap, string, owner-drawn struct)."
    ^label! 
attribute
        "Private - Answer the attribute of the menu item."
    ^attribute!
attribute: anInteger
        "Private - Set the attribute of the menu item."
    attribute := anInteger!
label: anObject
        "Private - Set the label of the receiver.
        The label is what is displayed for the receiver
        (bitmap, string, owner-drawn struct)."
    label := anObject!   
selector
        "Answer the selector of the menu item."
    ^selector! 
id: anInteger
        "Private - Set the Id of the menu item."
    id := anInteger! 
submenu
        "Answer the subMenu of the menu item."
    ^submenu!
submenu: aMenu
        "Private - Set the subMenu of the menu item."
    submenu := aMenu!  
hasSubmenu
        "Answer true if the receiver has a submenu."
    ^self submenu notNil!   
id
        "Answer the Id of the menu item."
    ^id!   
selector: aSymbol
        "Private - Set the selector of the menu item."
    selector := aSymbol!   
charSet: aCharSet
        "Set the charSet of the font to aCharSet.
        charSet may be one of following:
        AnsiCharset, OemCharset or SymbolCharset."
    aCharSet notNil
        ifTrue: [ logicalFont lfCharSet: aCharSet asParameter ]! 
getStockObject: aStockObject
        "Private - get aStockObject which
          may be one of the following:
          BlackBrush, DkgrayBrush, GrayBrush, HollowBrush,
          LtgrayBrush, NullBrush, WhiteBrush, BlackPen, NullPen,
          WhitePen, AnsiFixedFont, AnsiVarFont, DeviceDefaultFont,
          OemFixedFont, SystemFont, SystemFixedFont,
          DefaultPalette."
    | hObj |
    hObj := GDILibrary getStockObject: aStockObject.
    StockObjects add: hObj.
    ^hObj!  
basicStyle
        "Private - Answer an Integer with appropriate
         constants combination for basic subpane style."
    ^WsChild | WsVisible | WsClipsiblings!   
setFormatRect
        "Private - Set the format rectangle for the host control.
        Assumes 'handle = NullHandle' is false."
    UserLibrary
        sendMessage: handle
        msg: EmSetrect
        wparam: 0
        lparamStruct: self formatRect asParameter!   
add: aString toListBox: itemId
        "Add aString at anInteger to the list box whose
         id is itemId.  anInteger is either the zero-based
         index of the new item or a constant beginning
         with 'Lit' from the OperatingSystemConstants pool dictionary."
    self sendMessage: LbAddstring item: itemId wparam: 0 lparamStruct: aString asParameter! 
fromStructure: aStructure  startingAt: startingAt
        "Private - Answer an instance of receiver with its
         contents copied from the font metrics aStructure
         at index startingAt."
    |logFont |

    logFont := self new: self sizeInBytes.
    logFont bytesAtOffset: 0
                put: (aStructure bytesAtOffset: startingAt count: self sizeInBytes).
    ^ logFont!
sizeInBytes
    ^60! 
lfHeight
        "Private - Answer the lfHeight field."
    ^self longAtOffset: 0!  
lfQuality
        "Private - Answer the lfQuality field."
    ^self byteAtOffset: 26!   
lfQuality: aByte
        "Private - Set the lfQuality field."
    self byteAtOffset: 26 put: aByte! 
lfWeight
        "Private - Answer the lfWeight field."
    ^self longAtOffset: 16! 
lfOrientation
        "Private - Answer the lfOrientation field."
    ^self longAtOffset: 12!   
lfOrientation: anInteger
        "Private - Set the lfOrientation field."
    self longAtOffset: 12 put: anInteger! 
lfItalic: aByte
        "Private - Set the lfItalic field."
    self byteAtOffset: 20 put: aByte!   
lfWidth
        "Private - Answer the lfWidth field."
    ^self longAtOffset: 4!
lfWidth: anInt
        "Private - Set the lfWidth field."
    self longAtOffset: 4 put: anInt!  
lfClipPrecision
        "Private - Answer the lfClipPrecision field."
    ^self byteAtOffset: 25!   
lfClipPrecision: aByte
        "Private - Set the lfClipPrecision field."
    self byteAtOffset: 25 put: aByte! 
lfOutPrecision: aByte
        "Private - Set the lfOutPrecision field."
    self byteAtOffset: 24 put: aByte!   
lfOutPrecision
        "Private - Answer the lfOutPrecision field."
    ^self byteAtOffset: 24! 
szFaceName: aString
         "Private - Set the szFaceName field."
   1 to: aString size do:
     [ :i | self byteAtOffset: (28 + i - 1) put: (aString at: i) asciiValue ].
   ( aString size + 1 ) to: 32 do:
     [ :i | self byteAtOffset: (28 + i - 1) put: 0 ].!
lfCharSet
        "Private - Answer the lfCharSet field."
    ^self byteAtOffset: 23!   
lfCharSet: aByte
        "Private - Set the lfCharSet field."
    self byteAtOffset: 23 put: aByte! 
lfHeight: anInt
        "Private - Set the lfHeight field."
    self longAtOffset: 0 put: anInt!
lfPitchAndFamily
        "Private - Answer the lfPitchAndFamily field."
    ^self byteAtOffset: 27! 
lfWeight: anInt
        "Private - Set the lfWeight field."
    self longAtOffset: 16 put: anInt!   
padWithZeros
        "Private - Pad the end of the structure with zeros.
        The last field of the structure is the face name which
        is a null terminated string. Put zeros after the string."
    | aStream |
    aStream := ReadStream on: contents.
    aStream
        position: 28;
        upTo: 0.
    aStream position + 1 to: contents size do: [ :index |
        contents at: index put: 0 ]! 
lfPitchAndFamily: aByte
        "Private - Set the lfPitchAndFamily field."
    self byteAtOffset: 27 put: aByte!   
lfEscapement: anInteger
        "Private - Set the lfEscapement field."
    self longAtOffset: 8 put: anInteger!
lfItalic
        "Private - Answer the lfItalic field."
    ^self byteAtOffset: 20! 
szFaceName
         "Private - Answer the szFaceName field."
    | aString |
    aString := String new: 32.
   1 to: aString size do: [ :i |
        aString at: i put: ( self byteAtOffset: i + 27 ) asCharacter ].
   ^aString trimNullTerminator asNormalizedString! 
lfEscapement
        "Private - Answer the lfEscapement field."
    ^self longAtOffset: 8!  
lfStrikeOut
        "Private - Answer the lfStrikeOut field."
    ^self byteAtOffset: 22!   
lfStrikeOut: aByte
        "Private - Set the lfStrikeOut field."
    self byteAtOffset: 22 put: aByte! 
lfUnderline
        "Private - Answer the lfUnderline field."
    ^self byteAtOffset: 21!   
lfUnderline: aByte
        "Private - Set the lfUnderline field."
    self byteAtOffset: 21 put: aByte! 
pages
        "Answers whether the user has selected Pages"
     ^( self style & PdPagenums ) ~= 0! 
wmGetminmaxinfo: wparam with: lparam
        "Private - control the minimum size that the
        receiver may be scaled to using the sizing border."
    ^nil!
dialogTemplateFor: aDialogTopPane
        "Private - create and answer a dialog template
         with contents for the description contained in
         aDialogTopPane."
    | style font items template tempByteArray size offset rectangle extendedStyle |
    style := aDialogTopPane style.
    ( extendedStyle := aDialogTopPane extendedStyle ) isNil
        ifTrue: [ aDialogTopPane extendedStyle: ( extendedStyle := aDialogTopPane defaultExtendedStyle ) ].
    ( font := aDialogTopPane font ) notNil
        ifTrue: [ style := style | DsSetfont ].
    items := self buildItemsFor: aDialogTopPane.
    rectangle := aDialogTopPane rectangleAttribute.
    template := self
        dialogTemplateStyle: ( style bitAnd: ( WsVisible bitXor: 16rFFFFFFFF ) )  "create hidden, show after validate"
        extendedStyle: extendedStyle
        itemCount: items size
        x: rectangle origin x
        y: rectangle origin y
        cx: rectangle extent x
        cy: rectangle extent y
        menuName: nil
        className: nil
        text: aDialogTopPane label
        fontName: font faceName
        pointSize: font pointSize.

    size := items inject: template contents size into: [ :bytes :item |
        bytes + item contents size ].
    tempByteArray := ByteArray new: size.
    tempByteArray
        replaceFrom: 1
        to: template contents size
        with: template contents
        startingAt: 1.
    offset := template contents size + 1.
    items do: [ :item |
        tempByteArray
            replaceFrom: offset
            to: offset + item contents size - 1
            with: item contents
            startingAt: 1.
        offset := offset + item contents size ].
    template contents: tempByteArray.
    ^template! 
dialogTemplateStyle: style
    extendedStyle: extendedStyle
    itemCount: itemCount
    x: x
    y: y
    cx: cx
    cy: cy
    menuName: menuName
    className: className
    text: text
    fontName: fontName
    pointSize: pointSize
        "Private - Answer a new dialog template
         with its attributes set from the parameters."
    | size dlgTemplate classNameOffset textOffset unicodeClass unicodeMenu unicodeText
        unicodeFont fontSizeOffset fontNameOffset |
    unicodeClass := className isNil
        ifTrue: [ ByteArray new: 2 ]
        ifFalse: [ className asExternalString asNullTerminatedUnicodeString ].
    unicodeMenu := menuName isNil
        ifTrue: [ ByteArray new: 2 ]
        ifFalse: [ menuName asExternalString asNullTerminatedUnicodeString ].
    unicodeText := text isNil
        ifTrue: [ ByteArray new: 2 ]
        ifFalse: [ text asExternalString asNullTerminatedUnicodeString ].
    unicodeFont := fontName isNil
        ifTrue: [ nil ]
        ifFalse: [ fontName asExternalString asNullTerminatedUnicodeString ].

    size := 18.         "Base DLGTEMPLATE size"
    classNameOffset := size := size + unicodeMenu size.
    textOffset := size := size + unicodeClass size.
    fontSizeOffset := size := size + unicodeText size.
    ( style bitAnd: DsSetfont ) = DsSetfont ifTrue: [
        fontNameOffset := size := size + 2.
        size := size + unicodeFont size ].
    size := ( size - 1 truncateTo: 4 ) + 4.  "item templates must be DWORD aligned"

    dlgTemplate := self new: size.
    dlgTemplate uLongAtOffset: 0 put: style.
    dlgTemplate uLongAtOffset: 4 put: extendedStyle.
    dlgTemplate uShortAtOffset: 8 put: itemCount.
    dlgTemplate uShortAtOffset: 10 put: x truncated.
    dlgTemplate uShortAtOffset: 12 put: y truncated.
    dlgTemplate uShortAtOffset: 14 put: cx truncated.
    dlgTemplate uShortAtOffset: 16 put: cy truncated.
    dlgTemplate bytesAtOffset: 18 put: unicodeMenu.
    dlgTemplate bytesAtOffset: classNameOffset put: unicodeClass.
    dlgTemplate bytesAtOffset: textOffset put: unicodeText.
    ( style bitAnd: DsSetfont ) = DsSetfont ifTrue: [
        dlgTemplate uShortAtOffset: fontSizeOffset put: pointSize.
        dlgTemplate bytesAtOffset: fontNameOffset put: unicodeFont ].

    ^dlgTemplate!   
buildItemsFor: aDialogTopPane
        "Private - Build the control items within the dialog box.  Answer
         an array of item templates."
    | answer rect text template style extendedStyle |
    answer := OrderedCollection new.
    aDialogTopPane childrenInBuildOrder do: [ :subpane |
        subpane isSubPane ifTrue: [
            ( rect := subpane framingBlock ) isRectangle
                ifFalse: [ rect := rect value: ( 0@0 extent: aDialogTopPane rectangleAttribute extent ) ].
            ( text := subpane initialText ) isString ifFalse: [ text := nil ].
            ( style := subpane style ) isNil
                ifTrue: [ style := subpane getStyle ].
            ( extendedStyle := subpane extendedStyle ) isNil
                ifTrue: [ subpane extendedStyle: ( extendedStyle := subpane defaultExtendedStyle ) ].
            template := self
                itemTemplateStyle: style
                extendedStyle: extendedStyle
                x: rect left
                y: rect top
                cx: rect extent x
                cy: rect extent y
                id: subpane id
                className: subpane windowClass
                text: text.
            answer add: template.
            subpane style: style.
            subpane initSize: rect ] ].
    ^answer! 
itemTemplateStyle: style extendedStyle: extendedStyle x: x y: y cx: cx cy: cy id: id className: className text: text
        "Private - Calculate the size of a dialog item template
         and answer a new item template with attributes
         set from the arguments."
    | size dlgItemTemplate extraDataSizeOffset textOffset unicodeClass unicodeText |
    unicodeClass := className isNil
        ifTrue: [ ByteArray new: 2 ]
        ifFalse: [ className asExternalString asNullTerminatedUnicodeString ].
    unicodeText := text isNil
        ifTrue: [ ByteArray new: 2 ]
        ifFalse: [ text asExternalString asNullTerminatedUnicodeString ].

    size := 18.         "Base DLGITEMTEMPLATE size"
    textOffset := size := size + unicodeClass size.
    extraDataSizeOffset := size := size + unicodeText size.
    size := size + 2.
    size := ( size - 1 truncateTo: 4 ) + 4.  "item templates must be DWORD aligned"

    dlgItemTemplate := self new: size.
    dlgItemTemplate uLongAtOffset:  0 put: style.
    dlgItemTemplate uLongAtOffset: 4 put: extendedStyle.
    dlgItemTemplate uShortAtOffset: 8 put: x truncated.
    dlgItemTemplate uShortAtOffset: 10 put: y truncated.
    dlgItemTemplate uShortAtOffset: 12 put: cx truncated.
    dlgItemTemplate uShortAtOffset: 14 put: cy truncated.
    dlgItemTemplate uShortAtOffset: 16 put: id.

    dlgItemTemplate bytesAtOffset: 18 put: unicodeClass.
    dlgItemTemplate bytesAtOffset: textOffset put: unicodeText.
    dlgItemTemplate uShortAtOffset: extraDataSizeOffset put: 0.

    ^dlgItemTemplate!   
invertRect: aDeviceContext in: aWinRectStruct
    <api: InvertRect ulong struct boolean>
    ^self invalidArgument! 
wmPaint: aLongStruct with: aWordStruct
        "Private - Process the paint message."
    | paintStructure |
        "must copy to nonST memory because BeginPaint generates WM_ERASEBKGRND"
    paintStructure := ExternalAddress allocateMemory: WinPaintStructure sizeInBytes.
    UserLibrary
         beginPaint: handle
         paintStructure: paintStructure asParameter.
    self display.
    ( UserLibrary
        endPaint: handle
        paintStructure: paintStructure asParameter )
            ifFalse: [ ^self osError ].
    paintStructure free.
     ^1!  
getCursorPos: aByteArray
    <api: GetCursorPos struct boolean>
    ^self invalidArgument!  
setClipRect: aRectangle
        "Set the clipping region for the receiver to aRectangle."
    | region  |
    aRectangle isNil ifTrue: [^self setClipRegion: nil].
    region := self createRegion: aRectangle.
    region = 0 ifTrue: [^self error: 'Create Region error'].
    self setClipRegion: region.
    ^region!  
asWindowHandle
        "Answer the receiver as a WindowHandle."
    ^WindowHandle fromBytes: self!  
isGroupBox
        "Answer whether the receiver is a kind of GroupBox."
    ^false! 
wmClose: wordInteger with: longInteger
        "Private - Process the close window message."
    self sendInputEvent: #close.
    ^1!  
defaultStyle
        "Private - Answer the default radio button window style."
    ^BsAutoradiobutton!  
resetUndo
        "Private - Reset the undo flag of the receiver."
    self isHandleOk ifTrue: [
        UserLibrary
            sendMessage: handle
            msg: EmEmptyundobuffer
            wparam: 0
            lparam: 0 ]! 
startUp
        "Private - Initialize class variables."
    self anchorDictionary: Dictionary new.
    self
        stockObject: BlackPen;
        stockObject: WhitePen.
    self allInstancesPrim do: [ :each | each initHandle ].
    self threshold: 32!   
style: aStyle color: aColor width: wInteger
        "Answer a logical pen with specified
         aStyle, aColor, and wInteger.  aStyle can be
         PsSolid, PsDash, PsDot, PsDashdot, PsDashdotdot,
         PsNull, or PsInsideFrame."
    | attrib |
    attrib := Array with: PsSolid with: ClrBlack with: 0.
    aStyle isNil ifFalse: [ attrib at: 1 put: aStyle ].
    aColor isNil ifFalse: [ attrib at: 2 put: aColor asInteger ].
    wInteger isNil ifFalse: [ attrib at: 3 put: wInteger ].
    ^self objectWithAttributes: attrib! 
fromAttributes: anArray
        "Private - Answer a logical brush with attributes
         specified in anArray."
    ^self new
        style: ( anArray at: 1 ) color: ( anArray at: 2 ) width: ( anArray at: 3 );
        createObject!
winStruct
        "Private - Answer the host structure for receiver."
    ^WinLogPen new!   
style: aStyle color: aColor width: anInteger
        "Private - Set attributes to
         aStyle, aColor, and anInteger."
    style := aStyle.
    color := aColor.
    width := anInteger! 
attributeArray
        "Private - Answer attributes as an array."
    ^Array with: style with: color with: width!   
width
        "Answer the width of the receiver."
    ^width!   
style
        "Answer the style of the receiver."
    ^style!   
fromStruct: struct
        "Private - Answer an instance with attributes
         specified in anArray."
    style := struct style.
    color := GraphicsTool rgbToPalette: struct color.
    width := struct width.
    self createObject! 
getHandle
        "Private - Answer handle after creating
         the windows object."
    | aHandle |
    stockObject notNil ifTrue: [ ^GraphicsTool getStockObject: stockObject ].
    ( aHandle := GDILibrary createPen: style width: width color: color asParameter ) = 0
        ifTrue: [ ^self osError ].
    ^aHandle!
setSysFont: aFont
        "Private - Set the global system font to aFont."
    SysFont := aFont.
    SysFontWidth := aFont charSize x.
    SysFontHeight := aFont charSize y.
    TextFont isNil ifTrue: [ TextFont := SysFont ].
    ListFont isNil ifTrue: [ ListFont := SysFont ].
    ButtonFont isNil ifTrue: [ ButtonFont := SysFont ]!  
isIcon
        "Answer whether the receiver is a kind of Icon."
    ^false! 
screenToClient: aWindowHandle point: aByteArray
    <api: ScreenToClient ulong struct boolean>
    ^self invalidArgument!   
itemIndexFromPoint: aPoint
        "Answer the index of the element under aPoint
		(where aPoint is relative to the receiver window)."
	| top index |
    top := self topCorner y.
    index := top + ( aPoint y // self font height ).
	^index!
isRadioButton
        "Answer whether the receiver is a radio button. "
    ^false! 
initialSize: aSize
        "Set the initial window size to aSize."
    rectangle := aSize isRectangle
        ifTrue: [ aSize ]
        ifFalse: [
            aSize isPoint
                ifTrue: [ self boxOfSize: aSize ]
                ifFalse: [ nil ] ].
    rectangle := WindowDialog inDialogUnits: rectangle!
dragTarget
        "Enable the receiver as a drag drop target."
    self dragTarget: true!  
wmMeasureitem: wparam with: lparam
        "Private - Ignore measure item message."
    | aStruct anAddress control |
    aStruct := WinMeasureItemStruct atAddress:
        ( anAddress := ExternalAddress fromInteger: lparam ).
    aStruct ctlType = OdtMenu
        ifTrue: [ self measureControl: aStruct ]
        ifFalse: [
            control := self childAtId: aStruct ctlId.
            control notNil ifTrue: [ control measureControl: aStruct ] ].
     ^nil! 
enableScrollBar: hwnd type: type flags: flags
    <api: EnableScrollBar ulong ulong ulong boolean>
	^self invalidArgument!  
adjustWindowRect: lpRect dwStyle: anInteger bMenu: aBoolean
    <api: AdjustWindowRect struct ulong boolean boolean>
    ^self invalidArgument! 
asParameter
        "Answer the receiver in a form suitable for 
         passing as a parameter to a procedure call."
    ^self handle!   
initialize
        "Private - Initialize the receiver."
    super initialize.
    menus := OrderedCollection new.
    accel := Dictionary new.
    allMenus := OrderedCollection new.
    allMenus add: Menu new  "For system menu items."! 
selectMessage
        "Private - Answer the host message for selecting an item."
    ^LbSetsel! 
clearMouseCapture
        "End mouse capture."
    UserLibrary releaseCapture ifFalse: [ self osError ]!
menuWindow
        "Private - Needed to support translateAccelerator in Notification Manager."
    ^ nil.!  
notifySliderPosition: aParameter
        "Private - the host signaled that the position changed."
    self
        position: aParameter;
        event: #sliderPosition";
        triggerChanged"!   
initialize
        "Private - First time initialization. Creates the SelfDefinedStructure "
    | d |
    d := Dictionary new.
    d
        at: #lStructSize put: #(0 #ulong #yourself);
        at: #hwndOwner put: #(4 #handle #yourself);
        at: #hInstance put: #(8 #handle #yourself);
        at: #lpstrFilter put: #(12 #ulong #yourself);
        at: #lpstrCustomFilter put: #(16 #ulong #yourself);
        at: #nMaxCustFilter put: #(20 #ulong #yourself);
        at: #nFilterIndex put: #(24 #ulong #yourself);
        at: #lpstrFile put: #(28 #ulong #yourself);
        at: #nMaxFile put: #(32 #ulong #yourself);
        at: #lpstrFileTitle put: #(36 #ulong #yourself);
        at: #nMaxFileTitle put: #(40 #ulong #yourself);
        at: #lpstrInitialDir put: #(44 #ulong #yourself);
        at: #lpstrTitle put: #(48 #ulong #yourself);
        at: #flags put: #(52 #ulong #yourself);
        at: #nFileOffset put: #(56 #ushort #yourself);
        at: #nFileExtension put: #(58 #ushort #yourself);
        at: #lpstrDefExt put: #(60 #ulong #yourself);
        at: #lCustData put: #(64 #ulong #yourself);
        at: #lpfnHook put: #(68 #ulong #yourself);
        at: #lpstrTemplateName put: #(72 #ulong #yourself);
        yourself.
    SelfDefinedStructure define: 'OPENFILENAME' withFields: d!   
openFile: patternString
        "Brings up the default open file dialog.  The title is set to 'Open File'
        and fileSpec is set to patternString. "
    self title: 'Open'.
    patternString notNil ifTrue: [ self fileSpec: patternString ].
    self
        hideReadonly;
        shareAware;
        addFilter: '*.*' description: 'All Files (*.*)';
        addFilter: '*.txt' description: 'Text Files (*.TXT)'.
    Smalltalk isRunTime ifFalse: [ self addSmalltalkFileFilters ].
    ( self propertyAt: #defFilter ) isNil ifTrue:[ self defFilter: '*.*'].
    self open.!  
saveFile: aString
        "Brings up the save file dialog with aString as the
         default name.  The title is set to 'Save File'. "
    self saveTitle: 'Save File' fileName: aString!
file
        "Answer the selected file."
    ^fileName! 
openFile
        "Brings up the default open file dialog.  The title is set to 'Open File'
        and fileSpec is set to '*.*'. "
    self openFile: '*.*'.!  
saveTitle: aTitle fileName: aFileSpec
        "Brings up the file save dialog with aTitle and aString
         as the default name."
    self title: aTitle;
            fileSpec: aFileSpec;
            hideReadonly;
            overwritePrompt;
            addFilter: '*.*' description: 'All Files (*.*)';
            addFilter: '*.txt' description: 'Text Files (*.TXT)'.

    self save.!
emptyClipboard
    <api: EmptyClipboard boolean>
    ^self invalidArgument! 
wmTimer: wParam with: lParam
        "Private - Process the timer message."
    self propertyAt: #timerID put: wParam.
    self event: #timer.
    self triggerEvent: #timer: with: wParam.
    self propertyAt: #timerID put: nil.
    ^nil!   
devModeFromAddress: anExternalAddress
        "Private - answer a DEVMODE SelfDefinedStructure"
    | struct devMode defs value |

    struct := SelfDefinedStructure named: 'DEVMODE' atAddress: anExternalAddress.
    devMode := SelfDefinedStructure named: 'DEVMODE'.
    devMode definition: ( defs := devMode definition copy ).

    "update the structure definition to handle variable size field."

    value := ( defs at: #dmDriverData ) copy.
    value at: 2 put: struct dmDriverExtra.
    defs at: #dmDriverData put: value.
    defs at: #dmDriverData, ':' asSymbol put: value.

    defs at: #sizeInBytes put:  ( value at: 1 ) + ( value at: 2 ).

    devMode contents: ( ByteArray new: ( defs at: #sizeInBytes )).
    ^devMode fillFromAddress: anExternalAddress.!   
flipVertically
		"Answer a copy of the receiver flipped vertically."
	| flippedBitmap |
	flippedBitmap := self class
		width: self width
		height: self height
		planes: self planes
		bitCount: self bitCount.
	flippedBitmap pen copyBitmapFlippedVertically: self.
	^flippedBitmap!   
dialogBackground
        "Answer default dialog background color.  Note that
        the Win32 platform does not distinguish dialog background
        color, so we emulate it using the window background color."
    ^( ( OperatingSystem isWin32 and: [ OperatingSystem versionMajor = 4 ] ) or: [ Window ctl3dEnabled ] )
        ifTrue: [ self buttonFace ]
        ifFalse: [ self windowBackground ]!   
isDialogWindow
        "Answer whether the receiver is a kind of dialog window."
    ^true! 
wmSetfocus: wordInteger with: longInteger
        "Private - Process the set focus message."
    super wmSetfocus: wordInteger with: longInteger.
    self doGraphics: [ selection createCaret: nil at: selection origin ].
    ^nil! 
ownDCExtent: anExtent
        "Create a monochrome bitmap with width anExtent x
         height anExtent y. The bitmap has its own device context."
    ^self ownDCWidth: anExtent x height: anExtent y!   
open
        "Private - Open the subpane."
    self font isNil ifTrue: [ self fontAttribute: self defaultFont ].
    children size ~= 0
        ifTrue: [
            children do: [ :each |
                each isApplicationWindow  "TopPane open is different"
                    ifFalse: [ each open ] ] ]! 
wmCreate: wordInteger with: longInteger
        "Private - Process the create message."
    ^nil!   
width: w height: h bits: aByteArray
        "Answer a new Bitmap with width w and height h
         and bits copied from aByteArray."
    ^self new width: w height: h bits: aByteArray!   
setFocus: aWindowHandle
    <api: SetFocus ulong ulongReturn>
    ^self invalidArgument!
createDialogParam: hInstance templateName: aTemplateName parent: hWndParent dialogFunction: lpDialogFunc initParam: anInteger
    <api: CreateDialogParamA ulong struct ulong ulong ulong ulongReturn>
    ^self invalidArgument!   
sendMessage: msg item: itemId wparam: int1 lparam: int2
        "Private - send the given message to the given item."
    ^UserLibrary
        sendDlgItemMessageInt: handle
        item: itemId
        msg: msg
        wparam: int1
        lparam: int2!  
setScrollPos: aWindowHandle bar: anInteger position: posInteger redraw: aBoolean
    <api: SetScrollPos ulong long long boolean long>
    ^self invalidArgument!
defaultAction
        "This is the action that is performed if this exception is signaled
        and there is no active handler for it."
    RecursionInError := nil.
    OperatingSystem cleanUpAfterError.
    CurrentEvents initialSize: 5. "empty it"
    Process
        queueWalkback: self defaultDescriptionString
        makeUserIF: CurrentProcess isUserIF
        resumable: 2!
defaultDescriptionString
        "Private - answer a textual description of the exception if an
        explicit description has not been provided."
    ^'Keyboard Interrupt'!
helpRequest
        "Private - Notify a help event to any window
        which can handle it following the window chain."
    self mainWindow helpContext isNil ifTrue: [
        self mainWindow helpContext: ( Association key: self name value: self ) ].

    ^( ( self handlesEvent: #help ) or: [ self hasActionForEvent: #help ] )
        ifTrue: [
            self event: #help.
            self triggerEvent: #help ]
        ifFalse: [ parent helpRequest ]!  
setSelection
        "Private - Set the text selection in the host control.
        Assumes 'handle = NullHandle' is false."
    selection isNil ifTrue: [ ^self ].
    UserLibrary
        sendMessage: handle
        msg: EmSetsel
        wparam: selection x - 1
        lparam: selection y!
notify
        "Add the notify style."
    ^self addStyle: LbsNotify!   
readBitmapsFromFileStream: aFileStream
    "Private - read the xorMask and andMask bitmaps for the receiver
      from aFileStream."

    | andBitInfo xorBitInfo andMaskSize xorBits andBits |
    xorBitInfo := Bitmap readBitmapInfo: aFileStream.
    xorBitInfo height: xorBitInfo height // 2.
    andMaskSize := xorBitInfo width / 8 * xorBitInfo width.
    xorBitInfo sizeImage: xorBitInfo sizeImage - andMaskSize.

    xorBits := ByteArray new: xorBitInfo sizeImage.
    andBits := ByteArray new: andMaskSize.
    aFileStream getBytesFor: xorBits.
    aFileStream getBytesFor: andBits.

    "Create AND and XOR bitmap objects but don't create
      OS objects until needed. "
    andMask := Bitmap new.
    andBitInfo := WinBitmapInfo
        width: xorBitInfo width
        height: xorBitInfo height
        planes: 1
        bitCount: 1
        size: ( WinBitmapInfo getCb: 1 ).
    andBitInfo colorTable: (
        (ByteArray with: 0 with: 0 with: 0 with: 0) , (
        ByteArray with: 255 with: 255 with: 255 with: 0)).
    andMask
        bitmapInfo: andBitInfo;
        archive: andBits;
        deviceContext: Bitmap memoryContext;
        graphicsTool: ( Pen for: Bitmap memoryContext medium: andMask ).

    xorMask := Bitmap new
        bitmapInfo: xorBitInfo;
        archive: xorBits;
        deviceContext: Bitmap memoryContext;
        graphicsTool: ( Pen for: Bitmap memoryContext medium: xorMask )! 
dragSourceNeedsObject: dragSession
        "Private - retrieve the object to be dragged."
    self dragSourceSelection: ( Rectangle leftTop: selection origin rightBottom: selection corner ).
    ^super dragSourceNeedsObject: dragSession.
!   
charsInRow
        "Private - Answer the receiver width in characters."
    ^self getFormatRect width // self font width!   
destroyCaret
    <api: DestroyCaret boolean>
    ^self invalidArgument! 
findWindow:aHandle
        "Private - Answer the menu window which has aHandle as HMENU"
    allMenus do: [ :m |
        m window notNil ifTrue: [
            aHandle = m window handle ifTrue: [ ^m ] ] ].
    allMenus do: [ :m |
        ( m findWindow: aHandle ) notNil ifTrue: [
            ^m findWindow: aHandle ] ].
    ^nil! 
enableRedraw
        "Private - the receiver should repaint itself"
    ^self noRedraw: false!  
extent
        "Private - Answer the extent of the receiver window."
    ^self rectangle extent!
enable
        "Enable the receiver window."
    self enable: true! 
hideWindow
        "Private - make the receiver invisible."
    ^self showWindow: false!
disable
        "Disable the receiver window."
    self enable: false!  
showWindow
        "Private - make the receiver visible."
    ^self showWindow: true!   
disableRedraw
        "Private - the receiver should not repaint itself"
    ^self noRedraw: true!  
loadBitmap: hInstance nameString: resourceName
    <api: LoadBitmapA ulong struct ulongReturn>
    ^self invalidArgument!   
nullValue
        "Answer an instance of the receiver class which represents
        an invalid (uninitialized) value."
    ^NullWindowHandle! 
addMenu: aMenu
        "Add aMenu to the receiver."
    self owner isMDIChild ifTrue: [
        self addMDIMenu: aMenu.
        ^self ].
    menus add: aMenu.
    self isHandleOk ifTrue: [
        self insertItem: ( aMenu buildWindow: self ) label: aMenu title.
        ( UserLibrary drawMenuBar: parent asParameter )
            ifFalse: [ ^self osError ] ]!  
dragTargetEmphasisTypesSupported
		"Private - answer a collection of emphasis types that the receiver can support."
	^self class dragTargetEmphasisTypesSupported!  
excludeClipRect: hdc x1: anInt1 y1: anInt2 x2: anInt3 y2: anInt4
    <api: ExcludeClipRect ulong long long long long long>
    ^self invalidArgument!   
getMetaFileBitsEx: hmf bufsize: bufsize pbuf: pbuf
    <api: GetMetaFileBitsEx ulong ulong struct ulongReturn>
    ^self invalidArgument!   
setBrushOrgEx: hdc x: anInt1 y: anInt2 oldOrigin: aWinPoint
    <api: SetBrushOrgEx ulong long long struct boolean>
    ^self invalidArgument!  
deleteObject: aGDIObject
    <api: DeleteObject ulong boolean>
    ^self invalidArgument!   
createCompatibleBitmap: aDeviceContext width: anInt1 height: anInt2
    <api: CreateCompatibleBitmap ulong long long ulongReturn>
    ^self invalidArgument!
getObjectType: objectHandle
    <api: GetObjectType ulong ulongReturn>
    ^self invalidArgument!   
combineRgn: hDestRgn srcRgn1: hSrcRgn1 srcRgn2: hSrcRgn2 mode: anInt
    <api: CombineRgn ulong ulong ulong long long>
    ^self invalidArgument!   
realizePalette: hdc
    <api: RealizePalette ulong ulongReturn>
    ^self invalidArgument!  
rectVisible: hdc rectangle: aRect
    <api: RectVisible ulong struct boolean>
    ^self invalidArgument!
getTextFace: hDC size: nCount lpFaceName: lpFaceName
   <api: GetTextFaceA ulong long struct long>
    ^self invalidArgument!   
createPen: style width: width color: color
    <api: CreatePen long long ulong ulongReturn>
    ^self invalidArgument!  
copyMetaFile: hdc fileName: aString
    <api: CopyMetaFileA ulong struct ulongReturn>
    ^self invalidArgument!
createBrushIndirect: logBrush
    <api: CreateBrushIndirect struct ulongReturn>
    ^self invalidArgument!  
setPixelV: deviceContext x: xPixel y: yPixel color: color
    <api: SetPixelV ulong long long ulong boolean>
    ^self invalidArgument! 
setMapMode: hdc mode: mapMode
    <api: SetMapMode ulong long long>
    ^self invalidArgument!  
getViewportOrgEx: hdc origin: pSize
    <api: GetViewportOrgEx ulong struct boolean>
    ^self invalidArgument! 
arc: hdc x1: anInt1 y1: anInt2 x2: anInt3 y2: anInt4 x3: anInt5 y3: anInt6 x4: anInt7 y4: anInt8
    <api: Arc ulong long long long long long long long long boolean>
    ^self invalidArgument!
getMetaFile: fileName
    <api: GetMetaFileA struct ulongReturn>
    ^self invalidArgument! 
getDIBits: hdc hBitmap: hBitmap startScan: anInt1 scans: anInt2 bitsStruct: aByteArray bitsInfo: bitmapInfo wUsage: int3
    <api: GetDIBits ulong ulong ulong ulong struct struct ulong long>
    ^self invalidArgument!   
setDIBitsToDevice: hdc destX: anInt1 destY: anInt2 width: anInt3 height: anInt4 srcX: anInt5 srcY: anInt6 startScan: anInt7 scans: anInt8 bits: aByteArray bitsInfo: bitmapInfo wUsage: int3
    <api: SetDIBitsToDevice ulong long long ulong ulong long long ulong ulong struct struct ulong long>
    ^self invalidArgument! 
getTextMetrics: hDC lpMetrics: lpMetrics
    <api: GetTextMetricsA ulong struct boolean>
    ^self invalidArgument! 
setDIBits: hdc hBitmap: hBitmap startScan: anInt1 scans: anInt2 bitsStruct: aByteArray bitsInfo: bitmapInfo wUsage: int3
    <api: SetDIBits ulong ulong ulong ulong struct struct ulong long>
    ^self invalidArgument!   
deleteMetaFile: hMetaFile
    <api: DeleteMetaFile ulong boolean>
    ^self invalidArgument!
getPixel: hdc x: anInt1 y: anInt2
    <api: GetPixel ulong long long ulongReturn>
    ^self invalidArgument!
selectObject: aDeviceContext with: anObject
    <api: SelectObject ulong ulong ulongReturn>
    ^self invalidArgument!  
setBkColor: aDeviceContext with: aColor
    <api: SetBkColor ulong ulong ulongReturn>
    ^self invalidArgument!
setBkMode: hdc mode: aMode
    <api: SetBkMode ulong long long>
    ^self invalidArgument!  
setRop2: hdc drawMode: aR2Constant
    <api: SetROP2 ulong long long>
    ^self invalidArgument!
getCharWidth: hdc firstChar: anInt1 lastChar: anInt2 buffer: aByteArray
    <api: GetCharWidthA ulong ulong ulong struct boolean>
    ^self invalidArgument!
saveDC: hdc
    <api: SaveDC ulong long>
    ^self invalidArgument! 
getCurrentPositionEx: aDeviceContext point: winPoint
    <api: GetCurrentPositionEx ulong struct boolean>
    ^self invalidArgument!
setTextColor: aDeviceContext with: aColor
   <api: SetTextColor ulong ulong ulongReturn>
    ^self invalidArgument! 
getStockObject: anInteger
   <api: GetStockObject long ulongReturn>
    ^self invalidArgument!  
selectPalette: aDeviceContext with: anObject forceBackground: aBoolean
    <api: SelectPalette ulong ulong boolean ulongReturn>
    ^self invalidArgument!  
setMetaFileBitsEx: size buffer: buffer
    <api: SetMetaFileBitsEx ulong struct ulongReturn>
    ^self invalidArgument! 
setTextAlign: aDeviceContext flags: taFlags
   <api: SetTextAlign ulong ulong ulongReturn>
    ^self invalidArgument!   
getViewportExtEx: hdc extent: pSize
    <api: GetViewportExtEx ulong struct boolean>
    ^self invalidArgument! 
escape: hDC function: anInt1 count: anInt2 inDataULong: aWinAddress1 outDataULong: aWinAddress2
    <api: Escape ulong long long ulong ulong long>
    ^self invalidArgument!   
getBitmapBits: hBitmap count: anInteger bitsStruct: aByteArray
    <api: GetBitmapBits ulong long struct long>
    ^self invalidArgument!   
getMapMode: hdc
    <api: GetMapMode ulong long>
    ^self invalidArgument! 
lineTo: aDeviceContext x: anInteger1 y: anInteger2
    <api: LineTo ulong long long boolean>
    ^self invalidArgument! 
scaleWindowExtEx: hdc xNum: anInt1 xDenom: anInt2 yNum: anInt3 yDenom: anInt4 oldExtent: pSize
    <api: ScaleWindowExtEx ulong long long long long ulong boolean>
     ^self invalidArgument!  
getBitmapBits: hBitmap count: anInteger bits: aWinAddress
    <api: GetBitmapBits ulong long ulong long>
    ^self invalidArgument! 
deleteDC: aDeviceContext
    <api: DeleteDC ulong boolean>
    ^self invalidArgument!   
getNearestPaletteIndex: hPallete color: rgb
    <api: GetNearestPaletteIndex ulong ulong ulongReturn>
    ^self invalidArgument!
getTextAlign: aDeviceContext
   <api: GetTextAlign ulong ulongReturn>
    ^self invalidArgument!
escape: hDC function: anInt1 count: anInt2 inData: aStruct1 outData: aStruct2
    <api: Escape ulong long long struct ulong long>
    ^self invalidArgument!
getObject: objectHandle count: anInteger lpObject: aStruct
   <api: GetObjectA ulong long struct long>
    ^self invalidArgument!   
setBitmapBits: hBitmap count: anInteger bits: aWinAddress
    <api: SetBitmapBits ulong ulong ulong long>
    ^self invalidArgument!
enumFonts: hDC facename: lpFacename lpFontFunc: lpFontFunc lpData: lpData
    <api: EnumFontsA ulong struct ulong ulong long>
    ^self invalidArgument!
polyline: hDC lpPoints: anLPPOINT count: anInt
    <api: Polyline ulong struct ulong boolean>
    ^self invalidArgument!
createPalette: pLogPal
    <api: CreatePalette struct ulongReturn>
    ^self invalidArgument!   
getDeviceCaps: hdc index: anInteger
    <api: GetDeviceCaps ulong long long>
    ^self invalidArgument! 
endPage: aDeviceContext
    <api: EndPage ulong long>
    ^self invalidArgument!
setPixel: deviceContext x: xPixel y: yPixel color: color
    <api: SetPixel ulong long long ulong ulongReturn>
    ^self invalidArgument!   
selectClipRgn: hDC rgn: hRgn
    <api: SelectClipRgn ulong ulong long>
    ^self invalidArgument!   
setViewportExtEx: hdc x: anInt1 y: anInt2 oldExtent: pSize
    <api: SetViewportExtEx ulong long long ulong boolean>
    ^self invalidArgument! 
setViewportOrgEx: hdc x: anInt1 y: anInt2 oldOrigin: pPoint
    <api: SetViewportOrgEx ulong long long ulong boolean>
    ^self invalidArgument!
startDoc: aDeviceContext docInfo: aDocinfo
    <api: StartDocA ulong struct long>
    ^self invalidArgument!
patBlt: dc x: anInt1 y: anInt2 width: anInt3 height: anInt4 rop: ropConstant
    <api: PatBlt ulong long long long long ulong boolean>
    ^self invalidArgument!   
bitBlt: hDest x: anInt1 y: anInt2 width: anInt3 height: anInt4 srcDC: hSrc xSrc: anInt5 ySrc: anInt6 rop: ropConstant
    <api: BitBlt ulong long long long long ulong long long ulong boolean>
    ^self invalidArgument!  
playMetaFile: hdc with: hMetaFile
    <api: PlayMetaFile ulong ulong boolean>
    ^self invalidArgument!
createHatchBrush: nIndex color: aColor
    <api: CreateHatchBrush long ulong ulongReturn>
    ^self invalidArgument!
getWindowOrgEx: hdc origin: pSize
    <api: GetWindowOrgEx ulong struct boolean>
    ^self invalidArgument! 
endDoc: aDeviceContext
    <api: EndDoc ulong long>
    ^self invalidArgument!  
createDC: driverName deviceName: aDevice output: aString initData: deviceMode
    <api: CreateDCA struct struct struct struct ulongReturn>
    ^self invalidArgument!   
createIC: lpDriverName deviceName: deviceName output: output initData: initData
    <api: CreateICA struct struct struct struct ulongReturn>
    ^self invalidArgument! 
getCharWidth: hDC firstChar: firstChar lastChar: lastChar pWidths: pWidths
    <api: GetCharWidthA ulong ulong ulong struct boolean>
    ^self invalidArgument! 
closeMetaFile: hdc
    <api: CloseMetaFile ulong ulongReturn>
    ^self invalidArgument!
ellipse: hDC x1: anInt1 y1: anInt2 x2: anInt3 y2: anInt4
    <api: Ellipse ulong long long long long boolean>
    ^self invalidArgument!
offsetViewportOrgEx: hdc x: anInt1 y: anInt2 oldPosition: pWinPoint
    <api: OffsetViewportOrgEx ulong long long ulong boolean>
    ^self invalidArgument! 
polygon: hDC lpPoints: anLPPOINT nCount: anInt
    <api: Polygon ulong struct long boolean>
    ^self invalidArgument!  
rectangle: aDeviceContext x1: ulx y1: uly x2: lrx y2: lry
    <api: Rectangle ulong long long long long boolean>
    ^self invalidArgument! 
roundRect: hdc x1: anInt1 y1: anInt2 x2: anInt3 y2: anInt4 x3: anInt5 y3: anInt6
    <api: RoundRect ulong long long long long long long boolean>
    ^self invalidArgument!
createBitmapIndirect: lpBitmap
    <api: CreateBitmapIndirect struct ulongReturn>
    ^self invalidArgument!
getWindowExtEx: hdc extent: pSize
    <api: GetWindowExtEx ulong struct boolean>
    ^self invalidArgument! 
chord: hdc x1: anInt1 y1: anInt2 x2: anInt3 y2: anInt4 x3: anInt5 y3: anInt6 x4: anInt7 y4: anInt8
    <api: Chord ulong long long long long long long long long boolean>
    ^self invalidArgument!
scaleViewportExtentEx: hdc xNum: anInt1 xDenom: anInt2 yNum: anInt3 yDenom: anInt4 oldExtent: pSize
    <api: ScaleViewportExtEx ulong long long long long ulong boolean>
     ^self invalidArgument!   
pie: hdc x1: anInt1 y1: anInt2 x2: anInt3 y2: anInt4 x3: anInt5 y3: anInt6 x4: anInt7 y4: anInt8
    <api: Pie ulong long long long long long long long long boolean>
    ^self invalidArgument!
startPage: aDeviceContext
    <api: StartPage ulong long>
    ^self invalidArgument!
createDIBitmap: hdc infoHeader: infoStruct dwUsage: anInt1 initBitsStruct: aByteArray initInfo: bitmapInfo wUsage: anInt2
    <api: CreateDIBitmap ulong struct ulong struct struct ulong ulongReturn>
    ^self invalidArgument!   
createMetaFile: fileName
    <api: CreateMetaFileA struct ulongReturn>
    ^self invalidArgument!   
enumFonts: hDC lpFacename: lpFacename lpFontFunc: lpFontFunc lpData: lpData
    <api: EnumFontsA ulong ulong ulong ulong long>
    ^self invalidArgument!   
extFloodFill: aHDC x:x y:y color:color fillType:fillType
    <api: ExtFloodFill ulong long long ulong ulong boolean>
    ^self invalidArgument! 
stretchBlt: hDest x: anInt1 y: anInt2 dWidth: anInt3 dHeight: anInt4 srcDC: hSrc xSrc: anInt5 ySrc: anInt6 sWidth: anInt7 sHeight: anInt8 rop: ropConstant
    <api: StretchBlt ulong long long long long ulong long long long long ulong boolean>
    ^self invalidArgument!   
dpToLp: hdc point: pointStruct count: anInt
    <api: DPtoLP ulong struct long boolean>
    ^self invalidArgument!  
restoreDC: hdc savedDC: anInt
    <api: RestoreDC ulong long boolean>
    ^self invalidArgument!
createSolidBrush: anInteger
    <api: CreateSolidBrush ulong ulongReturn>
    ^self invalidArgument!
createRectRgnX1: anInt1  y1: anInt2 x2: anInt3 y2: anInt4
    <api: CreateRectRgn long long long long ulongReturn>
    ^self invalidArgument!   
stretchDIBits: hDC xDest: anInt1 yDest: anInt2 cxDest: anInt3 cyDest: anInt4 xSrc: anInt5 ySrc: anInt6 cxSrc: anInt7 cySrc: anInt8 bits: bits bmi: bmi colorUse: anInt9 rop:rop
    <api: StretchDIBits ulong long long long long long long long long struct struct ulong ulong long>
    ^self invalidArgument!
createBitmap: w height: h planes: anInt1 bitCount: anInt2 bits: aWinAddress
    <api: CreateBitmap long long ulong ulong ulong ulongReturn>
    ^self invalidArgument!  
createCompatibleDC: aDeviceContext
    <api: CreateCompatibleDC ulong ulongReturn>
    ^self invalidArgument!   
createDIBitmap: hdc infoHeader: infoStruct dwUsage: anInt1 initBits: aWinAddress initInfo: bitmapInfo wUsage: anInt2
    <api: CreateDIBitmap ulong struct ulong ulong struct ulong ulongReturn>
    ^self invalidArgument! 
abortDoc: aDeviceContext
    <api: AbortDoc ulong long>
    ^self invalidArgument!  
extTextOut: hDC x: anInt1 y: anInt2 options: anInt3 rect: aRectangle text: aString length: anInt4 dx: lpArray
    <api: ExtTextOutA ulong long long ulong struct struct ulong struct boolean>
    ^self invalidArgument!
createFontIndirect: lpLogFont
    <api: CreateFontIndirectA struct ulongReturn>
    ^self invalidArgument!  
createPatternBrush: hBitmap
    <api: CreatePatternBrush ulong ulongReturn>
    ^self invalidArgument!  
textOut: aDeviceContext x: anInteger1 y: anInteger2 text: aString length: anInteger3
    <api: TextOutA ulong long long struct long boolean>
    ^self invalidArgument! 
setAbortProc: aDeviceContext proc: anAddress
    <api: SetAbortProc ulong ulong long>
    ^self invalidArgument!
getClipBox: dcHandle rectangle: aStruct
    <api: GetClipBox ulong struct long>
    ^self invalidArgument!  
getDIBits: hdc hBitmap: hBitmap startScan: anInt1 scans: anInt2 bits: aWinAddress bitsInfo: bitmapInfo wUsage: int3
    <api: GetDIBits ulong ulong ulong ulong ulong struct ulong long>
    ^self invalidArgument! 
getPaletteEntries: hPalette startIndex: startIndex numEntries: numEntries lpPaletteEntries: lpPaletteEntries
   <api: GetPaletteEntries ulong ulong ulong struct ulongReturn>
    ^self invalidArgument!
getTextExtentPoint: hDC string: lpString count: nCount size: pSize
   <api: GetTextExtentPointA ulong struct long struct boolean>
    ^self invalidArgument!
moveToEx: aDeviceContext x: anInteger1 y: anInteger2 oldPosition: winPoint
    <api: MoveToEx ulong long long struct boolean>
    ^self invalidArgument!
setDIBits: hdc hBitmap: hBitmap startScan: anInt1 scans: anInt2 bits: aWinAddress bitsInfo: bitmapInfo wUsage: int3
    <api: SetDIBits ulong ulong ulong ulong ulong struct ulong long>
    ^self invalidArgument! 
setWindowExtEx: hdc x: anInt1 y: anInt2 oldExtent: pSize
    <api: SetWindowExtEx ulong long long ulong boolean>
    ^self invalidArgument! 
setWindowOrgEx: hdc x: anInt1 y: anInt2 oldOrigin: pPoint
    <api: SetWindowOrgEx ulong long long ulong boolean>
    ^self invalidArgument!
frameWindow
        "Answer the frame window of the receiver."
    ^self!   
okButtonLayoutFrame
    "Private"
    "Answer the layout frame for the OK button."

    | buttonExtent horizontalMargin verticalMargin intraButtonSpacing |
    buttonExtent := self buttonExtent.
    horizontalMargin := self horizontalMargin.
    verticalMargin := self verticalMargin.
    intraButtonSpacing := self intraButtonSpacing.
    OperatingSystem isOS2
        ifTrue:
            [^(LayoutFrame topLeftRatio: 0 @ 1 bottomRightRatio: 0 @ 1)
                topInset: (verticalMargin + buttonExtent y) negated;
                leftInset: horizontalMargin;
                bottomInset: verticalMargin;
                rightInset: (horizontalMargin + buttonExtent x) negated].
    OperatingSystem isWindows95
        ifTrue:
            [^(LayoutFrame topLeftRatio: 1 @ 1 bottomRightRatio: 1 @ 1)
                topInset: (verticalMargin + buttonExtent y) negated;
                leftInset: (horizontalMargin + (buttonExtent x * 2) + intraButtonSpacing) negated;
                bottomInset: verticalMargin;
                rightInset: horizontalMargin + buttonExtent x + intraButtonSpacing].
    ^(LayoutFrame topLeftRatio: 0.5 @ 1 bottomRightRatio: 0.5 @ 1)
        topInset: (verticalMargin + buttonExtent y) negated;
        leftInset: (buttonExtent x + (intraButtonSpacing // 2)) negated;
        bottomInset: verticalMargin;
        rightInset: intraButtonSpacing // 2!
dialogUnitsToPixels: dialogUnits
    "Private"
    "Answer the result of converting the given <dialogUnits> into pixels."

    ^dialogUnits * WindowDialog dialogUnit / WindowDialog unitMultiplier!  
openOn: listOfChoices
initialSelection: initialSelection
prompt: messageText
    "Allow the user to choose an item from the given <listOfChoices>. Use the given <messageText> as the prompt. Make the given <initialSelection> be the initially selected item."

    ^self
        openOn: listOfChoices
        initialSelection: initialSelection
        prompt: messageText
        printSelector: #printString!
openOn: listOfChoices
initialSelection: initialSelection
prompt: messageText
printSelector: printSelector
    "Allow the user to choose an item from the given <listOfChoices>. Use the given <messageText> as the prompt. Make the given <initialSelection> be the initially selected item. Send the <printSelector> to each item to convert it to a string for display purposes."

    ^self
        openOn: listOfChoices
        initialSelection: initialSelection
        titled: 'Choose'
        prompt: messageText
        printSelector: printSelector! 
horizontalMargin
    "Private"
    "Answer the width of the margin to the left and right of each control in dialog units."

    ^6!   
borderWidth
    "Private"
    "Answer the width of the border around the list pane."

    ^1! 
cancelButtonLayoutFrame
    "Private"
    "Answer the layout frame for the Cancel button."

    | buttonExtent horizontalMargin verticalMargin intraButtonSpacing |
    buttonExtent := self buttonExtent.
    horizontalMargin := self horizontalMargin.
    verticalMargin := self verticalMargin.
    intraButtonSpacing := self intraButtonSpacing.
    OperatingSystem isOS2
        ifTrue:
            [^(LayoutFrame topLeftRatio: 0 @ 1 bottomRightRatio: 0 @ 1)
                topInset: (verticalMargin + buttonExtent y) negated;
                leftInset: horizontalMargin + buttonExtent x + intraButtonSpacing;
                bottomInset: verticalMargin;
                rightInset: (horizontalMargin + (buttonExtent x * 2) + intraButtonSpacing) negated].
    OperatingSystem isWindows95
        ifTrue:
            [^(LayoutFrame topLeftRatio: 1 @ 1 bottomRightRatio: 1 @ 1)
                topInset: (verticalMargin + buttonExtent y) negated;
                leftInset: (horizontalMargin + buttonExtent x) negated;
                bottomInset: verticalMargin;
                rightInset: horizontalMargin].
    ^(LayoutFrame topLeftRatio: 0.5 @ 1 bottomRightRatio: 0.5 @ 1)
        topInset: (verticalMargin + buttonExtent y) negated;
        leftInset: intraButtonSpacing // 2;
        bottomInset: verticalMargin;
        rightInset: (buttonExtent x + (intraButtonSpacing // 2)) negated!
verticalMargin
    "Private"
    "Answer the height of the margin above and below each control in dialog units."

    ^6! 
maxItemsToShow
    "Private"
    "Answer the maximum number of items the list may contain before a scroll bar is required."

    ^10! 
computeWindowWidthFromPaneWidth: maxPaneWidthPixels
    "Private"
    "Compute the width of the window."

    ^maxPaneWidthPixels + (self dialogUnitsToPixels: self horizontalMargin * 2) x
        max: (self dialogUnitsToPixels: (self horizontalMargin * 2) + self intraButtonSpacing + (self buttonExtent x * 2)) x!
defaultFont
    "Private"
    "Answer the default font for instances of the receiver."

    ^ListFont!
openOn: listOfChoices
initialSelection: initialSelection
titled: dialogTitle
prompt: messageText
printSelector: printSelector
    "Allow the user to choose an item from the given <listOfChoices>. Use the given <messageText> as the prompt and title the dialog with the given <dialogTitle>. Make the given <initialSelection> be the initially selected item. Send the <printSelector> to each item to convert it to a string for display purposes."

    | model view |
    model := self new.
    model list: listOfChoices.
    model label: messageText.
    model currentSelection: initialSelection.
    view := self createViewFor: model.
    self buildView: view forModel: model printSelector: printSelector.
    dialogTitle == nil
        ifFalse: [view labelWithoutPrefix: dialogTitle].
    view open.
    ^model! 
buildView: view
forModel: listChooser
printSelector: printSelector
    "Private"
    "Create the structure of the <listChooser> within the given <view>. Use the given <printSelector> to convert the list items to strings for display purposes."

    | horizontalMargin verticalMargin labelHeight pane |
    verticalMargin := self verticalMargin.
    horizontalMargin := self horizontalMargin.
    labelHeight := (WindowDialog inDialogUnits: 0 @ SysFont height) y.
    view addPane: (StaticText new
        contents: listChooser label;
        font: SysFont;
        layoutFrame: ((LayoutFrame topLeftRatio: 0 @ 0 bottomRightRatio: 1 @ 0)
                topInset: verticalMargin;
                leftInset: horizontalMargin;
                bottomInset: (verticalMargin + labelHeight) negated;
                rightInset: horizontalMargin)).
    view addPane: ((pane := ListBox new)
        font: self defaultFont;
        printSelector: printSelector;
        when: #doubleClicked: send: #doubleClickSelection: to: listChooser;
        when: #changed: send: #setSelection: to: listChooser;
        when: #needsContents send: #setList: to: listChooser with: pane;
        layoutFrame: ((LayoutFrame topLeftRatio: 0 @ 0 bottomRightRatio: 1 @ 1)
                topInset: verticalMargin * 2 + labelHeight;
                leftInset: horizontalMargin;
                bottomInset: verticalMargin * 2 + self buttonExtent y;
                rightInset: horizontalMargin)).
    view addPane: (Button new
        label: 'OK';
        defaultPushButton;
        when: #clicked send: #pressedOK to: listChooser;
        layoutFrame: self okButtonLayoutFrame).
    view addPane: (Button new
        label: 'Cancel';
        when: #clicked send: #pressedCancel to: listChooser;
        layoutFrame: self cancelButtonLayoutFrame).
    view initialSize: (listChooser windowSize: pane)!  
openOn: listOfChoices
prompt: messageText
    "Allow the user to choose an item from the given <listOfChoices>. Use the given <messageText> as the prompt."

    ^self
        openOn: listOfChoices
        initialSelection: nil
        prompt: messageText!
intraButtonSpacing
    "Private"
    "Answer the distance between buttons in dialog units."

    ^4!  
buttonExtent
    "Private"
    "Answer the size of the buttons in dialog units."

    ^40 @ 14!   
computeWindowHeightFromPaneHeight: maxPaneHeightPixels
    "Private"
    "Compute the height. Add in the height of the static text, plus the buttons, plus the margins surrounding the controls"

    ^maxPaneHeightPixels
        + SysFont height
        + (self dialogUnitsToPixels: self buttonExtent y + (self verticalMargin * 4)) y!
windowClass
    "Answer the class of windows for the receiver."

    ^DialogTopPane!   
open: aCoordinator
    "Build and open a window for <aCoordinator>."

    | view |
    view := self constructViewFor: aCoordinator.
    view open!   
constructEventsTriggered
        "Private - Construct the set of events triggered by instances
        of the receiver."
    ^super constructEventsTriggered
        add: #closeApplication ;
        yourself!  
openOn: initialState
    "Build and open a window for a new instance of the receiver viewing
    the <initialState> object."

    | coordinator |
    coordinator := self new.
    coordinator initialState: initialState.
    self open: coordinator.
    ^coordinator!  
buildView: aView forModel: aCoordinator
    "Create the structure of the window <aView> for the application <aCoordinator>."

    ^self implementedBySubclass! 
eventsTriggered
        "Answer all the events which can be triggered
        by instances of the receiver."
    eventsTriggered isNil ifTrue: [ self initializeEventsTriggered ].
    ^eventsTriggered!  
eventsTriggered: aCollection
        "Private - specify all the events which can be triggered
        by instances of the receiver."
    eventsTriggered := aCollection!   
initialize
    "Initialize the receiver."
    "ApplicationCoordinator initialize"

    self initializeEventsTriggered!
new
		"Answer a new instance of the receiver."
	^super new initialize!  
constructViewFor: aCoordinator
    "Create a new view of the application <aCoordinator> and define its structure."

    | view |
    view := self createViewFor: aCoordinator.
    self buildView: view forModel: aCoordinator.
    ^view!  
windowPolicyClass
    "Answer the class of window policy for the receiver."

    ^StandardWindowPolicy "current"!  
initializeAll
    "Initialize the receiver and its subclasses."
    "ApplicationCoordinator initializeAll"

    self withAllSubclasses do:
        [:each |
        each initialize]!   
createViewFor: aCoordinator
    "Create and configure a window for <aCoordinator>."

    | window |
    window := self windowClass new.
    window isDialogTopPane ifFalse: [ window owner: window ].
    window windowPolicy: ( self windowPolicyClass on: window ).
    aCoordinator when: #closeApplication send: #close to: window.
    ^window!  
initializeEventsTriggered
        "Private - initialize all the events which can be triggered
        by instances of the receiver."
    self eventsTriggered: self constructEventsTriggered!  
open
    "Build and open a window for a new instance of the receiver."

    | coordinator |
    coordinator := self new.
    self open: coordinator.
    ^coordinator!  
disabled
        "Answer true if the receiver is disabled, else false."
    | drawStruct |
    ^(drawStruct := self ownerDrawStruct) notNil
        ifTrue: [drawStruct itemIsDisabled]
        ifFalse: [super disabled]!   
registerWindowMessage: fingMsgString
    <api: RegisterWindowMessageA struct ulongReturn>
    ^self invalidArgument!
getWindowLongString: aWindowHandle index: anInteger
    <api: GetWindowLongA ulong long ulong>
    ^self invalidArgument!   
statusPane
        "Answer the receiver's statusPane"
    ^self mainView statusPane!
wmLbuttonup: wordInteger with: longInteger
        "Private - Process the left button up message."
    | point |
    self class toolTipInstalled
        ifTrue: [ self relay: WmLbuttonup wparam: wordInteger lparam: longInteger ].
    point := Point fromInteger: longInteger.
    ( wordInteger bitAnd: MkShift ) ~= 0
        ifTrue: [ self sendInputEvent: #button1UpShift: with: point ]
        ifFalse: [ self sendInputEvent: #button1Up: with: point ].
    ^nil!   
overHang
        "Private - Answer overHang amount."
    ^self physicalFont tmOverhang! 
dragTargetEraseSeparatorEmphasis
		"Private - erase the previously drawn separator emphasis."
	| lastIndex rect |
	lastIndex := self dragTargetSelection.
	rect := self lineToRect: lastIndex.
	self
		dragTargetDrawEmphasisLineFrom: rect leftTop
		to: rect rightTop!   
endPaint: aWindowHandle paintStructure: aWinAddress
    <api: EndPaint ulong ulong boolean>
    ^self invalidArgument!  
composing: firstLayout
with: secondLayout
	"Answer an instance of the receiver representing the composition of the <firstLayout> with the <secondLayout>."

	| composite |
	composite := self new.
	composite layoutList: (Array
		with: firstLayout
		with: secondLayout).
	^composite! 
new
		"Answer a new instance of the receiver."
	^super new initialize!  
new
		"Answer a new instance of the receiver."
	^super new initialize!  
object: anObject
        "Answer a new instance of the receiver class
		containing the single format defined by anObject."
    ^self new object: anObject! 
metafile: aMetafile
        "Answer a new instance of the receiver class
		containing the single format defined by aMetafile."
    ^self new metafile: aMetafile!  
bitmap: aBitmap
        "Answer a new instance of the receiver class
		containing the single format defined by aBitmap."
    ^self new bitmap: aBitmap!
string: aString
        "Answer a new instance of the receiver class
		containing the single format defined by aString."
    ^self new string: aString!
getValue
        "Private - Get the value of the receiver.  Return value
        is either true, false, or nil."
    | result |
    result := UserLibrary
        sendMessageInt: handle
        msg: BmGetcheck
        wparam: 0
        lparam: 0.
    ^value := ( result = 2 ) ifTrue: [ nil ] ifFalse: [ result ~= 0 ]! 
replaceAtPattern
        "Private - search for the next occurrence of
        SearchString, and replace it with NewString."
    self replace: false!   
altDownInWmChar: wordInteger with: longInteger
        "Private - Process the alt case in WmSysChar.
        Check if a sibling uses this char for a mnemonic and
        queue a mnemonic handler for it if it does.
        Answer true if a sibling handles the char."
    | wasHandled |

    ( longInteger bitAnd: 16r20000000 ) ~= 0    "Alt key down"
        ifTrue: [
            wasHandled :=
                self superWindow
                    altKeyInput: wordInteger asCharacter
                    from: self.
            ^wasHandled ].
    ^false!   
dragTargetLeave: dragSession
        "Private - the mouse left the bounds of the
        receiver during a drag drop transfer."
    self isDragTarget ifFalse: [ ^nil ].
    dragSession targetSelection: nil.
    self dragTargetStopScrollTimer.
    dragSession targetEraseEmphasis.
    self
        triggerEvent: #dragTargetLeave:
        withArguments: ( Array with: dragSession )
        ifNotHandled: [ self dragTargetLeaveDefault: dragSession ]! 
lockWindowUpdate: hwndLock
    <api: LockWindowUpdate ulong boolean>
    ^self invalidArgument! 
boundingBoxOfText: string at: displayPoint
        "Private - answer the bounding box in which the given <string> will be displayed
        if it is displayed at the <displayPoint> using the current state of the receiver."
    | textAlign heightAlign widthAlign stringWidth top bottom left right |
    textAlign := self getTextAlign.
    heightAlign := textAlign // 8 * 8.
    widthAlign := textAlign \\ 8.
    stringWidth := self stringWidthOf: string.

    heightAlign = TaTop ifTrue: [
        top := displayPoint y.
        bottom := top down: self font height ].
    heightAlign = TaBaseline ifTrue: [
        top := displayPoint y up: self font basePoint y.
        bottom := top down: self font height ].
    heightAlign = TaBottom ifTrue: [
        bottom := displayPoint y.
        top := bottom up: self font height ].

    widthAlign = TaLeft ifTrue: [
        left := displayPoint x.
        right := left right: stringWidth ].
    widthAlign = TaCenter ifTrue: [
        left := displayPoint x left: stringWidth // 2.
        right := left right: stringWidth ].
    widthAlign = TaRight ifTrue: [
        right := displayPoint x.
        left := right left: stringWidth ].

    ^left @ top rightBottom: right @ bottom!  
wmKeyup: wordInteger with: longInteger
        "Private - Process the key up message."
    | event |
	( event := KeyboardInputEvent fromWmKeyup: wordInteger with: longInteger ) isNil ifTrue: [ ^nil ].
	self sendInputEvent: #keyboardInput: with: event.
    ^nil!
threeStateNotify: titleString withText: messageString
        "Display a message box with titleString as its
         title and messageString as the content.  Display
         buttons labeled 'Yes', 'No', and 'Cancel'.
         Answer true, false, or nil."
    ^self new
        title: titleString;
        message: messageString;
        iconQuestion;
        yesNoCancel;
        open! 
titled: aString withText: aString2 style: mbConstants
        "Private - Open a message box with title aString and text aString2
         and style mbConstants (from OperatingSystemConstants).
         Answer an OperatingSystemConstant indicating the selection."
    ^self new
        title: aString;
        message: aString2;
        style: mbConstants;
        openPrivate!  
message: aString
        "Display a message box with aString as the content and
        'OK' for the choices."
    ^self new
        title: 'Information';
        message: aString;
        iconInformation;
        ok;
        open!   
notify: titleString withText: messageString
        "Display a message box with titleString as its
        title and messageString as the content and
        'OK' for the choices."
    ^self new
        title: titleString;
        message: messageString;
        iconExclamation;
        ok;
        open!
confirm: aString
        "Display a message box with aString as the title and
        'Yes' and 'No' for the choices.  Answer true if the
         selection is Yes, else false."
    ^self new
        title: 'Please Confirm';
        message: aString;
        iconQuestion;
        yesNo;
        open!
warning: aString
        "Display a warning message box with aString as the text."
    self notify: 'Warning' withText: aString!
iconHand
        "Specify a hand icon; same as iconStop"
    style := style | MbIconhand!   
message: aString
        "Set the message string to display to aString."
    message := aString!
defaultButton: anInteger
        "Set the initially selected (default) pushbutton to
        button # anInteger."
    | flags |
    anInteger = 1 ifTrue: [ flags := MbDefbutton1 ].
    anInteger = 2 ifTrue: [ flags := MbDefbutton2 ].
    anInteger = 3 ifTrue: [ flags := MbDefbutton3 ].
    style := style | flags! 
title: aString
        "Set the title of the receiver to aString."
    title := aString!
ok
        "Specify OK button."
    style := style | MbOk!  
iconQuestion
        "Specify a question mark icon."
    style := style | MbIconquestion!   
initialize
        "Private - initialize the receiver's state to default values."
    title := WindowLabelPrefix.
    style := 0!  
resultSymbol
        "Answer a symbol corresponding to the user selection;
        may be one of the following: #ok, #cancel, #yes, #no,
        #retry, #ignore, #abort."
    ^resultSymbol! 
yesNo
        "Specify Yes, No buttons."
    style := style | MbYesno!  
retryCancel
        "Specify Retry, Cancel buttons."
    style := style | MbRetrycancel!
applicationModal
        "Make the receiver application modal."
    style := style | MbApplmodal!   
okCancel
        "Specify OK, Cancel buttons."
    style := style | MbOkcancel! 
yesNoCancel
        "Specify Yes, No, Cancel buttons."
    style := style | MbYesnocancel!  
abortRetryIgnore
        "Specify Abort, Retry, Ignore buttons."
    style := style | MbAbortretryignore!   
iconAsterisk
        "Specify an asterisk icon; same as iconInformation."
    style := style | MbIconasterisk!  
systemModal
        "Make the receiver system modal."
    style := style | MbSystemmodal!   
iconExclamation
        "Specify an exclamation mark icon."
    style := style | MbIconexclamation! 
result
        "Answer the result for the selection made by the user; true
        is the result when the first pushbutton is selected, false
        is the result when the second pushbutton is selected, and
        nil is the result when the third pushbutton is selected."
    ^result!   
open
        "Display the receiver, and answer the result corresponding
        to the user selection."
    | hostResult |
    hostResult := self openPrivate.
    self getResult: hostResult.
    ^result! 
noDefaultStyle
        "Tell the receiver not to use its defaultStyle method
         as the basis for subsequent style settings (start
         from scratch)."
    self style: self basicStyle! 
setValue
        "Private - Set the state of the receiver on, off, or indeterminate."
    | arg |
    arg := value isNil
        ifTrue: [ 2 ]
        ifFalse: [ value asParameter ].
    UserLibrary
        sendMessage: handle
        msg: BmSetcheck
        wparam: arg
        lparam: 0!   
privateDisplayWith: aGraphicsTool
        "Private - display the receiver through aGraphicsTool."
    ( GDILibrary
        playMetaFile: aGraphicsTool handle
        with: hMetaFile )
            ifFalse: [ self osWarning ]! 
pointFromIndex: index
        "Private - Convert an index to
         (offset in line, line)."
    | result line x |
    result := UserLibrary
        sendMessageInt: handle
        msg: EmLinefromchar
        wparam: index
        lparam: 0.
    line := result + 1.
    result := UserLibrary
        sendMessageInt: handle
        msg: EmLineindex
        wparam: line - 1
        lparam: 0.
    x := index - result.
    ^x @ line!  
setPenForTracking
        "Private - Set the pen for tracking with the mouse."
    self pen
        setLineWidth: 1;
        setLineType: LineTypeDot;
        foreColor: Color white;
        backColor: Color black;
        setForegroundMode: MixRuleXor!  
setPeekCount: anInteger
        "Tell the Smalltalk virtual machine to look if there
         is any interrupt request after every anInteger number
         of Smalltalk message sends.  anInteger must be
         a SmallInteger. Default is 4096. -1 means never
     check the queue. 0 means reset count to its initial
         value. Always returns the previous initial value."
    <primitive: 146>!
insert: aString
        "Insert aString at current location replacing
        selection if present."
    self isHandleOk
        ifTrue: [
            UserLibrary
                sendMessage: handle
                msg: EmReplacesel
                wparam: 0
                lparamStruct: aString asParameter ]
        ifFalse: [ value := value, aString ]!
dragTargetEraseEmphasisDefault: dragSession
		"Private - erase the (last drawn) target emphasis for the receiver.
		By default, do nothing.  Reimplemented by subclasses."! 
fileMenu
        "Answer the standard File menu."
    | menu |
    menu := Menu new.
    menu
        title: '\uFile' replaceEscapeCharacters;
        appendItem: '\uNew' replaceEscapeCharacters selector: #newFile;
        appendItem: '\uOpen...\tCtrl+O' replaceEscapeCharacters selector: #openFile accelKey: $O accelBits: AfControl;
        appendItem: '\uSave\tAlt+S' replaceEscapeCharacters selector: #accept accelKey: $S accelBits: AfAlt;
        appendItem: 'Save \uAs...' replaceEscapeCharacters selector: #saveAs.
    ( Smalltalk includesKey: #MailMessage ) ifTrue: [ menu appendItem: 'Sen\ud' replaceEscapeCharacters selector: #sendFile ].
    menu
        appendSeparator;
        appendItem: '\uPrint...' replaceEscapeCharacters selector: #print;
        appendItem: 'Print Se\utup...' replaceEscapeCharacters selector: #printSetup;
        appendSeparator;
        appendItem: 'E\uxit	Alt+F4' replaceEscapeCharacters selector: #close accelKey: F4Key accelBits: AfAlt;
        yourself.
    ^menu! 
addFileMenu
        "Private - add the File menu to the menu bar."
    | menu |
    ( menu := self class fileMenu ) notNil ifTrue: [
        menu owner: window owner.
        ( window owner respondsTo: #newFile )
            ifFalse: [ menu disableItem: #newFile ].
        "( window owner respondsTo: #accept )
            ifFalse: [ menu disableItem: #accept ]."
        ( window owner respondsTo: #saveAs )
            ifFalse: [ menu disableItem: #saveAs ] ].
        window menuWindow addMenu: menu!   
addStandardRightMenus
        "Private - add any menus that should appear
         right-most in the menu bar."
    window helpManager notNil ifTrue: [ self addHelpMenu ]!
addApplicationMenus
        "Private - add the menus for the panes of the window
         <aWindow> to the menu bar <aMenuBar>."
    | menu |
    window allChildrenInBuildOrderDo: [ :each |
        ( menu := each menu ) notNil
            ifTrue: [ window menuWindow addMenu: menu ] ]!   
addEditMenu
        "Private - add Edit menu to the menu bar."
    | menu textPane |
    ( textPane := window searchForDefaultTextPane ) notNil ifTrue: [
        ( menu := self class editMenu ) notNil ifTrue: [
            menu allOwners: textPane.
            window menuWindow addMenu: menu ] ]!   
addStandardLeftMenus
        "Private - add the menus that are to be located
         on the menu bar before any application-specific
         menus (File & Edit)."
    self addFileMenu.
    self addEditMenu.!
frameRect: aDeviceContext in: aWinRectStruct brush: hBrush

    <api: FrameRect ulong struct ulong long>
    ^self invalidArgument!
blankRestFrom: anInteger
        "Private - Blank the bottom portion of the receiver
         medium starting from anInteger row."
    self blank: ( 0 @ anInteger corner:
        width @ height)!   
validate
        "Private - The host window for the receiver was
         just created or recreated."
    self font: ( self font notNil ifTrue: [ self font ] ifFalse: [ self defaultFont ] ).
    ^super validate!   
setScrollRanges
        "Private - Set the ranges for the horizontal and vertical
          scroll bars."
    | rangeRect minHorz maxHorz minVert maxVert |
    rangeRect := self scrollingRectangle
        insetBy: (self rectangle extent // 2).
    minHorz := rangeRect left.
    maxHorz := rangeRect right.
    minVert := rangeRect top.
    maxVert := rangeRect bottom.
    (self style bitAnd: WsHscroll) = 0
        ifTrue: [minHorz := maxHorz := 0].
    (self style bitAnd: WsVscroll) = 0
        ifTrue: [minVert := maxVert := 0].
    ( UserLibrary
        setScrollRange: self asParameter
        bar: SbHorz
        min: minHorz
        max: maxHorz
        redraw: false )
            ifFalse: [ ^self osError ].
    ( UserLibrary
        setScrollRange: self asParameter
        bar: SbVert
        min: minVert
        max: maxVert
        redraw: false )
            ifFalse: [ ^self osError ]!
getSelection
        "Private - Answer the selection."
    value := UserLibrary
        sendMessageInt: handle
        msg: self selectionMessage
        wparam: 0
        lparam: 0.
    value = self class listEnd  "LbErr, as unsigned quantity"
        ifTrue: [ ^value := nil ]
        ifFalse: [ ^value := value + 1 ]! 
getIconHeaderDIBits
        "Private - Get Device Independent Bitmap bits."
    | bitCount colorCount colors bitmapHeader bmapInfo size dibArchive |

    bitCount := bitmapInfo bitCount * bitmapInfo planes.

    ((bitmapInfo width ~= 32) or:
        [ (bitmapInfo height ~= 32) or:
            [ (bitCount ~= 4) ]]) ifTrue:[
            ^self error: 'Bitmap format not compatible with Icon'].

    size := ((bitmapInfo width * bitCount + 31) // 32 * 4) *
        bitmapInfo height.

    bitCount = 24
        ifTrue: [colorCount := 0]      "No color table for this format."
        ifFalse: [colorCount := (1 bitShift: bitCount) * 4].

    bitmapHeader := WinBitmapInfoHeader new.
    bitmapHeader
        biSize: 40;
        width: self width;
        height: self height;
        planes: 1;
        bitCount: bitCount;
        compression: BiRgb;
        sizeImage: size.
    colors := ByteArray new: colorCount.
    bmapInfo := bitmapHeader contents, colors.
    "Call getDIBits with nil to fill in the rest of bmapInfo."
    GDILibrary
        getDIBits: Display pen handle
        hBitmap: self handle
        startScan: 0
        scans: self height
        bits: nil
        bitsInfo: bmapInfo
        wUsage: DibRgbColors.
    "Call getDIBits with non nil to actually get the bits."
    dibArchive := ByteArray new: size.
    ( GDILibrary
        getDIBits: Display pen handle
        hBitmap: self handle
        startScan: 0
        scans: self height
        bitsStruct: dibArchive asParameter
        bitsInfo: bmapInfo
        wUsage: DibRgbColors ) = 0
            ifTrue: [ ^self osError ].

    bmapInfo at: 9 put: 64.
    bmapInfo at: 21 put: 128.
    ^bmapInfo, dibArchive!
from: aFileStream
    | header |
    header := self new.
    aFileStream getBytesFor: header contents.
    ^header!   
sizeInBytes
    ^22! 
key
    ^16r9AC6CDD7!
blank: aRectangle
        "Fill aRectangle with the current background color."
    self fill: aRectangle
        color: backColor! 
charUpperBuff: aString length: anInteger
    <api: CharUpperBuffA struct ulong ulongReturn>
    ^self invalidArgument!  
setForegroundColor
        "Private - The user selected Color/Foreground... from the Options
        menu; bring up a ColorDialog to select a color for the current window."
    | dialog paneWithFocus color |
    color := ( paneWithFocus := self subPaneWithFocus ) notNil
        ifTrue: [ paneWithFocus foreColor ]
        ifFalse: [ nil ].
    dialog := ColorDialog new
        color: color;
        open.
    color := dialog chosen.
    ( color notNil and: [ self foreColor ~= color ] ) ifTrue: [
        self foreColor: color.
        self allChildrenDo: [ :pane | pane foreColor: color ].
        self colorChange ]!
loadCursor: hInst name: anObject
    anObject isString
        ifTrue: [ ^self loadCursor: hInst nameString: anObject ]
        ifFalse: [ ^self loadCursor: hInst nameInteger: anObject ]!
basicStyle
        "Private - Answer an Integer with appropriate
         constants combination for basic subpane style."
    ^WsChild | WsVisible | WsClipsiblings!   
closeView
        "Private - close the receiver and all its children."
    self isHandleOk ifFalse: [ ^self ]. "already closed"
    self closeInnerWindows ifFalse: [ ^nil ].
    self helpManager notNil
        ifTrue: [ self helpManager closeHelpWindow ].
    self class toolTipInstalled ifTrue: [ self destroyToolTip ].
    handle hideWindow.
    menuWindow notNil ifTrue: [ menuWindow close ].
    self propertyAt: #sysMenu put: nil.
    super close.
    self subPaneWithFocus: nil.
    self icon notNil ifTrue: [ self icon release ].
    super initialize!   
dragTargetEmphasisTypesSupported
		"Private - answer a collection of emphasis types that the receiver can support."
	^#( 'pane' 'separator' )!  
clearGraphicsTool
        "Private - clear the graphics tool handle."
    graphicsTool notNil ifTrue: [ graphicsTool handle: nil ]! 
setBackMode: aMode
        "Set the receiver's background mode used with text,
          hatched brushes, or any pen style that is not a solid line.
          aMode can be Opaque or Transparent."
    self allHandles do: [ :h |
        ( GDILibrary setBkMode: h mode: aMode ) = 0
            ifTrue: [ ^self osError ] ]! 
wmTimer: wparam with: lparam
        "Private - process the timer message to implement
        continuous scrolling."
    wparam = self class leftButtonScrollTimerId ifTrue: [
        self
            sendMouseMoveInputEvent: #button1Move:
            with: self cursorWindowPosition ].
    ^super wmTimer: wparam with: lparam!
verticalScrollMinRange
        "Private - Answer the vertical scrollbar's min range"
    | minPos |
    ( UserLibrary
        getScrollRange: self handle asParameter
        bar: SbVert
        lpMinPos: ( minPos := ExternalLong new ) asParameter
        lpMaxPos: ExternalLong new asParameter )
            ifFalse: [ ^self osError ].
    ^minPos asInteger!   
sizeInBytes
    ^16! 
appendMenu: aMenuHandle
    flags: anInteger
    id: idInteger
    contentsStruct: aString
        "Private - Perform the Win AppendMenu function.  This
         api call only handles strings."
    <api: AppendMenuA ulong ulong ulong struct boolean>
    ^self invalidArgument!   
deleteAllItemsInComboBox: itemId
        "Delete all the items in the combo box whose id is itemId."
    self sendMessage: CbResetcontent item: itemId wparam: 0 lparam: 0! 
wmVScroll: aLongInteger with: aWordInteger
        "Private - Process the vertical scroll message."
    ^nil!   
integralHeight
        "Remove the no integral height style."
    ^self removeStyle: LbsNointegralheight!   
isDropDown
        "Answer true if the receiver is a drop down."
    ^self hasStyle: CbsDropdown!   
descender
        "Answer a positive Integer which is the
         maximum descender."
    ^self charSize y - self basePoint y!
black
        "Set the color of the receiver to black.
          Retained for compatibility."
    self foreColor: Color black! 
stop
        "Stop the receiver."
    ( UserLibrary killTimer: SystemWindow current handle idEvent: self id ) = 0
        ifTrue: [ ^self osError ].
    self class timers removeKey: self id ifAbsent: [ nil ].
    self id: nil!   
topLeftRatio: topLeft
bottomRightRatio: bottomRight
    "Answer an instance of the receiver describing a rectangle whose top-left corner is the <topLeft> percentage of the distance from the top-left corner of the reference rectangle to the bottom-right corner, and whose bottom-right corner is the <bottomRight> percentage of the same distance."

    | topLeftRatio bottomRightRatio |
    topLeftRatio := topLeft asPoint.
    bottomRightRatio := bottomRight asPoint.
    ^self
        new topRatio: topLeftRatio y;
        leftRatio: topLeftRatio x;
        bottomRatio: bottomRightRatio y;
        rightRatio: bottomRightRatio x! 
topRatio: top
leftRatio: left
bottomRatio: bottom
rightRatio: right
    "Answer an instance of the receiver describing a rectangle whose top, left, bottom and right edges are the cooresponding <top>, <left>, <bottom> and <right> percentages of the distance from the top-left corner of the reference rectangle to the bottom-right corner."

    ^self new
        topRatio: top;
        leftRatio: left;
        bottomRatio: bottom;
        rightRatio: right!
topLeftRatio: aPoint
    "Answer an instance of the receiver describing a rectangle whose bottom-right corner is the bottom-right corner of the reference rectangle and whose top-left corner is a fraction of the way to the top-left corner of the reference rectangle."

    | ratio |
    ratio := aPoint asPoint.
    ^self new
        topRatio: ratio y;
        leftRatio: ratio x!
top: top
left: left
bottom: bottom
right: right
    "Answer an instance of the receiver describing a rectangle with top, left, bottom, and right values given by  <top>, <left>, <bottom> and <right>.  This method is useful for defining the layout of a pane that has a fixed boundary."

    ^self new
        topInset: top;
        leftInset: left;
        bottomInset: bottom negated;
        rightInset: right negated!  
topInset: top
leftInset: left
bottomInset: bottom
rightInset: right
    "Answer an instance of the receiver describing a rectangle that is inset from the <top>, <left>, <bottom> and <right> edges of the reference rectangle by the corresponding amounts."

    ^self new
        topInset: top;
        leftInset: left;
        bottomInset: bottom;
        rightInset: right!
topLeftRatio: topLeftRatio
inset: topLeftInset
bottomRightRatio: bottomRightRatio
inset: bottomRightInset
    "Answer an instance of the receiver describing a rectangle whose top-left corner is the <topLeft> percentage of the distance from the top-left corner of the reference rectangle to the bottom-right corner, and whose bottom-right corner is the <bottomRight> percentage of the same distance, modified by inseting the corners by the number of pixels in topLeftInset and bottomRightInset."

    ^self
        ratio: (topLeftRatio asPoint rightBottom: bottomRightRatio asPoint)
        inset: (topLeftInset asPoint rightBottom: bottomRightInset asPoint)!
ratio: aRatioRectangle
inset: anInsetRectangle
    "Answer a LayoutFrame that, when sent the message
        relativeTo: aRectangle
    answers the result of computing
        (aRectangle scaleBy: <aRatioRectangle>) insetBy: <anInsetRectangle>"

    | topLeft bottomRight layout |
    aRatioRectangle isRectangle
        ifTrue:
            [topLeft := aRatioRectangle leftTop.
            bottomRight := aRatioRectangle rightBottom]
        ifFalse:
            [topLeft := bottomRight := aRatioRectangle asPoint].
    layout := self new.
    layout
        topRatio: topLeft y;
        leftRatio: topLeft x;
        bottomRatio: bottomRight y;
        rightRatio: bottomRight x.
    anInsetRectangle isRectangle
        ifTrue:
            [topLeft := anInsetRectangle leftTop.
            bottomRight := anInsetRectangle rightBottom]
        ifFalse:
            [topLeft := bottomRight := anInsetRectangle asPoint].
    layout
        topInset: topLeft y;
        leftInset: topLeft x;
        bottomInset: bottomRight y;
        rightInset: bottomRight x.
    ^layout!  
bottomRightRatio: aPoint
    "Answer an instance of the receiver describing a rectangle whose top-left corner is the top-left corner of the reference rectangle and whose bottom-right corner is a fraction of the way to the bottom-right corner of the reference rectangle."

    | ratio |
    ratio := aPoint asPoint.
    ^self new
        bottomRatio: ratio y;
        rightRatio: ratio x!
listFont: aFont
        "Private - Set the font to aFont"
    self font: aFont.
    super listFont: aFont! 
printSelector: aSymbol
        "Set the selector which is sent to the items in list
        to format for display in the control; if none is set, non-String
        objects are sent #printString."
    ^self propertyAt: #printSelector put: aSymbol!   
deselect
        "Deselect the current selection."
    self hasSelection ifTrue: [
        self
            clearSelection;
            triggerChanged ]!
notifyDoubleClicked: aParameter
		"Private - the host signaled that the receiver was double-clicked."
    self event: #doubleClickSelect.
    self triggerEvent: #doubleClicked: with: self selectedItem!  
valueIndex: itemIndex
        "Set the selection in the receiver's list to the item at itemIndex."
    itemIndex isNil
        ifTrue: [ ^self clearSelection ].
    self selectIndex: itemIndex! 
drawHighlight: aDrawStruct
        "Private - Highlight the item to be drawn."
    self triggerEvent: #drawSelection:
        withArguments: ( Array with: self drawIndex )
        ifNotHandled: [ super drawHighlight: aDrawStruct ]!   
bitmaps
        "Answer the list of bitmaps for owner drawing."
    ^self propertyAt: #bitmaps! 
valueIndex
        "Answer the index of the selected item in the list."
    ^self selectedIndex!
value: anItem
        "Set the selection in the receiver's list to anItem."
    anItem isNil
        ifTrue: [ ^self clearSelection ].
    self selectItem: anItem!   
selectedIndex
        "Answer the index of the selected item."
    ^self selection! 
listAttribute: anArray
        "Private - set the list in the receiver without
        attempting to update the pane."
    list := anArray!
selectedItem
        "Answer the item selected in the listbox."
    | index |
    ^( index := self selection ) isNil
        ifTrue: [ nil ]
        ifFalse: [ list at: index ]!
isOkToChange
        "Private - answer whether it is OK to change the selection."
    ^( self hasActionForEvent: #aboutToChange )
        ifTrue: [ super isOkToChange ]
        ifFalse: [ self commitSelection ]!   
contents: aCollection
        "Set the receiver's contents to aCollection."
    list := aCollection.
    self isHandleOk ifTrue: [
        self disableRedraw;
            deleteAllFromControl;
            insertArray: list;
            updateHorizontalExtent;
            enableRedraw ].
     ^list!  
deleteItem: anItem
        "Delete anItem from the receiver's list."
    | index |
    ( index := self indexOf: anItem ) isNil ifTrue: [ ^nil ].
    self deleteIndex: index! 
scrollVerticalCharacters: anInteger
        "Private - Scroll the pane up by anInteger
         number of characters (if positive) or down by
         the absolute value of anInteger (if negative)."
    self setTopIndex: ( self getTopIndex - anInteger min: list size )
!   
setValue: anItem
        "Set the selection in the receiver's list to anItem.
        Trigger changed event if the selection has changed.
        Answer anItem."
    self setValueIndex: ( anItem isNil
        ifTrue: [ nil ]
        ifFalse: [ self indexOf: anItem ] ).
    ^anItem! 
lineAt: index
        "Answer the line at index"
    ^list at: index!   
font: aFont
        "Set the font for the receiver to aFont."
    | font |
    ( self isOwnerDrawn not or: [ height isNil ] ) ifTrue: [
        font := aFont.
        aFont isNil ifTrue: [ font := self defaultFont ].
        self itemHeight: font height ].
    super font: aFont!
lineToRect: anInteger
        "Private - Answer a Rectangle that surrounds the
         item in the list indexed by anInteger."
    | rect |
    rect := self drawingRectangle.
    ^Rectangle
        leftTop: ( rect leftTop down: ( ( anInteger - self getTopIndex ) * self itemHeight ) )
        extent: rect width @ self itemHeight
!  
insertArray: aCollection
        "Private - Insert aCollection into control window."
    [ aCollection size > 0 ifTrue: [
        aCollection do: [ :each |
			self insertItemInControl: each ] ] ] on: Warning do: [ :e | e defaultAction. ^self ]!  
list: anArray
        "Set the list in the receiver."
    self contents: anArray!   
selection: anObject
        "Display the list with the line indicated by anObject selected.
        anObject is either the index into the list or a string
        with which to search the list."
    list isNil ifTrue: [
        self event: #getContents.
        self triggerEvent: #needsContents ].
    self selectItem: anObject!  
restoreWithRefresh: anObject
        "Refresh the list from the owner
         and keep the line containing
         anObject visible and selected."
    self restoreSelected: anObject!  
selectItem: anObject
        "Private - Select the item anObject. anObject can
        be an index or a string."
    anObject isInteger
        ifTrue: [ self selectIndex: anObject ]
        ifFalse: [ self selectIndex: ( self indexOf: anObject ) ]!
setList: aCollection
        "Set the receiver's list to aCollection.  Answer aCollection."
    | newList |
    newList := aCollection isString
        ifTrue: [ Array with: aCollection]
        ifFalse: [
            aCollection isNil
                ifTrue: [ Array new ]
                ifFalse: [
                    aCollection isIndexedCollection
                        ifTrue: [ aCollection ]
                        ifFalse: [ Array with: aCollection asString ] ] ].
    self list: newList.
    ^aCollection!
isIndexValid: itemIndex
        "Private - answer whether itemIndex is a valid index."
    ^itemIndex notNil and: [ self isIndexInList: itemIndex ]!
defaultMeasureControl: aMeasureItemStruct
        "Private - Set the size of the requested drawn item."
    self itemSize: 0 @ self itemHeight  "width ignored for list boxes"! 
restoreSelected
        "Refresh the list from the owner
         and keep the old selection. "
    | index topIndex |
    index := self selection.
    topIndex := self getTopIndex.
    self
        disableRedraw;
        event: #getContents;
        triggerEvent: #needsContents;
        setTopIndex: topIndex;
        selectIndex: index;
        enableRedraw;
        invalidateRect: self rectangle!
hasSelection
        "Private - answer whether the receiver has anything selected."
    ^self selection notNil! 
itemHeight
        "Answer the height of a list item."
    | aFont |
    height isNil ifTrue: [
        aFont := self font notNil
            ifTrue: [ self font ]
            ifFalse: [
                parent isDialogTopPane
                    ifTrue: [ Font systemFont ]
                    ifFalse: [ self defaultFont ] ].
        height := aFont height ].
    ^height!  
getValue
        "Private - Answer the selection."
    ^self getSelection!  
itemIndexFromPoint: aPoint
        "Answer the index of the element under aPoint
		(where aPoint is relative to the receiver window)."
	| top index offsetFromTop |
	offsetFromTop := ( self drawingRectangle top - aPoint y ) abs.
    top := self getTopIndex.
    index := top + ( offsetFromTop // self itemHeight ).
	^index! 
printSelector
        "Answer the selector which is sent to the items in list
        to format for display in the control; default = #printString."
    ^self propertyAt: #printSelector! 
drawItem: aDrawStruct
        "Private - Draw the requested control item."
    | answer |
    ( self handlesEvent: #drawItem )
        ifTrue: [   " preserve semantics of old event system "
            ( answer := self event: #drawItem ) notNil
                ifTrue: [ ^self ].  " drawn by handler "
            ]
        ifFalse: [  " new event system "
            ( self hasActionForEvent: #drawItem: )
                ifTrue: [ ^self triggerEvent: #drawItem: with: self drawIndex ]
        ].    " default drawing "
    self defaultDrawItem: aDrawStruct!  
setInitialContents
        "Private - set the receiver's contents and selection."
    self contents: list.
    value notNil ifTrue: [ self setSelection ]! 
list
        "Answer the list in the receiver."
    ^self contents! 
bitmaps: aCollection
        "Set the list of bitmaps for owner drawing to aCollection."
    self propertyAt: #bitmaps put: aCollection!
stringForItem: item
        "Private - Answer a string for the given item (which may be
        either a string or some other object which is converted to
        a string using the current printSelector)."
    | printSelector |
    ^( printSelector := self printSelector ) isNil
        ifTrue: [ item asString ]
        ifFalse: [ printSelector evaluateFor: item ]!
indexOf: aString
        "Answer the index of the item aString."
    list isNil ifTrue: [ ^nil ].
    ^list indexOf: aString ifAbsent: [ nil ]!
contents
        "Answer the list contents of the receiver."
    ^list! 
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process cursor keys."
    | virtualKey |
    virtualKey := aKeyboardInputEvent virtualKey.
    virtualKey == LeftKey
        ifTrue: [ ( self tabScope previousInGroup: self ) setFocus ].
    virtualKey = RightKey
        ifTrue: [ ( self tabScope nextInGroup: self ) setFocus ].
    ( virtualKey == TabKey or: [ virtualKey = BacktabKey ] ) ifTrue: [ self tabKeyInput: aKeyboardInputEvent ].
    ^super keyboardInput: aKeyboardInputEvent!
value
        "Answer the selected item in the list."
    ^self selectedItem!   
characterTyped
        "Private - Answer the character just typed."
    ^self propertyAt: #characterTyped!  
isIndexInList: itemIndex
        "Private - answer whether itemIndex is a valid index."
    ^itemIndex > 0 and: [ itemIndex <= list size ]! 
listAttribute
        "Private - answer the receiver's list attribute."
    ^list!  
triggerChanged
        "Private - trigger the changed: event."
    self triggerEvent: #changed: with: self value.
    self triggerEvent: #changedIndex: with: self selectedIndex!  
restore
        "Refresh the list from the owner
         and maintain the position in the list
         without selecting it."
    | topIndex |
    topIndex := self getTopIndex.
    self event: #getContents.
    self triggerEvent: #needsContents.
    self setTopIndex: topIndex!   
characterInput: aCharacter
        "Private - Process the character input message."
    ( ( self hasActionForEvent: #characterTyped: ) or: [ self handlesEvent: #charInput ] )
        ifTrue: [
            self propertyAt: #characterTyped put: aCharacter.
            self event: #charInput.
            self triggerEvent: #characterTyped: with: aCharacter ]!  
itemHeight: anInteger
        "Set the height of a list item; only has an effect
        before the receiver window is opened."
    height := anInteger!   
drawBitmap: aBitmap for: anItem
        "Draw aBitmap rather than displaying
         the text of anItem.  anItem can be either
         the index or the string of the item."
    | bitmaps |
    ( bitmaps := self bitmaps ) isNil
        ifTrue: [ self bitmaps: ( bitmaps := Dictionary new ) ].
    anItem isInteger
        ifTrue: [ bitmaps at: anItem put: aBitmap ]
        ifFalse: [ bitmaps at: ( self indexOf: anItem ) put: aBitmap ]!   
selectIndex: itemIndex
        "Select the item at itemIndex. Index starts at 1."
    value := itemIndex.
    self isHandleOk ifFalse: [ ^self ].
    self setSelection!  
setValueIndex: itemIndex
        "Set the selection in the receiver's list to the item at itemIndex.
        Trigger changed event if the selection has changed.
        Answer itemIndex."
    | previousSelection anItemIndex |
    anItemIndex := itemIndex notNil
        ifTrue: [ itemIndex asInteger ]
        ifFalse: [ nil ].
    ( anItemIndex notNil
    and: [ ( self isIndexInList: anItemIndex ) not ] )
        ifTrue: [ ^nil ].  " do nothing for out-of-range index "
    previousSelection := self selectedIndex.
    self valueIndex: anItemIndex.
    self selectedIndex ~= previousSelection
        ifTrue: [ self triggerChanged ].
    ^anItemIndex! 
insertItem: item at: index
        "Insert the given item into the list (and the host control)
		at the given position."
    list := list isNil
        ifTrue: [ Array with: item ]
        ifFalse: [
			index > self contents size
				ifTrue: [ list copyWith: item ]
				ifFalse: [ ( list copyFrom: 1 to: index - 1 ), ( Array with: item ), ( list copyFrom: index to: list size ) ] ].
    self isHandleOk
        ifTrue: [ self insertItemInControl: item at: ( ( index = self contents size ) ifTrue: [ self class listEnd ] ifFalse: [ index - 1 ] ) ]! 
commitSelection
        "Private - Answer true if list box should
        commit to selection request."
    ^[ owner commitSelection: self ]
        on: MessageNotUnderstood
        do: [ :e | self mainWindow textModified not ]! 
insertItem: aString
        "Append an item containing aString to the receiver's list."
    list := ( list isNil
        ifTrue: [ Array with: aString ]
        ifFalse: [ list copyWith: aString ] ).
    self isHandleOk
        ifTrue: [ self insertItemInControl: aString ]!  
selection
        "Answer the selection as a one based index."
    self isHandleOk ifTrue: [ ^self getSelection ].
    ^value! 
deleteAll
        "Delete the whole list."
    | hasSelection |
    hasSelection := self hasSelection.
    list := Array new.
    value := nil.
    self isHandleOk ifTrue: [
        self deleteAllFromControl ].
    hasSelection
        ifTrue: [ self triggerChanged ]! 
isIndexSelected: itemIndex
        "Private - answer whether itemIndex is selected."
    ^itemIndex = self selectedIndex!   
restoreSelected: anObject
        "Private - Restore the contents and select anObject.
         Retained for compatibility."
    | topIndex |
    topIndex := self getTopIndex.
    self
        disableRedraw;
        event: #getContents;
        triggerEvent: #needsContents;
        setTopIndex: topIndex;
        selection: anObject;
        enableRedraw;
        invalidateRect: self rectangle!  
owner: anOwner
        "Sets the owner of the Dialog box."
    super owner: anOwner.
    owner isWindow
        ifTrue: [ parent := owner ]
        ifFalse: [ parent := owner mainView.
                       parent isWindow ifFalse: [
                            parent := Notifier findWindow: WindowHandle queryActive ]].
    chooseFontStruct hwndOwner: parent asParameter.!   
list
    "Private"
    "Answer the list of items from which the user can choose."

    ^list! 
pressedCancel
    "The user has clicked on the Cancel button. Close the receiver without making a selection."

    self close! 
selection
    "Answer the item that was selected."

    ^selection!
selection: listItem
    "Private"
    "Set the selected item to the given <listItem>."

    selection := listItem!
setList: listPane
    "Set the contents of the given <listPane> to the list of choices available for selection."

    listPane contents: self list.
    listPane selection: self currentSelection!
setSelection: listItem
    "The user has clicked on the given <listItem>."

    self currentSelection: listItem!   
pressedOK
    "The user has clicked on the OK button. Make the current selection be the user's choice."

    self selection: self currentSelection.
    self close!   
initialize
    "Private"
    "Initialize the receiver."

    super initialize.
    self list: #().
    self label: ''.
    ^self!  
doubleClickSelection: listItem
    "The user has double-clicked on the given <listItem>. Close the receiver with that item being the selected item."

    self selection: listItem.
    self close!   
windowSize: listPane
    "Private"
    "Compute the overall window size based on the contents and font of the given <listPane>."

    | font scrollBarWidth minimumScrollBarHeight listWidth listHeight |
    font := listPane font.
    scrollBarWidth := 16.                                "This is a guess."
    minimumScrollBarHeight := 16 * 3.        "This is a guess."
    listWidth := font stringWidth: self label.
    self list
        do:
            [:each |
            listWidth := listWidth max: (font stringWidth: (listPane stringForItem: each))].
    listWidth := listWidth + scrollBarWidth + (self class borderWidth * 2).
    listHeight := (self list size min: self class maxItemsToShow) * font height + (self class borderWidth * 2)
            max: minimumScrollBarHeight.
    ^(self class computeWindowWidthFromPaneWidth: listWidth)
            @ (self class computeWindowHeightFromPaneHeight: listHeight)!   
label
    "Private"
    "Answer the message text used to describe to the user what is being chosen."

    ^label! 
label: messageText
    "Private"
    "Set the message text used to describe to the user what is being chosen to the given <messageText>."

    label := messageText!  
currentSelection: listItem
    "Private"
    "Set the item currently selected in the list to the given <listItem>."

    currentSelection := listItem!
list: itemList
    "Private"
    "Set the list of items from which the user can choose to the items contained in the <itemList>."

    list := itemList!  
currentSelection
    "Private"
    "Answer the item currently selected in the list."

    ^currentSelection!  
close
    "Close the views connected to the receiver.
    Queue the generation of the #closeApplication event until
    all current processing has unwound by posting it on
    the Notifier's input event queue."
    Notifier postInputEvent:
        (Message
            receiver: self
            selector: #triggerEvent:
            arguments: #(#closeApplication))!   
addDependent: anObject interestIn: anAspect
    "Add a dependent <anObject> that receives an update event when the event named <anAspect> is triggered."

    self
        when: anAspect
        send: #update
        to: anObject!   
eventTable
    "Private"
    "Answer a Dictionary mapping event names to actions
    for the receiver."

    ^handlers == nil
        ifTrue: [self eventTableCreate]
        ifFalse: [handlers]! 
eventTableForEdit
    "Private"
    "Answer a Dictionary mapping event names to actions,
    allocate it if necessary."

    handlers == nil
        ifTrue: [handlers := self eventTableCreate].
    ^handlers!   
initialState: anObject
    "Set the initial state of the receiver to <anObject>. The
    argument <anObject> is the parameter to the #openOn: message
    sent to the class."! 
initMenu
        "Private - Initialize the menu."
    ^nil! 
releaseEventTable
    "Private"
    "Break all connections to event handlers."

    handlers := nil!  
createAcceleratorTable: accelArray size: nEntries
    <api: CreateAcceleratorTableA struct ulong ulongReturn>
    ^self invalidArgument!
constructNotifications
        "Private - answer the mapping between host control
        notification codes and corresponding Smalltalk event
        notifications."
    ^Dictionary new
        at: CbnSelchange put: #notifySelected: ;
        at: CbnDblclk put: #notifyDoubleClicked: ;
        at: CbnDropdown put: #notifyListVisible: ;
        yourself!   
deleteItem: aMenuItem
        "Private - Remove aMenuItem from the receiver."
    ( UserLibrary
        deleteMenu: self handle
        position:  aMenuItem id
        flag: MfBycommand )
            ifFalse: [ ^self osError ]! 
wmSize: wordInteger with: longInteger
        "Private - Process the window resizing message."
    "do nothing if being minimized"
    wordInteger = Sizeiconic ifTrue: [ ^nil ].
    ^super wmSize: wordInteger with: longInteger!   
getNextChildId
        "Private - Answer the next available id (slot) in the children dictionary."
    | size |
    size := children size.
    "Note: Windows attaches special significance to id = 1, 2, so start at a higher value."
    ( children includesKey: size + 101 ) ifFalse: [ ^size + 101 ].
    101 to: size + 101 do: [ :i |
        children at: i  ifAbsent: [ ^i ] ]!
disableNoScroll
        "Add the disable no scroll style."
    ^self addStyle: CbsDisablenoscroll!  
dragTargetEmphasisDefault
		"Set the type of target emphasis to be employed to
		be the default."
	self dragTargetEmphasis: nil!   
layoutList
	"Private"
	"Answer the list of layouts that have been composed by the receiver."

	layoutList == nil
		ifTrue: [^Array new].
	^layoutList!  
layoutList: arrayOfLayouts
	"Private"
	"Set the layouts composed by the receiver to those in the <arrayOfLayouts>."

	layoutList := arrayOfLayouts!   
relativeTo: referenceRectangle
	"Answer the rectangle described by the receiver relative to the <referenceRectangle>."

	^self layoutList
		inject: referenceRectangle
		into:
			[:rectangle :layout |
			layout relativeTo: rectangle]!  
composedWith: layoutUnit
	"Answer the result of composing the receiver with the given <layoutUnit>."

	self layoutList: (self layoutList copyWith: layoutUnit)!
value: referenceRectangle
    "Answer the rectangle described by the receiver relative to the <referenceRectangle>."
    "Context polymorphism"

    ^self relativeTo: referenceRectangle!
, layoutUnit
	"Answer the result of composing the receiver with the given <layoutUnit>."

	^self composedWith: layoutUnit! 
asLayout
    "Answer a layout equivalent to the receiver."

    ^self! 
relativeTo: referenceRectangle
    "Answer the rectangle described by the receiver relative to the <referenceRectangle>."

    self implementedBySubclass! 
composedWith: layoutUnit
	"Answer the result of composing the receiver with the given <layoutUnit>."

	^CompositeLayout composing: self with: layoutUnit!  
hasFormat: typeNameString
        "Answer whether the receiver can provide data
		in the given format."
    ^self formats includesKey: typeNameString! 
format: formatTypeString data: formatData
        "Set the data for the given format to formatData."
    self formats at: formatTypeString put: formatData! 
format: formatTypeString ifAbsent: aBlock
        "Answer data of the given format, or answer
		the result of evaluating aBlock if no such format
		is available."
    ^self formats at: formatTypeString ifAbsent: aBlock!   
formats
        "Private - answer the Dictionary of formats & data."
    ^formats!  
formats: aDictionary
		"Private - set the Dictionary of formats and data to aDictionary."
    formats := aDictionary!   
initialize
		"Private - initialize the receiver."
    self formats: Dictionary new! 
availableFormats
        "Answer an ordered collection of strings identifying
        the formats available in the receiver."
    ^self formats keys!  
format: formatTypeString
        "Answer data in the specified format, or signal
        an error if no such format is available."
    ^self formats at: formatTypeString! 
bitmap
        "Answer a bitmap representation of the receiver,
        or signal an error if no such format is available."
    ^self format: 'bitmap'!
object: anObject
        "Add anObject to the receiver's data formats."
    self format: 'object' data: anObject!   
hasFormat: typeNameString
        "Answer whether the receiver can provide data in the
		given format; redefined by subclasses."
    self implementedBySubclass!   
metafile: aMetafile
        "Add aMetafile to the receiver's data formats."
    self format: 'metafile' data: aMetafile!
format: formatTypeString data: formatData
        "Set the data for the given format to formatData;
		redefined by subclasses."
    self implementedBySubclass!
object
        "Answer an object representation of the receiver,
        or signal an error if no such format is available."
    ^self format: 'object'!   
hasMetafile
        "Answer whether a metafile representation is available."
    ^self hasFormat: 'metafile'!   
hasString
        "Answer whether a string representation is available."
    ^self hasFormat: 'string'! 
format: formatTypeString ifAbsent: aBlock
        "Answer data of the given format, or answer
		the result of evaluating aBlock if no such format
		is available; redefined by subclasses"
    self implementedBySubclass!
objectIfAbsent: aBlock
        "Answer an object representation of the receiver,
        or answer the result of evaluating aBlock if no such
		format is available."
    ^self format: 'object' ifAbsent: aBlock!
hasBitmap
        "Answer whether a bitmap representation is available."
    ^self hasFormat: 'bitmap'! 
stringIfAbsent: aBlock
        "Answer a string representation of the receiver,
        or answer the result of evaluating aBlock if no such
		format is available."
    ^self format: 'string' ifAbsent: aBlock! 
hasObject
        "Answer whether an object representation is available."
    ^self hasFormat: 'object'!
availableFormats
        "Answer an ordered collection of strings identifying
        the formats available in the receiver; redefined by
		subclasses."
    self implementedBySubclass!  
metafile
        "Answer a metafile representation of the receiver,
        or signal an error if no such format is available."
    ^self format: 'metafile'!  
metafileIfAbsent: aBlock
        "Answer a metafile representation of the receiver,
        or answer the result of evaluating aBlock if no such
		format is available."
    ^self format: 'metafile' ifAbsent: aBlock!   
bitmap: aBitmap
        "Add aBitmap to the receiver's data formats."
    self format: 'bitmap' data: aBitmap!  
string: aString
        "Add aString to the receiver's data formats."
    ^self format: 'string' data: aString! 
bitmapIfAbsent: aBlock
        "Answer a bitmap representation of the receiver,
        or answer the result of evaluating aBlock if no such
		format is available."
    ^self format: 'bitmap' ifAbsent: aBlock! 
format: formatTypeString
        "Answer data in the specified format, or signal
        an error if no such format is available; redefined
		by subclasses."
    self implementedBySubclass! 
string
        "Answer a string representation of the receiver,
        or signal an error if no such format is available."
    ^self format: 'string'!
release
        "Free the resource associated with the receiver."
    ( handle notNil and: [ handle ~= NullHandle ] ) ifTrue: [
        ( UserLibrary destroyCursor: handle )
            ifFalse: [ ^self osError ] ].
    handle := nil!   
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        remove: #entered: ;
        yourself!  
selectAtEnd
        "Place the gap selection at
         the end of the text."
     | end |
    end := self getTextLength.
    self selectAfter: end!
formatRect
        "Answer the formatting rectangle."
    ^self propertyAt: #formatRect!
selectBefore: position
		"Move the caret to the position before the given character
		position, which may be either a Point (character in line, line)
		or an Integer."
    selection := position isPoint
        ifTrue: [ ( self pointToIndex: position ) @ ( ( self pointToIndex: position ) - 1 ) ]
		ifFalse: [ position @ ( position - 1 ) ].
	self setSelection!
selectIndexFrom: start to: end
        "Private - Set text selection for the receiver where start
        and end are zero-based byte positions."
	selection := ( start + 1 ) @ end.
    self isHandleOk
        ifTrue: [ self setSelection ]
        ifFalse: [
            self
                whenValid: #selectIndexFrom:to:
                withArguments: ( Array with: start with: end ) ]! 
initialize
        "Private - Set the default state for a multi line text control."
    super initialize.
    self wrap: false!
isWordWrapEnabled
        "Answer whether the receiver has word wrap enabled."
    ^self wrap!  
defaultTabStopInterval
        "Private - answer the default tab stop size."
    ^nil!  
disableWordWrap
        "Disable word wrap in the receiver."
    self wrap: false!  
update
        "Refresh the text from the
         owner and display it."
    super update.
	self selectBefore: 1.
    self isHandleOk ifTrue: [ self setSelection ]!
wrap
        "Answer the value of the word-wrap attribute."
    ^wrap!  
enableWordWrap
        "Enable word wrap in the receiver."
    self wrap: true! 
textChanged
        "Private - handle the changing of text contents."
    self isReadOnly ifFalse: [ value := nil ].
    super textChanged!
formatRect: aRectangle
        "Set the formatting rectangle to aRectangle."
    self propertyAt: #formatRect put: aRectangle!  
notifyVertScroll: aParameter
		"Private - the host signaled that the receiver has been scrolled vertically."
    self event: #vertScroll!   
tabStopInterval
        "Answer tabInterval in number of pels."
    ^self propertyAt: #tabStop! 
tabStopInterval: tabInterval
        "Set tabstops to tabInterval number of pels."
    self propertyAt: #tabStop put: tabInterval.
    self isHandleOk
        ifTrue: [ self setTabStop ]
        ifFalse: [ self whenValid: #setTabStop ]! 
maxTextWidth: aWidth
        "Set the maximum width to be allowed for edited text."
    | rect |
    ( rect := self formatRect ) isNil
        ifTrue: [ self formatRect: ( rect := 0@0 extent: 0@0 ) ].
    rect width: aWidth.
    self isHandleOk
        ifTrue: [ self setFormatRect ]
        ifFalse: [ self whenValid: #setFormatRect ]!  
selectAfter: position
		"Move the caret to the position after the given character
		position, which may be either a Point (character in line, line)
		or an Integer."
    selection := position isPoint
        ifTrue: [ ( ( self pointToIndex: position ) + 1 ) @ ( self pointToIndex: position ) ]
		ifFalse: [ ( position + 1 ) @ position ].
	self setSelection!  
notifyLosingFocus: aParameter
		"Private - the host signaled that the receiver has lost the focus."
    self getSelection!  
deleteAll
        "Delete all of the text in the control."
	self selectBefore: 1.
    value := nil.
    self isHandleOk ifTrue: [ self deleteText ]!  
notifyHorizScroll: aParameter
		"Private - the host signaled that the receiver has been scrolled horizontally."
    self event: #horizScroll!   
maxTextHeight: aHeight
        "Set the maximum height to be allowed for edited text."
    | rect |
    ( rect := self formatRect ) isNil
        ifTrue: [ self formatRect: ( rect := Rectangle new ) ].
    rect height: aHeight.
    self isHandleOk
        ifTrue: [ self setFormatRect ]
        ifFalse: [ self whenValid: #setFormatRect ]!   
setTabStop
        "Private - Set the tabstop in the host control."
    | dlgUnits dlgUnitSize struct tabInterval |
    ( tabInterval := self tabStopInterval ) isNil
        ifTrue: [ tabInterval := self defaultTabStopInterval ].
    ( ( self isHandleOk and: [ tabInterval notNil ] ) and: [ tabInterval > 0 ] ) ifTrue: [
        dlgUnitSize := UserLibrary getDialogBaseUnits lowWord // 4.  "width in low word of DWORD"
        dlgUnits := tabInterval // dlgUnitSize.
        ( struct := ExternalBuffer new: 4 ) uShortAtOffset: 0 put: dlgUnits.
        UserLibrary
            sendMessage: handle
            msg: EmSettabstops
            wparam: 1
            lparamStruct: struct asParameter ]! 
isColorBitmap
        "Answer true if the receiver is a color bitmap."
    ^(self isMonoBitmap not)!
isActive
        "Answer true if the receiver's main window
         is the currently active window."
     ^UserLibrary getActiveWindow = self mainWindow handle asInteger!
disableUpdate
        "Disable update of the receiver window."
    UserLibrary lockWindowUpdate: self asParameter!  
hDCPrinter
        "Answers the Printer's hDC"
    ^hDCPrinter! 
scrollVertically
    "Add a vertical scroll bar to the receiver."

    self addVerticalScrollbarStyle! 
cutSelection
        "Cut the selection into the Clipboard"
     UserLibrary
        sendMessage: handle
        msg: WmCut
        wparam: 0
        lparam: 0!
add: aString toComboBox: itemId at: anInteger
        "Add aString at anInteger to the combo box whose
         id is itemId.  anInteger is either the zero-based
         index of the new item or a constant beginning
         with 'Lit' from the OperatingSystemConstants pool dictionary."
    self sendMessage: CbInsertstring item: itemId wparam: anInteger lparamStruct: aString asParameter!  
updateRectangle
        "Private - Update rectangle to be the same
         as that maintained by the host window."
    super updateRectangle.
    self setScale! 
button1Move: aPoint
        "Private - button 1 is down and the
        mouse has been moved.
        Let the owner process the event."
    self isDragSource ifTrue: [ ^super button1Move: aPoint ].
    handle = WindowHandle queryCapture ifFalse: [ ^self ].
    mouse := aPoint.
    self event: #button1Move.
    self triggerEvent: #button1Moved! 
destroyIcon: aHandle
    <api: DestroyIcon ulong boolean>
    ^self invalidArgument!
setString: aString
        "Set the contents of the clipboard to aString."
    | hMem |
    aString isNil ifTrue: [ ^nil ].
    self open ifFalse: [ ^nil ].
    hMem := ExternalGlobalAddress memoryHandleFrom: aString asParameter.
    ( UserLibrary setClipboardData: CfText hMem: hMem ) = 0
        ifTrue: [ ^self osError ].
    self close!  
default
        "Answer the default Printer, or nil if none."
    | defaultName |
    ^( defaultName := self defaultPrinterName ) isNil
        ifTrue: [ nil ]
        ifFalse: [ self named: defaultName ]
    !  
dragTargetDoScroll
		"Private - implement drag scrolling."
    self implementedBySubclass!  
drawIndex
        "Answer the index of the item to be drawn."
    ^self ownerDrawStruct itemData!   
wmMousemove: wParam with: lParam
        "Private - Process mouse move message."
    | point |
    self class toolTipInstalled
        ifTrue: [ self relay: WmMousemove wparam: wParam lparam: lParam ].
    point := Point fromInteger: lParam.
    ( wParam bitAnd: MkLbutton ) ~= 0 ifTrue: [
        self sendMouseMoveInputEvent: #button1Move: with: point.
        ^nil ].
    ( wParam bitAnd: MkRbutton ) ~= 0 ifTrue: [
        self sendMouseMoveInputEvent: #button2Move: with: point.
        ^nil ].
    self sendMouseMoveInputEvent: #mouseMove: with: point.
    ^nil! 
scrollBoth
    "Add horizontal and vertical scroll bars to the receiver."

    self addHorizontalScrollbarStyle; addVerticalScrollbarStyle!
asColor
        "Answer a Color created from the receiver."
    ^self asIndexedColor!   
startUp
        "Private - Initialize class variables."
    | dc |
    StockObjects := Set new.
    DefaultObjects := Dictionary new.
    ( dc := GDILibrary
        createDC: 'Display' asParameter
        deviceName: nil
        output: nil
        initData: nil ) = 0
            ifTrue: [ ^self osError ].
    DefaultObjects
        at: 'Brush' put:
            (GDILibrary
                    selectObject: dc
                    with: (self getStockObject: WhiteBrush));
        at: 'Pen' put:
            (GDILibrary
                    selectObject: dc
                    with: (self getStockObject: BlackPen));
        at: 'Bitmap' put: (Bitmap defaultBitmap);
        at: 'Font' put:
            (GDILibrary
                    selectObject: dc
                    with: (self getStockObject: SystemFont)).
    ( GDILibrary deleteDC: dc ) ifFalse: [ ^self osError ]!  
setWindowText: aString
        "Private - set the window text of the receiver."
    | str |
    "more than somewhat less than 32k of data causes this API to fail silently under Win32s."
    str := ( aString size > 32000 and: [ OperatingSystem isWin32s ] )
        ifTrue: [ ( aString copyFrom: 1 to: 32000 ), '...' ]
        ifFalse: [ aString ].
    self isHandleOk
        ifTrue: [
            ( UserLibrary setWindowText: handle text: str asParameter )
                ifFalse: [ self osNotification ] ]
        ifFalse: [ self whenValid: #setWindowText: with: aString ]!
basicStyle
        "Private - Answer an Integer with appropriate
         constants combination for basic subpane style."
    ^WsChild | WsVisible!
messageBox: hWndParent withText: lpText titled: lpCaption style: wType
    ^self
        messageBoxEx: hWndParent
        withText: lpText
        titled: lpCaption
        style: wType
        language: 0!  
defaultStyle
        "Private - Answer an Integer with appropriate styles in it."
    ^WsBorder!
whiteRect
        "Set and answer the control style for a static white rectangle;
        this is the default style."
	self
		removeStyle: SsBlackframe;
		removeStyle: SsBlackrect;
		removeStyle: SsWhiteframe;
		removeStyle: SsGrayframe;
		removeStyle: SsGrayrect.
    ^self addStyle: SsWhiterect!
addDialogBorderStyle
        "Add the dialog border style."
    ^self addStyle: WsDlgframe! 
outputToPrinter
        "Print the receiver on a printer selected by the user."
    | bitmap |
    bitmap := Bitmap fromScreen: Display boundingBox.
    bitmap outputToPrinter.
    bitmap release! 
outputToPrinter: printerOrNameOrRectangle
        "Output the receiver to the printer specified by printerOrName,
        which may be either an instance of Printer, or a String specifying
        a printer name, or nil (in which case the default printer is selected).
        For backward compatibility, the argument may also be a Rectangle,
        in which case the specified screen region is selected and printed
        to the default printer."
    | bitmap aRectangle aPrinter |
    printerOrNameOrRectangle isRectangle
        ifTrue: [
            aRectangle := printerOrNameOrRectangle.
            aPrinter := nil ]
        ifFalse: [
            aRectangle := Display boundingBox.
            aPrinter := printerOrNameOrRectangle ].

    bitmap := Bitmap fromScreen: aRectangle.
    bitmap outputToPrinter: aPrinter.
    bitmap release! 
white
        "Fill the screen with white."
    graphicsTool fill: Color white! 
black
        "Fill the screen with black."
    graphicsTool fill: Color black! 
face: aString
    size: fontSize
    fixedWidth: aBoolean
        "Private - Kept for backward compatibility.
        Answer a Font whose characteristics most
        closely match the arguments."
    ^self
        face: aString
        size: fontSize
        fixedWidth: aBoolean
        attributes: 0
        graphicsMedium: Display!
getStringOrNil
        "Answer the contents of the clipboard as a String, or nil
         if the clipboard is empty or cannot render a string."
    | a hText lpText s |
    self containsText ifFalse: [ ^nil ].
    self open ifFalse: [ ^nil ].
    ( hText := UserLibrary getClipboardData: CfText ) = 0 ifTrue: [
        self osWarning.
        self close.
        ^nil ].
    ( lpText := KernelLibrary globalLock: hText ) = 0
        ifTrue: [ ^self osError ].
    a := ExternalGlobalAddress fromInteger: lpText.
    s := String fromAddress: a.
    KernelLibrary globalUnlock: hText.
    self close.
    ^s!
icon: anIcon
        "Set the receiver's icon"
    | iconHandle |
    self propertyAt: #icon put: anIcon.
    ( self isHandleOk and: [ ( OperatingSystem isWin32 and: [ OperatingSystem versionMajor = 4 ] ) ] ) ifTrue: [
        iconHandle := anIcon isNil
            ifTrue: [ 0 ]
            ifFalse: [ anIcon readOnly
                ifTrue: [ anIcon handle ]
                ifFalse: [ anIcon createPointerIndirect: 0 @ 0 flag: false ] ].
        UserLibrary
            sendMessageInt: self handle
            msg: WmSeticon
            wparam: 0
            lparam: iconHandle ]! 
labelWithoutPrefix: aString
        "Set the window label without the WindowLabelPrefix
         of the receiver to aString."
    label := aString.
    self isHandleOk
        ifTrue: [ self setWindowText: label ].!  
beginPaint: aWindowHandle paintStructure: aWinAddress
    <api: BeginPaint ulong ulong ulongReturn>
    ^self invalidArgument!  
sendMessage: aWindowHandle
        msg: msgInteger
        wparam: wordInteger
        lparamStruct: longInteger
    <api: SendMessageA ulong ulong ulong struct long>
    ^self invalidArgument!
popUpIn: aWindow
        "Popup the receiver menu at the current mouse
         location within aWindow, wait for the user to
         make a selection, and answer the selector of
         the selected item or nil if the user selected
         nothing."
    | w old answer inputEvent |
    popup := nil.
    ( w := aWindow ) isNil ifTrue: [
        w := Window handle: ( WindowHandle fromInteger: 0 ) ].
    old := Process enableInterrupts: false.
    self
        popUpAt: ( Cursor sense mapScreenToClient: w )
        in: w.

    w captureMouseInput.
    Notifier consumeInputUntil: [ :e |
        e selector == #performMenuItem:
            ifTrue: [ answer := popup selectorOf: ( e arguments at: 1 ) ]
            ifFalse: [
                inputEvent := #( #keyboardInput: #characterInput: #button1Up: #button1Down: #button2Up: #button2Down: )
                    includes: e selector.
                inputEvent ifFalse: [ e perform ] ].
        e selector == #performMenuItem: or: [ inputEvent ] ].
    w clearMouseCapture.

    Process enableInterrupts: old.
    popup destroy.
    popup := nil.
    ^answer! 
itemSize: aPoint
        "Set the size of the (currently being drawn) list item."
     ^self itemHeight: aPoint y  "x component ignored for list items"!
insertMessage
        "Private - Answer the host message for inserting an item."
    ^LbInsertstring!   
dragTargetDefaultEmphasis
		"Private - answer the type of target emphasis that should be employed
		if not otherwise specified."
	^'separator'!
setCursor
        "Private - Change the current cursor to the shape of the receiver."
    | w defaultCursor |
    handle isNil ifTrue: [
        ( w := self class windowUnderCursor ) isNil
            ifTrue: [ ^self class setWinCursor: IdcArrow ]
            ifFalse: [
                ( defaultCursor := w defaultCursor ) notNil
                    ifTrue: [ ^UserLibrary setCursor: defaultCursor handle ]
                    ifFalse: [
                        ( defaultCursor := UserLibrary getClassLong: w handle index: GclHcursor ) = 0
                            ifTrue: [ defaultCursor := self class arrow handle ].
                        ^UserLibrary setCursor: defaultCursor ] ] ].
    handle isExternalHandle
        ifTrue: [ ^UserLibrary setCursor: handle ].
    handle isInteger
        ifTrue: [ self class setWinCursor: handle ]! 
createDIBitmap: hDC
    bitmapInfo: bitmapInfo
    init: initFlag
    bits: bits
    usage: usageFlag
        "Private - call the CreateDIBitmap API."
    | hBitmap bitmapInfoHeader |
    bitmapInfoHeader := WinBitmapInfoHeader
        width: bitmapInfo width
        height: bitmapInfo height
        planes: bitmapInfo planes
        bitCount: bitmapInfo bitCount.
    ( hBitmap := GDILibrary
        createDIBitmap: hDC
        infoHeader: bitmapInfoHeader asParameter
        dwUsage: initFlag
        initBitsStruct: bits asParameter
        initInfo: bitmapInfo asParameter
        wUsage: usageFlag ) = 0
            ifTrue: [ ^self osError ].
    ^hBitmap!  
isDefaultPushButton
        "Private - Answer true if the receiver is the
        default pushbutton."
    ^self hasStyle: BsDefpushbutton!
displayWindow
        "Private - Let the owner process the display event
        or draw all the retained segments."
    ( ( self handlesEvent: #display )
     or: [ self hasActionForEvent: #display ] )
        ifTrue: [
            self event: #display.
            self triggerEvent: #display]
        ifFalse: [
            firstTime ifFalse: [ self erase ].
            self showBitmap.
            graphicsTool drawChain]!
ellipse: boundingBox
        "Private - Call GDI ellipse function."
    self allHandles do: [ :h |
        ( GDILibrary ellipse: h
            x1: boundingBox origin x
            y1: boundingBox origin y
            x2: boundingBox corner x
            y2: boundingBox corner y )
                ifFalse: [ self osNotification ] ]!  
exit
        "Private - release the pen associated with the Display."
    Display pen deleteDC! 
setViewportOrg: aPoint
        "Set the viewport origin of the graphicsMedium associated
          with the receiver."
    self allHandles do: [ :h |
        ( GDILibrary
            setViewportOrgEx: h
            x: aPoint x
            y: aPoint y
            oldOrigin: nil )
                ifFalse: [ ^self osError ] ]!
openIn: aRectangle
        "Private - Open the receiver in aRectangle."
    | result |
    [ self buildIcon.
        self initSize: aRectangle.
        self hasSmalltalkMenuBar ifTrue: [ self buildMenuBar ].
        self event: #menuBuilt.
        self triggerEvent: #menuBarBuilt.
        children do: [ :subpane | subpane isApplicationWindow ifFalse: [ subpane open ] ].
        result := self validate ] ifCurtailed: [ self close ].
    ^result!
showCaret:aBoolean
        "Private - Show or hide the caret."
    | result |
    result := aBoolean
        ifTrue: [ UserLibrary showCaret: pane asParameter ]
        ifFalse: [ UserLibrary hideCaret: pane asParameter ].
    result ifFalse: [ self osNotification ]! 
constructNotifications
        "Private - answer the mapping between host control
        notification codes and corresponding Smalltalk event
        notifications."
    ^Dictionary new
        at: BnClicked put: #notifyClicked: ;
        at: BnDoubleclicked put: #notifyDoubleClicked: ;
        yourself! 
fromModule: handleOrString id: id
        "Open the dialog box whose id is anInteger
         contained in the module identified by
         handleOrString.  id may be a String or an Integer
         that identifies the dialog template."
    ^self new fromModule: handleOrString id: id!   
ownerDrawFixed
        "Set and answer the owner draw fixed item height style for list box."
    ^self addStyle:
        WsVscroll | WsBorder | LbsNointegralheight |
        LbsHasstrings | LbsOwnerdrawfixed | LbsNotify!  
checkItem: item
        "Place a check mark on an item.
         item can be the label or the selector."
    | mi |
    ( self isThere: item ) ifFalse: [ ^nil ].
    mi := self getMenuItem: item.
    mi attribute: mi attribute | MfChecked.
    self updateItem: mi!   
selectedItem
        "Answer a String containing the
         text selected in clipboard format."
    self getSelection.
    ^( self contents asExternalString copyFrom: selection x to: selection y )
        asNormalizedString!   
processInput
        "Make the receiver synchronous to its owner window.
         This method doesn't return until close has been
         sent to the receiver."
    | userIF |
    CursorManager normal changeFor: [
        Window new clearMouseCapture.
        userIF := UserInterfaceProcess.
        sem := Semaphore new.
        [ CurrentProcess makeUserIF. Notifier run ] fork.
        "dialog may be closed before getting here, so check for nil."
        sem notNil ifTrue: [ sem wait ].
        userIF makeUserIF ]!  
dragTargetDrawItemEmphasis: aPoint
		"Private - draw the target emphasis for the receiver
		given the cursor location aPoint (relative to the receiver).
		Emphasis is drawn indicating individual list items as
		individual targets."
	| index lastIndex rect |
	index := ( self itemIndexFromPoint: aPoint ) min: list size.
		"only update if changed"
	lastIndex := self dragTargetSelection.
	index = lastIndex ifTrue: [ ^nil ].  "don't draw emphasis if already drawn."
	lastIndex notNil ifTrue: [ self dragTargetEraseItemEmphasis ].
	rect := self lineToRect: index.
	self dragTargetDrawEmphasisRectangle: rect.
	self dragTargetSelection: index! 
getWindowExt
        "Answer the window extent."
    | winPoint |
    ( GDILibrary
        getWindowExtEx: self handle
        extent: ( winPoint := WinPoint new ) asParameter )
            ifFalse: [ ^self osError ].
    ^winPoint asPoint!   
copySelection
        "Copy the selection into the Clipboard"
     UserLibrary
        sendMessage: handle
        msg: WmCopy
        wparam: 0
        lparam: 0! 
foreColor: aColor
        "Set the foreground color of the receiver to aColor.
         aColor can be an RGB value or an index into the
         color palette."
    super foreColor: aColor.
    logicalTool := WinLogicalPen
        style: logicalTool style
        color: aColor
        width: logicalTool width.
    deviceContext isNil ifTrue:[^self].
    downState ifTrue: [
        self selectObject: logicalTool handle]!
registerHelpMessage
        "Private - register a new message for our internal
         help message, and save it away for later use by the system"
    | oldNumber id |
    oldNumber := OperatingSystemEventsExtra keyAtValue: #wmHelp:with: ifAbsent: [ nil ].
    oldNumber notNil ifTrue: [ OperatingSystemEventsExtra removeKey: oldNumber ].
    ( id := UserLibrary registerWindowMessage: 'WM_STHELP' asParameter ) = 0
        ifTrue: [ ^self osError ].
    WmStHelp := id.
    OperatingSystemEventsExtra at: WmStHelp put: #wmHelp:with:!  
leftJustifiedNoWordWrap
        "Set and answer the window style for left justified text
         which does not automatically wrap to the next line;
         this is the default style."
    ^self leftJustified!   
getFormatName: aCfFormat
        "Answer the name of the registered clipboard format <aCfFormat>
        or nil if the format is not registered. "
    | name count |
    count := UserLibrary
        getClipboardFormatName: aCfFormat
        buffer: ( name := String new: 128 )
        length: name size.
    count = 0 ifTrue: [ ^nil ].
    ^name copyFrom: 1 to: count! 
defaultTextLimit
        "Private - answer the default text limit for the receiver."
    ^0!
autoHScroll
        "Add the auto horizontal scroll style."
    ^self addStyle: CbsAutohscroll! 
allFaces: aGraphicsMedium
        "Answer an array of all available face names in the device
         identified by aGraphicsMedium."
    | aCallBack aMessage faceList |
    aMessage := Message new
        receiver: self;
        selector: #enumFaces:lpTextMetrics:nFontType:lpData: ;
        yourself.
    aCallBack := CallBack
        registerMessage: aMessage
        parameterTypes: #( #ulong #ulong #ulong #ulong )
        returnType: #long
        callingConvention: #api.
    TempFontList := OrderedCollection new.
    GDILibrary
        enumFonts: aGraphicsMedium deviceContext
        lpFacename: 0
        lpFontFunc: aCallBack asParameter
        lpData: 0.
    aCallBack release.
    faceList := TempFontList asArray.
    TempFontList := nil.
    ^faceList!   
pointToLogical: pointSize graphicsMedium: graphicsMedium
        "Private - Answers logical width and height equivalent
         to the pointSize for the selected font in aGraphicsMedium."
    | logPixelSY deviceUnit pen logicalUnit |
    logPixelSY := GDILibrary
        getDeviceCaps: graphicsMedium graphicsTool handle
        index: Logpixelsy.
    deviceUnit := ( pointSize / 72 * logPixelSY ) rounded.
    pen := graphicsMedium graphicsTool.
    logicalUnit :=
        ( ( 0 @ deviceUnit ) deviceToLogical: pen )  -
        ( ( 0 @ 0 ) deviceToLogical: pen ).    "logical origin may not be 0@0"
    ^logicalUnit!
chooseAFont: aString
        "Open a dialog which lets the user choose a font.
         aString title is ignored. Answer an instance of Font."
    ^self chooseAFont!  
fromFont: aFont graphicsMedium: aGraphicsMedium
        "Answer a new font with identical appearance characteristics
        as aFont conditioned for use with aGraphicsMedium."
    ^self fromLogicalFont: aFont logicalFont graphicsMedium: aGraphicsMedium.!
startUp
        "Private - Initialize the class."
    | oldFont |
    oldFont := SysFont.
    FontHandleTable := Dictionary new.
    self setSysFont: ( self fromStockFont: SystemFont ).
    oldFont isNil ifTrue: [ oldFont := SysFont ].
    OriginalSysFontSize := oldFont charSize.
    self allInstancesPrim do: [ :font | font initFontHandle ].
    Terminal font: SysFont.! 
allFonts: aGraphicsMedium
        "Answer an array of all available fonts in the device
         identified by aGraphicsMedium."
    | aCallBack aMessage faceList allFonts font |
    faceList := self allFaces: aGraphicsMedium.
    aMessage := Message new
        receiver: self;
        selector: #enumFonts:lpTextMetrics:nFontType:lpData: ;
        yourself.
    aCallBack := CallBack
        registerMessage: aMessage
        parameterTypes: #( #ulong #ulong #ulong #ulong )
        returnType: #long
        callingConvention: #api.
    TempFontList := OrderedCollection new.
    faceList do: [ :face |
        GDILibrary
            enumFonts: aGraphicsMedium deviceContext
            facename: face asParameter
            lpFontFunc: aCallBack asParameter
            lpData: 0 ].
    aCallBack release.
    allFonts := Array new: TempFontList size.
    1 to: TempFontList size do: [ :i |
        font := self new.
        font
            graphicsMedium: aGraphicsMedium;
            logicalFont: ( ( TempFontList at: i ) at: 2 );
            initFontInfo: ( ( TempFontList at: i ) at: 3 ).
        allFonts at: i put: font ].
    TempFontList := nil.
    ^allFonts! 
fromLogicalFont: aLogFont
        "Answer a Font build from WinLogFont structure aLogFont."
    ^self fromLogicalFont: aLogFont 
        graphicsMedium: Display!  
face: aString
    size: fontSize
    fixedWidth: aBoolean
    attributes: anInteger
    graphicsMedium: aGraphicsMedium
        "Answer a Font for aGraphicsMedium whose
         characteristics most closely match the arguments .
         anInteger is a combination of style constants.

         The fontSize can be a Point in terms of  width and
         height of the characters in pixels or as an Integer 
         specifying the point size  in the units of 1/72 inch. "
    | font |
    font := self new.
    font
        faceName: aString;
        fixedWidth: aBoolean;
        charSet: AnsiCharset;
        yourself.
    fontSize isInteger
        ifTrue: [ font pointSize: fontSize ]
        ifFalse: [ font charSize: fontSize ].
    ^font!  
pixelToPoint: pixelSize graphicsMedium: aGraphicsMedium
        "Private - Answer the point size for aGraphicsMedium
         equivalent to the pixel size."
    | logPixelSY |
    logPixelSY := GDILibrary
        getDeviceCaps: aGraphicsMedium deviceContext
        index: Logpixelsy.
    ^( pixelSize  * 72 / logPixelSY ) rounded!
pointToPixel: pointSize graphicsMedium: aGraphicsMedium
        "Private - Answer the pixel size equivalent
          to the pointSize for aGraphicsMedium."
    | logPixelSY |
    logPixelSY := GDILibrary
        getDeviceCaps: aGraphicsMedium deviceContext
        index: Logpixelsy.
    ^( pointSize / 72 * logPixelSY ) rounded! 
fromLogicalFont: aLogFont graphicsMedium: aGraphicsMedium
        "Answer a Font for aGraphicsMedium 
         build from WinLogFont structure aLogFont ."
    ^self new
        logicalFont: aLogFont;
        makeFont: aGraphicsMedium;
        yourself!
fixedSystemFont
        "Answer the fixed width system font."
    ^self fromStockFont: SystemFixedFont! 
isHelpRequest: aWinMessage
        "Private - answer true if the message passing through the
         message filter is a help request, otherwise false"
    ^( aWinMessage msg = WmKeydown ) & ( aWinMessage wparam = VkF1 )! 
killTimer: hWnd idEvent: anInteger
    <api: KillTimer ulong ulong boolean>
    ^self invalidArgument!  
findSearchString
        "Private - do a pattern match on the receiver's current
         text, according to the current settings of the receiver class
         (SearchString, Forward, & CaseSensitive).  Answer a Point
         describing the (start,end) location of the found match,
         or nil if no match found."
    | toSelect pattern matchBlock startIndex |
    CursorManager execute changeFor: [
        self getSelection.  "set selection inst var"
        startIndex := Forward
            ifTrue: [ (  selection x + ( selection y < selection x ifTrue: [0] ifFalse: [1] ) ) max: 1 ]
            ifFalse: [ (  selection y - ( selection y < selection x ifTrue: [0] ifFalse: [1] ) ) max: 1 ].
        self getText.  "set value inst var"
        CaseSensitive
            ifTrue: [
                pattern := Pattern new: SearchString.
                matchBlock := [ :char | char ] ]
            ifFalse: [
                pattern := Pattern new: SearchString asLowerCase.
                matchBlock := [ :char | char asLowerCase ] ].

        toSelect := Forward
            ifTrue: [ pattern match: value index: startIndex each: matchBlock ]
            ifFalse: [ pattern matchBackward: value index: startIndex each: matchBlock ] ].
    ^toSelect!
updateWindow: hWnd
    <api: UpdateWindow ulong boolean>
    ^self invalidArgument! 
bottomRatio
    "Answer the y-coordinate of the bottom of the relative rectangle as a percentage of the height of the reference rectangle."

    ^bottomRatio! 
bottomRatio: percentage
    "Set the y-coordinate of the bottom of the relative rectangle to be a <percentage> of the height of the reference rectangle."

    bottomRatio := percentage!  
leftRelativeTo: referenceRectangle
    "Private"
    "Answer the x-coordinate of the left edge of the rectangle relative to the <referenceRectangle>."

    ^((referenceRectangle left
        right: (self leftRatio * referenceRectangle width))
            right: self leftInset)
                rounded! 
rightInset
    "Answer the amount by which the right edge of the relative rectangle is inset from the reference rectangle."

    ^rightInset!  
rightRelativeTo: referenceRectangle
    "Private"
    "Answer the x-coordinate of the right edge of the rectangle relative to the <referenceRectangle>."

    ^((referenceRectangle left
        right: (self rightRatio * referenceRectangle width))
            left: self rightInset)
                rounded!  
topRatio: percentage
    "Set the y-coordinate of the top of the relative rectangle to be a <percentage> of the height of the reference rectangle."

    topRatio := percentage!   
bottomRightInset: aPoint
    "Set the bottomRatio and rightRatio to the x and y values of <aPoint>."

    self bottomInset: aPoint y.
    self rightInset: aPoint x!  
bottomRightRatio: aPoint
    "Set the bottomRatio and rightRatio to the x and y values of <aPoint>."

    self bottomRatio: aPoint y.
    self rightRatio: aPoint x!  
leftRatio
    "Answer the x-coordinate of the left edge of the relative rectangle as a percentage of the width of the reference rectangle."

    ^leftRatio!   
leftRatio: percentage
    "Set the x-coordinate of the left edge of the relative rectangle to be a <percentage> of the width of the reference rectangle."

    leftRatio := percentage!
initialize
    "Initialize the receiver to describe a relative rectangle that is equal to the reference rectangle."

    topInset := topRatio := 0.
    leftInset := leftRatio := 0.
    bottomInset := bottomRatio := 0.
    rightInset := rightRatio := 0!
bottomRelativeTo: referenceRectangle
    "Private"
    "Answer the y-coordinate of the bottom of the rectangle relative to the <referenceRectangle>."

    ^((referenceRectangle top
        down: (self bottomRatio * referenceRectangle height))
            up: self bottomInset)
                rounded!  
relativeTo: referenceRectangle
    "Answer the rectangle described by the receiver relative to the <referenceRectangle>."

    ^referenceRectangle class
        leftTop: (self leftRelativeTo: referenceRectangle) @ (self topRelativeTo: referenceRectangle)
        rightBottom: (self rightRelativeTo:referenceRectangle) @ (self bottomRelativeTo: referenceRectangle)! 
rightInset: aValue
    "Set the amount by which the right edge of the relative rectangle is inset from the reference rectangle to be <aValue>."

    rightInset := aValue! 
topInset: aValue
    "Set the amount by which the top of the relative rectangle is inset from the reference rectangle to be <aValue>."

    topInset := aValue!
topRatio
    "Answer the y-coordinate of the top of the relative rectangle as a percentage of the height of the reference rectangle."

    ^topRatio!  
leftInset
    "Answer the amount by which the left edge of the relative rectangle is inset from the reference rectangle."

    ^leftInset! 
leftInset: aValue
    "Set the amount by which the left edge of the relative rectangle is inset from the reference rectangle to be <aValue>."

    leftInset := aValue!
rightRatio
    "Answer the x-coordinate of the right edge of the relative rectangle as a percentage of the width of the reference rectangle."

    ^rightRatio!
bottomInset
    "Answer the amount by which the bottom of the relative rectangle is inset from the reference rectangle."

    ^bottomInset!
bottomInset: aValue
    "Set the amount by which the bottom of the relative rectangle is inset from the reference rectangle to be <aValue>."

    bottomInset := aValue!   
rightRatio: percentage
    "Set the x-coordinate of the right edge of the relative rectangle to be a <percentage> of the width of the reference rectangle."

    rightRatio := percentage! 
topLeftInset: aPoint
    "Set the topInset and leftInset to the x and y values of <aPoint>."

    self topInset: aPoint y.
    self leftInset: aPoint x!  
topLeftRatio: aPoint
    "Set the topRatio and leftRatio to the x and y values of <aPoint>."

    self topRatio: aPoint y.
    self leftRatio: aPoint x!  
topInset
    "Answer the amount by which the top of the relative rectangle is inset from the reference rectangle."

    ^topInset! 
topRelativeTo: referenceRectangle
    "Private"
    "Answer the y-coordinate of the top of the rectangle relative to the <referenceRectangle>."

    ^((referenceRectangle top
        down: (self topRatio * referenceRectangle height))
            down: self topInset)
                rounded!
deleteSegment: segId
        "Delete the segment whose id is segId."
    (segments at: segId) release.
    segments removeKey: segId!  
addHelpMenu
        "Private - add the Help menu to the menu bar."
    | menu |
    ( menu := window helpManager helpMenu ) notNil ifTrue: [
        menu owner: window helpManager.
        window isMDIFrame
            ifFalse: [ window menuWindow addMenu: menu ]
            ifTrue: [ window mdiMenuWindow addMenu: menu ] ]!  
startPrintJob
        "Start a print job.  Everything drawn between startPrintJob
         and endPrintJob will become one entry in the print queue."
    self startPrintJob: nil! 
lineCoordsAtCharIndex: index
    "Private - Answer a Point where x is the offset
    of the start of the line with the index'th character,
    and y is the offset of the end of the line."

    | aStream line chars lineSize |
    aStream := self contents asStream.
    chars := 0.
    [ aStream atEnd ]
        whileFalse: [
            line := aStream nextLine.
            lineSize := line isDoubleByteString
                ifTrue: [ line sizeOfMixedString ]
                ifFalse: [ line size ].
            ( index between: chars and: chars + lineSize + 1 )
                ifTrue: [ ^chars @ ( chars + lineSize ) ]
                ifFalse: [ chars := chars + lineSize + 2 ]].
    ^chars @ chars!   
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #dragSourceNeedsObject: ;
        add: #dragSourceNeedsCursors: ;
        add: #dragSourceCut: ;
        add: #dragTargetNeedsOperations: ;
        add: #dragTargetEnter: ;
        add: #dragTargetLeave: ;
        add: #dragTargetOver: ;
        add: #dragTargetDrawEmphasis: ;
        add: #dragTargetEraseEmphasis: ;
        add: #dragTargetDrop: ;
        yourself! 
displayAt: aPoint with: aPen
        "Display the receiver at aPoint using aPen."
    aPen notNil ifTrue: [
        aPen copyBitmap: self
            from: self boundingBox
            at: aPoint]!
setClassLong: hwnd index: integer value: aLong
        "Private - Set the window class long at index integer to aLong.
        Answer the previous long."
    <api: SetClassLongA ulong long long ulongReturn>
    ^self invalidArgument! 
noIntegralHeight
        "Add the no integral height style."
    ^self addStyle: CbsNointegralheight!   
resetAttributes
        "Private - set the attributes of the device context."
    super resetAttributes.
    self setTextAlign: TaBaseline.
    ( font notNil and: [ font originalHandle notNil ] ) ifTrue: [
        self selectObject: font fontHandle ]!  
handlers
        "Private - answer the event handlers dictionary."
    ^self propertyAt: #oldHandlers ifAbsentPut: [ IdentityDictionary new: 2 ]!   
createCaretAt: aPoint
        "Create a flashing caret. "
    | font |
    font := self font.
    font isNil ifTrue: [ font := SysFont ].
    UserLibrary
        createCaret: self handle
        bitmap: nil
        width: 0
        height: font height.
    UserLibrary
        setCaretPos: aPoint x
         y: aPoint y!  
resizeChildren
        "Private - Resize all children. If the receiver contains an in-place
         activated object, take into account the border space of the tools
         inserted by the object's server when resizing the children. "

    | container |
    ( ( container := self container ) isNil or: [ container activeObject isNil ] )
        ifTrue: [ super resizeChildren ]
        ifFalse: [ container frameResizeBorder: rectangle ] !
contents: aCollection
        "Set the receiver's contents to aCollection.  Override
        superclass implementation to preserve text contents."
    | textContents |
    textContents := self text.
    super contents: aCollection.
    self text: textContents!
resizeWindow
        "Private - Change the size of the window
         for the receiver."
    self handle setWindowPos: nil
        rectangle: rectangle
        fs: SwpNozorder.
    rectangle := 0 @ 0 extent: self extent.!  
checkMarkSize
        "Answer a Point specifying the size of
         the default menu item checkmark."
    | anInteger |
    anInteger := UserLibrary getMenuCheckMarkDimensions.
    ^anInteger lowWord @ anInteger highWord!  
selectLineAtCurrentSelection
        "Private - Select the line which
         contains the current selection."
  ^ self selectFrom: (1 @ selection origin y)
        to: ( (textHolder lineAt: (selection origin y)) size @ selection origin y)
            "0 @ (selection origin y + 1) "!
charWidth
        "Answer the character width in dialog units."
    ^4! 
messageBoxColor: aDeviceContext
        "Private - Set the foreground & background color for
        the message box which was opened with the receiver
        as its owner."
    | brush backColor foreColor |
    ( foreColor := self foreColor ) isNil ifTrue: [ foreColor := Color windowText ].
    ( GDILibrary setTextColor: aDeviceContext with: foreColor asParameter ) = 16rFFFFFFFF
        ifTrue: [ ^self osError ].
    ( backColor := self backColor ) isNil ifTrue: [ backColor := Color windowBackground ].
    ( brush := WinLogicalBrush style: BsSolid color: backColor hatch: nil )
         isNil ifTrue: [ ^nil ].
    ( GDILibrary setBkColor: aDeviceContext with: backColor asParameter ) = 16rFFFFFFFF
        ifTrue: [ ^self osError ].
    ( GDILibrary setBrushOrgEx: aDeviceContext x: 0 y: 0 oldOrigin: nil )
        ifFalse: [ ^self osError ].
    ^brush asParameter!
archive: aByteArray
        "Private - set the receiver's archive bits to aByteArray."
    archive := aByteArray!   
isGraphPane
        "Answer whether the receiver is a kind of GraphPane."
    ^false!   
deleteIndex: index
        "Delete item number index from the list."
    | selectionChanged topIndex |
    topIndex := self getTopIndex.
    selectionChanged := self isIndexSelected: index.
    list := ( list asOrderedCollection )
        removeIndex: index;
        asArray.
    self isHandleOk ifTrue: [
        UserLibrary
            sendMessage: handle
            msg: self deleteMessage
            wparam: index - 1
            lparam: 0.
        self setTopIndex: topIndex ].
    selectionChanged
        ifTrue: [ self triggerChanged ]!
physicalFontAttribute
        "Private - answer the physicalFont instance variable."
    ^physicalFont! 
createDialog: hInstance id: id parent: hWndParent dialogFunction: lpDialogFunc
    ^self createDialogParam: hInstance id: id parent: hWndParent dialogFunction: lpDialogFunc initParam: 0!   
lowerCase
        "Add the lower case style."
    ^self addStyle: EsLowercase!  
contextForItem: anInteger
        "Private - answer nil because DialogTopPane does
        not have a menu bar."
    ^nil! 
setPicture: aStoredPicture
        "Set the contents of the clipboard to be aStoredPicture."
    | metafilePict hMem |
    aStoredPicture handle isNil ifTrue: [ ^nil ].
    self open ifFalse: [ ^nil ].
    metafilePict := WinMetafilepict new.
    metafilePict mm: MmIsotropic. "Could be other mapping modes."
    aStoredPicture apmHeader notNil
        ifTrue: [
            metafilePict xExt: aStoredPicture apmHeader bbox width.
            metafilePict yExt: aStoredPicture apmHeader bbox height ]
        ifFalse: [
            metafilePict xExt: -1.
            metafilePict yExt: -1 ].
    metafilePict hMF: aStoredPicture handle.
    hMem := ExternalGlobalAddress memoryHandleFrom: metafilePict contents.
    self empty.
    ( UserLibrary setClipboardData: CfMetafilepict hMem: hMem ) = 0
        ifTrue: [ ^self osError ].
    self close! 
dragTargetScrollInterval
        "Private - answer ms interval between scrolls."
    ^30!   
getCb: bitCount
        "Private - Answer the size of the bitmapInfo struct."
    | count |
    count := WinBitmapInfoHeader sizeInBytes.
    bitCount >= 24
        ifTrue: [^count]     "No color table for this format."
        ifFalse: [^(count + (4 * (1 bitShift: bitCount)))]
!   
setMenu: aWindowHandle menu: aMenuHandle
    <api: SetMenu ulong ulong boolean>
    ^self invalidArgument!  
insertMenu: aMenu after: anInteger
        "Insert aMenu into the receiver after index anInteger.
        anInteger = 0 inserts first, anInteger = 1 after the first
        menu, etc."
    | item |
    menus add: aMenu afterIndex: anInteger.
    self isHandleOk ifTrue: [
        item := aMenu buildWindow: self.
        item position: anInteger.
        self insertItem: item label: aMenu title.
        ( UserLibrary drawMenuBar: parent asParameter )
            ifFalse: [ ^self osError ] ]! 
basicStyle
        "Private - Answer an Integer with appropriate
         constants combination for basic control style."
    ^WsChild | WsVisible | WsTabstop!
cleanUpAfterGuiError
    "Clean up any operating system specific items after
    an error occurs."

    Window new clearMouseCapture.
    Cursor reset.
    Clipboard close
    !  
clearSelection
        "Delete the current selection."
    self isHandleOk ifTrue: [
        UserLibrary
            sendMessage: handle
            msg: self clearMessage
            wparam: 0
            lparam: 0 ]! 
button1Move: aPoint
        "Private - The user moved the mouse to aPoint
         while holding down button 1."
    | sourceLocation |
    ( self isDragSource and: [ self dragOnMove and: [ self isDragSourceInitiation: aPoint ] ] ) ifTrue: [
        sourceLocation := self dragSourceLocation.
        self dragOnMove: nil location: nil.
        self doDragDropAt: sourceLocation button: 1 ]!
staticText
        "Answer default static text color.  Note that the Win32 platform
        does not distinguish static text color, so we emulate it using
        the window text color."
    ^self getSystemColor: ColorWindowtext! 
initGraphics
        "Private - Initialize the graphics tool for the receiver"
    self isHandleOk ifFalse: [ ^nil ].
    graphicsTool := Pen forDC: nil medium: self! 
wmErasebkgnd: wordInteger with: longInteger
        "Private - Process the erase background message."
    ^nil! 
wmHScroll: wordInteger with: longInteger
        "Private - Scroll the receiver horizontally."
    | type slider newX |
    self totalLength = 0 ifTrue: [ ^nil ].
    type := wordInteger lowWord.
    type = SbThumbtrack ifTrue: [
        slider := ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2.
        newX := ( slider * ( self totalWidth max: 1 )) // 100.
        self topCorner: newX @ self topCorner y.
        ^nil ].
    ^super wmHScroll: wordInteger with: longInteger!   
createIconIndirect: pIconInfo
    <api: CreateIconIndirect struct ulongReturn>
    ^self invalidArgument!   
dragTargetStopScrollTimer
        "Private - stop the drag scroll timer."
    Time stopTimer: self class dragTargetScrollTimerId forWindow: self.
    self dragTargetScrollDirection: nil.
    self dragTargetScrollElapsed: nil !
findCurrentLine: aPoint
        "Private - Set currentLine to the line
         containing aPoint."
    | line y fontHeight |
    fontHeight := self font height.
    y := aPoint y.

    ( rectangle containsPoint: aPoint )
        ifTrue: [ self stopTimer: self class leftButtonScrollTimerId ]
        ifFalse: [
            self captureMouseInput.
            self startTimer: self class leftButtonScrollTimerId period: self class leftButtonScrollInterval.
            y < 0
                "scroll up"
                ifFalse: [
                    self scrollVertical: 0 - fontHeight highlight: currentLine.
                    y := rectangle height - fontHeight ]
                ifTrue: [
                    "scroll down"
                    y > rectangle height
                        ifFalse: [
                            self scrollVertical: fontHeight highlight: currentLine.
                            y := 1 ]
                        ifTrue: [ ^nil ] ] ].

    line := rectangle height - ( rectangle height - y )
        // fontHeight
        + topCorner y.
    ^line > self totalLength
        ifTrue: [ nil ]
        ifFalse: [ line ]! 
winHelp: hWnd helpFile: aString command: anInteger dataStruct: aWinStructure
    <api: WinHelpA ulong struct ulong struct boolean>
    ^self invalidArgument!   
setHorizontalExtent: pixelWidth
        "Sets the width in pixels by which a list box can be
         scrolled horizontally.  If the size of the list box is
         smaller than this value, the horizontal scroll bar will
         scroll items in the list box.  If the list box is as large
         larger than this value, the horizontal scroll bar is disabled."
    self isHandleOk
        ifTrue: [
            UserLibrary
                sendMessage: handle
                msg: LbSethorizontalextent
                wparam: pixelWidth
                lparam: 0 ]
        ifFalse: [ self whenValid: #setHorizontalExtent: with: pixelWidth ]!  
closeSegment
        "Close the currently open segment."
    segmentIsOpen ifFalse: [^self].
    self currentSegment stopRecording.
    segmentIsOpen := false.!  
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        remove: #changedIndex: ;
        remove: #clicked: ;
        yourself!
hasSelection
        "Private - answer whether the receiver has anything selected."
    ^self selections notEmpty!  
triggerChanged
        "Private - trigger the changed: event."
    self triggerEvent: #changed: with: self value!   
deselectItem: anItem
        "Deselect anItem in the list.  Trigger the changed event."
    self deselectIndex: ( self indexOf: anItem )!   
setValue: aCollectionOfItems
        "Set the selection to the items in aCollectionOfItems.
        Trigger the changed event. Answer aCollectionOfItems."
    self
        value: aCollectionOfItems;
        triggerChanged.
    ^aCollectionOfItems! 
selectIndexPrivate: itemIndex
        "Private - Select the item at itemIndex. Index starts at 1."
    value isNil ifTrue: [ value := OrderedCollection new ].
    ( itemIndex notNil and: [ ( value includes: itemIndex ) not ] )
        ifTrue: [ value add: itemIndex ].
    self isHandleOk ifFalse: [ ^self ].
    self setSelection! 
selectedItems
        "Answer a collection of the selected items."
    (self selections) isNil
        ifTrue: [^nil]
        ifFalse: [^self selections collect: [:each |
            list at: each]]!  
deselectAll
        "Deselect all selected items in the list.  Trigger the changed event."
    self deselect!   
setValueIndices: aCollectionOfIntegers
        "Set the selection to the items in aCollectionOfIntegers.
        Trigger the changed event. Answer aCollectionOfIntegers."
    self
        valueIndices: aCollectionOfIntegers;
        triggerChanged.
    ^aCollectionOfIntegers!
selectAll
        "Select all the items in the receiver."
    | newValue |
    newValue := ( 1 to: list size ) asArray.
    newValue = value ifTrue: [ ^self ].
    value := newValue.
    self setSelection; triggerChanged!   
clearSelections
        "Make no items in the list selected"
    ^self clearSelection!  
selectIndex: itemIndex
        "Select the item at itemIndex. Index starts at 1.
        Trigger the changed event."
    ( ( self isIndexValid: itemIndex ) and: [ ( self valueIndices includes: itemIndex ) not ] ) ifTrue: [
        self
            selectIndexPrivate: itemIndex;
            triggerChanged ]!
valueIndices: aCollectionOfIntegers
        "Set the selection to the items at the index positions
        in aCollectionOfIntegers."
    | validIndices |
    aCollectionOfIntegers size = 0
        ifTrue: [ ^self clearSelection ].
    validIndices := aCollectionOfIntegers
        select: [ :i | self isIndexValid: i ].
    validIndices isEmpty
        ifTrue: [ ^self clearSelection ].
    value := OrderedCollection new.
    validIndices do: [ :index |
        ( index notNil and: [ ( value includes: index ) not ] )
            ifTrue: [ value add: index ] ].
    self isHandleOk ifTrue: [ self setSelection ]!  
selection: anObj
        "If anObj is a collection then select items whose indices
         are in anObj.
         If anObj is nil then unselect all items.
         If anObj is Integer then select the item indexed by anObj.
         Otherwise, select anObj in the list."
    anObj isNil ifTrue: [ self deselectAll. ^self ].
    ( anObj isCollection and: [ anObj isString not ] )
        ifTrue: [
            ( anObj isEmpty or: [ anObj first isInteger ] )
                ifTrue: [ self valueIndices: anObj ]
                ifFalse: [ self value: anObj ] ]
        ifFalse: [ super selection: anObj ]!   
selections
        "Answer indices of the items selected."
    self isHandleOk ifTrue: [ value := self getSelection ].
    value isNil ifTrue: [ ^OrderedCollection new ].
    ^value!
valueIndices
        "Answer a collection containing the indices
        of the currently selected items."
    ^self selections!   
deselectIndex: itemIndex
        "Deselect the item at itemIndex in the list.  Trigger the changed event."
    ( self valueIndices includes: itemIndex ) ifTrue: [
        self
            deselectIndexPrivate: itemIndex;
            triggerChanged ]!   
isIndexSelected: itemIndex
        "Private - answer whether itemIndex is selected."
    ^self valueIndices includes: itemIndex!
value
        "Answer a collection containing the
        currently selected items in the list."
    ^self selectedItems!  
value: aCollectionOfItems
        "Set the selection to the items in aCollection."
    aCollectionOfItems size = 0
        ifTrue: [ ^self clearSelection ].
    self valueIndices:
        ( aCollectionOfItems collect: [ :item | self indexOf: item ] )!  
setDIBits: aByteArray
        "Private - Set the bitmap bits of the receiver to aByteArray."
    self setDIBits: aByteArray using: bitmapInfo!  
showSelectionFrom: beginIndex to: endIndex
        "Private - Same as selectCharFrom:to:.
        Retained for compatibility."
    self selectCharFrom: beginIndex to: endIndex!   
resetAttributes
        "Private  - Reset the attributes of the device context."
    self backColor: backColor.
    self foreColor: foreColor! 
hostDragButtonIndex
        "Private - answer the default drag button index,
        or nil if not supported."
    ^1! 
aborted
        "Answer whether the user aborted from PrintAbortDialog."
    ^abort!
copies
        "Answers the Number of copies requested by the user"
    ^self propertyAt: #copies!  
displaySelectedText: aString at: aPoint
        "Private - Display selected aString at aPoint."
    self displayText: aString at: aPoint!   
deleteAtom: anInteger
        "Delete the atom identified by anInteger.  Obsolete,
        maintained for backward compatibility."
    ( Atom fromInteger: anInteger ) delete! 
createBitmap: width
    height: height
    planes: planes
    bitCount: bitCount
    bits: bits
        "Private - call the CreateBitmap API."
    | hBitmap |
    ( hBitmap := GDILibrary
        createBitmap: width
        height: height
        planes: planes
        bitCount: bitCount
        bits: bits ) = 0
            ifTrue: [ ^self osError ].
    ^hBitmap!   
checkRadioItem: item
        "Place a radio style check mark on an item, where item is either
        a label or a selector.  On platforms other than Windows 95, this has
        the same effect as sending checkItem: ."
    | mi |
    ( self isThere: item ) ifFalse: [ ^nil ].
    mi := self getMenuItem: item.
    mi attribute: mi attribute | MfChecked | MftRadiocheck.
    self updateItem: mi!   
dragTargetIsScrollable
		"Private - answer whether instances of the receiver are scrollable as a drag target."
    ^true!   
pointSize: anInteger graphicsMedium: aGraphicsMedium
        "Set the point size of the Font for aGraphicsMedium.
         Font's point size indicates the height of the characters
         in 1/72 inch."
    | logicalSize |
    logicalSize := self class
        pointToLogical: anInteger
        graphicsMedium: aGraphicsMedium.
    logicalFont lfWidth: 0.
    logicalFont lfHeight:   "This should be the negative pixel size of the font"
            ( 0 - (logicalSize y abs) ).   "logicSize can be either positive
                or negative depending on the mapping mode."
    graphicsMedium := aGraphicsMedium.
    pointSize := anInteger.!   
lineSpacing
        "Answer the vertical line size for this font."
    | physFont |
    physFont := self physicalFont.
    ^physFont tmAscent
        + physFont tmDescent
        + physFont tmInternalLeading
        + physFont tmExternalLeading!  
makeFont: aGraphicsMedium
        "Make a host system font  for a aGraphicsMedium
         out of the Smalltalk font description"
    self
        graphicsMedium: aGraphicsMedium;
        makeFont!
initialize
        "Private - Initialize the receiver."
    logicalFont := WinLogFont new.
    "Assuming Proof quality fonts"
    logicalFont lfQuality: ProofQuality.
    graphicsMedium := Display!
logicalFont
        "Private - Answer the LOGFONT structure for the receiver."
    ^logicalFont!
logicalFont: aLogFont
        "Private - Set logicalFont to the LOGFONT structure aLogFont."

    "System puts junk after font name, if we don't pad them 
    with zeros then the key in FontHandleTable won't match"
    aLogFont padWithZeros.

    "Must copy the contents of the structure to preserve unique instance data"
    logicalFont bytesAtOffset: 0 put: aLogFont contents!
bold: aBoolean
        "Set the bold flag of the font to aBoolean."
    aBoolean notNil ifTrue: [
        aBoolean
            ifTrue: [ logicalFont lfWeight: 700 ]      "700 is bold"
            ifFalse: [ logicalFont lfWeight: 400 ] ]   "400 is normal"!  
fixedWidth
        "Answer true if the font is of fixed
         width, else answer false."
     ^( self physicalFont tmPitchAndFamily & 16r01 ) =  0  "Fixed pitch = 0"!  
italic: aBoolean
        "Set the italic flag of the font to aBoolean."
    aBoolean notNil
        ifTrue: [ logicalFont lfItalic: aBoolean asParameter ]!
initFontInfo: aTextMetrics
        "Private - Initialize the receiver with the physical font
         metrics aTextMetrics of the font from the host system."
    self physicalFontAttribute: aTextMetrics.
    faceName := logicalFont szFaceName.
    pointSize isNil ifTrue: [
        pointSize := self class
            pixelToPoint: ( self physicalFont tmHeight - self physicalFont tmInternalLeading )
            graphicsMedium: graphicsMedium ]!
charSize
        "Answer a Point, the x coordinate is the average width
        and the y coordinate is the largest height of
        characters in the font."
    ^self physicalFont tmAveCharWidth @
        (self physicalFont tmHeight "- self physicalFont tmInternalLeading").!
charWidth: aCharacter graphicsTool: aGraphicsTool
        "Answer the width of aCharacter."
    | width widthTable hDC hOld |
    widthTable := ExternalBuffer new: 2.
    hDC := aGraphicsTool handle.
    hOld := GDILibrary selectObject: hDC with: handle.
    ( GDILibrary
        getCharWidth: hDC
        firstChar: aCharacter asciiValue
        lastChar: aCharacter asciiValue
        buffer: widthTable asParameter )
            ifFalse: [ ^self osNotification ].
    width := ( widthTable uShortAtOffset: 0 ) - self overHang.
    GDILibrary selectObject: hDC with: hOld.
    ^width!  
charSize: aPoint
        "Set charSize to aPoint."
    aPoint isPoint
        ifFalse: [ ^self error: 'argument must be a Point' ].
    aPoint x notNil
        ifTrue: [ logicalFont lfWidth: aPoint x ].
    aPoint y notNil
        ifTrue: [ logicalFont lfHeight: aPoint y ].
    pointSize := self class pixelToPoint: aPoint y graphicsMedium: graphicsMedium! 
maxBaselineExtent
        "Answer the receiver's max baseline extent."
    ^self physicalFont tmAscent
        + self physicalFont tmDescent!  
stringWidth: aString graphicsMedium: aGraphicsMedium
        "Answer the width of aString using the
        receiver font in the aGraphicsMedium."
    | answer hDC hOldFont|
    hDC := aGraphicsMedium pen handle.
    hOldFont := GDILibrary selectObject: hDC with: self fontHandle.
    answer := self stringWidth: aString withDC: hDC.
    GDILibrary selectObject: hDC with: hOldFont.
    ^answer!   
physicalFont
        "Private - Answer the TEXTMETRICS structure for the receiver."
    physicalFont isNil ifTrue: [
        physicalFont := WinTextMetrics new.
        self makeFont ].
    ^physicalFont! 
underscore
        "Answer the underscore flag of the font."
    ^self physicalFont tmUnderlined ~= 0.! 
bold
        "Answer whether the font is bold."
      ^self physicalFont tmWeight = 700!
strikeOut
        "Answer the strikeOut flag of the font."
     ^self physicalFont tmStruckOut ~= 0.!   
strikeOut: aBoolean
        "Set the strikeOut flag of the font to aBoolean."
    aBoolean notNil
        ifTrue: [ logicalFont lfStrikeOut: aBoolean asParameter ]!   
initFontHandle
        "Private - Invalidate  the font handle.
         Called during startup."

    self clearFontHandle.

    "Adjust the size of the font if the
     display resolution has changed."

    ( OriginalScreenExtent ~= Display extent )
         ifTrue: [ self mapPointSizeToMedium ]!   
basePoint
        "Answer a Point where the y-coordinate
         is the ascent of the font.  Note:
         charSize y - basePoint y is the
         descent."
        ^0  @ self physicalFont tmAscent!
basePoint: aPoint
        "Private - Obsolete method retained for compatibility.
        base point can not be set since it can not be defined
        in the LOGFONT structure."! 
fixedWidth: aBoolean
        "Set the fixed width to aBoolean"
    aBoolean notNil ifTrue: [
        aBoolean 
            ifTrue: [ logicalFont lfPitchAndFamily: FixedPitch ]
            ifFalse: [ logicalFont lfPitchAndFamily: VariablePitch ] ]!  
makeFont
        "Make a screen font out of the Smalltalk font description."
    | aHandle |
    aHandle := FontHandleTable
        at: self logicalFont contents
        ifAbsent: [ self createFont. ^self ].
    handle := aHandle.
    self extractFontInfo!   
underscore: aBoolean
        "Set the underscore flag of the font to aBoolean."
    aBoolean notNil
        ifTrue: [ logicalFont lfUnderline: aBoolean asParameter ]! 
isImage
        "Answer true if the font is an image font,
         false if it is an outline font."
    ^false!   
italic
        "Answer the italic flag of the font."
    ^self physicalFont tmItalic asBoolean! 
dragTargetIsScrollable
        "Private - answer whether instances of the receiver are scrollable as a drag target."
    ^true! 
indexOf: string at: widthInteger
        "Private - Answer the index of the character gap in
        string that covers the widthInteger."
    (font notNil and: [deviceContext notNil])
        ifTrue: [
            ^font
                indexOf: string
                at: widthInteger
                withDC: deviceContext ]!
foreColor: aColor
        "Set the foreground color of the receiver."
    | color |
    self propertyAt: #foreColor put: aColor.
    self isHandleOk ifFalse: [ ^self ].
    graphicsTool notNil ifTrue: [
        ( color := aColor ) isNil
            ifTrue: [ color := self defaultForeColor ].
        self graphicsToolForeColor: color.
        self invalidateRect: nil ]!  
newSubMenuFor: aMenu
        "Private - Create the menu window for aMenu with
        the receiver as parent. Fill in the window in aMenu
        and answer the menu's number."
    | mw anInteger |
    ( anInteger := UserLibrary createPopupMenu ) = 0
        ifTrue: [ self osWarning. ^nil ].
    mw := self class fromInteger: anInteger.
    mw isHandleOk ifFalse: [ ^nil ].
    aMenu window: mw.
    ^allMenus indexOf: aMenu ifAbsent: [
        allMenus add: aMenu.
        ^allMenus size ]!  
setTextColor: aColor
        "Set the text color. aColor can be an RGB value or an
          index to the color palette."
    | color |
    color := aColor isNil ifTrue: [ Color windowText ] ifFalse: [ aColor ].
    self allHandles do: [ :h |
        ( GDILibrary setTextColor: h with: color asParameter ) = 16rFFFFFFFF
            ifTrue: [ ^self osError ] ]!   
locationVar: aPoint
        "Private - Set the location instance variable to aPoint."
    location := aPoint!   
queryTextAtIndex: index inComboBox: itemId
        "Answers the string at index in combo box identified by itemId."
    | answer |
    answer := String new: 256.
    self sendMessage: CbGetlbtext item: itemId wparam: index lparamStruct: answer.
    ^answer trimNullTerminator asNormalizedString!  
disconnect
        "Disassociate the receiver from its graphics tool."
    graphicsTool isNil ifTrue: [ ^self ].
    graphicsTool := nil!  
boxOfSize: aPoint
        "Private - Answer a Rectangle with extent of aPoint
         and upper left corner at the cursor position."
    | corner |
    corner := Cursor sense.
    ^((corner max: (0 @ 0)) min: (Display extent - aPoint))
        extent: aPoint.!   
destroyCaret
        "Destroy the flashing caret."
    UserLibrary destroyCaret!
modifyMenu: aMenuHandle
        position: positionInteger
        flags: flagsInteger
        newId: idInteger
        newContentsInt: aString
    <api: ModifyMenuA ulong ulong ulong ulong ulong boolean>
    ^self invalidArgument!  
wmCharResultFor: aCharacter
        "Private - Answer the value to return to the host operating system
       character input message when aCharacter is being entered."
    ^nil     " need to let host control process Cr/Tab normally "!
new
		"Answer a new instance of the receiver."
	^super new initialize!  
dialogBoxIndirect: hInstance
    dialogTemplate: hDialogTemplate
    parent: hWndParent
    dialogFunction: lpDialogFunc
        "Private - Open a dialog box with prebuilt template."
    <api: DialogBoxIndirect ulong ulong ulong ulong ulongReturn>
    ^self invalidArgument!  
flags: flags
        "Private - Specifies the dialog box creation flags.
        Kept for compatibility reasons. Use style: instead"
    self style: flags!
constructNotifications
        "Private - answer the mapping between host control
        notification codes and corresponding Smalltalk event
        notifications."
    ^Dictionary new
        at: LbnSelchange put: #notifySelected: ;
        at: LbnDblclk put: #notifyDoubleClicked: ;
        yourself!   
dragTargetDropDefault: dragSession
        "Private - provide default handling of drop if no handler
        is provided by inserting the text at the position under the mouse."

    | dragObject dragFormats format item dropPosition
    dragSourceSelection charsBeforeDropLine dropAfterEndOfText dropOnEmptyLine backwardDrag toCut compensate |

    dragObject := dragSession objects first.
    ( dragFormats := self dragTargetFormats ) isNil
        ifTrue: [ ^self error: 'dragTargetFormats: must be specified' ].
    format := dragFormats detect: [ :s | dragObject hasFormat: s ] ifNone: [ ^nil ].
    ( self dragTargetOperations includes: dragSession operation ) ifFalse: [ ^nil ].
    item := dragObject format: format.

    "Do the insert.  This involves positioning the cursor correctly -- the three cases are:
        - in between two printable characters
        - on an empty line (before the non-printable cr and lf)
        - way past the end of the text"
    dropPosition := self characterCoordinate: dragSession targetLocation.  "charInLine @ line coordinate of the character just BEFORE the cursor"
    charsBeforeDropLine := self charactersBeforeLine: dropPosition y.
    dropAfterEndOfText := ( charsBeforeDropLine < 0 ).
    dropAfterEndOfText
        ifTrue: [
            selection := ( self contents size ) @ ( self contents size ).
            self setSelection ]
        ifFalse: [
            dropOnEmptyLine := ( self lineAt: dropPosition y ) isEmpty.
            compensate := ( dropOnEmptyLine ifTrue: [ 0 ] ifFalse: [ 1 ] ).
            dropPosition x: ( dropPosition x + compensate ).
                "If drop between 3rd and 4th character, it's ready to insert before the 4th, but won't stick it between a cr and lf if the line is empty"
            self selectBefore: dropPosition ].
    self insertAfterSelection: item.

    "if a cut is about to happen, fix up the selection"
    ( ( dragSession source == self ) and: [ dragSession operation asSymbol = #move ] ) ifTrue: [
        dragSourceSelection := self dragSourceSelection.  "startChar @ endChar"
        backwardDrag := ( dropAfterEndOfText not
            and: [ ( dragSourceSelection x ) > ( charsBeforeDropLine + ( dropPosition x ) ) ] ).
        compensate := ( backwardDrag ifTrue: [ item size ] ifFalse: [ 0 ] ).
        toCut := dragSourceSelection + compensate.  "startChar @ endChar"
        self selectCharFrom: ( toCut x ) to: ( toCut y + 1 ) ].

    modified := true! 
dlgDirSelectEx: hDlg
        selectedPathBuffer: lpString
        cbString: anInteger
        listboxId: nIDListBox
    <api: DlgDirSelectEx ulong struct long long boolean>
    ^self invalidArgument!  
fileInFrom: aFileStream
        "Refresh the pane data with the current
         contents of aFileStream."
    self contents: aFileStream contents.
    self modified: false.!
open
        "Private - Open an object (invisible) window."
    self
        create: self windowClass
        title: self label
        style: WsPopup
        extendedStyle: 0
        rectangle: ( 0 @ 0 extent: 0 @ 0 )
        parent: self parent.
    self receiveMessages!
runEventLoop
    "Private - main loop to execute events from the host system."
    [true]
        whileTrue:
            [self readWinQueue.
            CurrentEvent nullEventWin.
            self runPendingEvents.
            self runPeek]!  
wmRbuttonup: wordInteger with: longInteger
        "Private - Process the right button up message."
    self class toolTipInstalled
        ifTrue: [ self relay: WmRbuttonup wparam: wordInteger lparam: longInteger ].
    self
        sendInputEvent: #button2Up:
        with:  (Point fromInteger: longInteger).
    ^nil!   
startUp
        "Private - Initialize the global variable Display. This must
        be done at startup."
    | dc pen aScreen |
    Color initializeSystemColors.
    ( dc := GDILibrary
        createDC: 'Display' asParameter
        deviceName: nil
        output: nil
        initData: nil ) = 0
            ifTrue: [ ^self osError ].
    aScreen := self new.
    aScreen deviceContext: dc.
    pen := Pen forDC: dc medium: aScreen.
    aScreen graphicsTool: pen.
    aScreen setExtent.
    Terminal := aScreen pen.
    Display := aScreen!
wmMove: wparam with: lparam
        "Private - the receiver has been moved on the Display."
    ^nil!   
childAtId: anInteger
        "Answer the child with the id anInteger;
         load (create) the appropriate ControlPane
         object if necessary"
    ^self paneAt: anInteger!   
faceName: aString
        "Set the face name to aString."
    faceName := aString.
    aString notNil ifTrue:
        [ logicalFont szFaceName: aString ].!   
disableControls
        "Private - Disable the scrollbars of the receiver
         and disable its children."
    UserLibrary enableScrollBar: handle type: SbBoth flags: EsbDisableBoth.
    self disable.
    children size ~= 0 ifTrue: [
        children do: [ :each | each disableControls ] ]!   
pie: major minor: minor angles: aPoint
        "Draw a pie wedge whose major axis is major and minor
         axis is minor. aPoint x
         is the starting angle of the arc in degrees. aPoint y is the
         sweeping angle between the starting angle and ending
         angle which goes clockwise if positive and counter-clockwise
         if negative.
         The interior of the pie is not filled."
    | startPoint endPoint boundingBox hBrush points |
    boundingBox := (self location leftAndUp: major @ minor) corner: (
        self location rightAndDown: major @ minor).
    points := self getArcPoints: major minor: minor angles: aPoint.
    startPoint := points at: 1.
    endPoint := points at: 2.
    hBrush := self selectStockObject: NullBrush.
    self pie: boundingBox
        start: startPoint
        end: endPoint.
    self selectObject: hBrush! 
wmSyschar: wordInteger with: longInteger
        "Received a system menu key.  Default is do nothing."
    ^nil
!  
addSystemMenuStyle
        "Add the system menu style."
    ^self addStyle: WsSysmenu!  
isTextPane
        "Answer true if receiver is a kind of TextPane."
    ^false! 
new
		"Answer a new instance of the receiver."
	^super new initialize!  
newWindow
        "Private - answer the new window being created."
    ^NewWindow!  
newWindow: aWindow
        "Private - set the new window being created."
    NewWindow := aWindow!  
isAltKeyDown
        "Answer whether the ALT key is down."
    ^self isKeyDown: AltKey! 
cleanUpWindows
        "Remove the windows that are no longer valid in the
         host system from the receiver."
    | window |
    [ windows copy associationsDo: [ :assoc |
        window := assoc value.
        ( window handle isNil or: [ window handle isValid not ] )
            ifTrue: [ windows removeKey: assoc key ] ] ] evaluateWithoutInterrupts!  
isControlKeyDown
        "Answer whether the CTRL key is down."
    ^self isKeyDown: ControlKey!
warning: aString
        "Display aString in the warning box."
    | oldForeColor oldBackColor box |
    box := Display boundingBox leftBottom extentFromLeftBottom: Display extent // 2.
    oldForeColor := Display pen foreColor.
    oldBackColor := Display pen backColor.
    Display pen
        fill: box color: Color red;
        foreColor: Color white;
        backColor: Color red;
        place: box leftTop;
        cr;
        nextPutAll: aString;
        foreColor: oldForeColor;
        backColor: oldBackColor!
remove: events for: aWindow
        "Private - Remove queued events for aWindow."
    [   CurrentEvents copy do: [ :e |
            ( ( e receiver == aWindow ) and: [ events includes: e selector ] )
                ifTrue: [ CurrentEvents remove: e ifAbsent: [ nil ] ] ] ] evaluateWithoutInterrupts!   
closeAllHelpWindows
        "Private - Close all HelpManager windows."
    windows do: [ :w |
        w isApplicationWindow ifTrue: [
            w helpManager notNil
                 ifTrue: [ w helpManager closeHelpWindow ] ] ]!   
clearSavedWindows
    "Private - Clear the savedWindows list."

    savedWindows := nil!   
isShiftKeyDown
        "Answer whether the SHIFT key is down."
    ^self isKeyDown: ShiftKey!   
findWindow: aWindowHandle
        "Private - Answer the Window whose handle is aWindowHandle."
    ^windows at: aWindowHandle asInteger ifAbsent: [ nil ]!  
getFocusWindow
        "Answers the window object that has focus."
    | hwndFocus |
    hwndFocus := WindowHandle queryFocus.
    hwndFocus = WindowHandle nullValue ifTrue: [ ^nil ].
    ^self findRealWindow: hwndFocus! 
run
        "Private - initiate the main loop to execute events from the
        host system."
    CurrentProcess evaluate: (Message
        receiver: self
        selector: #runEventLoop)!
initialize
        "Private - Initialize the receiver."
    windows := Dictionary new!  
add: aWindow
        "Private - Add aWindow to the Notifier so aWindow can
         receive incoming events."
    [ windows at: aWindow handle asInteger put: aWindow ]
        evaluateWithoutInterrupts!
empty
        "Private - Empty CurrentEvents by performing
        all the Messages in it."
    | e aWindow |
    [ CurrentEvents notEmpty ] whileTrue: [
        [ e := CurrentEvents removeFirst ] evaluateWithoutInterrupts.
        e receiver isNil ifTrue: [
            aWindow := self findWindow: WindowHandle queryFocus.
            e receiver: aWindow ].
        e receiver isNil ifFalse: [ e perform ] ]!
isEscapeKeyInput: aMessage
        " Answer whether the event aMessage
        is an ESC key input."
    ^aMessage selector = #keyboardInput:
        and: [ ( aMessage arguments at: 1 ) virtualKey = EscapeKey ]!   
windows
        "Answer the collection of open windows."
    ^windows!  
initializeWindowHandles
        "Private - Sets the handle of the windows in the
         NotificationManager to nil."
    windows do: [ :w | w handle: WindowHandle nullValue ]!  
remove: aWindow
        "Private - Remove aWindow from the Notifier."
    self removeEventsFor: aWindow.
    [ windows removeKey: aWindow handle asInteger ifAbsent: [ nil ] ]
        evaluateWithoutInterrupts! 
selectorFor: aMessageNumber
        "Private - Answer the selector which corresponds
         to the Win message aMessageNumber."
    | selector |
    selector := ( ( aMessageNumber <= OperatingSystemEvents size ) and: [ aMessageNumber > 0 ] )
        ifTrue: [  OperatingSystemEvents at: aMessageNumber ]
        ifFalse: [ OperatingSystemEventsExtra at: aMessageNumber ifAbsent: [ nil ] ].
    ^selector isNil ifTrue: [ #unknownEvent:with: ] ifFalse: [ selector ]! 
postInputEvent: aMessage
        "Private - Add a Message to CurrentEvents."
    [ CurrentEvents add: aMessage ] evaluateWithoutInterrupts.
    OSEventSemaphore signal!   
resume: oldWindows
        "Private - Recreate all the saved windows and run."
    ( ( oldWindows size = 0 ) or: [ Transcript == nil ] )
        ifTrue: [ ^self initializeTranscript ].
    Transcript setLabel.
    self relocateWindows: oldWindows.
    self reopenWindows: oldWindows! 
removeEventsFor: aWindow
        "Private - Remove queued and deferred events for aWindow."
    [   CurrentEvents copy do: [ :e |
            e receiver == aWindow
                ifTrue: [
                    CurrentEvents remove: e ifAbsent: [ nil ].
                    "e perform" ] ].
        DeferredRequests copy do: [ :e |
            e receiver == aWindow
                ifTrue: [
                    DeferredRequests remove: e ifAbsent: [ nil ].
                    "e perform" ] ] ] evaluateWithoutInterrupts!  
dragSourceNeedsObjectDefault: dragSession
        "Private - provide default for requested drag items if no handler
        is provided by supplying the currently selected items."
    | objects dragDropObject |
    objects := OrderedCollection new.
    self selectedItems do: [ :item |
        dragDropObject := dragSession objectClass new
            object: item;
            string: ( self stringForItem: item );
            yourself.
        objects add: dragDropObject ].
    dragSession objects: objects! 
getActiveWindow
    <api: GetActiveWindow ulongReturn>
    ^self invalidArgument!   
ctl3dIfEnabled
        "Answer the Ctl3d32DLL class if present and enabled, otherwise answer nil."
	| ctl3d |
	ctl3d := Smalltalk at: #Ctl3d32DLL ifAbsent: [ ^nil ].
	^ctl3d enabled ifTrue: [ ctl3d ] ifFalse: [ nil ]! 
leftButtonScrollInterval
        "Private - answer the interval (in milliseconds) for the timer used
        to process left button scrolling."
    ^30!   
scrollTopCorner: aPoint
        "Private - Move the contents of the receiver
         pane by extent aPoint."
    | oldCorner |
    oldCorner := topCorner deepCopy.
    topCorner := topCorner - aPoint.
    oldCorner = topCorner ifTrue: [^self].
    ( UserLibrary scrollWindow: handle
        xAmount: aPoint x
        yAmount: aPoint y
        lpRect: nil
        clipRect: nil )
            ifFalse: [ ^self osError ].
    graphicsTool setWindowExt: rectangle extent.
    ( GDILibrary offsetViewportOrgEx: graphicsTool handle
        x: aPoint x
        y: aPoint y
        oldPosition: nil )
            ifFalse: [ ^self osError ].
    graphicsTool
        width: rectangle extent x;
        height: rectangle extent y.
    ( UserLibrary updateWindow: self handle )
        ifFalse: [ ^self osError ]!
tabStop
        "Make the dialog item recieve the focus when the user
        presses the TAB key.  Ignored for static controls because they
        can never be a tabstop."! 
canTab
        "Private - Static controls do not take focus, so cannot
        be tabbed into."
    ^false!
noTabStop
        "Make the receiver not be a tabstop.  Ignored
        for static controls because they can never be a tabstop."!  
subclassRecursively
        "Private - subclass the children."
    children size > 0 ifTrue: [
        children do: [ :child | child subclassRecursively ] ]!  
isATabStop
        "Private - Answer whether the receiver is a tabstop"
    ^false! 
getDialogProcInstance
        "Private - Obtain the Dialog proc instance address."
    ^ DialogProcInstance.!   
findWindow: handle
        "Private - Answer the menu with the given <handle>."
    self window notNil ifTrue: [
        handle = self window handle ifTrue: [ ^self ] ].
    items do: [ :i |
        i submenu notNil ifTrue: [
            ( i submenu findWindow: handle ) notNil ifTrue:[
                ^i submenu findWindow: handle ] ] ].
    ^nil! 
registerHookProc
        "Private - register the message filter hook proc as a CallBack,
         and answer the CallBack instance"
    | message anInteger threadId |
    message := Message new
        receiver: self;
        selector: #helpHook:wparam:lparam: ;
        yourself.
    HelpHookProc := CallBack
        registerMessage: message
        parameterTypes: #( #long #ulong #ulong )
        returnType: #ulong
        callingConvention: #api.
    threadId := KernelLibrary getCurrentThreadId.
    ( anInteger := UserLibrary
        setWindowsHookEx: WhMsgfilter
        proc: HelpHookProc asParameter
        module: 0
        thread: threadId ) = 0
            ifTrue: [ self osWarning ].
    NextMessageFilterProc := ExternalHandle fromInteger: anInteger!
windowUnderPoint: aPoint
        "Answer the window that is currently
         under aPoint, or nil if not a Smalltalk window.
        Hidden and disabled windows are ignored."
    | point handle |
    point := WinPoint fromPoint: aPoint.
    handle := UserLibrary windowFromPoint: point asParameter.
    ^Notifier findWindow: handle! 
buildItemAccel: i menu: menuNumber parent: menuBar
        "Private - Build the accelerator for the i'th item."
    | a |
    accel size >= i ifTrue: [
        ( a := accel at: i ) notNil ifTrue: [
            1 to: a size // 2 do: [ :index |
                menuBar accelTable
                    at: ( Array with: ( a at: index * 2 - 1 ) with: ( a at: index * 2 ) )
                    put: ( menuNumber * 256 + i ) ] ] ]!  
destroyWindow: aWindowHandle
    <api: DestroyWindow ulong boolean>
    ^self invalidArgument!  
releaseAllObjects
        "Private - Deselect all objects and delete the
         Pen and Brush objects."
    self selectObject: (DefaultObjects at: 'Pen').
    "logicalTool notNil ifTrue: [logicalTool initHandle]."
    self selectObject: (DefaultObjects at: 'Brush').
    self selectObject: (DefaultObjects at: 'Bitmap').
    self selectObject: (DefaultObjects at: 'Font')! 
initialize
        "Private - Initialize openFileNameStruct"
    super initialize.
    openFileNameStruct :=  ( SelfDefinedStructure named: 'OPENFILENAME' ).
    openFileNameStruct lStructSize: openFileNameStruct sizeInBytes.
    fileName := String new.
    filters := OrderedCollection new.
    self style: OfnNochangedir!
width
        "Answer the width of the receiver."
    ^bitmapInfo width!
indexOf: string at: widthInteger withDC: hDC
        "Answer the index of the character gap in
         string that covers the widthInteger. Use
         the font associated with device context hDC."
    | widthTable loc cCharWidth widthTableParm index |
    loc := 0.
    widthTable := ExternalBuffer new: 2.
    widthTableParm := widthTable asParameter.
    string isEmpty
        ifTrue: [index := 1]
        ifFalse: [
            1 to: string size do: [:i |
                ( GDILibrary
                    getCharWidth: hDC
                    firstChar: ( string at: i ) asciiValue
                    lastChar: ( string at: i ) asciiValue
                    buffer: widthTableParm )
                        ifFalse: [ ^self osNotification ].
                cCharWidth := ( widthTable uShortAtOffset: 0 ) - self overHang.
                (loc := loc + cCharWidth) > widthInteger ifTrue: [
                    loc - widthInteger < (widthInteger - (loc - cCharWidth))
                        ifTrue: [^i + 1]
                        ifFalse: [^i]].
                index := i]].
    ^index+1!   
close
        "Private - Close the window."
    self stopReceivingMessages.
    graphicsTool isGraphicsTool ifTrue: [
        graphicsTool destroy.
        graphicsTool := nil ].
    children size > 0 ifTrue: [
        children do: [ :subpane | subpane close ] ].
    self destroy.!
trackPopupMenu: aMenuHandle
        flags: flagsInteger
        x: xInteger
        y: yInteger
        reservedInt: zeroInteger
        window: aWindowHandle
        reservedStruct: nullStruct
    <api: TrackPopupMenu ulong ulong long long long ulong struct boolean>
    ^self invalidArgument!
boxFilled: aPoint
        "Draw a box using the current location as one corner
         and aPoint as the opposite corner. The box is filled
         with the current background color."
    | currentPosition  |
    currentPosition := self location.
    self rectangleFilled: ( currentPosition corner: aPoint )!  
deleteAuxiliaryDC
        "Private - Delete the auxiliary device context."
    ( GDILibrary deleteDC: AuxiliaryDC ) ifFalse: [ ^self osError ]! 
dragTargetDrawSeparatorEmphasis: aPoint
		"Private - draw the target emphasis for the receiver
		given the cursor location aPoint (relative to the receiver).
		Emphasis is drawn indicating spaces between existing
		characters as individual targets."
	| index lastIndex pt |
	index := ( self characterCoordinate: aPoint ).
	index := ( index x min: ( self lineAt: index y ) size ) @ ( index y "min: self totalLength" ).  "restrict within bounds"
		"only update if changed"
	lastIndex := self dragTargetSelection.
	index = lastIndex ifTrue: [ ^nil ].  "don't draw emphasis if already drawn."
	lastIndex notNil ifTrue: [ self dragTargetEraseSeparatorEmphasis ].
	pt := self bitCoordinate: index.
	self dragTargetDrawEmphasisCaretFrom: pt to: ( pt down: self font height ).
	self dragTargetSelection: index!  
openOn: aColor
        "Open the receiver & select aColor initially."
     self color: aColor; open!
initialize
        "Private - Initialize chooseColorStruct"
    super initialize.
    chooseColorStruct := SelfDefinedStructure named: 'CHOOSECOLOR'.
    chooseColorStruct lStructSize: chooseColorStruct sizeInBytes.
    self style: CcRgbinit.
    self color: ClrBlack.
    self customColors: (Array new: 16).!  
chosen
        "Public - Answer the color the user chose."
    ^chosen! 
color: aColor
        "Specifies the initial color setting of the dialog box."
    | rgbInteger |
    aColor isNil ifTrue: [ ^nil ].
    aColor isRGBColor ifTrue: [ rgbInteger := aColor asInteger ].
    aColor isIndexedColor ifTrue: [ rgbInteger := aColor asRGBColor asInteger ].
    aColor isInteger ifTrue: [
        rgbInteger := aColor.
        aColor & 16r01000000 = 16r01000000  "indexed color integer"
            ifTrue: [ rgbInteger := GraphicsTool paletteToRgb: rgbInteger ] ].
    chooseColorStruct rgbResult: rgbInteger!
open
        "Bring up a color dialog."
    | error |
    hLibrary := CommonDialogDLL current.
    self copyStruct.

    parent isWindow ifFalse: [
        parent := Notifier findWindow: WindowHandle queryActive.
        chooseColorStruct hwndOwner: parent asParameter ].
    style notNil ifTrue: [ chooseColorStruct flags: style ].
    ( hLibrary chooseColor: chooseColorStruct asParameter )
        ifTrue: [ self checkFlags ]
        ifFalse: [
            error := ( ExternalLong fromString: hLibrary commDlgExtendedError ) asInteger.
            error ~= 0 ifTrue: [
                self cleanUp.
                ^self osError: error ] ].
    self cleanUp.!   
dragTargetEraseEmphasisDefault: dragSession
		"Private - draw the target emphasis for the receiver
		given the cursor location aPoint (relative to the receiver)."
	| emphasisStyle |
	self dragTargetSelection isNil ifTrue: [ ^nil ].  "don't erase if no emphasis currently drawn."
	emphasisStyle := self dragTargetEmphasis.
	emphasisStyle = 'item'
		ifTrue: [ self dragTargetEraseItemEmphasis ]
		ifFalse: [
			emphasisStyle = 'separator'
				ifTrue: [ self dragTargetEraseSeparatorEmphasis ]
				ifFalse: [ self dragTargetErasePaneEmphasis ] ].
	self dragTargetSelection: nil!   
isPushButton
        "Answer whether the receiver is an instance of a push button"
	^false! 
createCaret: instanceHandle bitmap: bitmapHandle width: widthInteger height: heightInteger
    <api: CreateCaret ulong ulong long long boolean>
    ^self invalidArgument!  
wmSetfocus: wordInteger with: longInteger
        "Private - Process the set focus message."
    self sendInputEvent: #gettingFocus.
    ^nil! 
bound
        "Private - the GUI library has been bound, complete its installation."
    ( self class compiledMethodAt: #bound ) smalltalkLibrary releaseUnbindInfo.
    Icon runtimeIcon needsFinalization.
    self initializeStructures.
    SessionModel current guiLoaded: true!
openSegment: id
        "Open the segment identified by id."
    | segment |
    segmentIsOpen ifTrue: [ self closeSegment ].
    segment := StoredPicture new.
    segment startRecording.
    segments at: ( currentId := id ) put: segment.
    segmentIsOpen := true.
    ^id!
displayWith: aPen
        "Display the receiver through aPen."
    ^apmHeader isNil
        ifTrue: [ self privateDisplayWith: aPen ]
        ifFalse: [ self displayAt: 0@0 with: aPen ]!
isMenu
        "Answer true if receiver is a kind of Menu."
    ^false! 
id
        "Answer the id of the receiver."
    ^self propertyAt: #id!  
dragTargetScrollTimerId
		"Private - answer the id of the timer to use for drag scrolling."
    ^3! 
numberOfColors
		"Answer the number of colors in the receiver."
	self bitCount = 24
		ifTrue: [ ^ 0 ]		"A 24 bit count bitmap has no color table."
		ifFalse: [ ^( 1 bitShift: self bitCount ) ].!
fromScreen: aRect
        "Answer an instance of the receiver
         copied from the screen rectangle aRect."
    | bitmap |
    bitmap := self screenExtent: aRect extent.
    bitmap pen copy: Display pen
        from: aRect
        at: 0 @ 0.
    ^bitmap!
archiveAndRelease
        "Ensure that the receiver's bits are archived.
         Release the receiver from the system."
    archive isNil ifTrue: [archive := self getDIBits].
    self release! 
charLowerBuff: aString length: anInteger
    <api: CharLowerBuffA struct ulong ulongReturn>
    ^self invalidArgument!  
popup
        "Answer nil for no popup menu."
    ^nil! 
fromWmChar: wparam with: lparam
        "Private - answer an instance of the receiver class corresponding to
        the host WM_CHAR message described by the arguments."
    | event shiftState char scanCode |
    event := self new.

    shiftState := 0.
    ( Notifier isShiftKeyDown ) ifTrue: [ shiftState := shiftState bitOr: AfShift ].
    ( Notifier isControlKeyDown ) ifTrue: [ shiftState := shiftState bitOr: AfControl ].
    ( Notifier isAltKeyDown ) ifTrue: [ shiftState := shiftState bitOr: AfAlt ].
    event shiftState: shiftState.

    char := wparam.
        "for OS/2 compatibility, simulate a BackTab, even though Windows does not distinguish"
    ( char = VkTab and: [ Notifier isShiftKeyDown ] ) ifTrue: [ char := 7 ].
    event characterValue: char.

    scanCode := ( lparam bitShift: -16 ) bitAnd: 16rFF. "byte 3 is scan code"
    event scanCode: scanCode.

    ( ControlKeys includes: char ) ifTrue: [ event virtualKey: char ].

    ^event!  
endDeferWindowPos: aHandle
        "Private - End the defer of setting window position for anInteger
         number of windows so that all drawing can take place."
    <api: EndDeferWindowPos ulong boolean>
    ^self invalidArgument!
dragSessionClass: aClass
        "Set the class to use to model a drag drop transfer to aClass."
    self propertyAt: #dragSessionClass put: aClass!
createMasks
        "Private - Create the AND and XOR masks for the receiver."
    andMask := Bitmap  extent: self extent.
    xorMask := Bitmap width: self extent x height: self extent y planes: 1 bitCount: 4.
    andMask pen fill: andMask boundingBox
        rule: Blackness.
    xorMask pen fill: xorMask boundingBox
        rule: Whiteness!   
startUpSampleGuiApplication
        "Private - start the sample runtime application."
    | topPane window |
    window := ViewManager new.
    window
        addView: ( topPane := TopPane new
            label: 'Sample Application';
            windowPolicy: StandardWindowPolicy new;
            owner: window;
            yourself ).
    self isRunTime
        ifTrue: [ topPane when: #closed send: #exitSampleApplication to: self ].
    window
        addSubpane: ( TextPaneControl new
            owner: window;
            setName: #pane;
            contents: 'Hello, World';
            yourself );
    openWindow!  
for: aString
        "Answer a new instance of class StringModel
         containing an OrderedCollection of strings
         created from aString by separating it at
         the line-feed characters."
    ^self new string: aString.!   
fileOutOn: aStream
        "Write the receiver contents to aStream."
    lines do: [ :aString | aStream nextPutAll: aString; cr]!   
deleteCharIn: selection
        "Private - Delete the first character in
         the selection.  Answer a Point describing
         the character position before the deletion."
    | line answer |
    answer := selection origin.
    line := lines at: answer y.
    lines at: answer y put:
        (line
            copyReplaceFrom: answer x
            to: answer x
            with: '').
    answer := answer - (1@0).
    self
        broadcastChangesIn: selection
        upTo: answer
        withExcess: line size - answer x.
    ^answer!   
appendChar: aCharacter
        "Append aCharacter to the end of the last
         line and inform the text pane to update."
    | origin |
    lines isEmpty ifTrue: [ lines add: String new ].
    origin := ( extent x + 1 ) @ extent y.
    aCharacter == Lf
        ifTrue: [ lines add: String new ]
        ifFalse: [
            aCharacter == Tab
                ifTrue: [ lines at: lines size put: lines last, ( self tabStringAt: origin x ) ]
                ifFalse: [ lines at: lines size put: ( lines last copyWith: aCharacter ) ] ].
    extent := self extent.
    lastChild update: ( TextSelection origin: origin corner: extent )!  
appendText: aString
        "Append aString to the end of the last line
         and inform the text pane to update."
    | origin |
    origin := (extent x + 1) @ extent y.
    lines isEmpty
        ifTrue: [lines add: aString]
        ifFalse: [
            lines at: lines size put: lines last, aString].
    extent x: lines last size.
    lastChild update: (
        TextSelection origin: origin corner: extent)!   
detectCr: aString
        "Private - Answer the first line delimiter
        found in aString, either Cr or Lf."
    aString do: [:char |
        char = Cr ifTrue: [^Cr].
        char = Lf ifTrue: [^Lf]].
    ^Cr!   
extent
        "Answer the last character position
         in the text as a Point."
    lines size <= 0
        ifTrue: [^0 @ 1]
        ifFalse:[^lines last size @ (lines size)]! 
searchBack: aTextSelection for: aPattern
        "Search backward for aPattern starting from
         the end of aTextSelection.  Answer the
         matched selection if found, else answer nil."
    | row col answer |
    row := aTextSelection corner y min: lines size.
    col := aTextSelection corner x + 1.
    row to: 1 by: -1 do: [ :i |
        (answer := aPattern match: (lines at: i) index: col)
            isNil ifFalse: [
                ^aTextSelection
                    origin: answer x @ i
                    corner: answer y @ i].
        col := 1].
    ^nil!   
delete: selection
        "Delete the text contained in selection.
         Answer the Point position before the
         deletion."
    | line answer excess |
    answer := selection origin.
    (answer == selection corner
        and: [(lines at: answer y) size >= answer x])
            ifTrue: [^self deleteCharIn: selection].
    line := self rightPartAfter: selection corner.
    excess := line size.
    line := (self leftPartBefore: answer), line.
    answer := answer - (1@0).
    self
        replaceLinesIn: selection with: line;
        broadcastChangesIn: selection
            upTo: answer
            withExcess: excess.
    ^answer!
string
        "Answer a String containing
         the receiver contents."
    ^self convertToString: lines!  
lineAt: anInteger
        "Answer the String in the
         line indexed by anInteger."
    (lines size >= anInteger and:
        [anInteger > 0])
        ifTrue: [^lines at: anInteger]
        ifFalse: [^'']!  
convertToString: aCollection
        "Private - Answer a String containing the
         concatenation of aCollection of lines."
    | tally index result line i anyDBLines |
    tally := 0.
    anyDBLines := false.
    1 to: aCollection size do: [ :anIndex |
        line := aCollection at: anIndex.
        (line isEmpty or: [line last ~= $ ])
            ifFalse: [
                i := line size - 1.
                [i > 0 and: [(line at: i) == $ ]]
                    whileTrue: [i := i - 1].
                (i > 0 and: [(line at: i) == $$])
                    ifTrue: [i := i + 1].
                line := line copyFrom: 1 to: i.
                aCollection at: anIndex put: line].
        line isDoubleByteString ifTrue: [anyDBLines := true].
        tally := tally + line size + 2].            "2 for Cr-Lf"
    result := (anyDBLines
        ifTrue: [ DoubleByteString new: tally ]
        ifFalse: [ String new: tally ]).
    index := 1.
    aCollection do: [ :aLine |
        result
            replaceFrom: index
            to: index + aLine size - 1
            with: aLine.
        index := index + aLine size + 2.
        result at: index - 2 put: Cr.
        result at: index - 1 put: Lf].
    ^result!   
totalLength
        "Answer the number of lines
         held by the receiver."
    ^lines size!   
replaceGapBefore: aPoint withChar: aCharacter
        "Private - Insert aCharacter before aPoint.
         Answer the number of characters
         to the right of aPoint on the insertion line."
    | line position |
    position := aPoint x - 1.
    line := lines at: aPoint y.
    position = line size
        ifTrue: [
            lines at: aPoint y put:
                (line := line, (String with: aCharacter))]
        ifFalse: [position < line size
            ifTrue: [
                lines at: aPoint y put:
                    (line := line
                        copyReplaceFrom: position + 1
                        to: position
                        with: (String with: aCharacter))]
            ifFalse: [
                lines at: aPoint y put:
                    (line := (self leftPartBefore: aPoint),
                        (String with: aCharacter))]].
    ^line size - aPoint x!
getPointAt: index
        "Private - Answer a Point whose position
         corresponds to index when treating the lines
         of the receiver as one string."
    | row column lineSize |
    row := 1.
    column := index.
    [(column := column - (lineSize := (self lineAt: row) size + 2)) > 0]
        whileTrue: [row := row + 1].
    ^(lineSize + column) @ row!   
replaceLinesIn: aTextSelection with: aString
        "Private - Replace the selected text with aString."
    | top height |
    top := aTextSelection top.
    ((height := aTextSelection height) = 1)
        ifTrue: [lines at: top put: aString]
        ifFalse: [
            lines := lines
                replaceFrom: top
                to: top + height - 1
                with: (OrderedCollection with: aString)]!   
string: aString
        "Change the receiver contents to aString
         (lines are separated by line-feeds)."
    | s |
    s := aString.
    s isNil ifTrue: [ s := String new ].
    extent := 0@0.
    lines := OrderedCollection new.
    self fileInFrom: ( ReadStream on: s )!
broadcastChangesIn: aTextSelection
    upTo: aPoint
    withExcess: excess
        "Private - Inform the text pane to update the changed
         area (a Rectangle) whose corner is the maximum
         of the aTextSelection corner and the sum of aPoint
         and excess."
    | origin corner newExtent |
    origin := aTextSelection origin.
    corner := aTextSelection corner.
    corner = aPoint
        ifFalse: [
            (aPoint isBefore: corner)
                ifTrue: [
                    corner := corner x + excess @ corner y]
                ifFalse:[
                    corner := aPoint x + excess @
                        aPoint y]].
    (newExtent := self extent) = extent
        ifFalse: [
            (newExtent isBefore: extent)
                ifTrue: [corner := extent]
                ifFalse:[corner := newExtent].
            extent := newExtent].
    lastChild update: (
        TextSelection origin: origin corner: corner)!
frame: aRectangle
        "Change the frame to aRectangle."
    frame := aRectangle!
extendTo: aPoint
        "Private - If needed, extend lines
         to aPoint by adding empty strings."
    | index |
    index := aPoint y.
    [index > lines size]
        whileTrue: [lines add: (String new: 0)]! 
fileInFrom: aStream
        "Replace receiver's contents
         with the contents of aStream."
    | line |
    lines := OrderedCollection new.
    [aStream atEnd] whileFalse: [
        line := aStream nextLine.
        lines add: ( line replaceCharacter: Tab from: 1 to: line size withString: '    ' ) ].
    extent := self extent!
charAt: aPoint
        "Private - Answer the character at aPoint."
    | line |
    (aPoint y between: 1 and: lines size) ifFalse: [^nil].
    line := lines at: aPoint y.
    aPoint x < 1 ifTrue: [^nil].
    aPoint x > line size ifTrue: [^Space].
    ^line at: aPoint x! 
scanner: aCharacterScanner
        "Set scanner to aCharacterScanner."
    charScanner := aCharacterScanner!
stringIn: aTextSelection
        "Answer a String which concatenates all
         the lines contained in the aTextSelection."
    |origin corner |
    origin := aTextSelection origin.
    corner := aTextSelection corner.
    self extendTo: corner.
    (corner isBefore: origin)
        ifTrue: [^String new: 0]
        ifFalse:[
            origin y = corner y
                ifTrue: [
                    ^(self leftPartBefore: corner + (1@0))
                        copyFrom: origin x
                        to: corner x]
                ifFalse: [
                    ^self convertToString:
                        (self linesIn: aTextSelection)]]!   
topCorner: aPoint
        "Change topCorner to aPoint."
    topCorner := aPoint!
displayAll
        "Display the text contained in the pane."
    | firstLine lastLine fontHeight |
    charScanner := lastChild pen.
    firstLine := lastChild topCorner y.
    fontHeight := charScanner font height.
    lastLine := frame height //
         fontHeight + firstLine
         min: lines size.
    lastChild doGraphics: [charScanner
        displayAll: lines
        from: firstLine
        to: lastLine
        at: lastChild topCorner x].! 
textPane: aTextPane
        "Private - Associates aTextPane to the receiver
         by setting the lastChild to it."
    lastChild := aTextPane!  
rightPartAfter: aPoint
        "Private - Answer a String containing the
         characters to the right of aPoint."
    | aString |
    aString := lines at: aPoint y.
    aString size <= aPoint x
        ifTrue: [^String new: 0]
        ifFalse: [
            ^aString
                copyFrom: aPoint x + 1
                to: aString size]!
searchFrom: aTextSelection for: aPattern
        "Search for aPattern starting from
         the end of aTextSelection.  Answer the
         matched selection if found, else answer nil."
    | row col answer |
    row := aTextSelection corner y.
    col := aTextSelection corner x + 1.
    row to: lines size do: [ :i |
        (answer := aPattern match: (lines at: i) index: col)
            isNil ifFalse: [
                ^aTextSelection
                    origin: answer x @ i
                    corner: answer y @ i].
        col := 1].
    ^nil!  
leftPartBefore: aPoint
        "Private - Answer the substring prior
         to aPoint on that point's line."
    | line position |
    position := aPoint x - 1.
    aPoint y > lines size
        ifTrue: [
            ^(String new: position) atAllPut: Space].
    line := lines at: aPoint y.
    position <= line size
        ifTrue: [
            ^line copyFrom: 1 to: (0 max: position)]
        ifFalse: [
            ^line,
                ((String new: position - line size)
                    atAllPut: Space)]! 
maxLineBetween: x and: y
        "Answer the max line between
         line x and line y."
    | answer index |
    answer := 0.
    x to: (y min: lines size) do: [:i |
        answer := (lines at: i) size max: answer.
        (answer = (lines at: i) size)
            ifTrue: [index := i]].
    ^index isNil
        ifTrue: [ String new ]
        ifFalse: [ lines at: index ]!  
linesIn: aTextSelection
        "Answer an OrderedCollection of
         the lines contained in aTextSelection."
    | someLines origin corner |
    origin := aTextSelection origin.
    corner := aTextSelection corner.
    self extendTo: corner.
    someLines := OrderedCollection new.
    someLines add:
        (self rightPartAfter: origin - (1 @ 0)).
    (corner y - origin y) > 1
        ifTrue: [
            someLines addAll:
                (lines
                    copyFrom: origin y + 1
                    to: corner y - 1)].
    someLines add:
        (self leftPartBefore: corner + (1 @ 0)).
    ^someLines!   
replaceAtColumns: aPoint by: aString startAt: aTextSelection
        "Private - replace the line contents between the coordinates
         of aPoint with aString in aTextSelection.
         Answer a TextSelection of the new string."
    | row col |
    row := aTextSelection origin y min: lines size + 1.
    row to: lines size do: [:i |
        lines at: i put:
            (self leftPartBefore: aPoint x @ i), aString,
            (self rightPartAfter: aPoint y @ i)].
    col := aPoint x + aString size.
    ^aTextSelection
        origin: col @ lines size
        corner: col - 1 @ lines size!
replaceWithLf: aTextSelection
        "Private - Replace the text in aTextSelection with the
         line-feed character.  Answer the position
         of the new line.  Inform the text pane of
         the change."
    | origin corner endOfReplacement |
    origin := aTextSelection origin.
    corner := aTextSelection corner.
    self extendTo: corner.
    lines := lines
        replaceFrom: origin y
        to: corner y
        with:
            (OrderedCollection
                with: (self leftPartBefore: origin)
                with: (self rightPartAfter: corner)).
    endOfReplacement := 0 @ (origin y + 1).
    self
        broadcastChangesIn: aTextSelection
        upTo: endOfReplacement
        withExcess: (lines at: origin y + 1) size.
    ^endOfReplacement!   
replace: aTextSelection withChar: aCharacter
        "Replace the text in aTextSelection with aCharacter.
         Answer a Point describing the position of the new
         character.  Inform the text pane of the change."
    | origin corner line excess |
    aCharacter == Lf
        ifTrue: [^self replaceWithLf: aTextSelection].
    aCharacter == Tab
        ifTrue: [^self replaceWithTab: aTextSelection].
    origin := aTextSelection origin.
    corner := aTextSelection corner.
    self extendTo: corner.
    (corner isBefore: origin)
        ifTrue: [
            excess := self
                replaceGapBefore: origin
                withChar: aCharacter]
        ifFalse: [
            line := self rightPartAfter: corner.
            excess := line size.
            line := (self leftPartBefore: origin)
                 , (String with: aCharacter)
                 , line.
            self replaceLinesIn: aTextSelection with: line].
    self
        broadcastChangesIn: aTextSelection
        upTo: origin
        withExcess: excess.
    ^origin! 
replace: aTextSelection withText: aString
        "Replace the text in aTextSelection with aString.
         Answer a Point describing the position of the last
         replacement character.  Inform the text pane
         of the change."
    | newLines line endOfReplacement stream noneYet excess cr |
    self extendTo: aTextSelection corner.
    (aString isNil or: [aString isEmpty])
        ifTrue: [^self delete: aTextSelection].
    newLines := OrderedCollection new.
    noneYet := true.
    stream := ReadStream on: aString.
    cr := self detectCr: aString.
    [stream atEnd]
        whileFalse: [
            noneYet
                ifTrue: [
                    noneYet := false.
                    newLines add:
                        (self leftPartBefore: aTextSelection origin),
                            (stream upTo: cr)]
                ifFalse:[newLines add: (stream upTo: cr)].
            cr == Cr ifTrue: [stream peekFor: Lf]].
    noneYet
        ifTrue: [
            newLines add:
                (self leftPartBefore: aTextSelection origin)].
    endOfReplacement := (newLines last size) @
        (aTextSelection top + newLines size - 1).
    line := self rightPartAfter:
            aTextSelection origin + aTextSelection extent - (1@1).
    excess := line size.
    newLines at: newLines size put: newLines last , line.
    newLines size = 1
        ifTrue: [
            self
                replaceLinesIn: aTextSelection
                with: newLines first ]
        ifFalse: [
            lines := lines
                replaceFrom: aTextSelection top
                to: aTextSelection top + aTextSelection height - 1
                with: newLines].
    self
        broadcastChangesIn: aTextSelection
        upTo: endOfReplacement
        withExcess: excess.
    ^endOfReplacement!
replaceWithTab: aTextSelection
        "Private - Replace the text in aTextSelection with the
         Tab character.  Answer the position of the
         Tab.  Inform the text pane of the change."
    ^self
        replace: aTextSelection
        withText: (self tabStringAt: aTextSelection origin x)!  
adjustPoint: aPoint
        "Private - Answer a Point representing
         aPoint adjusted to a valid text position."
    | x y |
    (aPoint x > 0 and: [aPoint y > 0])
        ifTrue: [^aPoint].
    x := aPoint x.  y := aPoint y.
    x < 1 ifTrue: [y := y - 1].
    y < 1 ifTrue: [^1 @ 1].
    x < 1 ifTrue: [
        y <= lines size
            ifTrue: [x := (lines at: y) size + 1]
            ifFalse:[x := 1]].
    ^x @ y! 
getSelectionFrom: beginIndex to: endIndex
        "Answer a TextSelection containing the characters
         from beginIndex to endIndex, treating the lines
         of the receiver as one string."
    ^TextSelection
        origin: (self getPointAt: beginIndex)
        corner: (self getPointAt: endIndex)! 
scanForWordAt: aPoint
        "Find the word which surrounds the point."
    | start end row col i |
    lines isEmpty ifTrue: [
        ^1 @ 1 corner: 0 @ 1].
    start := aPoint x.
    aPoint y > lines size
        ifTrue: [ row := lines at: lines size.
                  ^ row size + 1 @ lines size corner: row size @ lines size ].
    row := lines at: aPoint y.
    start > row size
        ifTrue: [ ^ row size + 1 @ aPoint y corner: row size @ aPoint y ].
    end := col := aPoint x.
    i := start.
    [ i >= 1 and: [(row at: i) isAlphaNumeric or: [(row at: i) == $: or: [(row at: i) == $_]]]]
        whileTrue: [ start := i. i := i - 1. ].
    i := end.
    [ i <= row size and: [(row at: i) isAlphaNumeric or: [(row at: i) == $: or: [(row at: i) == $_]]]]
        whileTrue: [ end := i. i := i + 1. ].
    ^ start @ aPoint y corner: end @ aPoint y!
searchBack: aTextSelection for: aPattern caseSensitive: aBoolean
        "Search backward for aPattern starting from
         the end of aTextSelection.  Answer the matched 
         selection based upon the case sensitivity
         flag aBoolean, else answer nil."
    | row col answer pattern matchBlock|
    aBoolean
        ifTrue: [
            pattern := aPattern.
            matchBlock := [ :c | c ] ]
        ifFalse: [ 
            pattern := Pattern new: (aPattern input) asLowerCase.
            matchBlock := [ :c | c asLowerCase ] ].
    row := aTextSelection corner y min: lines size.
    col := aTextSelection origin x"corner x + 1".
    row to: 1 by: -1 do: [ :i |
        (answer := pattern matchBackward: (lines at: i) index: col each: matchBlock)
            isNil ifFalse: [
                ^aTextSelection
                    origin: answer x @ i
                    corner: answer y @ i].
        i = 1 ifFalse: [col := (lines at: i - 1) size] 
        "col := 1"].
    ^nil!
searchFrom: aTextSelection for: aPattern caseSensitive: aBoolean
        "Search for aPattern starting from the end
         of aTextSelection.  Answer the matched
         selection based upon the case sensitivity
         flag aBoolean, else answer nil."
    | row col answer pattern matchBlock|
    aBoolean
        ifTrue: [
            pattern := aPattern.
            matchBlock := [ :c | c ] ]
        ifFalse: [ 
            pattern := Pattern new: aPattern input asLowerCase.
            matchBlock := [ :c | c asLowerCase ] ].
    row := aTextSelection corner y.
    col := aTextSelection corner x + 1.
    row to: lines size do: [ :i |
        (answer := pattern match: (lines at: i) index: col each: matchBlock)
            isNil ifFalse: [
                ^aTextSelection
                    origin: answer x @ i
                    corner: answer y @ i].
        col := 1].
    ^nil!   
tabStringAt: anInteger
        "Private - Answer a String of spaces which spans
         from position anInteger to the next tab stop."
    ^(String new: 4 - ((anInteger - 1) \\ 4) )
        atAllPut: Space!   
wmSyscolorchange: wordInteger with: longInteger
        "Private - Process the system color change message."
    OperatingSystemInformation initializeSystemColors.
    Color initializeSystemColors.
    self colorChange.
    ^nil!
reopenWindows: oldWindows
        "Private - reopen the saved windows."
    oldWindows do: [ :w | w handle: WindowHandle nullValue ].
    savedWindows do: [ :w |
        ( w isApplicationWindow and: [ w frameWindow parent isWindow not ] )
            ifTrue:  [
                w allChildrenDo: [ :c | c clearGraphicsTool ].
                w validate ] ].
    savedWindows := nil.
    self cleanUpAllMessages!   
dragSourceCutDefault: dragSession
        "Private - provide default source cut if no handler is provided
        by removing the selected element from contents."
    | c selectedIndex cutIndex topIndex |
	topIndex := self getTopIndex.
	cutIndex := self dragSourceSelection.
	c := self contents asOrderedCollection.
    c removeIndex: cutIndex.
    self contents: c asArray.
	dragSession target == self
		ifTrue: [
			selectedIndex := "self selectedIndex" value.
			cutIndex < selectedIndex ifTrue: [ selectedIndex := selectedIndex - 1 ].
			self selectIndex: selectedIndex ]
		ifFalse: [ self deselect ].
	self setTopIndex: topIndex! 
button1Down: aPoint
        "Private - The user pressed down button1 at aPoint.  If not within
        the current selection, make a new selection, otherwise start a drag
        drop transfer."
    | pos sel selStart selEnd |
    ( self helpManager notNil and: [ self helpManager helpMode ] )
        ifTrue: [ self helpRequest. ^self ].  "from superclass implementation"
    ( self isDragSource and: [ self isDragButton: 1 ] ) ifTrue: [
        pos := self characterCoordinate: aPoint.
        sel := self selection.
        sel isGap ifFalse: [
            selStart := sel origin.
            selEnd := sel corner.
            "don't undo selection if about to drag"
            ( self selectionIncludesPoint: pos )
                ifTrue: [ self dragOnMove: true location: aPoint. ^self ] ] ].
    self captureMouseInput.
    self startTimer: self class leftButtonScrollTimerId period: self class leftButtonScrollInterval.
    self mainWindow activeTextPane: self.
    self selectAtCursor: aPoint.
    self
        displayChanges;
        showSelection!   
resize: aRectangle repaint: repaint
        "Private - The size of the receiver has been changed
         to aRectangle.  If repaint is true then always repaint
         else repaint only if the aRectangle is different from
         rectangle."
    | winPosInfo sons remainingClientArea |
    self maximized ifTrue: [ collapsed := rectangle ].
    ( repaint or: [ aRectangle ~= rectangle ] )
        ifTrue: [ rectangle := self resizeRectangleFor: aRectangle ]
        ifFalse: [ ^self ].  "if the new rectangle is unchanged, then don't resize"

    "Smalltalk has a limited stack size and if 20 or more
     children are handled we will get a stack overflow."
    ( sons := children size ) >= 20
        ifTrue: [ self resizeChildren ]
        ifFalse: [
            winPosInfo := UserLibrary beginDeferWindowPos: sons.
            remainingClientArea := rectangle.
            self childrenAffectingClientArea do: [ :subpane |
                subpane isHandleOk ifTrue: [
                    winPosInfo := subpane
                         resize: remainingClientArea
                         deferInfo: winPosInfo.
                    remainingClientArea := subpane freeClientArea: remainingClientArea ] ].
            children do: [ :subpane |
                ( subpane isHandleOk
                    and: [ subpane affectsFreeClientArea not ]) ifTrue: [
                    winPosInfo := subpane
                         resize: remainingClientArea
                         deferInfo: winPosInfo ] ].
            UserLibrary endDeferWindowPos: winPosInfo.
            children do: [:w | w updateRectangle ] ]!  
setActiveWindow: aWindowHandle
    <api: SetActiveWindow ulong ulongReturn>
    ^self invalidArgument!  
noRedraw
        "Add the no redraw style."
    ^self addStyle: LbsNoredraw!
fromModule: aString id: anInteger
        "Answer a CursorManager object, loaded from the DLL
         named aString, with the given resource id anInteger."
    | dll int handle |
    aString notNil ifTrue: [ dll := DynamicLinkLibrary open: aString ].
    ( int := UserLibrary loadCursor: dll name: anInteger ) = 0
        ifTrue: [ ^self osError ].
    dll notNil ifTrue: [ dll close ].
    handle := ExternalHandle fromInteger: int.
    ^self new handle: handle! 
close
        "Close the clipboard, if opened."
    Open ifFalse: [ ^nil ].
    UserLibrary closeClipboard
        ifFalse: [ ^self osError ].
    Open := false!
defFilter
        "Answers the aDefFilterString as the default filter of File dialog."
    ^self propertyAt: #defFilter!
loadIcon: hInstance name: name
    name isString
        ifTrue: [^self loadIcon: hInstance nameString: name]
        ifFalse: [^self loadIcon: hInstance nameInteger: name]!  
allocSelector: wSelector
    <api: AllocSelector ushort ushort>
    ^self invalidArgument!  
scrollTopCorner: aPoint
        "Private - Move the contents of the receiver
         pane by extent aPoint."
    | oldCorner newCorner height locX locY copyY theFont |
    theFont := self font.
    oldCorner := topCorner.
    newCorner := topCorner x - (aPoint x
        // theFont  width) @ (topCorner y -
        (aPoint y // theFont height)).
    newCorner x: (1 max: newCorner x);
        y: (1 max: (newCorner y min:
            list size)).
    oldCorner = newCorner
        ifFalse: [self doGraphics: [
            "hide selection"
            self drawLine: selection.
            topCorner := newCorner.
            "copy the area that's not going to change"
            copyY := (oldCorner y - topCorner y *  theFont height).
            (copyY abs > self height) ifFalse: [
                graphicsTool
                    selfCopyToX: oldCorner x - topCorner x *
                        theFont width
                    Y: copyY].
            " figure out gap area after copying "
            height := oldCorner y - topCorner y.
            height > 0
                ifTrue: [ "scroll up"
                    oldCorner := topCorner.
                    locX := 0.
                    locY := 0 - theFont height.
                    height := height * theFont height.
                ]
                ifFalse: [ "scroll down"
                    oldCorner
                        x: topCorner x;
                        y: (oldCorner y + self charsInColumn).
                    locX := 0.
                    locY := oldCorner y - topCorner y - 1 * theFont height.
                    height := rectangle height - locY].
            self
                refreshFrom: oldCorner
                for: height
                atX: locX
                Y: locY.
            self boldLine: selection]]! 
simple
        "Answer an instance of a simple combobox."
    ^self new simpleList; yourself!   
dropDown
        "Answer an instance of a drop down combobox."
    ^self new dropDown; yourself!
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        remove: #changedIndex: ;
        remove: #listVisible ;
        add: #doubleClicked: ;
        add: #entered: ;
        add: #textChanged: ;
        yourself! 
dropDownList
        "Answer an instance of a dropdown list combobox."
    ^self new dropDownList; yourself!
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #listVisible ;
        yourself!  
printOn: aStream
        "Append a text description of the receiver to aStream."
    | unitsPerInch box |
    aStream nextPutAll: 'a', self class name.
    apmHeader notNil ifTrue: [
        unitsPerInch := apmHeader inch.
        box := apmHeader bbox scaleBy: ( 1 / unitsPerInch ).
        box := ( box origin truncateTo: 0.001 ) extent: ( box extent truncateTo: 0.001 ).
        aStream nextPutAll: '{ ', box printString, ' }' ]!  
dragTargetDrawEmphasisCaretFrom: startPoint to: endPoint
		"Private - draw an insertion caret emphasis indicator
		between the given points."
	self doGraphics: [
		self pen
			setForegroundMode: MixRuleNotXor;
			place: startPoint;
			line: endPoint;
			place: ( startPoint left: 2 );
			line: ( startPoint right: 2 );
			place: ( endPoint left: 2 );
			line: ( endPoint right: 2 );
			setForegroundMode: MixRuleDefault ]!
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #aboutToDisplayMenu ;
        yourself!   
aboutToStartMenu
        "Private - a menu is being pulled down, trigger an event so the menu
        contents may be adjusted to correspond to application state."
    self triggerEvent: #aboutToDisplayMenu!
releaseEventTable
        "Private - break all connections to event handlers."
    self propertyAt: #eventTable put: nil!   
contextForItem: anInteger
        "Private - the user has highlighted a menu item
        in the receiver; answer a String for preview help."
    | index menu selector key helpOwner |
    ( ( index := anInteger // 256 ) > allMenus size or: [ index < 1 ] ) ifTrue: [ ^nil ].
    menu := allMenus at: anInteger // 256.
    selector := menu selectorOf: anInteger \\ 256.
    selector isMessage
        ifTrue: [
            key := selector selector.
            helpOwner := selector receiver ]
        ifFalse: [
            menu selector isNil
                ifTrue: [ selector isNil ifFalse: [ key := selector ] ]
                ifFalse: [ key := menu selector ].
            helpOwner := menu owner ].
    key isNil ifTrue: [ ^nil ].
    ^Association key: key asString value: helpOwner!
menuWithItemId: anInteger
        "Private - answer the menu which contains a menu item
        with the given item id, or nil if none."
    | index |
    ( index := anInteger // 256 ) > allMenus size
        ifTrue: [ ^nil ].
    ^allMenus at: index! 
menuTitled: aString
        "Answer the menu whose title is aString. Case is ignored
         and aString can include $&, $~, or neither."
    | plainString |
    plainString := aString reject: [:c | c = $& | (c = $~)].
    menus do: [:m |
        ((m title reject: [:c| c = $& | (c = $~)])
            equalsIgnoreCase: plainString)
             ifTrue: [^m]].
    ^nil!  
removeFromAllMenus: aMenu
        "Private - Remove aMenu and all its submenus from the instance variable allMenus. "
    allMenus remove: aMenu ifAbsent: [^self].
    aMenu items do: [:item |
         allMenus remove: item ifAbsent:[] ]!
accelTable
        "Private - Answer the accelerator table for
         the receiver."
    ^accel! 
addMenu: aMenu owner: anOwnerWindow
        "Add aMenu to the receiver and set
        aMenu's owner to anOwnerWindow."
    aMenu owner: anOwnerWindow.
    self addMenu: aMenu!  
eventTableForEdit
        "Private - Answer the table of event handlers for the receiver.
        Allocate if necessary so that updates can be stored."
    ^self propertyAt: #eventTable ifAbsentPut: [ self eventTableCreate ]!  
menus
        "Private - Answer the OrderedCollection of menus
         for the receiver."
    ^menus! 
performItemId: anInteger in: menu
        "Private - the menu item at anInteger has been selected.
        No selector has been registered. Default is to do nothing."! 
selectorOf: anInteger
        "Private - Answer the selector for the item whose id is anInteger."
    | menu |
    menu := allMenus at: (anInteger // 256).
    ^menu selectorOf: anInteger.! 
allMenus
        "Private - Answer all the menus used by the receiver,
        including submenus.  The first menu is a holder for system
        menu item additions."
    ^allMenus!
systemMenu
        "Private - Answer a Menu for the receiver's system menu to
         which items can be added."
    ^allMenus at: 1! 
deleteAndRebuildMenusStartingFrom: aMenu
        "Private - Delete aMenu and rebuild all the menus that follow it."
    | position menu menusToRebuild |
    
    position := ( menus indexOf: aMenu ).
    ( ( position = 0 ) or: [ position > menus size ] )
        ifTrue: [ ^self ].  "aMenu doesn't exist or is last -> no rebuilding needed."

    menusToRebuild := OrderedCollection new.

    "Delete the menus following aMenu"
    menus size to: position by: -1 do: [ :index |
        menu := menus at: index.
        menusToRebuild add: menu.
        self deleteMenu: (menus at: (index "- 1"))].
    menusToRebuild do: [:m |
        menus remove: m.
        self removeFromAllMenus: m ].

    "Rebuild the menus."
    menusToRebuild removeLast.
    menusToRebuild reverseDo: [:m | self addMenu: m ]    ! 
performMenuItem: anInteger
        "Private - Perform the menu item whose id is anInteger."
    | menu menuIndex itemIndex selector menuOwner |
    ( ( menuIndex := anInteger // 256 ) between: 1 and: allMenus size ) ifFalse: [ ^self ].
    menu := allMenus at: menuIndex.
    ( menuOwner := menu owner ) notNil ifTrue: [ menuOwner initMenu ].
    itemIndex := anInteger \\ 256.
    itemIndex > menu numberOfItems ifTrue: [ ^self].
    ( menu isDisabled: itemIndex ) ifTrue: [ ^self ].

    selector := menu selectorOf: itemIndex.
    selector isMessage ifTrue: [ ^selector perform ].
    menu selector notNil ifTrue: [ ^menuOwner perform: menu selector with: selector ].
    selector isNil
        ifTrue: [ self performItemId: itemIndex in: menu ]
        ifFalse: [
            selector isSymbol
                ifTrue: [ menuOwner perform: selector ]
                ifFalse: [
                    [ selector evaluateFor: menuOwner ]
                        on: MessageNotUnderstood do: [ :e | ] ] ]!   
eventTable
        "Private - answer the table of event handlers for the receiver."
    ^self propertyAt: #eventTable ifAbsent: [ self eventTableCreate ]!  
fontHandle: aHandle
        "Private - Set the font handle to aHandle."
    handle := aHandle!  
hideCaret: aWindowHandle
    <api: HideCaret ulong boolean>
    ^self invalidArgument!  
getClassInfo: hInstance className: aString wndClass: aStruct
   <api: GetClassInfoA ulong struct struct boolean>
   ^self invalidArgument!  
exitCallBackInterrupt
        "Private - Upon return from a callback, if no
        longer recursive, then yield if necessary."
    DropStack ifTrue: [
        Processor currentProcessIsRecursive
            ifTrue: [ self unwind ]
            ifFalse: [
                DropStack := false.
                self dropSenderChain.
                OSEventSemaphore signal.
                CurrentProcess isUserIF
                    ifTrue: [ Notifier run ]
                    ifFalse: [
                        self enableInterrupts: false.
                        Processor schedule ] ] ].
    Processor currentProcessIsRecursive ifFalse: [
       HaveBeenSignals ifTrue: [
           HaveBeenSignals := false.
           Processor yield ] ].
    self enableInterrupts: true!
fileOutOn: aFileStream
        "Write the pane data out on aFileStream."
    CursorManager execute changeFor: [
        aFileStream close.
        File remove: aFileStream pathName ifAbsent: [ nil ].
        aFileStream file open.
        aFileStream
            setCollection: aFileStream file;
            setLimits.
        self getText. "Sets Value."
        aFileStream nextPutAll: value.
        aFileStream flush ]! 
dragSourceCutDefault: dragSession
		"Private - perform default cut action if no handler is provided."
    self implementedBySubclass!   
contents: aString
        "Set the contents of the receiver to aString."
    textHolder string: aString.
    ( self isHandleOk and: [ self graphicsTool notNil and: [ self graphicsTool privateHandle isNil ] ] )
        ifTrue: [ self invalidateRect: nil erase: false ].
    ^aString!   
asWindowHandle
        "Private - Answer the receiver as a WindowHandle."
    ^WindowHandle fromBytes: (self handleAtOffset: 0).
! 
systemMenuHandle
        "Private - answer the handle of the system menu."
    ^nil!
setTextLimit
        "Private - Set the size of the entryfield.
        Assumes 'handle = NullHandle' is false."
    UserLibrary
        sendMessage: handle
        msg: EmLimittext
        wparam: ( self textLimit isNil ifTrue: [ self defaultTextLimit ] ifFalse: [ self textLimit ] )
        lparam: 0!
removeMinimizeButtonStyle
        "Remove the minimize button style."
    ^self removeStyle: WsMinimizebox! 
andMask
        "Private - Answer the AND mask."
    ^andMask!  
startUp
        "Private - Initialize the receiver class."
    self callBackTable: OrderedCollection new.
    ( ( Smalltalk includesKey: #CallBack16 ) and: [ OperatingSystem isWindows ] )
        ifTrue: [ ( Smalltalk at: #CallBack16 ) startUp ]!
fileName
        "Answer the receiver's file name."
     ^'shell32'!
dragAcceptFiles: hWnd accept: aBoolean
    <api: DragAcceptFiles ulong boolean none>
    ^self invalidArgument! 
dragFinish: hDrop
    <api: DragFinish ulong none>
    ^self invalidArgument!   
dragQueryFile: hDrop index: anInteger buffer: buffer cbBuffer: cbBuffer
    <api: DragQueryFileA ulong short struct short short>
    ^self invalidArgument! 
dragQueryPoint: hDrop point: aWinPoint
    <api: DragQueryPoint ulong struct boolean>
    ^self invalidArgument!
windowLabeled: aString frame: aRectangle
        "Create a new window with label aString
         and frame aRectangle."
    ^self windowLabeled: aString
        frame: aRectangle
        foreColor: Color windowText
        backColor: Color windowBackground!  
iconId
        "Answer the icon id for this window class."
    ^Smalltalk isRunTime ifTrue: [ 1 ] ifFalse: [ 9 ]!   
windowLabeled: aString
    frame: aRectangle
    foreColor: foreColor
    backColor: backColor
        "Private - Create a new window with label aString,
         frame aRectangle and colors foreColor and backColor."
    | aPane mainWindow |
    mainWindow := self new.
    aPane := TextPane new.
    aPane owner: String new.
    mainWindow
        label: aString;
        foreColor: foreColor;
        backColor: backColor;
        addSubpane: aPane.
    mainWindow mainView openIn: aRectangle.
    mainWindow mainView updateWindow.
    ^mainWindow!   
dragDropEnabled
        "Private - answer whether the receiver is enabled as a drag-drop
        source / target."
    ^DragDropEnabled isNil ifTrue: [ false ] ifFalse: [ DragDropEnabled ]!  
dragDropEnabled: aBoolean
        "Private - set whether the receiver is enabled as a drag-drop
        source / target, depending on the value of aBoolean."
    DragDropEnabled := aBoolean! 
initialize
        "Private - initialize the class variables of the receiver."
    self
        dragDropEnabled: false!
resourceFileName
        "Private - answer the filename of the module (DLL or EXE) containing
        host resources for an object of this class."
    ^Smalltalk isRunTime
        ifTrue: [ VirtualMachineLibrary class fileName ]
        ifFalse: [ ( Smalltalk at: #SmalltalkToolInterface ) current resourceFileName ]!
readEntireFile
        "Private - If a partial file was read, read it all now."
    partial := false.
    self changed: #text .
    self fileMenu enableItem: #accept.
    self menuWindow removeMenu: ( self menuTitled: 'Partial File' )!  
createView
        "Private - create the panes for the receiver window."
    | pane |
    self mainView.  "create indirectly for SysEdit compatibility"
    self addSubpane:
        ( ( pane := self textPaneClass new )
            owner: self;
            setName: #text ;
            when: #needsContents send: #stringContents: to: self with: pane;
            when: #saved send: #saveString: to: self with: pane;
            dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
            dragTarget: ( Smalltalk isRunTime ifTrue: [ false ] ifFalse: [ self class dragDropEnabled ] );
            framingBlock: [ :box | box ] ).
    Smalltalk isRunTime ifFalse: [ pane expressionEvaluator: self expressionEvaluatorClass new ]
!   
readPartialFile
        "Private - Display the head and tail of the
         selected file in the text pane."
    | aFileStream partialContents |
    CursorManager execute changeFor: [
        self pane modified: false.
        aFileStream := file.
        partialContents := aFileStream partialContents.
        aFileStream close.
        self pane fileInFrom: ( ReadStream on: partialContents ) ]!  
openOnPathName: aPathName
        "Open the receiver on the contents of the file
        named aPathName as its contents."
    | fs |
    fs := File pathNameReadOnly: aPathName.
    Notifier postInputEvent:
        ( Message receiver: self selector: #openOnFile: arguments: ( Array with: fs ) ).
    Notifier postInputEvent:
        ( Message receiver: fs selector: #close )!   
contents: aString
        "Set the contents of the text pane to aString."
    ^self pane contents: aString! 
dragDropTargetPanes
        "Private - answer a collection of pane names defined in the receiver
        which are capable of being a drag target."
    ^Array with: #text!
tab
        "Write a tab character to the receiver."
    self pane tab! 
cr
        "Append a line-feed to the end
         of the  text in the pane."
    ^self pane cr!   
updateMenu: aTopPane
        "Private - update the Walkback window's menu so that
        it also includes a submenu for partial file read."
    | menu indexOfLastMenu |
    partial ifTrue: [
        indexOfLastMenu := ( self mainView menuTitled: 'Smalltalk' ) isNil ifTrue: [ 2 ] ifFalse: [ 3 ].
        menu := Menu new
            owner: self;
            title: '\uPartial File' replaceEscapeCharacters;
            appendItem: '\uRead Entire File' replaceEscapeCharacters selector: #readEntireFile.
        self menuWindow insertMenu: menu after: indexOfLastMenu.
        self fileMenu disableItem: #accept ]! 
readFile: aPane
        "Private - Read in the file to aPane."
    | reOpened oldFileStream |
    reOpened := false.
    CursorManager execute change.
    file file fileId isNil ifTrue: [
        oldFileStream := file.
        file := File pathNameReadOnly: file file pathName.
        reOpened := true ].
    partial
        ifTrue: [ self readPartialFile ]
        ifFalse: [ aPane fileInFrom: file ].
    reOpened ifTrue: [ file close. file := oldFileStream ].
    CursorManager normal change.
    ^nil!  
saveFile: aPane
        "Private - Save aPane to file."
    | reOpened |
    partial ifTrue: [ ^MessageBox message: 'Cannot save a partial file!!' ].
    reOpened := false.
    CursorManager execute changeFor: [
        file file fileId isNil ifTrue: [ file file open. reOpened := true ].
        file file name asLowerCase = 'change.log' ifTrue: [
            ( MessageBox new
                title: 'Warning';
                message: 'Overwriting a change.log file will cause unrecoverable loss of\information.  Are you sure you want to continue?' withCrs;
                iconExclamation;
                yesNo;
                open ) ifFalse: [ ^self ] ].
        aPane fileOutOn: file.
        reOpened ifTrue: [ file close ] ].
    aPane modified: false! 
initWindowSize
        "Private - Answer the initial size of the receiver."
    ^( SysFontWidth * 70 ) @ ( SysFontHeight * 20 )!
openOn: aString
        "Open the receiver with aString as its initial contents."
    file := aString.
    partial := false.
    self createView.
    Smalltalk isRunTime ifFalse: [ self addHelpManager ].
    self openWindow!
openOnFile: aFileStream
        "Open the receiver with aFileStream as its contents."
    | pane |
    file := aFileStream.
    partial := ( file size > FileStream partialReadThreshold ).
    self createView.
    ( pane := self mainView )
        label: file pathName;
        when: #menuBarBuilt send: #updateMenu: to: self with: pane.
    ( pane := self pane )
        removeActionsForEvent: #needsContents;
        when: #needsContents send: #readFile: to: self with: pane;
        removeActionsForEvent: #saved;
        when: #saved send: #saveFile: to: self with: pane.
    Smalltalk isRunTime ifFalse: [ self addHelpManager ].
    self openWindow!  
space
        "Append a space to the end of
         the text in the pane."
    ^self nextPut: Space!  
show: aString
        "Add aString at the end of the
         text in the pane and force it
         to be shown."
    self nextPutAll: aString.! 
stringContents: aPane
        "Private - Fill the contents of aPane."
    aPane contents: file! 
pane
        "Private - Answer the text pane."
    ^self mainView searchForDefaultTextPane! 
saveAs
        "Private - User selected SaveAs...
         If the receiver is not already a file-editor workspace,
         turn it into one (unless it is the Transcript)."
    | fileName pane |
    self pane isNil ifTrue: [ ^nil ].
    fileName := file isFileStream ifTrue: [ file file name ] ifFalse: [ 'untitled.txt' ].
    fileName := ( FileDialog new saveFile: fileName ) file.
    fileName isNil ifTrue: [ ^nil ].
    file := File pathName: fileName.
    self pane fileOutOn: file.
    file close.
    self label: file pathName.
    ( pane := self pane )
        removeActionsForEvent: #needsContents ;
        setName: #readFile: ;
        when: #needsContents send: #readFile: to: self with: pane;
        removeActionsForEvent: #saved ;
        when: #saved send: #saveFile: to: self with: pane;
        modified: false.! 
nextPutAll: aString
        "Add aString at the end of the
         text in the pane."
    self pane nextPutAll: aString.
    self pane forceEndOntoDisplay!  
saveString: aPane
        "Private - Save the contents of a workspace."
    self saveAs notNil ifTrue: [
        ^aPane modified: false]!  
contents
        "Answer the contents of the text pane as a String."
    ^self pane contents!   
next: anInteger put: aCharacter
        "Append aCharacter to the receiver's pane
         anInteger number of times."
    anInteger timesRepeat: [ self nextPut: aCharacter ].
    self pane forceEndOntoDisplay
!  
nextPut: aCharacter
        "Add aCharacter at the end
         of the text in the pane."
    self pane nextPut: aCharacter.
    self pane forceEndOntoDisplay!   
open
        "Open the receiver on an empty string."
    self openOn: String new!   
dragDropSourcePanes
        "Private - answer a collection of pane names defined in the receiver
        which are capable of being a drag source."
    ^Array new!
dragDropTargetPanes
        "Private - answer a collection of pane names defined in the receiver
        which are capable of being a drag target."
    ^Array new!
helpContextStringFor: aHelpContext
        "Private - answer the help context string for the association
        aHelpContext."
    | ambiguousMenuTitles |
    aHelpContext isNil ifTrue: [ ^nil ].
    ( aHelpContext value isSubPane and: [ aHelpContext key = aHelpContext value name ] )
        ifTrue: [ ^nil ].  "ignore subpanes as contexts"
    ambiguousMenuTitles := #( 'Class' 'Method' 'Inspect' ).
    ( ambiguousMenuTitles includes: aHelpContext key ) ifTrue: [
        ^aHelpContext value class printString, aHelpContext key ].
    ^aHelpContext key!   
aboutDialogClass
        "Private - answer the class which defines the AboutDialog (for help manager)."
    ^nil!   
windowPolicyClass
        "Answer the class which is used to define menu bar
         menus for this type of window."
    ^Smalltalk isRunTime
        ifTrue: [ StandardWindowPolicy ]
        ifFalse: [ self toolWindowPolicyClass ]! 
wmTimer: wordInteger with: longInteger
        "Private - Process the timer message.  If the timer
		event is the drag scroll timer, do drag scrolling."
    ( wordInteger = self class dragTargetScrollTimerId and: [ self isDragTarget ] )
        ifTrue: [ self dragTargetDoScroll ].
    ^nil!  
applyStyle
        "Private - apply a style change to a window which accepts it."
    super applyStyle.
    self isVisible ifTrue: [ self invalidate ]!
setColumnWidth: anInteger
        "Set the column width for columns in a listbox
         with the multiColumn style to anInteger pixels"
    self isHandleOk
        ifTrue: [
            UserLibrary
                sendMessage: handle
                msg: LbSetcolumnwidth
                wparam: anInteger
                lparam: 0 ]
        ifFalse: [ self whenValid: #setColumnWidth: with: anInteger ]!  
peek: remove
        "Private - peek in the message queue to see if
         there is a waiting message; answer true if there
         is, otherwise false.  If remove is true, remove the
         next message from the queue and place it into
         WinMsgNS, and answer true; otherwise, answer
         false."
    | answer |
    answer := UserLibrary
        peekMessage: WinMsgNS asParameter
        hwnd: nil
        min: 0
        max: 0
        remove: ( remove ifTrue: [ PmRemove ] ifFalse: [ PmNoremove ] ).
    Notifier setPeekCount: 0.
    ^answer!
minimizingWindow
        "Private - Minimizing window.  Trigger an event notifying
        interested clients."
    framingBlock := self frameRectangle. "to be used
        for saving image with iconic window"
    self triggerEvent: #minimized! 
noPages
        "Disables the print dialog's Pages radio button."
    self style: ( self style | PdNopagenums )!
copyStruct
        "Private - copies the chooseColorStruct to nonSmalltalk memory"
    | temp buffer |
    temp := ExternalAddress copyToNonSmalltalkMemory: chooseColorStruct contents.
    chooseColorStruct := SelfDefinedStructure named: 'CHOOSECOLOR' atAddress: temp.
    lpCustColors := ExternalAddress allocateMemory: ( 16 * 4 ).
    chooseColorStruct lpCustColors: lpCustColors asInteger.
    buffer := ExternalBuffer atAddress: lpCustColors.
    1 to: 16 do: [ :ix |
        buffer uLongAtOffset: ( 4 * ( ix - 1 ) ) put: ( customColors at: ix ) ]! 
dragTargetEmphasis: anEmphasisType
		"Private - set the type of target emphasis that should be employed.
		anEmphasisType may be either 'pane', 'item', or 'separator'."
	( anEmphasisType notNil and: [ ( self dragTargetEmphasisTypesSupported includes: anEmphasisType ) not ] )
		ifTrue: [ ^self error: 'unsupported drag target emphasis' ].
	self propertyAt: #dragTargetEmphasis put: anEmphasisType!
getWindowRect: aWindowHandle rectangle: aByteArray
    <api: GetWindowRect ulong struct boolean>
    ^self invalidArgument! 
isChildOf: parent
        "Answer true if receiver is a child of parent."
    | father |
    ( ( father := UserLibrary getParent: self ) = 0 )
        ifTrue: [ ^false ].
    ( father := self class fromInteger: father ) = parent
        ifTrue: [ ^true ]
        ifFalse: [ ^father isChildOf: parent ]! 
fromWmKeydown: wparam with: lparam
        "Private - answer an instance of the receiver class corresponding to
        the host WM_CHAR message described by the arguments."
    | event shiftState scanCode virtualKey |
        "Don't process messages which will be translated into a WM_CHAR message."
    ( wparam == TabKey and: [ Notifier isControlKeyDown ] ) ifFalse: [
        ( wparam == TabKey or: [ ( UserLibrary mapVirtualKey: wparam mapType: 2 ) ~= 0 ] )
            ifTrue: [ ^nil ] ].

    event := self new.

    shiftState := 0.
    ( Notifier isShiftKeyDown ) ifTrue: [ shiftState := shiftState bitOr: AfShift ].
    ( Notifier isControlKeyDown ) ifTrue: [ shiftState := shiftState bitOr: AfControl ].
    ( Notifier isAltKeyDown ) ifTrue: [ shiftState := shiftState bitOr: AfAlt ].
    event shiftState: shiftState.

    virtualKey := wparam.
    event virtualKey: wparam.

    scanCode := ( lparam bitShift: -16 ) bitAnd: 16rFF. "byte 3 is scan code"
    event scanCode: scanCode.

    ^event!   
notifyRecursive
        "Private - Retrieve the current system message and
         notify its owner window."
    self getWindowsMsg: WinMsgST asParameter.
    ^self notify: WinMsgST!   
button1Down: aPoint
        "Private - Button 1 has been pressed down.
        Highlight the line covering aPoint."
    self previousSelection: selection.
    self highlightCursorLine: aPoint.
    self setFocus.
    ( self isDragSource and: [ self isDragButton: 1 ] )
        ifTrue: [ self dragOnMove: true location: aPoint ].
    self captureMouseInput!   
initialize
        "Private - initialize required SelfDefinedStructures."
    | d |
    d := IdentityDictionary new
		at: #fIcon put: #( 0 #ulong #yourself );
		at: #xHotspot put: #( 4 #ulong #yourself );
		at: #yHotspot put: #( 8 #ulong #yourself );
		at: #hbmMask put: #( 12 #ulong #yourself );
		at: #hbmColor put: #( 16 #ulong #yourself );
		yourself.
    SelfDefinedStructure define: 'ICONINFO' withFields: d!  
hasBorderStyle
        "Private - answer whether the receiver has a
        border style."
    ^self hasStyle: WsBorder!   
insertSeparatorAfter: anInteger
        "Insert a menu separator after the given position."
    | mi |
    mi := MenuItem new
        position: anInteger;
        style: MfSeparator;
        attribute: 0;
        id: 0.
    items add: mi.
    accel add: nil!   
cancelMode
        "Private - Cancel any internal mode of the receiver, if any"
    UserLibrary
        sendMessage: handle
        msg: WmCancelmode
        wparam: 0
        lparam: 0!  
dropDown
        "Set and answer the control style for drop down combo."
    self removeStyle: CbsDropdownlist.
    self removeStyle: CbsSimple.
    ^self addStyle: CbsDropdown! 
selection
        "Answer the index of the last selected / deselected item (the
		item with the selection focus)."
	| index |
    index := UserLibrary
		sendMessageInt: handle
		msg: LbGetcaretindex
		wparam: 0
		lparam: 0.
    index = self class listEnd
        ifTrue: [ nil ]
        ifFalse: [ ^index + 1 ]
!  
wmDisplaychange: wparam with: lparam
        "Private - handle display resolution change."
    ^nil!
createDialog: hInstance templateName: aTemplateName parent: hWndParent dialogFunction: lpDialogFunc
    ^self createDialogParam: hInstance templateName: aTemplateName parent: hWndParent dialogFunction: lpDialogFunc initParam: 0! 
windowClass
        "Private - Answer the host system window class
         name of the receiver."
    ^self class windowClass!
enableMenu: aMenu
    "Enable the menu <aMenu> in the receiver menu bar."
    | menuItem |
    parent isNil
        ifTrue: [ ^nil ].  "Not a menu in a menu bar"
    menuItem := aMenu menuItem.
    menuItem attribute: ( menuItem attribute bitAnd: ( MfGrayed bitXor: 16rFFFF ) ).
    UserLibrary
        enableMenuItem: self handle
        item: ( menuItem id // 256 ) - 2
        flags: menuItem attribute  | MfByposition.
    UserLibrary drawMenuBar: parent asParameter!
isDragSourceInitiation: aPoint
        "Private - answer whether aPoint is sufficiently removed
        from the initial dragSourceLocation to indicate a drag initation."
    | start delta threshold |
    start := self dragSourceLocation.
    delta := start - aPoint.
    threshold := self class dragSourceSensitivity.
    ^delta x abs >= threshold x or: [ delta y abs >= threshold y ]! 
enableWordWrapFlags
        "Private - set the style flags to enable word wrapping."
    style isNil ifTrue: [ style := self getStyle ].
    style & WsHscroll = WsHscroll
        ifTrue: [ style := style bitXor: WsHscroll ].
    style & EsAutohscroll = EsAutohscroll
        ifTrue: [ style := style bitXor: EsAutohscroll ]!
update
        "Private - Redisplay the receiver window."
    ((self hasActionForEvent: #needsContents)
    or: [self handlesEvent: #getContents])
        ifFalse: [^self displayWindow].
    firstTime            "otherwise Turtle would not work."
        ifFalse: [graphicsTool deleteAllSegments].
    self showBitmap.
    graphicsTool
        setDrawingModeToDrawandretain;
        openSegment.
    self event: #getContents.
    self triggerEvent: #needsContents.
    graphicsTool closeSegment.! 
sendDlgItemMessage: hDlg
        item: nIDDlgItem
        msg: wMsg
        wparam: wParam
        lparam: lParam
    <api: SendDlgItemMessageA ulong long ulong ulong ulong long>
    ^self invalidArgument!   
dragTargetNeedsOperationsDefault: dragSession
        "Private - set the names of supported operations in the dragSession."
    | operations |
    ( operations := self dragTargetOperations ) isNil
        ifTrue: [ operations := #( #move #copy #link ) ].
    dragSession operations: operations!   
isIconic: aWindowHandle
    <api: IsIconic ulong boolean>
    ^self invalidArgument!
toPage
        "Answers the last page number requested by the user"
    ^self propertyAt: #toPage!  
setWindowPos: aWindowHandle
        insertAfter: insertHandle
        x: xInteger
        y: yInteger
        cx: xExtent
        cy: yExtent
        flags: flagsInteger
    <api: SetWindowPos ulong ulong long long long long ulong boolean>
    ^self invalidArgument!
isValid
        "Answer true if the bitmap has a handle or archive."
    ^bitmapHandle notNil or: [archive notNil]! 
allFaces
        "Answer an array of all available font faces in the system."
    ^self allFaces: Display!  
defaultStyle
        "Private - Answer drawnButton as the default button style."
    ^BsOwnerdraw!  
totalLength
        "Private - Answer the total length of the receiver.
         Implemented by subclass"
   ^100! 
getMenuCheckMarkDimensions
    <api: GetMenuCheckMarkDimensions ulongReturn>
    ^self invalidArgument! 
slotSize
        "Private - Answer the size of each slot in bytes."
    ^20!
findEmptySlot
        "Private - Find the next available slot number: if there
         is a free slot, reuse it; otherwise signal an error."
    | index |
    [ index := self callBackTable
        indexOf: nil
        ifAbsent: [ ^self error: 'CallBack table is full' ] ] evaluateWithoutInterrupts.
    ^index!
lpfnSTCallBack
        "Private - answer the address of the VM callback entry point."
    ^LpfnSTCallBack!  
maxNumCallBack
        "Private - Answer the maximum number of 16-bit callbacks
        allowed per instance of Smalltalk."
    ^128!  
lpCodeCallBackEntry: anExternalAddress
        "Private - set the code segment address of the buffer containing 16-bit
        callbacks to anExternalAddress."
    LpCodeCallBackEntry := anExternalAddress!  
lpCodeCallBackEntry
        "Private - answer the code segment address of the buffer containing 16-bit callbacks."
    ^LpCodeCallBackEntry!
lpDataCallBackEntry
        "Private - answer the data segment address of the buffer containing 16-bit callbacks."
    ^LpDataCallBackEntry!
lpDataCallBackEntry: anExternalAddress
        "Private - set the data segment address of the buffer containing 16-bit
        callbacks to anExternalAddress."
    LpDataCallBackEntry := anExternalAddress!  
lpfnSTCallBack: anExternalAddress
        "Private - set the address of the VM callback entry point to anExternalAddress."
    LpfnSTCallBack := anExternalAddress! 
exit
        "Private - Clean up the receiver before exiting."
    KernelLibrary16 freeSelector: self lpDataCallBackEntry // 65536.
    ThunkWin32sDLL current close!  
initializeCallingConventions
        "Private - Initialize callingConventions class instance variable."
    self callingConventions: ( Dictionary new
        at: #pascal put: 3;
        at: #api put: 3;
        at: #c put: 4;
        yourself )!   
startUp
        "Private - Initialize the class and class instance variables."
    | dataSelector |
    self lpfnSTCallBack: ( ExternalSegmentedAddress fromString:
        ( KernelLibrary16 getProcAddress: ThunkWin32sDLL current procName: 'STCallBack16Proc' asParameter ) ).
    self callBackTable: ( Array new: self maxNumCallBack ).
    self lpCodeCallBackEntry: ( ExternalSegmentedAddress fromString:
        ( KernelLibrary16 getProcAddress: ThunkWin32sDLL current procName: 'entryPoints' asParameter ) ).
    dataSelector := KernelLibrary16 allocSelector: 0.
    dataSelector := KernelLibrary16
        prestoChangoSelector: self lpCodeCallBackEntry asUnsignedInteger // 65536
        destinationSelector: dataSelector.
    self lpDataCallBackEntry: ( dataSelector * 65536 ) + ( self lpCodeCallBackEntry asUnsignedInteger \\ 65536 )!
initializeAtSelectors
        "Private - Initialize atSelectors class instance variable."
    self atSelectors: ( Dictionary new
        at: #short put: ( Array with: 2 with: #shortAtOffset: );
        at: #ushort put: ( Array with: 2 with: #uShortAtOffset: );
        at: #long put: ( Array with: 4 with: #longAtOffset: );
        at: #ulong put: ( Array with: 4 with: #uLongAtOffset: );
        at: #handle put: ( Array with: 2 with: #handleAtOffset: );
        yourself )!   
uncheck
        "Set the receiver's state to unchecked (false).
        Trigger changed event. "
    self setValue: false! 
check
        "Set the receiver's state to checked (true).
        Trigger changed event. "
    self setValue: true!   
autoCheckBox
        "Set and answer the automatic check box window style."
    self removeStyle: BsCheckbox.
    ^self addStyle: BsAutocheckbox!  
click
        "Programatically click the button."
    self value: self getValue not.
    super click!  
changedEventFor: aBoolean
        "Private - answer the event to trigger for state aBoolean."
    ^aBoolean ifTrue: [ #checked ] ifFalse: [ #unchecked ]!   
checkBox
        "Set and answer the check box window style."
    self removeStyle: BsAutocheckbox.
    ^self addStyle: BsCheckbox!
minimized
        "Private - Answer true if the receiver is minimized."
    ^UserLibrary isIconic: self asParameter!
updateHorizontalSlider
        "Private - Update the horizontal slider position."
   ( UserLibrary
        setScrollPos: self asParameter
        bar: SbHorz
        position: self topCorner x
        redraw: true ) = 0
            ifTrue: [ self osNotification ]!   
constructNotifications
        "Private - answer the mapping between host control
        notification codes and corresponding Smalltalk event
        notifications."
    ^super constructNotifications
        at: EnHscroll put: #notifyHorizScroll: ;
        at: EnVscroll put: #notifyVertScroll: ;
        at: EnKillfocus put: #notifyLosingFocus: ;
        yourself!
performDeferred
        "Perform the expression by requeueing the request."
    [ DeferredRequests add: self ] evaluateWithoutInterrupts!   
wmNcpaint: wordInteger with: longInteger
        "Private - Paint the non-client area like borders."
    ^nil!  
isDialog
        "Answer true if the receiver is the window for a dialog box."
    ^false!  
wmSettingchange: wparam with: lparam
        "Private - handle desktop setting changes."
    ^nil!  
startupWindowSystem
        "Private - perform OS window system startup."
    | oldWindows |
    OSEventSemaphore := Semaphore new.

    "moved out from DLL startUp"
    KernelLibrary16 := OperatingSystem isWindowsNT
        ifTrue: [ nil ]
        ifFalse: [
            OperatingSystem isWindows95
                ifTrue: [ KernelDLL16  fromInteger: ( KernelDLL16 new loadLibrary: 'KERNEL' ) ]
                ifFalse: [ KernelLibrary16 := KernelDLL16 new. KernelDLL16 getHandle ] ].

    GDILibrary := GDIDLL getHandle.

    WinLogicalObject startUp.
    Screen startUp.
    Bitmap startUp.
    Font startUp.
    CursorManager startUp.
    CurrentEvents := OrderedCollection new.
    Notifier initializeWindowHandles.
    self runningApplications: Dictionary new.
    GraphicsTool startUp.
    WinMsgNS := WinMessage
        atAddress: ( ExternalAddress allocateMemory: WinMessage sizeInBytes ).
    PoppedModelessWindows := OrderedCollection new.
    DialogBox startUp.
    FileDialog startUp.
    CallBack startUp.
    oldWindows := Notifier windows.
    Notifier initialize.
    SystemWindow startUp.  "maybe needed in non-gui?"
    HelpManager startUp.
    PrintDialog startUp.
    Printer startUp.
    self isRunTime ifTrue: [
        CurrentProcess terminationBlock: [ ^nil ].
        self changeRuntimeIcon ].
    ^oldWindows!   
width: w height: h  planes: planes bitCount: bitCount
        "Answer a new instance of the receiver with width of w,
         height of h, planes of planes, bit count of bitCount and
         size of bytes."
    | bytes  bitmapInfo |
    bytes := self getCb: bitCount.
    bitmapInfo := self new: bytes.
    bitmapInfo
        biSize: 40;
        width:  w;
        height: h;
        planes: planes;
        bitCount: bitCount.
    ( bitCount = 16 or: [ bitCount = 32 ] ) ifTrue: [
        bitmapInfo
            compression: 3; "BI_BITFIELDS"
            clrUsed: 3;
            uLongAtOffset: 40 put: 16r7C00;
            uLongAtOffset: 44 put: 16r3E0;
            uLongAtOffset: 48 put: 16r1F ].
    ^bitmapInfo! 
width: w height: h  planes: planes bitCount: bitCount size: bytes
        "Answer a new instance of the receiver with width of w,
        height of h, planes of planes, bit count of bitCount and
        size of bytes."
    ^(self new: bytes)
        uLongAtOffset: 0 put: 40;
        uLongAtOffset: 4 put: w;
        uLongAtOffset: 8 put: h;
        uShortAtOffset: 12 put: planes;
        uShortAtOffset: 14 put: bitCount;
        yourself!   
colorTableSize: bitCount
        "Private - Answer the size of the color table."
    bitCount <= 8
        ifTrue: [  ^( 1 bitShift: bitCount ) * 4  ].
    ( bitCount = 16 or: [ bitCount = 32 ] )
        ifTrue: [ ^12 ].    "3 DWORD masks"
    ^0     "No color table for 24 bitCount format."!
getCb: bitCount
        "Private - Answer the size of the bitmapInfo struct ."
    | count |
    count := WinBitmapInfoHeader sizeInBytes.
    bitCount <= 8
        ifTrue: [  ^( count + ( 4 * ( 1 bitShift: bitCount )  ) ) ].
    ( bitCount = 16 or: [ bitCount = 32 ] )
        ifTrue: [ ^count + 12 ].    "3 DWORD masks"
    ^count     "No color table for 24 bitCount format."!
sizeInBytes
        "Private - Answer the default size in bytes."
    ^40!  
width: w height: h  planes: planes bitCount: bitCount
        "Answer a new instance of the receiver with width of w,
        height of h, planes of planes and bit count of bitCount."
    | bitmapInfoHeader |
    bitmapInfoHeader := self new.
    bitmapInfoHeader
        biSize: 40;
        width:  w;
        height: h;
        planes: planes;
        bitCount: bitCount.
    ( bitCount = 16 or: [ bitCount = 32 ] ) ifTrue: [
        bitmapInfoHeader
            compression: 3; "BI_BITFIELDS"
            clrUsed: 3 ].
    ^bitmapInfoHeader!   
setValue
        "Private - Set the check state of the receiver to value."
    UserLibrary
        sendMessage: handle
        msg: BmSetcheck
        wparam: value asParameter
        lparam: nil!   
open: aTitle printer: aPrinter
        "Open a printer abort dialog. This dialog box
         allows the user to abort while printing."
    printer := aPrinter.
    title := aTitle.
    self
        createView;
        openModeless!   
initWindowSize
        "Private - Answer the window size."
    ^(30 @ 7) * WindowDialog unitMultiplier! 
createView
        "Create the view for the receiver."
    | lineHeight font multiplier pane |
    multiplier := self class unitMultiplier.
    lineHeight := 8.
    font := self class platformDefaultFont.
    self
        addView: ( self mainView
            owner: self;
            font: font;
            yourself );
        labelWithoutPrefix: ( title isNil ifTrue: [ 'Printing' ] ifFalse: [ title ] );
        addSubpane: ( StaticText new
            centered;
            contents: 'Printing...';
            framingBlock: [: box |
                ( box leftTop rightAndDown: 1 @ 1 * multiplier )
                    extentFromLeftTop: ( 28 @ 1 * multiplier ) ] );
        addSubpane: ( ( pane := Button new )
             owner: self;
             defaultPushButton;
             contents: 'Cancel';
             when: #clicked send: #cancel: to: self with: pane;
                    framingBlock: [ : box |
                        ( box leftTop rightAndDown: 10 @ 4 * multiplier )
                            extentFromLeftTop: 10 @ 2 * multiplier ] )! 
cancel: aButton
        "Private - cancel button pushed, close the window."
    printer abortPrintJob.
    self mainView close!
setWindowsHook: nFilterType proc: pfnFilterProc
    <api: SetWindowsHookA long ulong ulongReturn>
    ^self invalidArgument!
blackRectangle
        "Set and answer the control style for a static black rectangle."
	self
		removeStyle: SsBlackframe;
		removeStyle: SsWhiteframe;
		removeStyle: SsWhiterect;
		removeStyle: SsGrayframe;
		removeStyle: SsGrayrect.
    ^self addStyle: SsBlackrect!   
buildDialogItems
        "Private - Build the control items."
    children do: [ :subpane |
        subpane isSubPane ifTrue: [ subpane buildDialogItem: handle ].
        subpane validate ]!
spaceWidth
        "Answer the width of a space character."
    ^self charWidth: $ .!   
paletteIndex: aColorIndex
        "Private - Answer a palette-index COLORREF value."
    ^ 16r01000000 | aColorIndex!   
setTextAlign: taFlag
        "Set the text-alignment for the receiver. taFlags can be
          one of the following:
          TaBaseline, TaBottom, TaCenter, TaLeft, TaNoupdatecp,
          TaRight, TaTop, TaUpdatecp"
    self allHandles do: [ :h |
        ( GDILibrary setTextAlign: h flags: taFlag ) = 16rFFFFFFFF
            ifTrue: [ self osNotification ] ]!   
helpRequest
        "Private - Notify the help event."
    ( self handlesEvent: #help ) ifTrue: [
        ( self event: #help ) isNil
            ifTrue: [ ^super helpRequest ].
        ^self ].

    ( self hasActionForEvent: #help )
        ifTrue: [ ^self triggerEvent: #help ]
        ifFalse: [
            parent isNil
                ifTrue: [ super helpRequest ]
                ifFalse: [ parent helpRequest ] ]!  
contextForItem: anInteger
        "Private - The user has highlighted a menu item
        Answer a String for preview help"
    ^self popup contextForItem: anInteger! 
disabled
        "Answer true if the receiver is disabled, else false."
    ^(UserLibrary
        isWindowEnabled: self asParameter) not.! 
helpManager
        "Answer the receiver HelpManager instance,
        or nil if none."
    owner isNil ifTrue: [ ^nil ].
    owner mainWindow isApplicationWindow
        ifTrue: [ ^owner mainWindow helpManager ].
    ^nil! 
wmTimer: wparam with: lparam
        "Private - process the timer message to implement
        continuous scrolling."
    wparam = self class leftButtonScrollTimerId ifTrue: [
        self
            sendMouseMoveInputEvent: #button1Move:
            with: self cursorWindowPosition ].
    ^super wmTimer: wparam with: lparam!
getCharacter
        "Private - get and answer the Character that corresponds to the
        current character value."
    ^self characterValue asCharacter!   
isChild: parentHandle child: childHandle
    <api: IsChild ulong ulong boolean>
    ^self invalidArgument!  
chord: major minor: minor angles: aPoint
        "Draw a chord whose major axis is major and minor
         axis is minor. aPoint x
         is the starting angle of the arc in degrees. aPoint y is the
         sweeping angle between the starting angle and ending
         angle which goes clockwise if positive and counter-clockwise
         if negative. The interior of the chord is not filled."
    | startPoint endPoint boundingBox hOldBrush points |
    boundingBox := (self location leftAndUp: major @ minor) corner: (
        self location rightAndDown: major @ minor).
    points := self getArcPoints: major minor: minor angles: aPoint.
    startPoint := points at: 1.
    endPoint := points at: 2.
    hOldBrush := self selectStockObject: NullBrush.
    self chord: boundingBox
        start: startPoint
        end: endPoint.
    self selectObject: hOldBrush!
displaySelection: aRectangle
        "Private - Display the text contained in aRectangle.
         This is used for highlighting."
    | sourceY dest lastX lastY sourceX font lastLine aLine blankLine leadingBlank |
    charScanner := lastChild pen.
    font := charScanner font.
    sourceX := aRectangle origin x max: 1.
    sourceY := aRectangle origin y lowerOf:
        (lastChild topCorner y up: 1).
    lastX := aRectangle corner x.
    lastY := aRectangle corner y higherOf: (lastChild topCorner y
        down: lastChild charsInColumn + 1).
    ((sourceY isBelow: lastY) or: [lastY isAbove: sourceY])
        ifTrue: [^self].
    dest :=
        (frame leftTop x left: (lastChild topCorner x - 1 * font width))  @
             ((frame leftTop y
                 down: font basePoint y)
                    down:  (sourceY - lastChild  topCorner y * font height)) .

    lastY > lines size
        ifTrue: [lastLine := String with: $ ]
        ifFalse: [lastLine := lines at: lastY].
"    lastX > lastLine size ifTrue: [""extend the line""
        lastLine := lastLine, ((String new: lastX - lastLine size)
            atAllPut: $ )].
"
    (sourceY = lastY) ifTrue: [ "single line"
        leadingBlank := (dest right:
                        (charScanner stringWidthOf: lastLine
                            at: sourceX - 1)).
        lastChild doGraphics: [
                charScanner
                    displaySelectedText: (lastLine copyFrom: sourceX to: ( lastLine size min: lastX))
                    at: leadingBlank].
            ^self].
        "display first line for multi lines"
 "   blankLine := (String new: (lastChild extent x - dest x //
        (lastChild font charWidth: $ )) + 1)
            atAllPut: $ . "
    blankLine := String new.
    leadingBlank := (dest right:
                        (charScanner stringWidthOf: lastLine
                            at: sourceX - 1)).
    lastChild doGraphics: [
        sourceY > lines size
                ifTrue: [aLine := blankLine]
                ifFalse: [aLine := (lines at: sourceY), blankLine].
        leadingBlank := (dest right:
                        (charScanner stringWidthOf: aLine
                            at: sourceX - 1)).
        charScanner
                displayText: aLine
                from: sourceX
                to: aLine size
                at: leadingBlank.

        sourceY + 1 to: lastY - 1 do: [ :i |
            dest y: (dest y down: font height).
            i > lines size
                ifTrue: [aLine := blankLine]
                ifFalse: [aLine := (lines at: i), blankLine].
            charScanner
                displayText: aLine
                at: dest].
        charScanner
            displayText: lastLine
            from: 1
            to: lastX
            at: dest x @ (dest y + font height)]! 
hiliteMenuItem: hWnd menu: hMenu item: item flags: flags
    <api: HiliteMenuItem ulong ulong ulong ulong boolean>
    ^self invalidArgument!   
compatibleDirection: aBoolean
        "Set whether the receiver treats direction according to
        Smalltalk for OS/2 standard (true, which will be the case on
        all future platforms), or according to the Smalltalk for Windows
        2.0 and earlier standard (false) to aBoolean."
    compatibleDirection := aBoolean!  
setExtent
        "Private - set the width and height of the receiver's graphicsTool, which
        define the extent of the receiver, based on current system settings."
    self graphicsTool
        width: ( GDILibrary getDeviceCaps: self deviceContext index: Horzres );
        height: ( GDILibrary getDeviceCaps: self deviceContext index: Vertres )! 
iconSize
        "Private - Answer the icon's size"
    ^( OperatingSystem getSystemValue: SmCxicon )
        @ ( OperatingSystem getSystemValue: SmCyicon )!  
runtimeIcon
        "Private - Load and answer the default runtime icon"
    RuntimeIcon isNil ifTrue: [
        RuntimeIcon := self fromExe: SessionModel current imageName id: 1 ].
    ^RuntimeIcon!   
fromBitmap: aBitmap
        "Private - Answer a new instance of Icon copied from aBitmap."
    | andMask icon |
    andMask := Bitmap extent: self iconSize.
    andMask pen fill: andMask boundingBox rule: Blackness.
    icon := self fromBitmap: aBitmap andMask: andMask.
    andMask release.
    ^icon! 
fromFileStream: stream
        "Answer an instance of Icon from stream."
    | icon |
    icon := self  new.
    icon readOnly: false.
    icon fromFileStream: stream.
    ^icon!  
icon
        "Answer an instance of StaticGraphic capable of holding an icon
         as its contents; this is the default"
    ^self new! 
deleteMemoryDC
        "Private - Delete the memory device context."
    GraphicsTool defaultObjects do: [: hObject |
        GDILibrary selectObject: MemoryContext with: hObject].
    ( GDILibrary deleteDC: MemoryContext ) ifFalse: [ ^self osError ]!   
dragTargetLeaveDefault: dragSession
		"Private - provide default pane leave handling if no handler is provided."!
removeSizingBorderStyle
        "Remove the sizing border style."
    ^self removeStyle: WsThickframe!  
wmCreate: wordInteger with: longInteger
        "Private - Process WM_CREATE message.
        Create menu and subpanes."
    | remainingClientArea |

    NotificationManager newWindow: nil.
    menuWindow notNil ifTrue: [
        ( menuWindow buildWindow: self ) isNil
            ifTrue: [ ^-1 ] ].
    self receiveMessages.

    remainingClientArea := rectangle.
    self childrenAffectingClientArea
        do: [ :subpane |
            subpane initSize: remainingClientArea.
            remainingClientArea := subpane freeClientArea: remainingClientArea ].
    self childrenInBuildOrder do: [ :subpane |
        subpane affectsFreeClientArea
            ifFalse: [ subpane initSize: remainingClientArea ].
        ( subpane buildWindow: self ) isNil
            ifTrue: [ ^-1 ] ].

    ^nil!  
pickAColor: prompt initialColor: initialColor
        "Use the OS color selection dialog to select a color. Answer the
        color selected as a new instance of the receiver or nil if the dialog
        was canceled. Use <prompt> as the prompt string and <aColor>
        as the initial color value."
    | dialog selectedColor |
    dialog := ColorDialog new.
    dialog color: initialColor asRGBColor asInteger.
    selectedColor := dialog open; chosen.
    ^selectedColor!
isStatusPane
        "Answer whether the receiver is a StatusPane."
    ^false! 
getParent: hWnd
    <api: GetParent ulong ulongReturn>
    ^self invalidArgument!   
isStoredPicture
        "Answer whether the receiver is an instance of class
         StoredPicture or one of its subclasses."
    ^true!  
defaultMeasureControl: aMeasureItemStruct
        "Private - Set the size of the requested drawn item.
        Default is do nothing."! 
handleReadOnly
        "Private - Answer the handle of an icon loaded from a DLL"
    | nameResource |
    hIcon notNil ifTrue: [ ^hIcon ].
    ( dllFileName isNil and: [ name isNil ] ) ifTrue: [ ^hIcon := self class runtimeIcon handle ].
    dllFileName isNil ifFalse: [
        ( hLibrary := KernelLibrary loadLibrary: dllFileName asParameter ) = 0
            ifTrue: [
                self osWarning.
                hLibrary := nil.
                ^hIcon := self class runtimeIcon handle ] ].
    nameResource := name.
    name isInteger ifTrue:[
        nameResource := ExternalAddress new lowHalf: name].
    hIcon := UserLibrary loadIcon: hLibrary asParameter name: nameResource asParameter.
    hIcon = 0 ifTrue: [
        hLibrary notNil ifTrue: [
            ( KernelLibrary freeLibrary: hLibrary asParameter )
                ifFalse: [ ^self osError ].
            hLibrary := nil ].
        ^hIcon := self class runtimeIcon handle ].
    self needsFinalization.
    ^hIcon!
rectangle
        "Answer the bounding rectangle of the receiver."
    ^self isHandleOk
        ifTrue: [self queryClientRectangle asRectangle]
        ifFalse: [rectangle]! 
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process tab key."
    | virtualKey character |
	virtualKey := aKeyboardInputEvent virtualKey.
	( virtualKey == TabKey or: [ virtualKey == BacktabKey ] )
        ifTrue: [ parent tabKeyInput: aKeyboardInputEvent ].

    character := aKeyboardInputEvent character.
    character == Cr ifTrue: [
        value := self contents.
        parent triggerEvent: #entered: with: self value ]! 
drawingRectangle
        "Answer a rectangle which completely encloses the drawable
        area of the receiver (exclusive of scrollbars & border)."
    ^self rectangle! 
defFilter: aDefFilterString
        "Specifies the aDefFilterString as the default filter of File dialog."
    self propertyAt: #defFilter put: aDefFilterString.!  
displayLines: anIndexedCollection in: aRectangle
        "Private - display anIndexedCollection of Strings clipped within
        the bounds of aRectangle."
    self
        displayLines: anIndexedCollection
        from: 1
        to: anIndexedCollection size
        in: aRectangle!   
wmTimer: wordInteger with: longInteger
        "Private - Process the timer message by passing it
        off to the Timer class for event distribution."
    Timer timerTicked: wordInteger.
    ^nil!   
getMenuItemCount: aMenuHandle
    <api: GetMenuItemCount ulong long>
    ^self invalidArgument! 
width
        "Answer the width of the receiver."
    ^width!   
isZoomed: aWindowHandle
    <api: IsZoomed ulong boolean>
    ^self invalidArgument!
deleteDC
        "Private - Delete the non-window device context."
    self releaseAllObjects.
    ( GDILibrary deleteDC: deviceContext ) ifFalse: [ ^self osError ]!  
openClipboard: aHwnd
    <api: OpenClipboard ulong boolean>
     ^self invalidArgument! 
isDefaultPushButton
        "Private - Answer true if the receiver is the
        default pushbutton."
    ^false! 
charsInColumn
        "Private - Answer the receiver height in characters."
    ^self rectangle height // self font height! 
sampleForeColor: aColor 
	    "Set the foreground color of the sample string to aColor."
    | color |
    aColor isNil ifTrue: [ ^self ].
    color := aColor isInteger
        ifTrue: [ IndexedColor index: aColor ]
        ifFalse: [ aColor asIndexedColor ].
	self propertyAt: #sampleForeColor put: color! 
font: aFont
       "Set the font for the receiver to aFont."
    | curFontHandle controlFontHandle |
    aFont isNil ifTrue: [ ^self ].
    super font: aFont.
    self isHandleOk ifFalse: [ ^self ].
    ( ( curFontHandle := self font fontHandle ) notNil )
        ifTrue: [
            controlFontHandle := UserLibrary
                sendMessageInt: handle
                msg: WmGetfont
                wparam: 0
                lparam: 0.

            ( curFontHandle ~= controlFontHandle
             and: [ ( controlFontHandle = 0
              and: [ self font sameLogicalFont:  SysFont ] ) not ] )
                ifTrue: [
                    UserLibrary
                        sendMessage: handle
                        msg: WmSetfont
                        wparam: self font fontHandle
                        lparam: 1 ] ]!   
scrollBy: aPoint scrollRect: scrollRect clipRect: clipRect flags: anInteger
        "Scroll the receiver by aPoint in the x and y directions.  The flags
        are platform-dependent scrolling options."

    UserLibrary
        scrollWindow: handle asParameter
        xAmount: aPoint x
        yAmount: aPoint y
        lpRect: scrollRect asParameter
        clipRect: clipRect asParameter
        updateRegion: nil
        updateRect: nil
        scrollingFlags: anInteger!  
currentPrinterNames
        "Answers a DEVNAMES selfDefinedStructure containing
         the current printer driver name and port"
    DevNames isNil ifTrue: [ self printerDefault ].
    ^DevNames! 
setTopIndex: anInteger
        "Set the first visible item in the receiver to be
         the item at anInteger."
    self isHandleOk ifFalse: [ ^self ].
    UserLibrary
        sendMessage: handle
        msg: LbSettopindex
        wparam: anInteger - 1
        lparam: 0! 
helpModeCommand: wordInteger
        "Private - Process the command message when we are in help mode."
    |context|
    context := self mainWindow helpContext.
    context isNil ifTrue:[^nil].
    self mainWindow helpContext: nil.
    self helpManager isNil ifTrue:[^nil].
    self helpManager helpMode ifFalse:[^nil].
    self helpManager displayHelp: context key.
    ^0!   
display
        "Draw the receiver using the current graphics tool."
    self displayWith: graphicsTool!
customColors: anArray
        "Specifies the initial custom color setting of the dialog box. 16 elements array"
    | aColor |
    customColors := Array new: 16.
    customColors replaceFrom: 1 to: 16 with: anArray.

    1 to: 16 do: [:ix |
        customColors at: ix
                        put: ((aColor := customColors at: ix) isNil
                                        ifTrue: [(GraphicsTool red: 255 green: 255 blue: 255)]
                                        ifFalse: [aColor & 16r01000000 = 16r01000000
                                                                    ifTrue:[GraphicsTool paletteToRgb: aColor] ifFalse:[aColor]] )
                        ].!   
fromHandle: hBitmap clipWidth: aClipWidth clipHeight: aClipHeight
         "Answer an instance of Bitmap copied from
          bitmap handle hBitmap, Clipped by clipWidth
          and clipHeight."
    | bitmapStruct srcDC newBitmap oldHandle1 oldHandle2 aWidth aHeight|
    srcDC := self createCompatibleDC: Display deviceContext.
    oldHandle1 := GDILibrary selectObject: srcDC with: hBitmap.
    GDILibrary
        getObject: hBitmap
        count: WinBitmapStruct sizeInBytes
        lpObject: ( bitmapStruct :=  WinBitmapStruct new ) asParameter.
    aWidth := aClipWidth isNil
        ifTrue: [ bitmapStruct width ]
        ifFalse: [ bitmapStruct width min: aClipWidth ].
    aHeight := aClipHeight isNil
        ifTrue: [ bitmapStruct height ]
        ifFalse: [ bitmapStruct height min: aClipHeight ].
    bitmapStruct width: aWidth.
    bitmapStruct height: aHeight.
    newBitmap := self new bitmapIndirect: bitmapStruct.
    oldHandle2 := GDILibrary
        selectObject: newBitmap deviceContext
        with: newBitmap handle.
    self
        bitBlt: newBitmap deviceContext
        x: 0
        y: 0
        width: aWidth
        height: aHeight
        srcDC: srcDC
        xSrc: 0
        ySrc: 0
        rop: Srccopy.
     oldHandle1 ~= 0 ifTrue: [ GDILibrary selectObject: srcDC with: oldHandle1 ].
     ( GDILibrary deleteDC: srcDC ) ifFalse: [ ^self osError ].
     GDILibrary selectObject: newBitmap deviceContext with: oldHandle2.
     ^newBitmap!   
controlColor: aDC
        "Private - Set the background color.
         Default is do nothing."
    ^nil!  
dragTargetIsScrollable
		"Private - answer whether instances of the receiver are scrollable as a drag target."
    ^false!  
selectionMessage
        "Private - Answer the host message for retrieving the selected item."
    ^CbGetcursel!
escape: anEscapeFunction
        "Send anEscapeFunction with no data to the receiver device.
         anEscapeFunction is a constant from the OperatingSystemConstants
         pool dictionary.  Return nil if an error occurred."
    ( GDILibrary escape: deviceContext
        function: anEscapeFunction
        count: 0
        inData: nil
        outData: nil ) <= 0
            ifTrue: [ self osWarning. ^nil ].!
recreateWindow
        "Private - recreate the host window, because something
         needs to change which cannot be changed dynamically
         by the host OS."
    super recreateWindow.
    "recreate the entryField part of the combo box."
    entryField notNil ifTrue: [entryField stopReceivingMessages].
    self setEntryField!  
backColor: aColor
        "Set the background color of the receiver."
    | color |
    self propertyAt: #backColor put: aColor.
    self isHandleOk ifFalse: [ ^self ].
    graphicsTool notNil ifTrue: [
        ( color := aColor ) isNil
            ifTrue: [ color := self defaultBackColor ].
        self graphicsToolBackColor: color.
        self invalidateRect: nil ]!  
displayWith: aPen
        "Display the receiver through aPen."
    self displayAt: 0@0 with: aPen!  
lopen: aString style: anInteger
    <api: '_lopen' struct long long>
    ^self invalidArgument! 
isBitmap
        "Answer true if receiver is a kind of Bitmap."
    ^false! 
aboutToSaveImage
        "Obsolete - the image is about to be saved, do anything
        needed to save state for restoring upon restart.  Applications
        should register an event handler on the #aboutToSaveImage
        event in SessionModel instead, as this message will not be
        broadcasted to all ViewManager subclasses in the future."!  
compatibleDirection
        "Answer whether the receiver treats direction according to
        Smalltalk for OS/2 standard (true, which will be the case on
        all future platforms), or according to the Smalltalk for Windows
        2.0 and earlier standard (false)."
    ^compatibleDirection!
createPopupMenu
    <api: CreatePopupMenu ulongReturn>
    ^self invalidArgument!   
dragTargetEmphasisSeparator
		"Set the type of target emphasis to be employed to
		be separator based."
	self dragTargetEmphasis: 'separator'! 
expandBothEnds
        "Private - Expand the selection to the beginning of the
         line on the left and one more character on the right.
         This is needed for fonts with overhang."
    begin := 1 @ (begin y).
    end := end right: 1.!
printSetup
        "Private - User selected the Print Setup menu item
         from the File menu."
    PrintDialog printerSetup!  
createFont
        "Private - Create a new font in the host system
         based on current logicalFont structure.
         Answer the new font handle."
    | aHandle |
    ( handle := GDILibrary createFontIndirect: logicalFont contents ) = 0
        ifTrue: [ ^self osError ].
    aHandle := handle. "handle must be set for extractFontInfo"
    self extractFontInfo.
    handle :=
        FontHandleTable at: logicalFont contents
            ifAbsent: [
                FontHandleTable size > 250
                    ifTrue: [
                        self class cleanUpHandles.
                        FontHandleTable size > 250 ifTrue: [
                            Warning signal: 'Exceeding max number of fonts']].
                FontHandleTable at: logicalFont contents copy put: aHandle.
                ^aHandle].

    "if already exists, use the old handle and delete the new one."
    ( GDILibrary deleteObject: aHandle )
        ifFalse: [ ^self osError ].
    ^handle!  
dragSource
        "Enable the receiver as a drag drop source."
    self dragSource: true!  
setWindowWord: aWindowHandle index: anInteger word: wordInteger
    <api: SetWindowWord ulong long ushort ushort>
    ^self invalidArgument!
unitMultiplier
        "Private - answer the factor to multiply to convert from dialog units
        to device units (pixels)."
    ^self dialogUnit!  
open
        "Open the receiver with default message text."
    ^self open: '' message: 'Updating links...'!
initWindowSize
        "Private - Answer the window size."
    ^42 @ 8 * self class unitMultiplier! 
noCancel
        "Don't show a Cancel pushbutton; the receiver can only then be
        closed programmatically (not by the user)."
    noCancel := true!  
open: titleString message: messageString
        "Open the receiver with the given title and message text."
    | dialogFont pane cancelButton multiplier |
    dialogFont := self class platformDefaultFont.
    multiplier := self class unitMultiplier.
    pane := ( self mainView )
        owner: self;
        noSmalltalkMenuBar;
        removeMinimizeButtonStyle;
        removeMaximizeButtonStyle;
        removeSizingBorderStyle;
        addDialogBorderStyle;
        font: dialogFont;
        yourself.
    noCancel ifTrue: [ pane removeSystemMenuStyle ].
    self addView: pane.

    self
        labelWithoutPrefix: titleString;
        addSubpane: ( messageText := StaticText new
            contents: messageString;
            framingBlock: [ :box | ( box leftTop rightAndDown: 1@1 * multiplier )
                extentFromLeftTop: 40@1 * multiplier ] ).
    self
        addSubpane: ( ( percentText := StaticText new )
            owner: self;
            centered;
            setName: #percentText: ;
            when: #needsContents send: #percentText: to: self with: percentText;
            framingBlock: [ :box | ( box leftTop rightAndDown: ( noCancel ifTrue: [ 17 ] ifFalse: [ 13 ] )@3 * multiplier )
                extentFromLeftTop: 4@1 * multiplier ] );
        addSubpane: ( ( percentGraphic := GraphPane new )
            removeVerticalScrollbarStyle;
            removeHorizontalScrollbarStyle;
            owner: self;
            setName: #percentGraphic: ;
            when: #needsContents send: #percentGraphic: to: self with: percentGraphic;
            framingBlock: [ :box | ( box leftTop rightAndDown: 1@4 * multiplier )
                extentFromLeftTop: ( noCancel ifTrue: [ 39 ] ifFalse: [ 28 ] )@1 * multiplier ] ).
    noCancel
        ifTrue: [ self menuWindow systemMenu ]
        ifFalse: [
            self addSubpane: ( ( cancelButton := Button new )
                owner: self;
                contents: 'Cancel';
                when: #clicked send: #cancel: to: self with: cancelButton;
                framingBlock: [ :box | ( box leftTop rightAndDown: 30@4 * multiplier )
                    extentFromLeftTop: 10@2 * multiplier ] ) ].
    showPercent ifFalse: [ self hidePercent ].
    self openWindow!  
showPercent
    "Show the percent controls."

    showPercent := true.
    percentText showWindow.
    percentGraphic showWindow.!   
percentText: aStaticText
        "Private - update the percent text indicator."
    aStaticText contents: percentComplete printString, '%'! 
message: aString
        "Set the message text to display to aString."
    messageText contents: aString!   
percentGraphic: aGraphPane
        "Private - update the gauge graphic."
    | pen rectangle |
    pen := aGraphPane pen.
    rectangle := 0@0 extent: aGraphPane rectangle extent.
    rectangle width: ( rectangle width * percentComplete // 100 ) truncated.
    prevPercentComplete > percentComplete
        ifTrue: [ pen erase ].
    pen fill: rectangle color: Color blue!  
initialize
        "Private - initialize the state of the receiver."
    super initialize.
    prevPercentComplete := 0.
    percentComplete := 0.
    noCancel := false.
    canceled := false.
    showPercent := true.! 
cancel: aButton
        "Private - Cancel pushbutton was selected"
    canceled := true.
    self close!   
hidePercent
    "Hide the percent controls."

    showPercent := false.
    percentText isNil ifTrue: [ ^self ].
    percentText hideWindow.
    percentGraphic hideWindow.!
percent: anInteger
        "Update the percent complete of the operation in progress"
    prevPercentComplete := percentComplete.
    percentComplete := anInteger.
    self changed: #percentText: ;
        changed: #percentGraphic:! 
topPaneClass
        "Private - answer the class of the receiver's TopPane."
    ^TopPane!  
canceled
        "Answer whether the receiver was canceled (the user selected
        the Cancel button)."
    ^canceled!  
querySelectionInComboBox: itemId
        "Answer the selected item in the combo box whose
         id is itemId."
    ^self sendMessage: CbGetcursel item: itemId wparam: 0 lparam: 0! 
doGraphics: aBlock
        "Private - Perform aBlock bracketed by obtaining
         and releasing the cached GraphicsTool handle."
    | v old |
    self graphicsTool isNil ifTrue: [ ^self ].
    old := Process enableInterrupts: false. "do not want to get a paint now"
    ( self graphicsTool ifNilHandle: [ self getDC ] )
        ifTrue: [
            v := aBlock ensure: [
                self releaseDC: graphicsTool handle.
                self graphicsTool handle: nil ] ]
        ifFalse: [ v := aBlock value ].
    Process enableInterrupts: old.
    ^v!
cleanUp
        "Private - Free printDlgStruct."
    | address |
    self style: self flags.
    hDevMode notNil ifTrue: [
        ( KernelLibrary globalFree: hDevMode ) = 0
            ifFalse: [ ^self osError ] ].
    hDevNames notNil ifTrue: [
        ( KernelLibrary globalFree: hDevNames ) = 0
            ifFalse: [ ^self osError ] ].
    address := printDlgStruct contents.
    address free.
    printDlgStruct := nil! 
fromFile: aFileName
        "Answer a new instance of the receiver read from 
         aFilename." 
    ^self new fromFile: aFileName! 
setDIBits: aByteArray using: aBitmapInfo
        "Private - Set the bitmap bits of the receiver to aByteArray."
    | hdc result |
    hdc := UserLibrary getDC: nil.
    result := GDILibrary
        setDIBits: hdc
        hBitmap: self handle
        startScan: 0
        scans: self height
        bitsStruct: aByteArray asParameter
        bitsInfo: aBitmapInfo asParameter
        wUsage: DibRgbColors.
    UserLibrary releaseDC: nil with: hdc.
    result = 0 ifTrue: [ self osError ]! 
wmGetminmaxinfo: wparam with: lparam
        "Private - control the minimum size that the
        receiver may be scaled to using the sizing border."
    | minExtent maxExtent minmaxinfo |
    minExtent := self minimumSize.
    maxExtent := self maximumSize.
    ( minExtent isNil and: [ maxExtent isNil ] ) ifTrue: [ ^nil ].
    minmaxinfo := WinMinmaxinfo atAddress: ( ExternalAddress fromInteger: lparam ).
    minExtent notNil
        ifTrue: [ minmaxinfo ptMinTrackSize: ( WinPoint fromPoint: minExtent ) ].
    maxExtent notNil
        ifTrue: [ minmaxinfo ptMaxTrackSize: ( WinPoint fromPoint: maxExtent ) ].
    ^0!   
helpHook: nCode wparam: wparam lparam: lparam
        "Private - process help requests via a message filter help hook"
    | pMsg msg hwndHelpFocus |
    ( nCode < 0 or: [ lparam = 0 ] )
        ifTrue: [ ^self callDefHookProc: nCode wparam: wparam lparam: lparam ].
    pMsg := ExternalAddress fromInteger: lparam.
    msg := WinMessage atAddress: pMsg.

    ( ( nCode = MsgfDialogbox or: [ nCode = MsgfMenu ] ) and: [ self isHelpRequest: msg ] )
        ifTrue: [
            hwndHelpFocus := self getHelpWindowHandle: msg hwnd.
            UserLibrary
                sendMessage: hwndHelpFocus
                msg: WmStHelp
                wparam: nCode
                lparam: msg hwnd.
            ^true ].

    ^self callDefHookProc: nCode wparam: wparam lparam: lparam!   
addSubpane: aPane
        "Add aPane as the child of the receiver."
    | id |
    children isNil ifTrue: [ children := IdentityDictionary new ].
    ( id := aPane id ) isNil
        ifTrue: [ aPane id: ( id := self getNextChildId ) ].
    children at: id put: aPane.
    aPane parent: self.
    aPane owner isNil
        ifTrue: [ aPane owner: self owner ].
    aPane isControlPane ifTrue: [
        "if being added dynamically, then do subclassing"
        self isValid ifTrue: [ aPane subclassRecursively ] ].
    self mainWindow add: aPane interestIn: aPane name!  
wmTimer: wparam with: lparam
        "Private - process the timer message to implement
        continuous scrolling."
    wparam = self class rightButtonScrollTimerId ifTrue: [
        self
            sendMouseMoveInputEvent: #rightButtonScroll:
            with: self cursorWindowPosition ].
    ^super wmTimer: wparam with: lparam! 
asPointParameter
        "Answer the receiver in a form suitable for passing
        as a parameter to a host procedure call.  Use this
        method when the parameter must be a point and
        cannot be nil."
    ^( WinPoint fromPoint: self ) asParameter! 
font: aFont
        "Set the font for the receiver to aFont."
    font := aFont.
    (aFont notNil and: [aFont fontHandle notNil
    and: [deviceContext notNil]]) ifTrue: [
        self selectObject: aFont fontHandle].!  
horizontalScrollMinRange
        "Private - Answer the horizontal scrollbar's max range"
    | minPos |
    ( UserLibrary
        getScrollRange: self handle asParameter
        bar: SbHorz
        lpMinPos: ( minPos := ExternalLong new ) asParameter
        lpMaxPos: ExternalLong new asParameter )
            ifFalse: [ ^self osError ].
    ^minPos asInteger!   
font
        "Answer the font for the receiver."
    | aFont |
    ( aFont := self propertyAt: #font ) isNil
        ifTrue: [ aFont := self defaultFont ].
    ^aFont!  
addFilter: aFilter description: aDescription
        "Add aFilter and aDescription to the list of File dialog
        filters."
    filters add: ( Association key: aFilter value: aDescription ).!
wmSettingchange: wparam with: lparam
        "Private - handle desktop setting changes."
    | string msg |
    wparam = 0  ifTrue: [ "ini settings (NLS, etc.)"
        lparam = 0 ifTrue: [ ^nil ].
        string := String fromAddress: ( ExternalAddress fromInteger: lparam ).
        ( string equalsIgnoreCase: 'intl' ) ifTrue: [
            msg := Message receiver: NationalLanguage selector: #initialize.
            Notifier postInputEvent: msg ] ].
    ^nil!  
statusPaneHelp: aKey
        "Answer the hint text used by the StatusPane
        for help support; aKey is the selector of the
        highlighted menu item."
    | helpDict |
    helpDict := Smalltalk at: #HelpStatusPane ifAbsent: [ ^nil ].
    ^helpDict at: aKey ifAbsent: [ nil ]!
selection
        "Answers whether the user has selected selection"
     ^( self style & PdSelection ) ~= 0!
sort
        "Add the sort style."
    ^self addStyle: CbsSort! 
createWindowStruct: classNameInteger
    nameStruct: nameString
    style: styleInteger
    x: xInteger
    y: yInteger
    width: widthInteger
    height: heightInteger
    parent: parentHandle
    menu: menuHandle
    instance: instanceHandle
    param: paramStructure
       "Private - This method only works for non-predefined window classes."
    ^self
        createWindowStructEx: 0
        class: classNameInteger
        nameStruct: nameString
        style: styleInteger
        x: xInteger
        y: yInteger
        width: widthInteger
        height: heightInteger
        parent: parentHandle
        menu: menuHandle
        instance: instanceHandle
        param: paramStructure!  
dragSourceLocation: aPoint
        "Private - set the Point which is where dragging started."
    self propertyAt: #dragSourceLocation put: aPoint! 
getWinCursor: anInteger
        "Private - Answer an ExternalHandle for the host system
         mouse pointer identified by anInteger (from OperatingSystemConstants)."
    | int |
    ( int := UserLibrary loadCursor: nil name: anInteger ) = 0
        ifTrue: [ ^self osError ].
    ^ExternalHandle fromInteger: int!
defaultStyle
        "Private - Answer the default style for three state buttons."
    ^BsAuto3state!   
sendFile
        "The user selected Send from the File menu."
    self mainView sendFile!   
wmCtlcolorscrollbar: wparam with: lparam
        "Private - Process set control color message."
    | hbrush ctl3d |
    ( ctl3d := self class ctl3dIfEnabled ) notNil ifTrue: [
        ( hbrush := ctl3d current
            ctlColorEx: WmCtlcolorscrollbar
            wparam: wparam
            lparam: lparam ) ~= 0 ifTrue: [ ^hbrush ] ].
    ^self controlColor: lparam hDC: wparam!
showWindowAtTop
        "Private - make the window visible, but don't activate."
    UserLibrary showWindow: self command: SwShowna!
rightJustified
        "Set and answer the window style for right justified text."
    self
        removeStyle: SsLeft;
        removeStyle: SsLeftnowordwrap;
        removeStyle: SsCenter;
        addStyle: SsRight.
    self setStyle: self style!   
winHelp: anInteger data: param
        "Private - call WinHelp with the appropriate parameters."
    UserLibrary
        winHelp: applicationWindow asParameter
        helpFile: helpFile asParameter
        command: anInteger
        dwData: param asParameter!
fontMenu: anOwner
        "Answer a menu with all the available fonts."
    | faces temp sizes menu s allFonts |
    CursorManager execute changeFor: [
        menu := Menu new.
        menu title: 'Fonts'; owner: anOwner.
        faces := Dictionary new.
        allFonts := self allFonts. "makes list if it isn't already made"
        allFonts do: [:font |
            (faces at: font faceName ifAbsent: [
                faces at: font faceName put: OrderedCollection new])
                    add: font].
        temp := faces keys asSortedCollection.
        temp do: [:face |
            sizes := Menu new.
            sizes title: face; owner: anOwner.
            (faces at: face) do: [:font |
                s := font charSize printString.
                font isImage ifFalse: [s := s, ' *'].
                sizes
                    appendItem: s
                    selector: (allFonts indexOf: font)].
            menu appendSubMenu: sizes] ].
    ^menu!  
dragTargetEraseEmphasis: dragSession
		"Private - erase the (last drawn) target emphasis for the receiver.
		By default, do nothing.  Reimplemented by subclasses."
	self isDragTarget ifFalse: [ ^nil ].
    self
        triggerEvent: #dragTargetEraseEmphasis:
		withArguments: ( Array with: dragSession )
        ifNotHandled: [ self dragTargetEraseEmphasisDefault: dragSession ].

!   
showWindow: aBoolean
        "Private - Show or hide the receiver window."
    UserLibrary
        showWindow: self
        command: ( aBoolean ifTrue: [ SwShow ] ifFalse: [ SwHide ] )! 
openWindow: aTitleString
        "Create a new window titled aTitleString
         with a single GraphPane. Answer the GraphPane."
    ^self
        openWindow: aTitleString
        extent: (Display width * 11 // 20) @ (Display height * 4 // 5)!
openWindow: aTitleString extent: aPoint
        "Create a new window titled aTitleString and initial
        extent aPoint with a single GraphPane. Answer the
        GraphPane."
    | g w |
    w := ViewManager new.
    w
        label: aTitleString;
        addSubpane: ( g := self new
            framingRatio: ( 0 @ 0 extent: 1 @ 1 ) ).
     w mainView openIn: ( w mainView boxOfSize: aPoint ).
    ^g! 
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #button1Down ;
        add: #button1DownShift ;
        add: #button1Moved ;
        add: #button1UpShift ;
        add: #button2DoubleClicked ;
        add: #button2Down ;
        add: #button2Moved ;
        add: #clicked: ;
        add: #doubleClicked ;
        yourself!
amountToPageUp
        "Private - Answer the number of pixels for
         vertical page scrolling."
    ^64!  
stretch: anInteger
        "Set the scaling attribute of the receiver.
            anInteger = 0 means no stretch,
            anInteger = 1 means stretch but maintain aspect ratio,
            anInteger = other means stretch according to the
                dimension of the window."
    stretch := anInteger!  
showBitmap
        "Private - display the receiver's bitmap"
    | bitmap |
    bitmap := self bitmapIfAbsent: [ ^nil ].
    stretch = 0
        ifTrue: [        "don't stretch bitmap"
            graphicsTool
                copyBitmap: bitmap
                from: bitmap boundingBox
                at: 0 @ 0 ]
        ifFalse: [        "stretch to fit"
            graphicsTool
                copyBitmap: bitmap
                from: bitmap boundingBox
                to: self rectangle ]! 
amountToScrollLeft
        "Private - Answer the number of pixels
         for horizontal scrolling."
    ^8!  
bitmapIfAbsent: aBlock
        "Private - answer the bitmap or evaluate aBlock."
    ^self propertyAt: #bitmap ifAbsent: aBlock!
aboutToSaveImage
        "Private - The image is about to be saved. Save the contents
        of the receiver."
    graphicsTool notNil ifTrue: [
        "in case subclass uses something other than a RecordingPen"
        [ graphicsTool saveSegments ] on: MessageNotUnderstood do: [ :e | ] ].
    ^super aboutToSaveImage!   
button1Up: aPoint
        "Private - Left button has been released.
        Let the owner process the event."
    super button1Up: aPoint.
    handle = WindowHandle queryCapture ifFalse: [ ^self ].
    self clearMouseCapture.
    mouse := aPoint.
    self event: #button1Up.
    self triggerEvent: #clicked: with: aPoint! 
button2Up: aPoint
        "Private - button 2 has been released.
        Let the owner process the event or
        finish the right button scrolling."
    mouse := aPoint.
    self clearMouseCapture.
    ( ( self handlesEvent: #button2Up )
    or: [ self hasActionForEvent: #rightClicked ] )
        ifTrue: [
            self event: #button2Up.
            self triggerEvent: #rightClicked ]
        ifFalse: [ super button2Up: aPoint ]!
charsInRow
        "Private - Answer the receiver frame width."
    ^rectangle width!   
totalLength
        "Private - Answer the height of the receiver's graphics medium."
    ^self scrollingRectangle height!   
bitmap: aBitmap
        "Set the bitmap associated with the receiver."
    self propertyAt: #bitmap put: aBitmap.!  
erase
        "Erase the contents of the receiver pane."
    graphicsTool erase!
button1DownShift: aPoint
        "Private - Left button and shift key are both down.
        Let the owner process the event."
    self captureMouseInput.
    mouse := aPoint.
    self event: #button1DownShift.
    self triggerEvent: #button1DownShift!
bitmap
        "Answer the bitmap associated with the receiver."
    ^self bitmapIfAbsent: [Bitmap screenExtent: self extent]!  
mouseMove: aPoint
        "Private - Mouse has moved to aPoint.
        Let the owner process the event."
    mouse := aPoint.
    self event: #mouseMove.
    ^super mouseMove: aPoint! 
button1DoubleClick: aPoint
        "Private - button 1 has been double clicked.
        Let the owner process the event."
    mouse := aPoint.
    self event: #button1DoubleClick.
    self triggerEvent: #doubleClicked!   
button1UpShift: aPoint
        "Private - Button 1 has been released with shift key down.
        Let the owner process the event."
    super button1UpShift: aPoint.
    handle = WindowHandle queryCapture ifFalse: [ ^self ].
    self clearMouseCapture.
    mouse := aPoint.
    self event: #button1UpShift.
    self triggerEvent: #button1UpShift!
button2DoubleClick: aPoint
        "Private - button 2 has been double clicked.
        Let the owner process the event."
    mouse := aPoint.
    self event: #button2DoubleClick.
    self triggerEvent: #button2DoubleClicked!
scrollHorizontal: anInteger
        "Private - Scroll the pane right by anInteger
         number of pixels (if positive) or left by
         the absolute value of anInteger (if negative)."
    self scrollTopCorner: anInteger  @ 0!   
totalWidth
        "Private - Answer the width of the receiver's graphics medium."
    ^self scrollingRectangle width!  
graphicsToolClass
        "Private - Answer the graphics tool class used by the receiver."
    ^RecordingPen!   
button2Move: aPoint
        "Private - button 2 is down and the
        mouse has been moved.
        Let the owner process the event."
    self isLocalDragSource ifTrue: [ ^super button2Move: aPoint ].

    mouse := aPoint.
    self event: #button2Move.
    self triggerEvent: #button2Moved!  
amountToScrollUp
        "Private - Answer the number of pixels
         for vertical scrolling."
    ^8!  
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process tab key."
    | virtualKey |
	virtualKey := aKeyboardInputEvent virtualKey. 
	( virtualKey == TabKey or: [ virtualKey == BacktabKey ] )
        ifTrue: [ self tabKeyInput: aKeyboardInputEvent ].
    ^super keyboardInput: aKeyboardInputEvent!   
isGraphPane
        "Answer whether the receiver is a kind of GraphPane."
    ^true!
button2Down: aPoint
        "Private - button 2 has been pressed down.
        Let the owner process the event
        or do the right button scrolling."
    mouse := aPoint.
    ( ( self handlesEvent: #button2Down )
    or: [ self hasActionForEvent: #button2Down ] )
        ifTrue: [
            self event: #button2Down.
            self triggerEvent: #button2Down ]
        ifFalse: [ super button2Down: aPoint ]!   
charsInColumn
        "Private - Answer the receiver frame height."
    ^rectangle height!  
amountToPageLeft
        "Private - Answer the number of pixels for
         horizontal page scrolling."
    ^64!  
itemIds
        "Private - Answer the dictionary which maps
         item ids to/from item names. Usually reimplemented
         in subclasses."
    ^Dictionary new! 
deleteAllFromControl
        "Private - delete the contents of the listbox control."
    UserLibrary
        sendMessage: handle
        msg: self deleteAllMessage
        wparam: 0
        lparam: 0!
autoHScroll
        "Add the auto horizontal scroll style."
    ^self addStyle: EsAutohscroll!  
wmInitmenu: wordInteger with: longInteger
        "Private - Initialize the menu."
    self initMenu.
    ^nil!
rightJustified
        "Add the right justified style."
    self
        removeStyle: EsLeft;
        removeStyle: EsCenter;
        addStyle: EsRight.
    self setStyle: self style!  
wmInitdialog: wparam with: lparam
        "Private - Process the init dialog message."
    ^nil!
wmCtlcolorlistbox: wparam with: lparam
        "Private - Process set control color message."
    | hbrush ctl3d |
    ( ctl3d := self class ctl3dIfEnabled ) notNil ifTrue: [
        ( hbrush := ctl3d current
            ctlColorEx: WmCtlcolorlistbox
            wparam: wparam
            lparam: lparam ) ~= 0 ifTrue: [ ^hbrush ] ].
    ^self controlColor: lparam hDC: wparam!
textColor
        "Answer the textColor that the user chose."
    ^chosenForeColor! 
fromModule: aModuleName id: anInteger
        "Answer an instance of the receiver obtained
         from a resource in aModuleName whose
         resource id is anInteger."
    ^self new fromModule: aModuleName id: anInteger.!
hideSelection: beginPoint to: endPoint
        "Private - Toggle the display of the selection."
    self
        showSelection: beginPoint
        to: endPoint
        with: #normal:!  
deleteMenu: aMenu
        "Private - Delete aMenu from the receiver."
    | position |
    position := ( menus indexOf: aMenu ) - 1.
     ( UserLibrary
        deleteMenu: self handle
        position:  position
        flag: MfByposition )
            ifFalse: [ ^self osError ].
    ( UserLibrary drawMenuBar: parent asParameter )
        ifFalse: [ ^self osError ] !   
defaultExtendedStyle
        "Private - answer the default extended style flags for the
        receiver.  Add the 3d border style."
    ^OperatingSystem versionMajor >= 4 ifTrue: [ WsExClientedge ] ifFalse: [ 0 ]! 
cancel
        "Private - Handle the default cancel action."
    ^self close!   
wmMousemove: wParam with: lParam
        "Private - Process mouse move message."
    super wmMousemove: wParam with: lParam.
    ^( self isDragSource and: [ self isDragButton: 1 ] )  ifTrue: [ false ] ifFalse: [ nil ]! 
scrollWindow: hWnd xAmount: anInt1 yAmount: anInt2 lpRect: aRect1 clipRect: aRect2
    <api: ScrollWindow ulong long long struct struct boolean>
    ^self invalidArgument! 
for: aWindow title: aString file: aFileName dialogs: aCollection
        "Answer an instance of the receiver initialized
         for aWindow with aString as its title and whose
         help file is in aFileName (a .HLP file).  aCollection
         must contain the dialog box ids for the application."
    ^self
        for: aWindow
        title: aString
        file: aFileName
        dialogs: aCollection
        aboutDlgClass: nil!  
mdiSelected:aBoolean
        "Private - Sets the focus flag of the MDI document.
        Default processing is to do nothing."! 
deferWindowPos: hWinPosInfo
        window: aWindowHandle
        insertAfter: insertHandle
        x: xInteger
        y: yInteger
        cx: xExtent
        cy: yExtent
        flags: flagsInteger
    <api: DeferWindowPos ulong ulong ulong long long long long ulong ulongReturn>
    ^self invalidArgument! 
autoVScroll
        "Add the auto vertical scroll style."
    ^self addStyle: EsAutovscroll!
isTopPane
        "Answer whether the receiver is a kind of TopPane."
    ^false
   !  
createControlPanes
        "Create instances of appropriate ControlPane subclasses
         for each host child control in the host dialog; the host dialog
         window must have been created prior to sending this
         message (e.g. via fromModule:id:)"
    | cHandle id |
    cHandle := UserLibrary getWindow: handle relationship: GwChild.
    [ cHandle ~= 0 ] whileTrue: [
        id := UserLibrary getWindowLong: cHandle index: GwlId.
        self paneAt: id.
        cHandle := UserLibrary getWindow: cHandle relationship: GwHwndnext ]! 
charAt: pos
        "Private - Answer the character at position pos.
         Answer nil if pos is out of bounds.  Assumes
        getWindowText has been called previously."
    pos < 1 ifTrue: [ ^nil ].
    pos > value size
        ifTrue: [ ^nil ]
        ifFalse: [ ^value at: pos ]! 
dragSourceNeedsObjectDefault: dragSession
        "Private - provide default for requested drag items if no handler
        is provided by supplying the currently selected item."
    | dragDropObject itemIndex item |
    itemIndex := self itemIndexFromPoint: ( dragSession screenLocation mapToWindow: self ).
    item := list at: itemIndex.
    dragDropObject := dragSession objectClass new
        object: item;
        string: ( self stringForItem: item );
        yourself.
    dragSession objects: ( Array with: dragDropObject )!   
undo
        "Undo the last edit operation if possible."
    | result |
    self isHandleOk
        ifTrue: [
        "EmUndo does not set the changed flag,
        so we first check to see if the undo is going to change
        the text, if so set the changed flag from Smalltalk."
            result := UserLibrary
                sendMessageInt: handle
                msg: EmCanundo
                wparam: 0
                lparam: 0.
            result asBoolean ifFalse: [ ^nil ].

            result := UserLibrary
                sendMessageInt: handle
                msg: EmUndo
                wparam: 0
                lparam: 0.
            result ~= 0 ifTrue: [
                self modified: true.
                value := nil.
                self event: #textChanged.
                self triggerEvent: #textChanged: with: self value ] ]!  
copySelection
        "Copy current selection to the clipboard."
    self resetUndo.
    self isHandleOk ifTrue: [
        UserLibrary
            sendMessage: handle
            msg: WmCopy
            wparam: 0
            lparam: 0 ]! 
returnFromRecursion: stack value: returnValue
        "Private - Return to host OS after handling callback message"
    <primitive: 127>!   
setRop2: r2Constant
        "Set the current drawing mode to r2Constant. r2Constant
         can be any one the following:
         R2Black, R2White, R2Nop, R2Not, R2Copypen, R2Notcopypen,
         R2Mergepennot, R2Maskpennot, R2Mergenotpen, R2Masknotpen,
         R2Mergepen, R2Notmergepen, R2Maskpen, R2Notmaskpen,
         R2Xorpen, R2Notxorpen"
    self allHandles do: [ :h |
        ( GDILibrary setRop2: h drawMode: r2Constant ) = 0
            ifTrue: [ ^self osError ] ]!  
asParameter
        "Answer the receiver in a form suitable
        for passing to an API call."
    ^( WinColorref fromColor: self ) asParameter! 
setWindowPos: hwndInsertBehind rectangle: aRectangle fs: flagWord
        "Private - Set the window size and position of the receiver."
    | aFlagWord |
    ( flagWord = 0 or: [ flagWord = nil ] )
        ifTrue: [ aFlagWord := SwpNoactivate ]
        ifFalse: [ aFlagWord := flagWord ].
    ( UserLibrary
        setWindowPos: self
        insertAfter: hwndInsertBehind
        x: aRectangle origin x asInteger
        y: aRectangle origin y asInteger
        cx: aRectangle width asInteger
        cy: aRectangle height asInteger
        flags: aFlagWord )
            ifFalse: [ ^self osError ]! 
update: anObject
        "Private - The model has changed. If anObject is a
         TextSelection, display it, else pass it
         up to superclass."
    | old |
    old :=  Process enableInterrupts: false. "do not want to get a paint message while in doGraphics"
    anObject isTextSelection
        ifTrue: [    "update changedArea"
            self font overHang > 1 ifTrue: [ anObject expandBothEnds ].
            changedArea == nil
                ifTrue: [ changedArea := anObject ]
                ifFalse: [ changedArea := changedArea merge: anObject ] ]
        ifFalse: [ super update: anObject ].
    Process enableInterrupts: old!   
defaultPushButton
        "Not support for DrawnButton."
    self invalidMessage!   
fontChange
        "Private - Window's font has changed."
    self font: self font.
    children size ~= 0
        ifTrue: [
            children do: [:each |
                each fontChange]]!   
ownDCScreenExtent: anExtent
        "Create a screen compatible bitmap with width anExtent
         x height anExtent y. The bitmap has its own device context."
    ^self ownDCScreenWidth: anExtent x height: anExtent y!
initialize
        "Private - Initialize the receiver."
    super initialize.
    firstTime := true.
    self fontAttribute: SysFont.
    mouse := 0 @ 0.
    topCorner := nil.
    stretch := 0!  
wmRbuttondblclk: wordInteger with: longInteger
        "Private - Process the right button double click message."
    self
        sendInputEvent: #button2DoubleClick:
        with: ( Point fromInteger: longInteger ).
    ^nil!  
cycle
        "Activate each main window in order."
    | mainWindows activeIndex nextWindow |
    mainWindows := windows select: [ :w |
        w isApplicationWindow and: [ w parent isNil ] ].
    mainWindows := mainWindows keys asArray.
    activeIndex := mainWindows indexOf:
        self activeMainWindow handle asInteger.
    activeIndex := ( activeIndex \\ mainWindows size ) + 1.
    nextWindow := windows at: ( mainWindows at: activeIndex ).
    nextWindow makeActive!
width: w height: h
        "Answer a new Bitmap with width w and height h."
    ^self new width: w height: h!   
wmSyscommand: wordInteger with: longInteger
        "Private - Add a MessageExpression to CurrentEvents
         and return right away."
    | id |
    ( self helpModeSyscommand: wordInteger ) notNil
        ifTrue: [ ^0 ].
    ( wordInteger bitAnd: 16rF000 ) = 0
        ifTrue: [
            id := wordInteger // 256 * 256 + ( wordInteger \\ 256 bitShift: -4 ).
            self
                sendInputEvent: #performMenuItem:
                with: id.
            ^0 ]
        ifFalse: [
            ( wordInteger bitAnd: 16rFFF0 ) = ScMinimize
                ifTrue: [ self minimizingWindow ]
                ifFalse: [ ( wordInteger bitAnd: 16rFFF0 ) = ScRestore
                    ifTrue: [ self restoringWindow ]
                    ifFalse: [ ( wordInteger bitAnd: 16rFFF0 ) = ScMaximize
                        ifTrue: [ self maximizingWindow ] ] ] ].
     ^nil!   
setDlgItemText: hDlg item: nIDDlgItem text: lpString
    <api: SetDlgItemTextA ulong long struct boolean>
    ^self invalidArgument!
copyStruct
        "Private - copies the chooseFontStruct to nonSmalltalk memory"
    | aPrinter temp |
    temp := ExternalAddress copyToNonSmalltalkMemory: chooseFontStruct contents.
    chooseFontStruct := SelfDefinedStructure named: 'CHOOSEFONT' atAddress: temp.

    Printer exists ifTrue: [
        aPrinter := Printer new.
        aPrinter buildPrinter.
        chooseFontStruct hDC: aPrinter deviceContext.
        self propertyAt: #printer put: aPrinter.
        self style: self style | CfPrinterfonts ].

    lpLogFont := ExternalAddress
        copyToNonSmalltalkMemory: self sampleFont logicalFont contents.
    chooseFontStruct lpLogFont: lpLogFont asInteger!  
tabScope
        "Private - GroupPane contains the tabbing information
        for all its children."
    ^self!   
scrollVertical: anInt
        "Private - Reimplemented here because GroupPanes do
         not scroll."!
addSubpane: aPane
			"Add subpane aPane to the receiver."
	super addSubpane: aPane.
	aPane owner isNil
		ifTrue: [ aPane owner: self ].
	self addTabInfoFor: aPane!  
canArrowInto
        "Private - Arrow keys cycle the focus inside the
        GroupPane.  Cannot cross the GroupPane boundary
        with the arrow keys."
    ^false!   
updateSliders
        "Private - Reimplemented here because GroupPanes
         have no scrollbars."!   
nextTabStop
        "Private - Answer the first child which is a tabstop."
    | orderedChildren |
    (orderedChildren := self orderedChildren) isEmpty
        ifTrue: [^self parent tabScope nextTabStop: self].
    ^orderedChildren first nextTabStop!  
childClicked: aChild
        "Private - Set the child that was clicked to aChild."
    childClicked := aChild.
    self event: #childClicked!  
nextTabStop: aSubPane
        "Private - Answer the first subpane following aSubPane
        which is a tabstop."
    | orderedChildren index |
    ( orderedChildren := self orderedChildren ) isEmpty
        ifTrue: [ ^self ].
    index := orderedChildren indexOf: aSubPane.
    ^index < orderedChildren size
        ifTrue: [(orderedChildren at: index + 1) nextTabStop]
        ifFalse: [self parent tabScope nextTabStop: self]!
scrollHorizontal: anInt
        "Private - Reimplemented here because GroupPanes do
         not scroll."!  
previousTabStop
        "Private - Answer the first child inside which is a tabstop
        starting from the end ."
    | orderedChildren |
    (orderedChildren := self orderedChildren) isEmpty
        ifTrue: [^self parent tabScope previousTabStop: self].
    ^orderedChildren last previousTabStop!
previousTabStop: aSubPane
        "Private - Answer the first subpane preceding from
        aSubPane which is a tabstop."
    | orderedChildren index |
    ( orderedChildren := self orderedChildren ) isEmpty
        ifTrue: [ ^self ].
    index := orderedChildren indexOf: aSubPane.
    ^index > 1
        ifTrue: [(orderedChildren at: index - 1) previousTabStop]
        ifFalse: [self parent tabScope previousTabStop: self]!  
childClicked
        "Answer the child that was clicked."
    ^childClicked!
createDialogParam: hInstance id: id parent: hWndParent dialogFunction: lpDialogFunc initParam: anInteger
    <api: CreateDialogParamA ulong ulong ulong ulong ulong ulongReturn>
    ^self invalidArgument! 
backColor: aColor
        "Set the background color and brush of the receiver to aColor."
    | color |
    super backColor: aColor.
    deviceContext notNil ifTrue: [
        color := backColor isNil ifTrue: [ Color windowBackground ] ifFalse: [ backColor ].
        self setSolidBrush: color ]!
setProp: hWnd name: lpString data: hdata
        "Private - Set item identified by lpString to hdata in hWnd's
         property list."
    <api: SetPropA ulong struct ulong boolean>
    ^self invalidArgument! 
queryText: text inComboBox: itemId
        "Find the first string in the combo box which matches
        the text and returns the index.  Index is 0 relative."
    ^ self
        queryText: text
        inComboBox: itemId
        startingAt: -1.!  
pasteSelection
        "Replace selected text with the clipboard contents."
    self resetUndo.
    self isHandleOk ifTrue: [
        UserLibrary
            sendMessage: handle
            msg: WmPaste
            wparam: 0
            lparam: 0 ]! 
setHatchBrush: hatchStyle color: aColor
        "Set the background hatched brush with hatchStyle and
         aColor as its hatch style and color."
    logicalBrush := WinLogicalBrush
        style: BsHatched color: aColor hatch: hatchStyle .
    self selectObject: logicalBrush handle!  
asRGBColor
        "Answer an instance of RGBColor created from the receiver."
    ^self asIndexedColor asRGBColor! 
getSavedWindow: hwnd with: lparam
        "Private - if hwnd corresponds to a Smalltalk window, add its
        window object to savedWindows."
    ( self windows includesKey: hwnd )
        ifTrue: [ savedWindows add: ( self windows at: hwnd ) ].
    ^true!   
helpRequest
        "Private - Help has been requested"
    self helpManager notNil ifTrue:[
        self helpContext isNil
            ifTrue:[self helpManager displayHelp: nil]
            ifFalse:[self helpManager displayHelp: self helpContext key].
        self helpContext: nil.
        ^true].!   
setScrollRange: aWindowHandle bar: anInteger min: minInteger max: maxInteger redraw: aBoolean
    <api: SetScrollRange ulong long long long boolean boolean>
    ^self invalidArgument! 
andMask: aBitmap
        "Private - Set the AND mask to aBitmap."
    andMask := aBitmap!   
dragSourceNeedsObject: dragSession
        "Private - retrieve the object to be dragged."
    self selectedItems isNil ifTrue: [ ^nil ].
    self dragSourceSelection: self selections.
    ^super dragSourceNeedsObject: dragSession.
! 
sendMessageInt: aWindowHandle
        msg: msgInteger
        wparam: wordInteger
        lparam: longInteger
    <api: SendMessageA ulong ulong ulong long long>
    ^self invalidArgument! 
translateMessage: aWinAddr
    <api: TranslateMessage ulong boolean>
    ^self invalidArgument! 
destroy
        "Private - Destroy the receiver."
    self isHandleOk ifFalse: [ ^self ].  "don't destroy if already destroyed."
    ( UserLibrary destroyMenu: self asParameter )
        ifFalse: [ ^self osError ].
    handle := WindowHandle nullValue! 
defaultPen
        "Private - Answer the default logical pen."
    ^WinLogicalPen style: nil color: nil width: nil! 
ownDCWidth: w height: h
        "Create a monochrome bitmap with width w height h.
         The bitmap has its own device context."
    | hOldBitmap aDC |
    aDC := self class createCompatibleDC: Display deviceContext.
    self initPenWidth: w
        height: h
        planes: 1
        bitCount: 1
        forDC: aDC.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap!
deactivate
        "Private - The receiver has been deactivated."
    graphicsTool notNil
        ifTrue: [graphicsTool release]!  
loadBitmap: hInstance nameInteger: resourceID
    <api: LoadBitmapA ulong ulong ulongReturn>
    ^self invalidArgument! 
wmParentnotify: wordInteger with: longInteger
        "Private - process the WM_PARENTNOTIFY message."
    ^nil!
turnOffHelpMode
        "Private - The user has clicked Esc
        Turn Help Mode off and set the cursor back"
    helpMode := false.
    Cursor handle notNil
        ifTrue:[Cursor setCursor]
        ifFalse:[CursorManager arrow setCursor]!  
upperCase
        "Add the upper case style."
    ^self addStyle: EsUppercase!  
fromRectangle: aRectangle
        "Private - Answer a WinRectangle created from aRectangle."
    | r |
    r := self new.
    r xLeft: aRectangle left.
    r yBottom: aRectangle bottom.
    r xRight: aRectangle right.
    r yTop: aRectangle top.
    ^r! 
sizeInBytes
    ^16.!
asRectangle
    ^self xLeft @ self yTop
        corner: self xRight @ self yBottom! 
printOn: aStream
        "Append a textual representation of the receiver to aStream."
    aStream nextPutAll: self class name, ' { ', self asRectangle printString, ' } '! 
xLeft
    ^self longAtOffset: 0! 
xLeft: anInteger
    ^self longAtOffset: 0 put: anInteger!   
xRight: anInteger
    ^self longAtOffset: 8 put: anInteger!  
yTop: anInteger
    ^self longAtOffset: 4 put: anInteger!
yBottom
    ^self longAtOffset: 12!  
yBottom: anInteger
    ^self longAtOffset: 12 put: anInteger!
yTop
    ^self longAtOffset: 4!  
xRight
    ^self longAtOffset: 8!
controlColor: aDeviceContext
        "Private - Set the background of the receiver."
    | brush backColor foreColor |
    ( foreColor := self foreColor ) isNil ifTrue: [ foreColor := self defaultForeColor ].
    ( GDILibrary setTextColor: aDeviceContext with: foreColor asParameter ) = 16rFFFFFFFF
        ifTrue: [ ^self osError ].
    ( backColor := self backColor ) isNil ifTrue: [
        ( self isTransparent and: [ self parent notNil ] )
            ifTrue: [
                backColor := parent backColor.
                backColor isNil ifTrue: [ backColor := parent defaultBackColor ] ]
            ifFalse: [ backColor := self defaultBackColor ] ].
    ( brush := WinLogicalBrush style: BsSolid color: backColor hatch: nil )
         isNil ifTrue: [ ^nil ].
    ( GDILibrary setBkColor: aDeviceContext with: backColor asParameter ) = 16rFFFFFFFF
        ifTrue: [ ^self osError ].
    ( GDILibrary setBrushOrgEx: aDeviceContext x: 0 y: 0 oldOrigin: nil )
        ifFalse: [ ^self osError ].
    ^brush asParameter!   
colorMenu: ownerWindow selector: aSymbol
        "Answer a Menu with the standard colors.
         When the user selects a color from the menu,
         aSymbol is sent to ownerWindow as a message
         with one argument which is the color chosen."
    ^(self
        labels: 'White\Black\Blue\Red\Green\Pink\Cyan\Yellow\Dark gray\Pale blue\Dark red\Dark pink\Dark green\Dark cyan\Brown\Pale gray' withCrs
        lines: #()
        selectors: #(16rFFFFFF 0 16rFF0000 16rFF 16rFF00 16rFF00FF 16rFFFF00 16rFFFF 16r828282 16r800000 16r80 16r800080 16r8000  16r1000006 16r8080 16rC0C0C0))
                title: '&Color';
                owner: ownerWindow;
                selector: aSymbol;
                yourself!
currentSegment
        "Private - answer the current graphics segment."
    ^(self segments at: currentId)! 
setReadOnly
        "Private - set or clear the read-only setting of the host control
        depending on the current read-only style setting."
    UserLibrary
        sendMessage: handle
        msg: EmSetreadonly
        wparam: ( self hasStyle: EsReadonly ) asParameter
        lparam: 0!   
addModalBorderStyle
        "Add the modal border style."
    ^self addStyle: DsModalframe! 
systemContextStrings
        "Private - Answer the system context strings dictionary"
    ^SystemContextStrings!
enableItem: item
        "Enable an item.  item can be the label or the selector."
    | mi |
    ( self isThere: item ) ifFalse: [ ^self ].
    mi := self getMenuItem: item.
    mi hasSubmenu
        ifTrue: [ ^mi submenu enableAll ].
    ( self isDisabled: item ) ifFalse: [ ^self ].
    mi attribute: ( mi attribute bitAnd: ( MfGrayed bitXor: 16rFFFF ) ).
    self updateItem: mi attributes: MfGrayed! 
print
        "Private - Open a PrintDialog to permit printing of the contents or selection
        of the receiver."
    | dialog hDCPrinter printer string |
    dialog := PrintDialog new
        noPages.
    self selectedItem isEmpty ifTrue: [ dialog noSelection ].
    dialog open.

    ( hDCPrinter := dialog hDCPrinter ) isNil ifTrue: [ ^nil ].
    printer := Printer fromDC: hDCPrinter.
    string := dialog selection ifTrue: [ self selectedItem ] ifFalse: [ self contents ].
    [ printer
        print: string
        font: self pen font
        title: nil
        collate: dialog collate
        copies: dialog copies
        wordWrap: false
        marginsRect: nil ] forkAt: 3!   
frameRelativeRectangle
        "Answer the receiver's frame window rectangle
         relative to the super window."
    | sw |
    (sw := self superWindow) isNil
        ifTrue: [^self frameRectangle].
    ^self frameRectangle mapToWindow: sw!
unhookWindowsHook: hookType proc: pfnHookProc
    <api: UnhookWindowsHook long ulong boolean>
    ^self invalidArgument!
isLocalDragSource
        "Answer whether the receiver is enabled as a local drag drop source."
    ^self isDragSource and: [
		self dragSessionClass isNil or: [
			self dragSessionClass isLocalDragDropSession ]]! 
fromHandle: handle style: style
        "Private - answer a new instance of the receiver class or one
        of its subclasses, based on the given window handle and style."
    | class |
    ( style & BsOwnerdraw ) = BsOwnerdraw
        ifTrue: [ class := DrawnButton ]
        ifFalse: [
            ( style & BsGroupbox ) = BsGroupbox
                ifTrue: [ class := GroupBox ]
                ifFalse: [
                    ( style & Bs3state ) = Bs3state |
                    ( style & BsAuto3state ) = BsAuto3state
                        ifTrue: [ class := ThreeStateButton ]
                        ifFalse: [
                            ( style & BsCheckbox = BsCheckbox ) |
                            ( style & BsAutocheckbox = BsAutocheckbox )
                                ifTrue: [ class := CheckBox ]
                                ifFalse: [
                                    ( style & BsRadiobutton = BsRadiobutton ) |
                                    ( style & BsAutoradiobutton = BsAutoradiobutton )
                                        ifTrue: [ class := RadioButton ]
                                        ifFalse: [ class := self ] ] ] ] ].

    ^class handle: ( WindowHandle fromInteger: handle )!  
getMenuState: aMenuHandle position: posInteger flags:flagsInteger
    <api: GetMenuState ulong ulong ulong ulongReturn>
    ^self invalidArgument!  
translateAccelerator: aWinMessage
        "Private -  Translates a system message into accelerator key stroke.
         Answer true if it is an accelerator key stroke, else answer false."
    | aWindow mainWindow afBits aMenuWindow accelTable index hwnd char scanCode |
    hwnd := aWinMessage hwnd.
    ( aWindow := Notifier findRealWindow: hwnd ) isNil
        ifTrue: [ ^false ].

    ( aWindow mainWindow isMDIChild or: [ aWindow isMDIClient ] )
        ifTrue: [
            ( self translateMDISysAccel: aWinMessage )
                ifTrue: [ ^true ] ].

    mainWindow := aWindow mainWindow.
    ( aMenuWindow := mainWindow menuWindow ) isNil
        ifTrue: [ ^false ].

    scanCode := aWinMessage scanCode.
    char := UserLibrary mapVirtualKey: scanCode mapType: 1.

    afBits := 0.
    ( UserLibrary getKeyState: VkControl ) < 0
        ifTrue: [ afBits := afBits | AfControl ].
    ( UserLibrary getKeyState: VkMenu ) < 0
        ifTrue: [ afBits := afBits | AfAlt ].
    ( UserLibrary getKeyState: VkShift ) < 0
        ifTrue: [ afBits := afBits | AfShift ].

        "Don't interpret the accelerator if the destination
         window wants to handle it itself"
    ( aWindow accel: char afBits: afBits )
        ifTrue: [ ^true ].

        "If Control-Break then halt."
    ( afBits = AfControl and: [ char = 145 ] ) ifTrue: [
        CurrentProcess isBeingDebugged
            ifTrue: [ Process controlBreakInterrupt. ^true ]
            ifFalse: [ Process interrupt: 2. ^true ] ].

        "Dispatch the interpreted message to its receiver"
    ( accelTable := aMenuWindow accelTable ) isNil
        ifTrue: [ ^false ].
    ( index := accelTable at: ( Array with: char with: afBits ) ifAbsent: [ nil ] ) isNil
        ifTrue: [ ^false ].
    aMenuWindow sendInputEvent: #performMenuItem: with: index.
    ^true!  
centerText: aString at: aPoint
        "Display aString centered at aPoint."
    | offset pt alignment |
    offset := ( ( font stringWidth: aString ) @ ( font height - font descender ) ) // 2.
    pt := aPoint leftAndDown: offset.
    alignment := self getTextAlign.
    self setTextAlign: TaBottom.
    self displayText: aString at: pt.
    self setTextAlign: alignment!  
extractStockFontInfo
        "Private - Extract stock font information from the host system."
    | sysLogFont sysFontMetrics hDC hOldFont |
    handle isNil ifTrue: [ ^self ].
    sysLogFont := WinLogFont new.
    sysFontMetrics := WinTextMetrics new.
    hDC := graphicsMedium deviceContext.
    hOldFont := GDILibrary selectObject: hDC with: handle.
    GDILibrary getObject: handle
        count: sysLogFont size
        lpObject: sysLogFont contents.
    ( GDILibrary getTextMetrics: hDC
        lpMetrics: sysFontMetrics contents )
            ifFalse: [ ^self osError ].
    self logicalFont: sysLogFont.
    self initFontInfo: sysFontMetrics! 
enableRedraw
        "Allow the receiver to be redrawn; force the receiver to
        repaint itself."
    self isHandleOk
        ifTrue: [
            handle enableRedraw.
            self invalidateRect: nil ]
        ifFalse: [ self whenValid: #enableRedraw ]!   
endDialog: hDlg withResult: nResult
    <api: EndDialog ulong long boolean>
    ^self invalidArgument!  
dragSourceNeedsObjectDefault: dragSession
        "Private - provide default for requested drag items if no handler
        is provided by supplying the currently selected item."
    | dragDropObject itemIndex item |
    itemIndex := self itemIndexFromPoint: ( dragSession screenLocation mapToWindow: self ).
    ( itemIndex between: 1 and: list size ) ifFalse: [ ^self ].  "out of list bounds"
    item := list at: itemIndex.
    dragDropObject := dragSession objectClass new
        object: item;
        string: ( self stringForItem: item );
        yourself.
    dragSession objects: ( Array with: dragDropObject )
!  
wmKeydown: wordInteger with: longInteger
        "Private - Make sure Control Tab does not generate
        a Tab character."
    super wmKeydown: wordInteger with: longInteger.
    ( wordInteger = TabKey and: [ ( UserLibrary getKeyState: VkControl ) < 0 ] )
        ifTrue: [ ^1 ].
    ^nil!
defaultStyle
        "Private - Answer the default check box window style."
    ^BsAutocheckbox!
buildPopupWindow
        "Private - Create the popup menu"
    | mi anInteger |
    allMenus := OrderedCollection with: allMenus first.
    menus isEmpty ifTrue: [ ^self ].
    ( anInteger := UserLibrary createMenu ) = 0
        ifTrue: [ self osWarning. ^nil ].
    handle := WindowHandle fromInteger: anInteger.
    menus do: [ :menu |
        mi := menu buildWindow: self.
        mi isNil ifTrue: [ self destroy. ^nil ].
        ( self insertItem: mi label: menu title ) isNil
            ifTrue: [ self destroy. ^nil ] ]!
loadIcon: hInstance nameInteger: resourceID
    <api: LoadIconA ulong ulong ulongReturn>
    ^self invalidArgument! 
dragSourceNeedsObject: dragSession
        "Private - retrieve the object to be dragged."
	self isDragSource ifFalse: [ ^nil ].
    self
        triggerEvent: #dragSourceNeedsObject:
		withArguments: ( Array with: dragSession )
        ifNotHandled: [ self dragSourceNeedsObjectDefault: dragSession ]!   
isGlobalDragTarget
        "Answer whether the receiver is enabled as a global drag drop target."
    ^self isDragTarget and: [
        self isLocalDragTarget not ]!  
getDialogBaseUnits
    <api: GetDialogBaseUnits long>
    ^self invalidArgument!
removeProp: hWnd name: lpString
        "Private - Remove item identified by lpString in hWnd's
         property list."
    <api: RemovePropA ulong struct ulongReturn>
    ^self invalidArgument!   
checkFlags
        "Private - check user action and get the printDlg parameters"
    | temp address struct |
    self style: self flags.
    hDCPrinter := printDlgStruct hDC.

    self
        propertyAt: #toPage put: printDlgStruct nToPage;
        propertyAt: #fromPage put: printDlgStruct nFromPage;
        propertyAt: #copies put: printDlgStruct nCopies.

    ( temp := printDlgStruct hDevMode ) ~= 0 ifTrue: [      "get DEVMODE structure"
        hDevMode := temp.
        ( address := KernelLibrary globalLock: temp ) = 0
            ifTrue: [ ^self osError ].
        address := ExternalAddress fromInteger: address.
        struct := self devModeFromAddress: address.
        DevMode := struct.
        KernelLibrary globalUnlock: temp ].
   ( temp := printDlgStruct hDevNames ) ~= 0 ifTrue: [      "get DEVNAMES structure"
        hDevNames := temp.
        ( address := KernelLibrary globalLock: temp ) = 0
            ifTrue: [ ^self osError ].
        address := ExternalAddress fromInteger: address.
        struct := self devNamesFromAddress: address.
        DevNames := struct.
        KernelLibrary globalUnlock: temp ]!  
showVerticalScrollBar: aBoolean
        " Hide or show the vertical scroll bar on the receiver,
        according to aBoolean. "
    UserLibrary
        showScrollBar: self handle asParameter
        bar: SbVert
        show: aBoolean! 
getDesktopWindow
    <api: GetDesktopWindow ulongReturn>
    ^self invalidArgument! 
close
        "Private - Close the subpane."
    (value isBitmap or: [value isIcon])
        ifTrue: [value initHandle].
    super close.!
uncheckRadioItem: item
        "Remove the radio style check mark from an item, where item is either
        the label or the selector.  On platforms other than Windows 95, this has the
        same effect as sending uncheckItem: ."
    | mi |
    ( self isThere: item ) ifFalse: [ ^nil ].
    mi := self getMenuItem: item.
    mi attribute: ( mi attribute bitAnd: ( ( MfChecked | MftRadiocheck ) bitXor: 16rFFFF ) ).
    self updateItem: mi!
dragTargetEnter: dragSession
        "Private - the mouse entered the bounds of the
        receiver during a drag drop transfer."
    self isDragTarget ifFalse: [ ^nil ].
    dragSession targetSelection: self dragTargetSelection.
    dragSession target: self.
    self
        triggerEvent: #dragTargetEnter:
        withArguments: ( Array with: dragSession )
        ifNotHandled: [ self dragTargetEnterDefault: dragSession ].
    dragSession targetDrawEmphasis!
exit
        "Private - release the AbortProc callback before
         exiting"
    AbortProc release! 
getData: segId
        "Private - Copy the graphics data from a
         segment identified by segId to a buffer.
         This is done when saving image."
    | count buffer hMetafile |
    hMetafile := ( segments at: segId ) handle.
    ( count := GDILibrary
        getMetaFileBitsEx: hMetafile
        bufsize: nil
        pbuf: nil ) = 0
            ifTrue: [ self osWarning ].
    buffer := ByteArray new: count.
    ( GDILibrary
        getMetaFileBitsEx: hMetafile
        bufsize: count
        pbuf: buffer ) = 0
            ifTrue: [ self osWarning ].
    ^buffer!  
asIndexedColorForPalette: hPalette
        "Answer the palette index for the color closest to the receiver,
        using the specified palette."
    | index |
    ( index := GDILibrary
        getNearestPaletteIndex: hPalette
        color: self asParameter ) = 16rFFFFFFFF
            ifTrue: [ ^self osError ].
    ^IndexedColor index: index | 16r1000000 "indexed color mask"
! 
wmHelp: helpType with: hwnd
        "Private - Process the Smalltalk help message."
    | context subpane name hm hwndFocus |
    ( hm := self helpManager ) isNil ifTrue: [ ^self ].
    hwndFocus := hwnd.
    helpType = MsgfMenu ifTrue: [
        self helpManager notNil ifTrue: [
            context := self helpContext.
            UserLibrary
                sendMessage: hwndFocus
                msg: WmCancelmode
                wparam: 0
                lparam: 0.
            self cancelMode.
            self helpManager displayHelp: context key ] ].

    helpType = MsgfDialogbox ifTrue: [
        [ subpane isNil and: [ hwndFocus ~= 0 ] ] whileTrue: [
            subpane := Notifier findWindow: hwndFocus.
            subpane isNil
                ifTrue: [ hwndFocus := UserLibrary getWindowLong: hwndFocus index: GwlHwndparent ] ].
        subpane isNil ifTrue: [ ^self ].
        name := subpane name.
        self helpManager displayHelp: name ].

    self helpContext: nil!   
releaseDC: aWindowHandle with: aDeviceContext
    <api: ReleaseDC ulong ulong long>
    ^self invalidArgument!  
icon: anIcon
        "Answer a new static icon control with the referenced icon."
    ^self icon contents: anIcon!  
bitmap: aBitmap
        "Answer a new static bitmap control with the referenced bitmap."
    ^self bitmap contents: aBitmap!
defaultStyle
        "Private - Answer the default style for entry field."
    ^EsAutohscroll | WsBorder!   
searchOld
        "Private - Search forward for SearchString.  Highlight
         the match, or display an error message if no match
         is found."
    self search! 
drawHighlight: aDrawStruct
        "Private - Draw the highlight state for an owner-drawn menu item."
    | menu |
    menu := menuWindow menuWithItemId: aDrawStruct itemId.
    menu triggerEvent: #drawSelection:
        withArguments: ( Array with: self drawIndex )
        ifNotHandled: [ super drawHighlight: aDrawStruct ]!  
noTabStop
        "Make the receiver not be a tabstop.  By default
        every subpane which can be a tabstop is a tabstop.
        Send this message if you want to make it not be a tabstop."
    self removeStyle: WsTabstop!
measureControl: aMeasureItemStruct
        "Private - Set the height of an owner-drawn
         control or menu item.  Default is to do nothing."
    self defaultMeasureControl: aMeasureItemStruct!  
isGlobalDragSource
        "Answer whether the receiver is enabled as a local drag drop source."
    ^self isDragSource and: [
		self isLocalDragSource not ]! 
setExtendedStyle: newStyle
        "Set the receiver's extended host style to newStyle. "
    self extendedStyle: newStyle.
    self isHandleOk ifTrue: [
        self canApplyStyle
            ifTrue: [ self applyStyle ]
            ifFalse: [ self recreateWindow ] ]!
windowClass
        "Private - Answer the window class for the receiver."
    ^'EDIT'!  
invalidCursor
        "Answer the cursor for an invalid target"
    ^CursorManager dragDropNone!
isGlobalDragDropSession
		"Private - Answer whether or not an instance of the receiver is a
		a global drag drop session."
	^false!
isLocalDragDropSession
		"Private - Answer whether or not an instance of the receiver is a
		a local drag drop session."
	^true!   
objectClass
        "Answer the class to use for DragDropObjects which are
		added to objects of the receiver class."
    ^LocalDragDropObject!
extendedDragButtonIndex
        "Private - answer the extended drag button index,
        or nil if not supported."
    ExtendedDragButtonIndex notNil ifTrue: [ ^ExtendedDragButtonIndex ].
    ^self hostExtendedDragButtonIndex!   
extendedDragButtonIndex: anInteger
        "Override the system extended drag button index setting for this session."
    ExtendedDragButtonIndex := anInteger! 
defaultClass
        "Answer the default class to use for modeling drag drop sessions."
    DefaultClass isNil ifTrue: [ ^LocalDragDropSession ].
    ^DefaultClass isClass
        ifTrue: [ DefaultClass ]
        ifFalse: [ Smalltalk at: DefaultClass ]!
isGlobalDragDropSession
        "Private - Answer whether or not an instance of the receiver is a
        a global drag drop session."
    ^self implementedBySubclass!
current
        "Private - answer the current drag drop session."
    ^Current! 
current: aDragDropSession
        "Private - set the current drag drop session."
    Current := aDragDropSession!   
objectClass
        "Answer the class to use for DragDropObjects which are
        added to objects of the receiver class."
    self implementedBySubclass!
isDragButton: anInteger
        "Answer whether the mouse button index identified by anInteger
        is a button that initiates a drag transfer on this host."
    ^anInteger = self dragButtonIndex or: [ anInteger = self extendedDragButtonIndex ]!   
operationDescriptions
        "Private - answer a map between known operation names
        ('move', 'copy', 'link') and their names as they should appear in
        a UI."
    OperationDescriptions isNil ifTrue: [ self initialize ].
    ^OperationDescriptions!
dragButtonIndex: anInteger
        "Override the system drag button index setting for this session."
    DragButtonIndex := anInteger!  
defaultClass: aClassOrSymbol
        "Private - set the default class to use for modeling drag drop
        sessions to aClassOrSymbol."
    DefaultClass := aClassOrSymbol!   
dragButtonIndex
        "Private - answer the drag button index,
        or nil if not supported."
    DragButtonIndex notNil ifTrue: [ ^DragButtonIndex ].
    ^self hostDragButtonIndex!
isLocalDragDropSession
        "Private - Answer whether or not an instance of the receiver is a
        a local drag drop session."
    ^self implementedBySubclass!  
source: anObject
        "Create a new instance with anObject as the drag source."
    ^self new source: anObject!  
contextForPopup: anInteger
        "Private - The user has popped up a menu."
    ^menuWindow contextForPopup: anInteger!   
button1DownShift: aPoint
        "Private - left button was pressed with the Shift key
        down; if the receiver is a drag source, start a drag
        drop transfer."
    ( self isDragSource and: [ self isDragButton: 1 ] )
        ifTrue: [ self dragOnMove: true location: aPoint ]!  
showCaret: aWindowHandle
    <api: ShowCaret ulong boolean>
    ^self invalidArgument!  
createCaret: bitmapHandle at: aPoint
        "Private - Create a cursor of type at aPoint."
    | bitLoc |
    bitLoc := self bitCoordinate: aPoint.
    ( UserLibrary
        createCaret: pane handle
        bitmap: bitmapHandle
        width: 0
        height: pane font height )
            ifFalse: [ ^self osError ].
    self moveCaret: ( bitLoc x max: 0 ) @ ( bitLoc y max: 0 ).
    self isGap ifTrue: [ selectFlag := false ].
    self displayGap!  
isIndexedColor
        "Answer whether the receiver is an IndexedColor."
    ^false!
topCorner: aPoint
        "Private - Set the receiver's topCorner to aPoint where
         the x coordinate is the character offset from the
         beginning of the line and the y coordinate is the line
         number.  This causes the text to scroll."
    self disableRedraw.
    UserLibrary
        sendMessage: handle
        msg: WmVscroll
        wparam: ( ExternalLong lowHalf: SbThumbposition highHalf: 0 ) asInteger
        lparam: 0.
    UserLibrary
        sendMessage: handle
        msg: WmHscroll
        wparam: ( ExternalLong lowHalf: SbThumbposition highHalf: 0 ) asInteger
        lparam: 0.
    UserLibrary
        sendMessage: handle
        msg: EmLinescroll
        wparam: aPoint x - 1
        lparam: aPoint y - 1.
    self enableRedraw!  
doPopupMenuAt: aPoint
        "Private - Popup the pane's menu at aPoint."
    | previous menuBarMenu |
    previous := popup.
    popup := self popupMenu.
    popup notNil ifTrue: [
        menuBarMenu := self mainWindow menuTitled: (popup title).
        menuBarMenu notNil ifTrue: [
            popup copyAttributesFrom: menuBarMenu].
        popup popUpAt: aPoint in: self.
        CurrentEvents := CurrentEvents select: [:msg |
            msg selector = #performMenuItem:]  "discard queued
                up events like right button click".
        "Dont destroy if popup existed previously"
        previous isNil ifTrue:[ self sendDeferredEvent: #destroyPopup]
         "don't destroy if cache desired"]!  
buildWindow: parentWindow
        "Private - Create the menu bar window and
         all menus in it."
    | mi anInteger |
    parent := parentWindow.
    allMenus := OrderedCollection with: allMenus first.
    self addSystemMenuItems: parent.
    menus isEmpty ifTrue: [ ^self ].
    ( anInteger := UserLibrary createMenu ) = 0
        ifTrue: [ self osWarning. ^nil ].
    handle := WindowHandle fromInteger: anInteger.
    self isHandleOk ifFalse: [ ^nil ].
    ( UserLibrary
        setMenu: parent asParameter
        menu: self asParameter ) = 0
            ifTrue: [ ^self osError ].
    self initGraphics.
    menus do: [ :menu |
        mi := menu buildWindow: self.
        mi isNil ifTrue: [ self destroy. ^nil ].
        ( self insertItem: mi label: menu title ) isNil
            ifTrue: [ self destroy. ^nil ] ]!  
sendMouseMoveInputEvent: selector with: argument
        "Private - Add a MessageExpression to CurrentEvents."
    | lastMessage int |
    CurrentEvents isEmpty
        ifTrue: [ ^self sendInputEvent: selector with: argument ].
    int := Process enableInterrupts: false.
    lastMessage := CurrentEvents last.
    ( ( selector = lastMessage selector )
    and: [ ( self = lastMessage receiver ) ] )
        ifTrue: [
            lastMessage arguments: ( Array with: argument ).
            CurrentEvents at: CurrentEvents size put: lastMessage ]
        ifFalse: [ self sendInputEvent: selector with: argument ].
    "KeyboardSemaphore signal"
    Process enableInterrupts: int! 
registerFormat: aString
        "Register aString as a user-defined clipboard format.
        Answer the format."
    | aFormat |
    ( aFormat := UserLibrary registerClipboardFormat: aString asParameter ) = 0
        ifTrue: [ ^self osError ].
    self class userFormats at: aString put: aFormat.
    ^aFormat!
callNextHookEx: hHook
        action: nCode
        wparam: wparam
        lparam: lparam
    <api: CallNextHookEx ulong long ulong ulong ulongReturn>
    ^self invalidArgument!
findWindow: className windowName: windowName
    <api: FindWindowA struct struct ulongReturn>
    ^self invalidArgument!
altDownInWmChar: wordInteger with: longInteger
        "Private - Process the alt case in WmSysChar.
        Check if a child uses this char for a mnemonic and
        queue a mnemonic handler for it if it does.
        Answer true if a child handles the char."
    | wasHandled |

    ( longInteger bitAnd: 16r20000000 ) ~= 0    "Alt key down"
        ifTrue: [
            wasHandled :=
                self altKeyInput: wordInteger asCharacter
                    from: self.
            ^wasHandled ].
    ^false!
button1Up: aPoint
        "Private - The user let up on button 1 at aPoint.
         Implemented by subclasses."
    self isDragSource ifTrue: [ self dragOnMove: nil location: nil ]! 
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #drawItem ;
        add: #drawFocus ;
        add: #drawSelection ;
        yourself!   
getWindowsMsg: aMsgStruct
        "Private - Retrieve the current host system message
         and store it in aMsgStruct."
    <primitive: 145>!  
closeAllWindows
        "Private - Close all windows including Transcript."
    | old |
    old := Smalltalk at: #Transcript ifAbsent: [ nil ].
    old isWindow ifTrue: [ old clearTextModified ].
    old notNil ifTrue: [ Smalltalk at: #Transcript put: nil ].
        "iterate over a copy of the windows list, because close will remove from it."
    windows copy do: [ :w |
        w isApplicationWindow
            ifTrue: [ w clearTextModified; close ] ].
    self cleanUpAllMessages.
    old notNil ifTrue: [ Smalltalk at: #Transcript put: old ]!   
searchString: aString
        "Set the search string to aString."
    SearchString := aString.
    Forward := true.
    PriorCommand := #searchOld!   
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #aboutToSave ;
        add: #controlTabbed ;
        add: #saved ;
        yourself!
popupMenu
        "Private - Answer the popup Menu for the receiver."
    | m otherMenu editMenu smalltalkMenu editTitle |
    m := super popupMenu.
    m isNil
        ifTrue: [
            m := Menu new
                appendItem: 'Cu\ut' replaceEscapeCharacters selector: #cutSelection ;
                appendItem: '\uCopy' replaceEscapeCharacters selector: #copySelection;
                appendItem: '\uPaste' replaceEscapeCharacters selector: #pasteSelection.
            Smalltalk isRunTime ifFalse: [
                m appendSeparator ;
                appendItem: '\uDo It' replaceEscapeCharacters selector: #doIt  ;
                appendItem: '\uShow It' replaceEscapeCharacters selector: #printIt ].
            m appendSeparator ;
                appendItem: '\uSave' replaceEscapeCharacters selector: #accept ;
                appendItem: 'A\ugain' replaceEscapeCharacters selector: #again.

            "retrieve the Edit/Smalltalk menus from the main window's window policy"
            editMenu := [ self mainWindow windowPolicy class editMenu ]
                on: MessageNotUnderstood do: [ nil ].
            editMenu notNil ifTrue: [ m appendSubMenu: ( editMenu allOwners: self ) ].
            Smalltalk isRunTime ifFalse: [
                smalltalkMenu := [ self mainWindow windowPolicy class smalltalkMenu: true ]
                    on: MessageNotUnderstood do: [ nil ].
                smalltalkMenu notNil ifTrue: [ m appendSubMenu: ( smalltalkMenu allOwners: self mainWindow owner ) ] ].

            m owner: self;
                title: 'TextPanePopup' ]
        ifFalse: [
            " if the popup is not the Edit menu, return it "
            editTitle := '\uEdit' replaceEscapeCharacters.
            ( m title ~= editTitle and: [ ( m isThere: editTitle ) not ] ) ifTrue: [ ^m ].

            editMenu :=
                ( m title = editTitle )
                    ifTrue: [ m ] "The entire popup is the edit menu."
                    ifFalse: [ m subMenuTitled: editTitle ] ]. "popup has a edit subitem."

        " copy popup menu attributes for File menu "
        m getIndex: #accept ifAbsent: [^m]. "Check to be sure the item is there."
        ( otherMenu := self mainWindow menuTitled: '\uFile' replaceEscapeCharacters ) isNil
            ifFalse: [ m copyItemAttributes: #accept from: otherMenu ].

        " copy popup menu attributes for Edit menu "

        ( otherMenu := self mainWindow menuTitled: '\uEdit' replaceEscapeCharacters ) isNil
            ifFalse: [
                otherMenu owner initMenu.
                ( Array with: m with: editMenu ) do: [ :mm |
                    mm copyItemAttributes: #copySelection from: otherMenu;
                        copyItemAttributes: #cutSelection from: otherMenu;
                        copyItemAttributes: #pasteSelection from: otherMenu ].
                editMenu copyItemAttributes: #clearSelection from: otherMenu ].

    ^self popupFromMenu: m! 
matchPatternBack: pattern from: anInteger
        "Answer a Point representing the start and
         stop of the subcollection within aCollection
         that matches the receiver starting at index
         position anInteger.  Answer nil if no match."
    | lastChar index patternSize state |
    self getText.
    (patternSize := pattern size) = 0 ifTrue: [^nil].
    state := patternSize.
    lastChar := pattern at: patternSize.
    index := anInteger.
    [index > 0] whileTrue: [
        (self charAt: index) = lastChar ifTrue: [
            state := state - 1.
            [state < 1
                ifTrue: [^index @ (index + patternSize - 1)].
             (index := index - 1) < 1
                ifTrue: [^nil].
             (pattern at: state) = (self charAt: index)
                ifTrue: [
                    state := state - 1]
                ifFalse: [
                    state := patternSize].
             state ~= patternSize]
                whileTrue: []].
        index := index - 1].
    ^nil!  
lineAtCharIndex: index
        "Private - Answer the line with the index'th character."

	| line |
	line := self lineCoordsAtCharIndex: index.
	line = ( 0 @ 0 ) ifTrue: [ ^'' ].
	^self contents copyFrom: line x to: line y.! 
replaceWithText: aString
        "Private - Replace the selected text with aString."
	Clipboard setString: aString.
	self pasteSelection!  
appendChar: aCharacter
        "Private - Append aCharacter to the end of the text."
    | wasModified |
    wasModified := self modified.
    self selectAtEnd.
    self insert: (String with: aCharacter).
    self modified: wasModified!
restore
        "Restore the contents of the receiver to the previously set
        contents."
    self cancel!
append: aString
        "Add aString at the end of the
         text in the pane."
    self nextPutAll: aString!   
contents: aString
        "Set the contents of the receiver to aString."
    super contents: aString.
    self modified: false.!   
tab
        "Write a tab character to the receiver."
    self nextPut: Tab! 
evaluating
        "Private - answer whether the current compilation is an evaluation."
    ^self propertyAt: #evaluate ifAbsent: [ false ]!
initMenu
        "Private - Initialize the edit menu."
    | editMenu bracketMenu smalltalkMenu |
    self mainWindow menuWindow isNil ifTrue: [ ^self ].
    ( editMenu := self mainWindow menuWindow menuTitled: 'Edit' ) isNil
        ifTrue: [ ^self ].
    smalltalkMenu := self mainWindow menuWindow menuTitled: 'Smalltalk'.
    ( editMenu isThere: 'Brackets' )
        ifTrue: [ bracketMenu := ( editMenu getMenuItem: 'Brackets' ) submenu ].
    ( Clipboard containsText and: [ self isReadOnly not ] )
        ifTrue: [ editMenu enableItem: #pasteSelection ]
        ifFalse: [ editMenu disableItem: #pasteSelection ].

    self isReadOnly
        ifTrue: [
            editMenu
                disableItem: #undo;
                disableItem: #restore.
			smalltalkMenu notNil ifTrue: [ smalltalkMenu disableItem: #printIt ].
            bracketMenu notNil
                ifTrue: [ bracketMenu disableAll; enableItem: #matchBracketChars ] ]
        ifFalse: [
            editMenu
                enableItem: #undo;
                enableItem: #restore.
			smalltalkMenu notNil ifTrue: [ smalltalkMenu enableItem: #printIt ].
            bracketMenu notNil ifTrue: [ bracketMenu enableAll ] ].
    ( self selectedString size > 0 and: [ self isReadOnly not ] )
        ifTrue: [
            editMenu
                enableItem: #cutSelection;
                enableItem: #clearSelection ]
        ifFalse: [
            editMenu
                disableItem: #cutSelection;
                disableItem: #clearSelection ].
    self selectedString size > 0
        ifTrue: [ editMenu enableItem: #copySelection ]
        ifFalse: [ editMenu disableItem: #copySelection ]
!   
tabKeyInput: aKeyboardInputEvent
        "Private - Respond to the tab keystroke."
    aKeyboardInputEvent isControlKeyDown ifFalse: [ ^nil ].
    self triggerEvent: #controlTabbed
        ifNotHandled: [
            aKeyboardInputEvent isShiftKeyDown
                ifTrue: [
                    [( self tabScope previousTabStop: self ) setFocus ]
                        on: Error
                        do: [ :e | ^self  "Stack overflow because no valid tab stop "  ]]
                ifFalse:  [
                    [( self tabScope nextTabStop: self ) setFocus ]
                        on: Error
                        do: [ :e | ^self ] ] ]!  
update: anObject
        "Refresh the text from the owner and
        display it.  Ignore anObject, retained
        for backward compatibility."
    self update!
searchFor: aString
        "Private - Search forward for aString."
     | oldSearchString oldCaseSensitive |
    oldSearchString := SearchString.
    oldCaseSensitive := CaseSensitive.
    SearchString := aString.
    CaseSensitive := true.
    self setFocus.
    [ self searchOld ] on: Warning do: [ :e | ].  "suppress message"
    self getSelection.
    SearchString := oldSearchString.
    CaseSensitive := oldCaseSensitive.!   
lineAt: index
        "Private - Answer the line with line number
         index.  Answer empty string if none."
    | aStream count |
    aStream := self contents asStream.
    count := 1.
    [aStream atEnd]
        whileFalse: [
            count = index
                ifTrue: [^(aStream nextLine)]
                ifFalse: [
                    aStream nextLine.
                    count := count + 1]].
    ^''!  
selectionIncludesPoint: aPoint
        "Private - answer whether aPoint is within the bounds of the
        current selection."
    | sel start end |
    sel := self getSelection.
    start := self pointFromIndex: sel x.
    end := self pointFromIndex: sel y.
"Transcript nextPutAll: 'sel = ', sel printString, ' start = ', start printString, ', end = ', end printString, ' aPoint = ', aPoint printString; cr."
    start = end ifTrue: [ ^false ].  "no selection, just a caret."
    ( aPoint y > start y and: [ aPoint y < end y ] ) ifTrue: [ ^true ].
    start y = end y ifTrue: [ ^aPoint y = start y and: [ ( aPoint x between: start x and: end x ) ] ].
    ( aPoint y = start y and: [ aPoint x > start x ] ) ifTrue: [ ^true ].
    ( aPoint y = end y and: [ aPoint x < end x ] ) ifTrue: [ ^true ].
    ^false! 
linesInSelection
        "Private - Answer an OrderedCollection of
         the lines contained in the selected text."
    ^self linesInStream: self selectedItem asStream.!   
isTextPane
        "Answer true if receiver is a kind of TextPane."
    ^true!  
textFont: aFont
        "Set the receiver's font and the text pane
        font of all children to aFont."
    self font: aFont.
    super textFont: aFont!   
initialize
        "Private - Initialize the receiver."
    super initialize.
    self changed: false.!
toggleWrap
        "Private - Toggle the word-wrap mode."
    | optionMenu |
    ( optionMenu := self mainWindow menuTitled: 'Options' ) isNil
        ifTrue: [ optionMenu := self mainWindow menuTitled: 'Edit' ].
    self wrap
        ifTrue: [
            optionMenu notNil ifTrue: [ optionMenu uncheckItem: #toggleWrap ].
            self disableWordWrap ]
        ifFalse: [
            optionMenu notNil ifTrue: [ optionMenu checkItem: #toggleWrap ].
            self enableWordWrap ]!  
selectLineAtCurrentSelection
        "Private - Select the line which
         contains the current selection."
    self selectLineAtChar: selection x!
defaultTabStopInterval
        "Private - answer the width of four spaces for backward compatibility."
    ^self font isNil
        ifTrue: [ 16 ]
        ifFalse: [ self font spaceWidth * 4 ]! 
printLines: lines
        "Private - Print the text lines."
    | aHandle |
    CursorManager execute changeFor: [
        aHandle := FileHandle openDevice: 'LPT1'.
        lines do: [ :line |
            aHandle deviceWrite: line.
            aHandle deviceWrite: ( String with: Lf with: Cr ) ].
        aHandle close ]! 
selectedText
        "Answer a string containing the currently selected text."
    ^self selectedItem!  
setModified
        "Set the modified flag."
    self modified: true!   
activate
		"Private - the receiver has been activated,
		make it the active text pane (owns the edit
		menu)."
    ( self mainWindow isActive and: [ self isVisible ] ) ifFalse: [ ^self ].
    self mainWindow activeTextPaneNoSetFocus: self.
    ^super activate!
again
        "Private - Redo the prior find or replace command."
    self setFocus.
    CursorManager execute changeFor: [
        self perform: PriorCommand ]! 
update
        "Refresh the text from the
         owner and display it."
    self disableRedraw.
    [ super update ] on: Error do: [ :e |
        self contents: ''.
        self enableRedraw.
        ^e handle ].
    self enableRedraw.
    self changed: false.!  
findReplace
        "Private - User selected the Find/Replace menu item."
    | dialog s itemLabel |
    s := self selectedItem.
    s notNil ifTrue: [ s := s asExternalString ].
    ( s includes: Lf ) ifTrue: [ s := SearchString := '' ].
    ( s isNil or: [ s isEmpty ] ) ifTrue: [ s := SearchString ].
    self setFocus.
    dialog := FindReplaceDialog new
        open: s
        replace: NewString
        forward: Forward
        caseSensitive: CaseSensitive.
    dialog command isNil ifTrue: [ ^self ].
    PriorCommand := dialog command.
    itemLabel := ( PriorCommand == #searchOld or: [ PriorCommand == #searchBackOld ] )
        ifTrue: [ 'Find A\ugain\tCtrl+G' replaceEscapeCharacters ]
        ifFalse: [ 'Replace A\ugain\tCtrl+G' replaceEscapeCharacters ].
    ( self mainWindow menuTitled: '\uEdit' replaceEscapeCharacters )
        changeItem: #again label: itemLabel.
    SearchString := dialog toFind.
    SearchString notNil
        ifTrue: [ SearchString := SearchString asExternalString ].
    NewString := dialog replaceWith.
    NewString notNil
        ifTrue: [ NewString := NewString asExternalString ].
    CaseSensitive := dialog caseSensitive.
    Forward := dialog forward.
    ^self perform: PriorCommand!  
selectLineAtChar: anInteger
        "Select the entire line with the given character index."

    | line |
	line := self lineCoordsAtCharIndex: anInteger.
	self selectIndexFrom: line x to: line y.!
insertAfterSelection: aString
        "Insert aString after the current selection
        and select it."
    | stringToInsert |
    stringToInsert := aString asExternalString.
    self getSelection.
    self selectAfter: selection y.
    self insert: stringToInsert.
    self
        selectIndexFrom: selection y
        to: selection y + stringToInsert size!
currentCursor
        "Private - Answer the mouse cursor that's
         appropriate for the receiver window."
    ^( self isDragSource and: [ self selectionIncludesPoint: ( self characterCoordinate: ( Cursor sense mapToWindow: self ) ) ] )
		ifTrue: [ CursorManager arrow ]
		ifFalse: [ super currentCursor ]!   
validate
        "Private - The host window for the receiver was
         just created or recreated."
    | editMenu |
    super validate.
    ( ( editMenu := self mainWindow menuTitled: 'Edit' ) notNil
    and: [ ( editMenu getIndex: #toggleWrap ifAbsent: [ nil ] ) notNil ] )
        ifTrue: [ self wrap
            ifTrue: [ editMenu checkItem: #toggleWrap ]
            ifFalse: [ editMenu uncheckItem: #toggleWrap ] ]!  
clearModified
        "Clear the modified flag."
    self modified: false!  
linesInPane
        "Private - Answer an OrderedCollection of
         the lines contained in the text pane."
    ^self linesInStream: self contents asStream.!
insertAndSelect: aString
        "Insert aString at current location, replacing
        selection if present, and select aString."
    self
        cutSelection;
        insertAfterSelection: aString! 
selectLine: anInteger
        "Select the entire line with the given index."
    | offset |
	offset := self charactersBeforeLine: anInteger.
	self selectFrom: offset + 1 to: offset + ( self lineAt: anInteger ) size!   
selectedString
        "Answer a String containing the text
        currently selected.  Retained for compatibility,
        use selectedItem instead."
    ^ self selectedItem.! 
cancel
        "Private - Restore the last saved
         version of the text."
    self modified: false.
    CursorManager execute changeFor: [
        self disableRedraw.
        owner isString
            ifTrue: [ self contents: owner ]
            ifFalse: [
                ( owner respondsTo: #cancel )
                    ifTrue: [ ^owner cancel ]
                    ifFalse: [
                        self event: #getContents.
                        self triggerEvent: #needsContents ] ].
        self selectBefore: 1.
        self setSelection.
        self enableRedraw ]! 
searchForDefaultTextPane
        "Private - Answer the receiver."
    ^self!
accept
        "Private - Save the modified text."
    self event: #aboutToSave.
    self triggerEvent: #aboutToSave.
    Smalltalk isRunTime ifFalse: [ self setEvaluate: false ].
    self modified ifTrue: [
        Cursor reset.
        CursorManager execute changeFor: [
            self name == #yourself
                ifTrue: [
                    owner := self contents.
                    self modified: false].
            self event: #save.
            self triggerEvent: #saved ] ]!   
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process tab keys."
    | virtualKey |
	virtualKey := aKeyboardInputEvent virtualKey.
	( ( virtualKey == TabKey or: [ virtualKey == BacktabKey ] )
     and: [ aKeyboardInputEvent isControlKeyDown ] )
        ifTrue: [ self tabKeyInput: aKeyboardInputEvent ].
    "Cr shouldn't trigger default pushbutton."
    aKeyboardInputEvent character = Cr ifTrue: [ ^self ].
    ^super keyboardInput: aKeyboardInputEvent!
linesInStream: aStream
        "Private - Answer an OrderedCollection of
         the lines obtained from aStream."
    | someLines |
    someLines := OrderedCollection new.
    [aStream atEnd]
        whileFalse: [someLines add: aStream nextLine].
    ^someLines!   
replaceString: aString
        "Private - Answer a String by replacing
         all wild card characters in aString
         with the selected string."
    | index answer |
    answer := aString.
    [true] whileTrue: [
        index := answer indexOf: Pattern wildcardChar
            ifAbsent: [^answer].
        answer :=
            (answer copyFrom: 1 to: index - 1),
            self selectedString,
            (answer copyFrom: index + 1 to: answer size)]!  
selectFrom: start to: end
        "Set the selection described by
        start and end.  start and end can
        be either (character in line, line) pairs
        or character positions from beginning
        of the text."

	start isPoint
        ifTrue: [
			self
				selectIndexFrom: ( self pointToIndex: start )
				to: ( self pointToIndex: end ) ]
        ifFalse: [ self selectCharFrom: start to: end ].!  
nextPut: aCharacter
        "Add aCharacter at the end of the
         text in the pane."
    self nextPutAll: ( String with: aCharacter )!
search
        "Private - Search for SearchString.  Highlight
         the match, or display an error message if no match
         is found."
    | point |
    self getValue size > 0 ifFalse: [ ^self ].
    point := self findSearchString.
    point isNil ifTrue: [
        ^Warning signal: 'Search string not found' ].
	self selectIndexFrom: point x - 1 to: point y.
    self forceSelectionOntoDisplay!  
removeHorizontalScrollbarStyle
        "Remove the horizontal scrollbar style."
    ^self removeStyle: WsHscroll!   
extent
        "Answer a point with the receiver's extent."
    ^bitmapInfo width @ bitmapInfo height!  
updateVerticalSlider
        "Private - Update the vertical slider position."
   ( UserLibrary
        setScrollPos: self asParameter
        bar: SbVert
        position: self topCorner y
        redraw: true ) = 0
            ifTrue: [ self osNotification ]!   
doubleClickQueued
        "Private - answer whether a doubleClick event
        is coming in the input event queue."
    CurrentEvents
        detect: [ :msg |
            msg selector = #asyncControlEvent:with:
            and: [ msg receiver == self
            and: [ msg arguments size = 2
            and: [ ( msg arguments at: 1 ) = self doubleClickMessage ] ] ] ]
        ifNone: [ ^false ].
    ^true!   
deselectFromAuxDC: hPrevious
        "Private - Deselect the receiver from the auxiliary
         device context."
    ( GDILibrary
        selectPalette: AuxiliaryDC
        with: DefaultPaletteHandle
        forceBackground: false ) = 0
            ifTrue: [ ^self osError ].
    ^GDILibrary selectObject: AuxiliaryDC with: hPrevious!  
createBitmapIndirect: aWinBitmapStruct
        "Private - Create a host bitmap from
         aWinBitmapStruct. Answer the handle of the bitmap."
    | hBitmap |
    ( hBitmap := GDILibrary createBitmapIndirect: aWinBitmapStruct asParameter ) = 0
        ifTrue: [ ^self osError ].
    ^hBitmap!  
auxiliaryDC
        "Private - Answer the auxiliary device context used for
        copying to another bitmap."
    ^AuxiliaryDC!  
event: aSymbol
        "Private - Notify the receiver's owner of an event
         by performing the message that the owner set for
         this event.  Retained for compatibility."
    | message oldHandlers |
    ( oldHandlers := self handlersOrNil ) isNil ifTrue: [ ^nil ].
    message := oldHandlers at: aSymbol ifAbsent: [ ^nil ].
    message isNil ifTrue: [ ^nil ].
    ^message perform! 
initialize
        "Private - Initialize printDlgStruct."
    super initialize.
    printDlgStruct :=  ( SelfDefinedStructure named: 'PRINTDLG' ).
    printDlgStruct lStructSize: printDlgStruct sizeInBytes.
    self style: PdReturndc.!  
setFonts
        "Private - The user selected Font... from the Options menu;
         open a FontDialog to select a font for the current window."
    | fontDialog theFont color |
    fontDialog := FontDialog new
        sampleForeColor: self subPaneWithFocus foreColor;
        sampleFont: self subPaneWithFocus font;
        open.
    color := fontDialog textColor.
    ( theFont := fontDialog chosen ) isNil ifTrue: [ ^self ].
    theFont makeFont.
    ListFont := TextFont := ButtonFont := theFont.
    self
        listFont: ListFont;
        textFont: TextFont;
        buttonFont: ButtonFont! 
isBitmap
        "Answer true if receiver is a kind of Bitmap."
    ^true!  
windowClass
        "Private - Answer the host system window class
         name of the receiver."
    ^OperatingSystem winClassName!  
getClassWord: hwnd index: integer
    <api: GetClassWord ulong long ushort>
    ^self invalidArgument!  
bitBlt: destDC
    x: x1
    y: y1
    width: srcWidth
    height: srcHeight
    srcDC: srcDC
    xSrc: x2
    ySrc: y2
    rop: aRopConstant
        "Call GDI BitBlt function."
    ( segmentIsOpen not or: [ drawingMode = DrawingModeDraw ] ) ifTrue: [
        ^Bitmap
            bitBlt: destDC
            x: x1
            y: y1
            width: srcWidth
            height: srcHeight
            srcDC: srcDC
            xSrc: x2
            ySrc: y2
            rop: aRopConstant ].
    drawingMode = DrawingModeDrawAndRetain ifTrue: [
        Bitmap
            bitBlt: destDC
            x: x1
            y: y1
            width: srcWidth
            height: srcHeight
            srcDC: srcDC
            xSrc: x2
            ySrc: y2
            rop: aRopConstant ].
    Bitmap
         bitBlt: self currentSegment deviceContext
         x: x1
         y: y1
         width: srcWidth
         height: srcHeight
         srcDC: srcDC
         xSrc: x2
         ySrc: y2
         rop: aRopConstant!  
buildWindow
        "Private - Create the host window for the receiver."
    | myRealRectangle focusPane extendedStyle |
    style isNil ifTrue: [ style := self getStyle ].
    ( extendedStyle := self extendedStyle ) isNil ifTrue: [
        self extendedStyle: ( extendedStyle := self defaultExtendedStyle ) ].
    NotificationManager newWindow notNil ifTrue: [
        NotificationManager newWindow: nil.
        ^nil ].   "A Walkback came up during creation of window"
    NotificationManager newWindow: self.

    " clear rectangle during build to force sizeChanged: to resize children "
    myRealRectangle := rectangle.
    rectangle := 0@0 extent: 0@0.

    self
        create: self windowClass
        title: label
        style: ( style bitAnd: ( WsVisible bitXor: 16rFFFFFFFF ) )  "create hidden, show after validate"
        extendedStyle: extendedStyle
        rectangle: rectangle
        parent: parent.
    NotificationManager newWindow: nil.
    self icon: self icon.

    self isHandleOk ifFalse: [ self outOfMemory. ^nil ].

    self systemMenuHandle.

    "menu and subpanes created in the wmCreate message process"

    "Set the size of the frame window."
    self handle
        setWindowPos: nil
        rectangle: myRealRectangle
        fs: SwpNozorder.

    focusPane := self subPaneWithFocus.
    self activeTextPane: self searchForDefaultTextPane.
    focusPane notNil ifTrue: [ focusPane setFocus ].
    self subPaneWithFocus: focusPane! 
extendedSelect
        "Set and answer the Extended Selection List box."
    self removeStyle: LbsMultiplesel.
    ^self addStyle: LbsExtendedsel! 
removeStyle: styleBits
        "Private - if style is nil, initialize it appropriately:
         if #noDefaultStyle was previously sent to the receiver,
         set it to 0, otherwise set it to defaultStyle; then remove
         the given style bits from the flag.  Answer the removed
         styleBits."
    | mask |
    style isNil ifTrue: [ style := self getStyle ].
    mask := styleBits bitXor: 16rFFFFFFFF.
    style := style bitAnd: mask.
    ^styleBits! 
clientToScreen: aWindowHandle point: aWinPoint
    <api: ClientToScreen ulong struct boolean>
    ^self invalidArgument!
contents: aString
        "Set the contents of the receiver to aString."
    super contents: aString.
    self selectBefore: 1.
    self resetUndo!   
queryText: text inListBox: itemId startingAt: startingAt
         "Find the index of text in list box itemId starting at.
        index startingAt.  Index is 0 relative."
    ^self sendMessage: LbFindstring item: itemId wparam: startingAt lparamStruct: text asParameter! 
clearSelection
        "Make no list items selected"
    value := nil.
    self isHandleOk ifFalse: [ ^self ].
    UserLibrary
        sendMessage: handle
        msg: self selectMessage
        wparam: 0
        lparam: self class listEnd!  
isGraphicsTool
        "Answer whether the receiver is a kind of GraphicsTool."
    ^true!  
showScrollBar: aWindowHandle bar: scrollBar show: aBoolean
    <api: ShowScrollBar ulong short boolean boolean>
    ^self invalidArgument!  
isWindowEnabled: aWindowHandle
    <api: IsWindowEnabled ulong boolean>
    ^self invalidArgument!  
removeMenu: aMenuHandle position: positionInteger flag: flagInteger
    <api: RemoveMenu ulong ulong ulong boolean>
    ^self invalidArgument!  
contents
        "Answer the value of the receiver."
    ^value!
value: anIcon
        "Set the value of the receiver to anIcon. "
    self contents: anIcon!
setValue: anIcon
        "Set the value of the receiver to anIcon.
        Answer anIcon. "
    self contents: anIcon.
    ^anIcon!   
value
        "Answer the icon displayed by the receiver."
    ^self contents!  
contents: anIcon
        "Set the value of the receiver to anObject."
    value := anIcon isNil
        ifTrue: [ Icon new ]
        ifFalse: [ anIcon ].
    self isHandleOk ifTrue: [ self setHandle ]!
validate
        "Private - The host window for the receiver was
         just created or recreated."
    super validate.
    self setHandle! 
allFonts
        "Answer an array of all available fonts in the system."
    ^self allFonts: Display!   
bitBlt: destDC
    x: x1
    y: y1
    width: srcWidth
    height: srcHeight
    srcDC: srcDC
    xSrc: x2
    ySrc: y2
    rop: aRopConstant
        "Private - Call GDI BitBlt function."
    ( GDILibrary
         bitBlt: destDC
         x: x1
         y: y1
         width: srcWidth
         height: srcHeight
         srcDC: srcDC
         xSrc: x2
         ySrc: y2
         rop: aRopConstant )
            ifFalse: [ ^self osError ]! 
resize: aRectangle
        "Private - The size of the receiver has been changed
         to aRectangle."
    self minimized ifTrue: [ ^nil ].
    rectangle := self framingRectangleFor: aRectangle.
    self resizeWindow!  
defaultBitmap
        "Private - Answer the default host bitmap."
    ^DefaultBitmap!   
screenWidth: w height: h
        "Answer a new screen Bitmap with width w and height h."
    ^self new screenWidth: w height: h!
standard
        "Add the standard style."
    ^self addStyle: LbsStandard! 
dragTargetEmphasisTypesSupported
		"Private - answer a collection of emphasis types that the receiver can support."
	^#( 'pane' )!  
createWindowULongEx: exStyle
    class: className
    nameULong: nameString
    style: styleInteger
    x: xInteger
    y: yInteger
    width: widthInteger
    height: heightInteger
    parent: parentHandle
    menu: menuHandle
    instance: instanceHandle
    paramULong: paramStructure
       "Private - This method only works for non-predefined window classes."
   <api: CreateWindowExA ulong ulong ulong ulong long long
                                            long long ulong ulong ulong ulong ulongReturn>
    ^self invalidArgument!  
empty
        "Private - empty the clipboard. Note: it must be opened first."
    | result |
    ( result := UserLibrary emptyClipboard ) = 0
        ifTrue: [ ^self osError ].
    ^result!
sendDlgItemMessageInt: hDlg
        item: nIDDlgItem
        msg: wMsg
        wparam: wParam
        lparamStruct: lParamStruct
    <api: SendDlgItemMessageA ulong long ulong ulong struct long>
    ^self invalidArgument!   
initialRectangleFor: aRectangle
        "Private - answer the real rectangle."

    ^self framingBlock value: aRectangle!  
dragTargetMultipleItem: aBoolean
        "Determine whether the receiver will accept multiple
        item drag-drop transfers, according to the value of aBoolean."
    self propertyAt: #dragTargetMultipleItem put: aBoolean!   
getClassName: hwnd buffer: string bufSize: integer
   <api: GetClassNameA ulong struct long long>
   ^self invalidArgument! 
graphicsMedium: aGraphicsMedium
        "Private - Set the graphics medium associated 
         with the font to aGraphicsMedium."
    graphicsMedium := aGraphicsMedium!  
fromFile: aFileName in: aDirectory
        "Read a DIB bitmap from a file named aFileName."
    | stream answer |
    stream := File pathNameReadOnly: aFileName in: aDirectory.
    answer := self fromFileStream: stream.
    stream close.
    ^answer!  
fromFileStream: aFileStream
        "Create a DIB bitmap from bitmapFile"
    | file dib type |
    file := aFileStream asByteFileStreamCopy.
    type := String new: 2.
    type at: 1 put: file next.
    type at: 2 put: file next.
    "check file type and position file pointer to DIB's info header."
    type  = 'BM'
        ifTrue: [file skip: 12]
        ifFalse: [
            type = 'BA'
                ifTrue: [file skip: 26]
                ifFalse: [
                    file close.
                    self error: 'Invalid bitmap format'.
                    ^nil]
            ].

    dib := self new
        fromStream: file.
    ^dib!   
fromFile: bitmapFile
        "Create a DIB bitmap from bitmapFile"
   ^self fromFile: bitmapFile in: Disk!  
fromModule: module id: bitmapId
        "Create a DIB bitmap from module. Its id is
        bitmapName, it can be either a string or an integer;
        module may be either the name of the module
        (a String), or the module's handle (an Integer
        or instance of a DynamicLinkLibrary subclass))."
    | hLibrary hrsrc hglb resource bytesResource stream dib id anInteger |
    module isString
        ifTrue: [
            ( hLibrary := KernelLibrary loadLibrary: module asParameter ) = 0
                ifTrue: [ ^ self osError ] ]
        ifFalse: [ hLibrary := module ].
    id := bitmapId.
    id isInteger ifTrue: [ id := ExternalLong new lowHalf: id ].
    hrsrc := KernelLibrary
        findResource: hLibrary asParameter
        name: id asParameter
        type: ( ExternalLong new lowHalf: RtBitmap ) asParameter.
    hrsrc = 0 ifTrue: [
        module isString ifTrue: [
            ( KernelLibrary freeLibrary: hLibrary )
                ifFalse: [ ^self osError ] ].
        self osWarning.
        ^nil ].
    ( hglb := KernelLibrary loadResource: hLibrary asParameter hrsrc: hrsrc asParameter ) = 0
        ifTrue: [ ^self osError ].
    ( resource := KernelLibrary lockResource: hglb ) = 0
        ifTrue: [ ^self osError ].
    resource := ExternalAddress fromString: resource.
    ( anInteger := KernelLibrary sizeofResource: hLibrary hrsrc: hrsrc ) = 0
        ifTrue: [ ^self osError ].
    bytesResource := ByteArray new: anInteger.
    bytesResource replace: bytesResource size with: resource.
    stream := ReadWriteStream on: bytesResource asString.
    dib := self new fromStream: stream.
    module isString ifTrue: [
        ( KernelLibrary freeLibrary: hLibrary )
            ifFalse: [ ^self osError ] ].
    ^dib! 
displayWith: destPen from: sRectangle to: dRectangle
        "Copy sRectangle from the receiver to dRectangle in
        the destPen medium using aRopConstant.  Data will be
        compressed or stretched if the two rectangles are not
        the same extent."
    self
        displayWith: destPen
        from: sRectangle
        to: dRectangle
        rule: Srccopy!   
boundingBox
        "Answer a rectangle which bounds the receiver."
    ^(Rectangle leftTopUnit extent: self extent)!   
createDIBPalette
        "Private - Create a GDI palette from the color table of
        bitmapInfo; answer the palette handle."
    | logPalette hPalette |
    self bitCount = 24 ifTrue: [^0].
    logPalette := WinLogPalette fromRgbColor: bitmapInfo colorTable.
    ( hPalette := GDILibrary createPalette: logPalette asParameter ) = 0
        ifTrue: [ ^self osError ].
    ^hPalette! 
displayAt: aPoint with: destPen
        "Display the receiver at aPoint."
    self
        displayWith: destPen
        from: self boundingBox
        to: ( aPoint extent: self boundingBox extent )
        rule: Srccopy!
displayWith: destPen from: sRectangle
        "Copy sRectangle from the receiver in the destPen medium
        using aRopConstant.  Data will be compressed or stretched if
        the two rectangles are not the same extent."
    self
        displayWith: destPen
        from: sRectangle
        to: sRectangle
        rule: Srccopy! 
numberOfColors
        "Answer the number of colors in the bitmap."
    self bitCount = 24
        ifTrue: [^0]         "A 24 bitCount bitmap has no color table."
        ifFalse: [^(1 bitShift: self bitCount)]!   
colorTable
        "Private - Answer the receiver color table"
    ^bitmapInfo colorTable!  
height
        "Answer receiver's height."
    ^bitmapInfo height!  
width
        "Answer receiver's width."
    ^bitmapInfo width! 
bitCount
        "Answer the bitCount field of bitmapInfo structure."
    ^bitmapInfo bitCount! 
colorTable: aColorTable
        "Private - Set the receiver's color table"
    bitmapInfo colorTable: aColorTable!  
asBitmap
        "Convert from DIB bitmap to DDB bitmap."
    |bitmap|
    bitmap := Bitmap new.
    bitmap bitmapInfo: bitmapInfo.
    bitmap createBitmap: bits.
    bitmap
        deviceContext: Bitmap memoryContext;
        graphicsTool: (
            Pen forDC: Bitmap memoryContext medium: bitmap).

    ^bitmap!  
extent
        "Answer a Point which is the extent of the receiver."
    ^self width @ self height! 
fromStream: aStream
        "Private - Set the receiver's instance variables,
         parsing aStream. aStream must point to the DIB's
         info header."
    | bytes |
    bitmapInfo := Bitmap readBitmapInfo: aStream.
    bitmapInfo sizeImage = 0
        ifTrue: [bytes := (((
            bitmapInfo width * bitmapInfo bitCount) + 31) // 32 * 4) * bitmapInfo height]
        ifFalse: [bytes := bitmapInfo sizeImage].

    bits := ByteArray new: bytes.
    bits replaceFrom: 1
        to: bytes
        with: aStream contents
        startingAt: aStream position + 1.!   
isDIB
        "Answer true if receiver is an instance of class
         DIB or one of its subclasses, else answer false."
    ^true!   
displayWith: destPen from: sRectangle to: dRectangle rule: aRopConstant
        "Copy sRectangle from the receiver to dRectangle in
        the destPen medium using aRopConstant.  Data will be
        compressed or stretched if the two rectangles are not the
        same extent."
    | destinationDC hPrevious isMemDC hPalette hPPalette |
    destinationDC := destPen handle.
    ( isMemDC := ( destPen graphicsMedium isBitmap and: [
        destPen graphicsMedium deviceContext = Bitmap memoryContext ] ) )
        ifTrue: [
            destinationDC := Bitmap auxiliaryDC.
            hPrevious := destPen graphicsMedium selectToAuxDC ].

    ( hPalette := self createDIBPalette ) ~= 0
        ifTrue: [
            ( hPPalette := GDILibrary selectPalette: destinationDC
                with: hPalette
                forceBackground: false ) = 0
                    ifTrue: [ ^self osError ].
            ( GDILibrary realizePalette: destinationDC ) = 16rFFFFFFFF
                ifTrue: [ ^self osError ] ].

    GDILibrary
        stretchDIBits: destinationDC
        xDest: dRectangle left
        yDest: dRectangle top
        cxDest: dRectangle width
        cyDest: dRectangle height
        xSrc: sRectangle left
        ySrc: sRectangle top
        cxSrc: sRectangle width
        cySrc: sRectangle height
        bits: bits asParameter
        bmi: bitmapInfo asParameter
        colorUse: DibRgbColors
        rop: aRopConstant.

    hPalette ~= 0
        ifTrue: [
            ( GDILibrary selectPalette: destinationDC
                with: hPPalette
                forceBackground: false ) = 0
                    ifTrue: [ ^self osError ].
            ( GDILibrary deleteObject: hPalette ) ifFalse: [ ^self osError ] ].

    isMemDC
        ifTrue: [ destPen graphicsMedium deselectFromAuxDC: hPrevious ]! 
colors: aColorDictionary
        "Change the receiver's color palette with aColorDictionary
         The key is the index in the colorTable.
         The value is anExternalLong defining the RGB value"
    | colorTable n anExternalLong |
    colorTable := self colorTable.
    aColorDictionary associationsDo: [ :each |
        n := each key.
        anExternalLong := each value.
        anExternalLong isString
            ifTrue: [ anExternalLong := ExternalLong fromString: anExternalLong ]
            ifFalse: [ anExternalLong := ExternalLong fromInteger: anExternalLong ] .
        colorTable at: n - 1 * 4  + 1 put: ( anExternalLong byteAtOffset: 2 ).
        colorTable at: n - 1 * 4  + 2 put: ( anExternalLong byteAtOffset: 1 ).
        colorTable at: n - 1 * 4  + 3 put: ( anExternalLong byteAtOffset: 0 ) ].

    self colorTable: colorTable! 
isDisabled: item
        "Answer true if item is disabled.
         item can be the label or the selector."
    | mi |
    mi := self getMenuItem: item.
    ^( mi attribute bitAnd: MfGrayed ) ~= 0!
wmHScroll: wordInteger with: longInteger
        "Private - Process the horizontal scroll message."
    ^nil!   
checkFlags
        "Private - check user action and get the colors"
    | buffer |

    self style: self flags.
    chosen :=  RGBColor fromInteger: chooseColorStruct rgbResult.
    buffer := ExternalBuffer atAddress: ( ExternalHeapAddress fromInteger: chooseColorStruct lpCustColors ).
    1 to: 16 do: [:ix | customColors at: ix put:
                                ( buffer uLongAtOffset: ( 4 * ( ix - 1 )))].! 
invalidateRect: aRectangle erase: eraseBackground
        "Invalidate aRectangle area in the receiver
         thus force the area to be repainted.  If eraseBackground
         is true then the area is erased before being
         repainted."
    self isHandleOk ifFalse: [ ^self ].  "a 0 handle is interpreted as the desktop window."
    ( UserLibrary
        invalidateRect: self asParameter
        rectangle: aRectangle asParameter
        erase: eraseBackground )
            ifFalse: [ ^self osError ]!
propertyAt: name put: aVariableByteObject
        "Private - Set the value at the name in receiver's property list
        to aVariableByteObject, which must be 4 bytes."
    aVariableByteObject isNil
        ifTrue: [ UserLibrary removeProp: self name: name asParameter ]
        ifFalse: [
            [ UserLibrary
                setProp: self
                name: name asParameter
                data: aVariableByteObject asParameter ]
                whileFalse: [ ] ]  "retry until Microsoft gets around to fixing this..."!
isButton1Down
        "Answer whether the left mouse button is down."
    ^self isKeyDown: VkLbutton!   
loadMenuIndirect: template
    <api: LoadMenuIndirectW struct ulongReturn>
    ^self invalidArgument!   
simpleList
        "Set and answer the control style for simple list combo."
    self removeStyle: CbsDropdownlist.
    self removeStyle: CbsDropdown.
    ^self addStyle: CbsSimple! 
lastEvent
        "Private - answer a Symbol which represents the last keyboard / mouse state
        change that occurred during a drag drop transfer (#cancel, #dragButtonUp)."
    ^lastEvent!  
lastEvent: aSymbol
        "Private - set the symbol which represents the last keyboard / mouse state
        change that occurred during a drag drop transfer to aSymbol."
    lastEvent := aSymbol!  
lastEvent: aMessage upSelector: upSelector
        "Private - set the symbol which represents the last keyboard / mouse state
        change that occurred during a drag drop transfer to aSymbol."
    self lastEvent: nil.
    aMessage selector == upSelector
        ifTrue: [ self lastEvent: #dragButtonUp ]
        ifFalse: [
            ( Notifier isEscapeKeyInput: aMessage )
                ifTrue: [ self operation: nil. self lastEvent: #escapeKey ] ]!  
continue
        "Private - answer a Symbol which represents how to continue
        the current session: #continue, #cancel, or #drop."
	^continue!   
doDragDropAt: aPoint button: anInteger
        "Private - begin a drag drop transfer.  The index of the mouse button
        that was used to initiate the drag is indicated by anInteger.  Answer whether
        a drag operaton was implied by the given button."
    | oldCursor cursorInvalid nextTarget lastTarget moveSelector upSelector |
    ( self class isDragButton: anInteger ) ifFalse: [ ^false ].
    anInteger isNil
        ifTrue: [
            moveSelector := #mouseMove: .
            upSelector := #button1Up: ]
        ifFalse: [
            moveSelector := ( 'button', anInteger printString, 'Move:' ) asSymbol.
            upSelector := ( 'button', anInteger printString, 'Up:' ) asSymbol ].
    extended := anInteger = self class extendedDragButtonIndex.
    self screenLocation: ( aPoint mapClientToScreen: source ).
    oldCursor := Cursor.
    self sourceNeedsObject isNil ifTrue: [ ^false ].
    self sourceNeedsCursors.
    ( self objects isNil or: [ self objects isEmpty ] ) ifTrue: [ ^false ].
    self source captureMouseInput.
    [
    self class current: self.
    self target: self source.
    self scroll: false.
    self targetEnter.
    self sourceFeedback.
    lastTarget := self target.
    self continue: #continue.
    cursorInvalid := self invalidCursor.
    Notifier consumeInputUntil: [ :e |
        ( e selector = moveSelector or: [ e selector = #keyboardInput: and: [ ( Notifier isEscapeKeyInput: e ) not ] ] )
            ifTrue: [
                self setLocation.
                ( nextTarget := self getTarget ) isNil
                    ifTrue: [
                        self targetLeave.
                        self operation: nil.
                        self scroll: false.
                        Cursor == cursorInvalid ifFalse: [ cursorInvalid change ] ]
                    ifFalse: [
                        nextTarget = lastTarget
                            ifTrue: [
                                self operation: nil.
                                self targetOver.
                                self sourceFeedback ]
                            ifFalse: [
                                self targetLeave.
                                self target: nextTarget.
                                self targetSelection: nil.
                                lastTarget := self target.
                                self targetEnter.
                                self sourceFeedback ] ] ]
            ifFalse: [
                self lastEvent: e upSelector: upSelector.
                self sourceQueryContinue ].
        self continue ~~ #continue ]
    ] on: Error do: [ :e | self source clearMouseCapture. oldCursor change. e defaultAction ].
    self source clearMouseCapture.
    oldCursor change.
    ( self continue == #cancel or: [ self operation isNil ] ) ifTrue: [ self targetLeave ].
    ( self target notNil and: [ self operation notNil ] ) ifTrue: [
        extended ifTrue: [ self getExtendedOperation ].
        ( self operation notNil and: [ self continue == #drop ] ) ifTrue: [ self targetDrop ].
        self operation = #move ifTrue: [ self sourceCut ] ].
    self class current: nil.
    ^true! 
continue: aSymbol
        "Private - set the symbol which represents how to continue
        the current session to aSymbol: #continue, #cancel, or #drop."
	continue := aSymbol!  
getTarget
        "Private - answer the window under the mouse."
    ^CursorManager windowUnderCursor!  
getExtendedOperation
		"Private - an extended drag-drop just completed, so popUp a context menu
		containing available operations to determine the drop operation."
    | menu ops opNames |
    menu := Menu new.
    self targetNeedsOperations.  "request target to say which operations are supported."
    ops := self operations.
    opNames := self class operationDescriptions.
    operations do: [ :s |
        menu appendItem: ( opNames at: s ifAbsent: [ s ] ) selector: s ].
    self operation: ( menu popUpIn: self target )! 
sourceQueryContinue
        "Private - the keyboard or mouse state changed;
        determine how to continue the drag drop transfer."
    self continue:
        ( self lastEvent == #dragButtonUp
            ifTrue: [ #drop ]
            ifFalse: [
                self lastEvent == #escapeKey
                    ifTrue: [ #cancel ]
                    ifFalse: [ #continue ]] )! 
supportsScrolling
		"Private - Answer whether the receiver supports
		target window scrolling."
	^true!
doDragDropAt: aPoint
		"Private - initiate a drag drop transfer starting at the given location."
	^self doDragDropAt: aPoint button: self class dragButtonIndex!
invalidCursor
        "Answer the cursor for an invalid target"
    ^self class invalidCursor!  
sourceFeedback
        "Private - provide visual feedback for the current
        operation code ('move', 'copy', 'link', or nil), which
        indicates what would happen if a drop occurred
        over the current location (target) right now."
    | cursor |
    ( cursor := self cursorForOperation ) isNil
        ifTrue: [ cursor := self class cursorForOperation: self operation scroll: self scroll ].
    cursor = Cursor ifFalse: [ cursor change ]!
setLocation
        "Private - set the location to the current mouse position,
        relative to the screen."
    self screenLocation: Cursor sense! 
targetDrawEmphasis
        "Private - the target should draw emphasis."
    self target dragTargetDrawEmphasis: self!   
target
        "Answer the drag drop target."
    ^target!  
defaultOperation
        "Answer the default operation that will be carried out if no shift keys
        are selected while the drag is performed.  If unset by the source,
        the default operation is #move."
    ^defaultOperation notNil ifTrue: [ defaultOperation ] ifFalse: [ #move ]!
screenLocation
        "Answer aPoint which is the current location of the cursor
        relative to the screen."
    ^screenLocation!
doDragDropAt: aPoint
		"Private - begin a drag drop transfer."
    self implementedBySubclass!  
impliedOperation
        "Answer the drag-drop operation implied by the current state of the
        shift keys (Alt, Control, Shift).  If no shift keys are toggled, answer
        nil (which means that the target application's default operation
        is implied)."
    Notifier isAltKeyDown ifTrue: [ ^#move ].
    Notifier isControlKeyDown ifTrue: [ ^#copy ].
    Notifier isShiftKeyDown ifTrue: [ ^#link ].
    ^nil! 
targetLeave
        "Private - the mouse left the bounds of the
        current target during a drag drop transfer."
    self target dragTargetLeave: self!
targetLocation
        "Answer aPoint which is the current location of the cursor
        relative to the current target."
    ^self screenLocation mapToWindow: self target!  
cursorForOperation
        "Private - answer a Cursor to use for the current operation and scroll.
         Answer nil to use a standard drag drop cursor."
    self cursors isNil ifTrue: [ ^nil ].        "use standard cursor"
    self operation = #move ifTrue: [
        ^self scroll
            ifTrue: [ self cursors at: #dragDropMoveScroll ifAbsent: [ nil ] ]
            ifFalse: [ self cursors at: #dragDropMove ifAbsent: [ nil ] ] ].
    self operation = #copy ifTrue: [
        ^self scroll
            ifTrue: [ self cursors at: #dragDropCopyScroll ifAbsent: [ nil ] ]
            ifFalse: [ self cursors at: #dragDropCopy ifAbsent: [ nil ] ] ].
    self operation = #link ifTrue: [
        ^self scroll
            ifTrue: [ self cursors at: #dragDropLinkScroll ifAbsent: [ nil ] ]
            ifFalse: [ self cursors at: #dragDropLink ifAbsent: [ nil ] ] ].
    ^self cursors at: self operation ifAbsent: [ self cursors at: #dragDropNone ifAbsent: [ nil ] ]!  
sourceNeedsCursors
        "Private - retrieve the drag drop cursors from the
        drag source."
    self source dragSourceNeedsCursors: self!  
addObject: aDragObject
        "Add aDragObject to the receiver's
        collection of drag objects."
    self objects: ( self objects isNil
        ifTrue: [ Array with: aDragObject ]
        ifFalse: [ self objects copyWith: aDragObject ] )! 
supportsScrolling
        "Private - Answer whether the receiver supports
        target window scrolling."
    ^self implementedBySubclass!   
target: anObject
        "Set the drag drop target to anObject."
    target := anObject!
objects
        "Answer the objects being dragged."
    ^objects!   
objects: aCollection
        "Set the objects being dragged to aCollection."
    objects := aCollection!
sourceCut
        "Private - the drag drop transfer that was just completed
        requires that the source object be cut (move operation)."
    self source dragSourceCut: self! 
defaultOperation: aString
        "Set the default operation which will be carried out if no shift keys are
        depressed during the drag to aString."
    defaultOperation := aString
!  
sourceNeedsObject
        "Private - retrieve the drag drop object from the
        drag source."
    self source dragSourceNeedsObject: self! 
screenLocation: aPoint
        "Private - set the current location of the cursor
        relative to the screen to aPoint."
    screenLocation := aPoint!  
scroll: aBoolean
        "Set a flag which determines whether visual feedback is required
        to indicate scrolling (cursor)."
    scroll := aBoolean! 
operation
        "Answer a String which specifies what would happen if the
        drag object were dropped right now at the current location
        and over the current target ('move', 'copy', 'link', nil, or some
        other string which specifies a user-defined operation)."
    ^operation!
operation: operationName
        "Set the operationName which specifies what would happen if the
        drag object were dropped right now at the current location
        and over the current target ('move', 'copy', 'link', nil, or some
        other string specifying a user-defined operaton)."
    operation := operationName! 
operations
        "Private - answer the list of operations that the current target
        can accept."
    ^operations!  
targetOver
        "Private - the mouse moved within the bounds of the
        current target during a drag drop transfer."
    self target dragTargetOver: self!  
source: anObject
        "Set the drag drop source to anObject."
    source := anObject!
cursors
        "Answer the Dictionary of cursors for drag operations."
    ^cursors!   
operations: aCollection
        "Set the collection of operations that the current target can accept
        to aCollection."
    operations := aCollection!   
cursors: aDictionary
        "Set the cursors to be used during drag drop."
    cursors := aDictionary! 
targetEnter
        "Private - the mouse entered the bounds of the
        current target during a drag drop transfer."
    self target dragTargetEnter: self! 
isGlobalDragDropSession
        "Private - Answer whether or not the receiver is
        a global drag drop session."
    ^self class isGlobalDragDropSession! 
targetSelection
        "Answer the selection within the target if any."
    ^targetSelection!  
targetSelection: anObject
        "Set the selection within the target to anObject."
    targetSelection := anObject!   
objectClass
        "Answer the class to use for DragDropObjects added
        to the receiver."
    ^self class objectClass!  
targetEraseEmphasis
        "Private - the target should erase emphasis."
    self target dragTargetEraseEmphasis: self!
targetNeedsOperations
        "Private - retrieve the list of drag-drop (extended) operations
        from the target."
    self target dragTargetNeedsOperations: self!   
isLocalDragDropSession
        "Private - Answer whether or not the receiver is
        a local drag drop session."
    ^self class isLocalDragDropSession!
source
        "Answer the drag drop source."
    ^source!  
targetDrop
        "Private - the dragged object was dropped over the current
        target at the current location."
    self target dragTargetDrop: self!   
scroll
        "Private - answer whether visual feedback is required to indicate scrolling."
    ^scroll!   
width
        "Answer the average character width."
    | aCharSize |
    aCharSize := self charSize.
    aCharSize notNil
        ifTrue: [^aCharSize x]
        ifFalse: [^nil]!  
fromInteger: anInteger
        "Answer an instance of the receiver class created from
        anInteger (16r00ggbbrr)."
    ^( WinColorref fromInteger: anInteger ) asColor!   
updateRectangle
        "Private - Reset the bounding rectangle."
   super updateRectangle.
   textHolder frame: (0 @ 0 extent: rectangle extent).
   "textHolder display: (rectangle)."! 
charWidth: aCharacter graphicsMedium: aGraphicsMedium
        "Answer the width of aCharacter in the aGraphicsMedium."
    ^self charWidth: aCharacter 
        graphicsTool: aGraphicsMedium graphicsTool!
displayUnhighlightedText: string at: displayPoint
        "Display the given <string> at the <displayPoint> using the system settings for
        highlight background & foreground colors, and blank out the background behind it
        (but not the rest of the pane width, like #lineDisplay:at: does)."
    self
        setBackgroundMode: BackgroundMixTransparent ;
        fill: (self boundingBoxOfText: string at: displayPoint) color: self backColor;
        displayText: string at: displayPoint!  
defaultCursor
        "Private - Answer the default mouse cursor
         for the receiver. Default is arrow cursor."
    ^nil!
entryFieldHandle
        "Private - Answer a WindowHandle for the entry field component
         of the ComboBox, or nil if not valid."
    | child |
    child := UserLibrary getWindow: handle relationship: GwChild.
    "For a simple combo box, the entry field is the last child."
    child := UserLibrary getWindow: child relationship: GwHwndlast.
    ^child = 0 ifTrue: [ nil ] ifFalse: [ WindowHandle fromInteger: child ]!  
charsInColumn
        "Private - Answer the receiver height in characters."
    ^self getFormatRect height // self font height! 
deleteMenu: aMenuHandle position: positionInteger flag: flagInteger
    <api: DeleteMenu ulong ulong ulong boolean>
    ^self invalidArgument!  
paletteToRgb: aPaletteIndex
        "Answers the RGB color that is at the default
        palette at aPaletteIndex"
    | anAddress |
    anAddress := ExternalAddress new.
    self paletteIndex:
        (GDILibrary
            getPaletteEntries:
                (GDILibrary getStockObject: DefaultPalette)
            startIndex: aPaletteIndex
            numEntries: 1
            lpPaletteEntries: anAddress asParameter).
    ^anAddress asInteger! 
defaultBackColor
        "Answer the default background color for windows of
         this class."
    ^Color windowBackground!
setHandle
        "Private - set the icon handle in the control window."
    | temp |
    ( self isHandleOk and: [ value notNil ] ) ifFalse: [ ^self ].
    UserLibrary
        sendMessage: handle
        msg: StmSeticon
        wparam: ( temp := value clone ) asParameter
        lparam: 0.
    temp == value ifFalse: [ temp initHandle ]!   
isValid
        "Private - Answer true if the receiver is a valid window
         handle."
    ^super isValid and: [ UserLibrary isWindow: self ]! 
flags: flags
        "Private - Specifies the dialog box creation flags.
        Kept for compatibility reasons. Use style: instead"
   self style: flags! 
prompt: questionString default: answerString
        "Open a Prompter dialog box with questionString as
         its question and answerString as its
         default answer.  Answer the user
         response (a String) with leading and
         trailing spaces trimmed."
    ^self new
        evaluating: false;
        withBlank: false;
        prompt: questionString default: answerString!
promptWithBlanks: questionString default: answerString
        "Open a Prompter dialog box with questionString as its
         question and answerString as its default answer.
         Answer the user response (a String) without
         trimming the blanks."
    ^self new
        evaluating: false;
        withBlank: true;
        prompt: questionString default: answerString!   
title: titleString prompt: questionString default: answerString
        "Open a new Prompter with the given arguments;
         answer the typed value"
    ^self new
        evaluating: false;
        withBlank: false;
        title: titleString prompt: questionString default: answerString! 
prompt: questionString default: answerString
        "Private - Initialize a Prompter window
         and give it control."
    ^self title: '' prompt: questionString default: answerString!  
initWindowSize
        "Private - Answer the window size."
    ^40 @ (15/2) * WindowDialog unitMultiplier!  
cancelAnswer
        "Private - answer what the receiver should answer
        if the user clicks on the Cancel button."
    ^nil! 
opened: topPane
        "Private - Dialog is opened, select the text
         and set the initial focus."
    | entryField |
    ( entryField := self paneAt: #text )
        selectFrom: 1 to: entryField contents asExternalString size.
    entryField setFocus! 
evaluating: aBoolean
        "Private - Set the instance variable
         evaluating to aBoolean."
    evaluating := aBoolean!
okToClose
        "Private - Process the receiver's contents and answer
        whether it is ok for the receiver to be closed."
    ^evaluating
        ifTrue: [ self compileExpression ]
        ifFalse: [
            reply := self query: #text.
            withBlank ifFalse: [ reply := reply trimBlanks ].
            true ]!  
cancel: aButton
        "Private - The user clicked on the Cancel button."
    reply := self cancelAnswer.
    self close! 
withBlank: aBoolean
        "Private - Set the instance variable
         withBlank to aBoolean."
    withBlank := aBoolean!   
createPanesWithTitle: titleString prompt: questionString default: answerString
        "Private - create the panes for the receiver."
    | lineHeight charSize pane font |
    font := self class platformDefaultFont.
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.

    ( pane := self mainView )
        owner: self;
        labelWithoutPrefix: titleString;
        when: #opened send: #opened: to: self with: pane;
        font: font.
    self addView: pane.

    self addSubpane:
        (StaticText new
            setName: #questionString;
            leftJustified;
            contents: questionString;
            framingBlock: [:box |
                (box leftTop rightAndDown: 1@1 * charSize)
                    extentFromLeftTop: 38@1 * charSize ] ).

    self addSubpane:
        (EntryField new
            setName: #text;
			setTextLimit: 255;
            contents: answerString;
            framingBlock: [:box |  (box leftTop rightAndDown: (1 @ (5/2)) * charSize)
                extentFromLeftTop: ((38 @ (3/2)) * charSize) rounded ] ).

    self addSubpane:
        ( ( pane := Button new )
            setName: #ok;
            defaultPushButton;
            contents: 'OK';
            when: #clicked send: #ok: to: self with: pane;
            framingBlock: [:box | (box leftTop rightAndDown: (1 @ 5) * charSize)
                extentFromLeftTop: 10@2 * charSize ] ).

    self addSubpane:
        ( ( pane := Button new )
            setName: #cancel;
            pushButton;
            contents: 'Cancel';
            when: #clicked send: #cancel: to: self with: pane;
            framingBlock: [:box | (box leftTop rightAndDown: (12 @ 5) * charSize)
                extentFromLeftTop: 10@2 * charSize ] )!  
title: titleString prompt: questionString default: answerString
        "Private - Initialize a Prompter window
         and give it control."
    self
        createPanesWithTitle: titleString prompt: questionString default: answerString;
        openWindow.
    ^reply! 
ok: aButton
        "Private - The user selected ok."
    self okToClose ifTrue: [self close]!  
lcreat: aString style: anInteger
        "Private - Call the Win _lcreat function. 'anInteger' =
         0 normal; 1 read only; 2 hidden; 3 system;
         Obsolete - use CreateFile"
    <api: '_lcreat' struct long long>
    ^self invalidArgument!
copyAcceleratorTable: hAccel to: anAddress count: anInteger
    <api: CopyAcceleratorTableA ulong ulong ulong long>
    ^self invalidArgument!  
defaultStyle
        "Private - Answer the default style for the receiver."
    ^CbsDropdownlist | WsVscroll!   
removeMenu: aMenu
        "Remove aMenu from the receiver."
    self owner isMDIChild ifTrue: [
        self destroyMDIMenu: aMenu.
        ^self ].
    self isHandleOk 
        ifTrue: [ self deleteAndRebuildMenusStartingFrom: aMenu ].
    menus remove: aMenu ifAbsent: [ ^self ].
    self removeFromAllMenus: aMenu! 
queryText: text inComboBox: itemId startingAt: startingAt
        "Find the index of text in combo box itemId starting.
        at index startingAt.  Index is 0 relative."
    ^self sendMessage: CbFindstring item: itemId wparam: startingAt lparamStruct: text asParameter!
constructNotifications
        "Private - answer the mapping between host control
        notification codes and corresponding Smalltalk event
        notifications."
    ^super constructNotifications
        at: CbnEditchange put: #notifyTextChanged: ;
        yourself! 
exitWindowSystem1
        "Private - perform OS window system shutdown."
    self runningApplications values do: [ :handle | KernelLibrary closeHandle: handle ].
    Printer exit.
    SystemWindow exit.  "maybe needed in non-gui mode"
    Notifier closeAllWindows! 
wmQuerydragicon: wordInteger with:longInteger
        "Private - Answer the icon handle"
    | icon |
    ( icon := self icon ) isNil ifTrue: [ ^nil ].
    ^icon handle! 
peekMessage: aWinAddr hwnd: aHandle min: min max: max remove: flags
   <api: PeekMessageA ulong ulong ulong ulong ulong boolean>
    ^self invalidArgument! 
updateHorizontalExtent
        "Private - if the receiver has a horizontal scrollbar,
         call this method after setting its contents to calculate
         and set the correct horizontal scrollbar range."
    | maxWidth font |
    ( self hasStyle: WsHscroll ) ifFalse: [ ^self ].
    list size = 0 ifTrue: [ ^self ].
    ( font := self font ) isNil ifTrue: [ font := ListFont ].
    maxWidth := list inject: 0 into: [ :max :item |
        max max: ( font stringWidth: ( self stringForItem: item ) ) + 5 ].
    self setHorizontalExtent: maxWidth!  
deleteMessage
        "Private - Answer OS delete message for the receiver."
    ^CbDeletestring!   
windowClass
        "Private - Answer the host class of scrollbar control."
    ^'SCROLLBAR'!   
dragTargetEmphasisPane
		"Set the type of target emphasis to be employed to
		be pane based."
	self dragTargetEmphasis: 'pane'!
apmHeader
        "Private - answer the metafile header for the receiver."
    ^apmHeader!  
makeProcInstance: lpProc withInstance: hInstance
    <api: MakeProcInstance ulong handle ulong>
    ^self invalidArgument!  
getCharHeight
        "Private - answer the height of the font selected in the receiver's
        device context."
    | textMetrics |
    textMetrics := WinTextMetrics new.
    ( GDILibrary getTextMetrics: deviceContext lpMetrics: textMetrics asParameter )
        ifFalse: [ ^self osError ].
    ^textMetrics tmHeight + textMetrics tmExternalLeading!   
horizontal
        "Answer an instance of a horizontal scrollbar."
    ^self new horizontal; yourself!  
vertical
        "Answer an instance of a vertical scrollbar."
    ^self new vertical; yourself!
horizontal
        "Set the horizontal style scrollbar."
    self removeStyle: SbsVert.
    self addStyle: SbsHorz.
    self setStyle: self style!
isVertical
        "Answer whether the receiver is vertical style."
    ^self hasStyle: SbsVert!
notifyNextLine: aParameter
        "Private - the host signaled that a cursor down occurred."
    self
        incrementPositionBy: self lineIncrement;
        event: #nextLine;
        triggerEvent: #nextLine;
        triggerChanging! 
notifyNextPage: aParameter
        "Private - the host signaled that a page down occurred."
    self
        incrementPositionBy: self pageIncrement;
        event: #nextPage;
        triggerEvent: #nextPage;
        triggerChanging!   
notifySliderTrack: aParameter
        "Private - the host signaled that the slider moved during a continuous scroll."
    self
        position: aParameter;
        event: #sliderTrack;
        triggerChanging!   
notifyEndScroll: aParameter
        "Private - the host signaled that scrolling completed."
    self
        event: #endScroll;
        triggerChanged!   
notifyEnd: aParameter
        "Private - the host signaled that End was selected."
    self
        position: self maximum;
        event: #end;
        triggerEvent: #end;
        triggerChanging!   
notifyPreviousLine: aParameter
        "Private - the host signaled that a cursor up occurred."
    self
        decrementPositionBy: self lineIncrement;
        event: #prevLine;
        triggerEvent: #previousLine;
        triggerChanging!   
notifyPreviousPage: aParameter
        "Private - the host signaled that a page up occurred."
    self
        decrementPositionBy: self pageIncrement;
        event: #prevPage;
        triggerEvent: #previousPage;
        triggerChanging! 
setMaximum
        "Private - update the host control's maximum value."
    self setRange!  
setMinimum
        "Private - update the host control's minimum value."
    self setRange!  
initialize
        "Private - Initialize the receiver."
    super initialize.
    self
        lineIncrement: 1;
        pageIncrement: 24!  
notifyHome: aParameter
        "Private - the host signaled that Home was selected."
    self
        position: self minimum;
        event: #home;
        triggerEvent: #home;
        triggerChanging!   
vertical
        "Set the vertical style scrollbar."
    self removeStyle: SbsHorz.
    self addStyle: SbsVert.
    self setStyle: self style!
isHorizontal
        "Answer whether the receiver is horizontal style."
    ^self hasStyle: SbsHorz!
convertIndex: anInteger string: aString
        "Private - Change anInteger, a one based character
        position in aString, to a zero based byte position."
    ^anInteger - 1!
windowText
        "Answer the receiver's window text."
    | string size |
    self isHandleOk
        ifTrue: [
           string := (String new: self windowTextLength + 1) asParameter.
           size := UserLibrary
                getWindowText: self handle
                text: string
                maxLength: string size.
            ^( string copyFrom: 1 to: size ) asNormalizedString ]
        ifFalse: [ ^String new ]! 
showRestoredWindow
        "Private - make the window visible, maximized."
    UserLibrary showWindow: self command: SwRestore! 
isMonoBitmap
        "Answer true if the receiver is a monochrome bitmap."
    ^((bitmapInfo bitCount * bitmapInfo planes) = 1)!
sendFile
        "Private - send the current selection as an e-mail message."
    | textPane selection session |
    ( textPane := self activeTextPane ) isNil ifTrue: [ ^self ].
    selection := textPane selectedItem isEmpty
        ifTrue: [ textPane contents ]
        ifFalse: [ textPane selectedItem ].
    session := ( Smalltalk at: #MailSession ) logon.
    session newMessage send: selection!   
checkDlgButton: hDlg item: nIDButton checkIt: wCheck
    <api: CheckDlgButton ulong long ulong boolean>
    ^self invalidArgument!  
isDropDownList
        "Answer true if the receiver is a kind of DropDownList."
    ^true!  
notifyListVisible: aParameter
		"Private - the host signaled that the list was dropped down."
    self event: #listVisible.
    self triggerEvent: #listVisible!   
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process Esc key."
    aKeyboardInputEvent virtualKey = EscapeKey
        ifTrue: [ self showDropdown: false ].
    ^super keyboardInput: aKeyboardInputEvent! 
contents: aCollection
        "Set the receiver's contents to aCollection."
    | isSimple |
    list := aCollection.
    isSimple := self isSimpleList.
    self isHandleOk ifTrue: [
        isSimple ifTrue: [ self disableRedraw ].
        self
            deleteAllFromControl;
            insertArray: list.
        isSimple ifTrue: [ self enableRedraw ] ].
     ^list!
clear
        "Clear the contents of the entry field part."
    self isHandleOk
        ifTrue: [ self setWindowText: '' ]!
isSimpleList
        "Answer true if the receiver is a simple list."
    ^false!
setInitialContents
        "Private - set the receiver's contents. Defer this because
         list is not shown until drop down button is clicked on."
    "defer setting contents for non-simple-lists with no selection."
    ( self isSimpleList or: [ value notNil ] )
        ifTrue: [ ^super setInitialContents ].
    self sendDeferredEvent: #setContents.
    self sendDeferredEvent: #setSelection!
setContents
        "Private - set the receiver's contents."
    self contents: list!   
wmLbuttondown: wParam with: lParam
        "Private - If button1down over a deactivated textPane,
        make it active but do not change the selection."
    | point |
    self mainWindow isActive ifFalse: [ self makeActive. ^true ].
    ( self isDragSource and: [ self isDragButton: 1 ] ) ifTrue: [
        point := ( WinPoint fromInteger: lParam ) asPoint.
        point := self characterCoordinate: point.
        "don't pass onto default window handler if inside selection & dragging"
        ( self selectionIncludesPoint: point )
            ifTrue: [ super wmLbuttondown: wParam with: lParam. ^true ] ].
    self mainWindow activeTextPane: self.
    ^super wmLbuttondown: wParam with: lParam!  
invalidateRect: aRectangle
        "Invalidate aRectangle area in the receiver
         thus force the area to be repainted."
    self invalidateRect: aRectangle erase: true! 
connectTo: aGraphicsTool
        "Disassociate the receiver from its current graphics 
         tool and then associate with aGraphicsTool."
    graphicsTool isNil 
        ifFalse: [
            aGraphicsTool graphicsMedium == self
                ifTrue: [^self].
            graphicsTool := aGraphicsTool.
            graphicsTool graphicsMedium: self ]! 
dragTarget: aBoolean
        "Enable or disable the receiver as a drag drop target."
    self propertyAt: #dragTarget put: ( aBoolean ifTrue: [ true ] ifFalse: [ nil ] )!  
appendMenu: aMenuHandle
    flags: anInteger
    id: idInteger
    contents: stringOrBitmapHandle
        "Private - Perform the Win AppendMenu function."
    ^stringOrBitmapHandle isInteger
        ifTrue: [ self appendMenu: aMenuHandle flags: anInteger id: idInteger contentsInt: stringOrBitmapHandle ]
        ifFalse: [ self appendMenu: aMenuHandle flags: anInteger id: idInteger contentsStruct: stringOrBitmapHandle ]!
fromHandle: hBitmap
         "Answer an instance of Bitmap copied from
        bitmap handle hBitmap."
    ^self fromHandle: hBitmap clipWidth: nil clipHeight: nil!   
fromFileStream: aFileStream
        "Answer an instance of Bitmap read from aFileStream.
        The contents of aFileStream must be in DIB format (as
        that of a file with '.bmp' extension)."
    ^(DIB fromFileStream: aFileStream) asBitmap!   
fromFile: bitmapFile
        "Answer an instance of Bitmap copied from bitmapFile.
        bitmapFile must be in DIB format with '.bmp' extension."
    ^(DIB fromFile:bitmapFile) asBitmap!   
fromHandle: hBitmap offset: offset extent: extent
         "Answer an instance of Bitmap copied from
          bitmap handle hBitmap, Clipped by clipWidth
          and clipHeight."
    | bitmapStruct srcDC newBitmap oldHandle1 oldHandle2 aWidth aHeight aClipWidth aClipHeight |
    aClipWidth := extent x.
    aClipHeight := extent y.
    srcDC := self createCompatibleDC: Display deviceContext.
    oldHandle1 := GDILibrary selectObject: srcDC with: hBitmap.
    GDILibrary
        getObject: hBitmap
        count: WinBitmapStruct sizeInBytes
        lpObject: ( bitmapStruct :=  WinBitmapStruct new ) asParameter.
    aWidth := aClipWidth isNil
        ifTrue: [ bitmapStruct width ]
        ifFalse: [ bitmapStruct width min: aClipWidth ].
    aHeight := aClipHeight isNil
        ifTrue: [ bitmapStruct height ]
        ifFalse: [ bitmapStruct height min: aClipHeight ].
    bitmapStruct width: aWidth.
    bitmapStruct height: aHeight.
    newBitmap := self new bitmapIndirect: bitmapStruct.
    oldHandle2 := GDILibrary
        selectObject: newBitmap deviceContext
        with: newBitmap handle.
    self
        bitBlt: newBitmap deviceContext
        x: 0
        y: 0
        width: aWidth
        height: aHeight
        srcDC: srcDC
        xSrc: offset x "- 1"
        ySrc: offset y "- 1"
        rop: Srccopy.
     oldHandle1 ~= 0 ifTrue: [ GDILibrary selectObject: srcDC with: oldHandle1 ].
     ( GDILibrary deleteDC: srcDC ) ifFalse: [ ^self osError ].
     GDILibrary selectObject: newBitmap deviceContext with: oldHandle2.
     ^newBitmap!  
fromModule: aModuleName id: bitmapName
        "Answer an instance of Bitmap whose id is bitmapName
         contain in the module identified by aModule.
         bitmapName may be an integer or a string."
    ^self new fromModule: aModuleName id: bitmapName!   
startUp
        "Private - Initialize memory device context. This must
         be done at each startUp."
    | hBitmap |
    MemoryContext := self createCompatibleDC: Display deviceContext.
    AuxiliaryDC := self createCompatibleDC: Display deviceContext.
    hBitmap := self
        createBitmap: 1
        height: 1
        planes: 1
        bitCount: 1
        bits: nil.
    DefaultBitmap := GDILibrary selectObject: MemoryContext with: hBitmap.
    GDILibrary selectObject: MemoryContext with: DefaultBitmap.
    ( GDILibrary deleteObject: hBitmap ) ifFalse: [ ^self osError ].
    DefaultPaletteHandle := GraphicsTool getStockObject: DefaultPalette.! 
readBitmapInfo: aStream
        "Private - Answer an instance of WinBitmapInfoHeader
         read from aStream . aStream position is updated."
    | bitmapInfo size rgb rgbTriple position byteArray coreHeader  count |
    position := aStream position.
    size := aStream nextULong.
    aStream position: position.
    size = 12
        ifTrue: [   "OS/2 1.2 format."
            coreHeader := SelfDefinedStructure named: 'OS2BITMAPCOREHEADER'.
            coreHeader contents
                replaceFrom: 1
                to: coreHeader contents size
                with: aStream contents
                startingAt: position + 1.
            position := position + size.
            rgbTriple := ByteArray new: ((1 bitShift: coreHeader bitCount) * 3).
            rgbTriple
                replaceFrom: 1
                to: rgbTriple size
                with: aStream contents
                startingAt: position + 1.
            position := position + rgbTriple size.
            bitmapInfo := WinBitmapInfoHeader
                width: coreHeader width
                height: coreHeader height
                planes: 1
                bitCount: (coreHeader bitCount * coreHeader planes).
            coreHeader bitCount = 24 ifFalse: [
                rgb := ByteArray new: ((1 bitShift: coreHeader bitCount) * 4).
                count := 0.
                1 to: rgbTriple size by: 3 do: [: i |
                    rgb at: i + count put: (rgbTriple at: i).
                    rgb at: i + 1 + count  put: (rgbTriple at: i + 1).
                    rgb at: i + 2 + count put: (rgbTriple at: i + 2).
                    rgb at: i + 3 + count put: 0.
                    count := count + 1]]]

        ifFalse: [  "Windows or OS/2 2.0 format."
            byteArray := ByteArray new: size.
            byteArray replaceFrom: 1
                to: size
                with: aStream contents
                startingAt: position + 1.
            position := position + size.
            bitmapInfo := WinBitmapInfoHeader fromBytes: (
                byteArray copyFrom: 1 to: WinBitmapInfoHeader sizeInBytes).
            bitmapInfo biSize: WinBitmapInfoHeader sizeInBytes.

            bitmapInfo bitCount = 24
                ifFalse: [
                    rgb := ByteArray new:  ( WinBitmapInfo colorTableSize: bitmapInfo bitCount ).
                    rgb replaceFrom: 1
                        to: rgb size
                        with: aStream contents
                        startingAt: position + 1.
                    position := position + rgb size ] ].

    bitmapInfo := WinBitmapInfo fromBytes: (
        rgb isNil
            ifTrue: [ bitmapInfo contents ]
            ifFalse: [ bitmapInfo contents, rgb ] ).
    aStream position: position.
    ^bitmapInfo! 
fromFile: bitmapFile in: dir
        "Answer an instance of Bitmap copied from bitmapFile.
        bitmapFile must be in DIB format with '.bmp' extension."
    ^(DIB fromFile: bitmapFile in: dir) asBitmap!  
xorMask
        "Private - Answer the XOR mask."
    ^xorMask!  
width: w height: h planes: p bitCount: b
        "Answer a new Bitmap with width w , height h
         planes p, and bitCount b."
    ^self new width: w height: h planes: p bitCount: b!  
validate
        "Private - Don't want to rebuild dialogs from saved image"
    ^ nil!  
bitmapIndirect: aWinBitmapStruct
        "Private - Create the receiver from aWinBitmapStruct."
    | hOldBitmap bitCount |
    bitCount := aWinBitmapStruct planes * aWinBitmapStruct bitsPixel.
    self initPenWidth: aWinBitmapStruct width
        height: aWinBitmapStruct height
        planes: 1
        bitCount: bitCount.
    self createBitmap.
    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap!   
button1Down: aPoint
        "Private - Left button has been pressed down.
        Let the owner process the event."
    (super button1Down: aPoint) ifFalse: [^ self].
    self captureMouseInput.
    mouse := aPoint.
    self event: #button1Down.
    self triggerEvent: #button1Down.!
chosen
        "Answer the font the user chose."
    ^chosen!   
open
        "Bring up a font dialog."
    | error |
    hLibrary := CommonDialogDLL current.
    self copyStruct.

    parent isWindow ifFalse: [
        parent := Notifier findWindow: WindowHandle queryActive.
        chooseFontStruct hwndOwner: parent asParameter ].
    style notNil ifTrue: [ chooseFontStruct flags: style ].

    ( hLibrary chooseFont: chooseFontStruct asParameter )
        ifTrue: [ self checkFlags ]
        ifFalse: [
            error := ( ExternalLong fromString: hLibrary commDlgExtendedError ) asInteger.
            error ~= 0 ifTrue: [
                self cleanUp.
                ^self osError: error ] ].
    self cleanUp.!  
add: aString toComboBox: itemId
        "Add aString at anInteger to the combo box whose
         id is itemId.  anInteger is either the zero-based
         index of the new item or a constant beginning
         with 'Lit' from the OperatingSystemConstants pool dictionary."
    self sendMessage: CbAddstring item: itemId wparam: 0 lparamStruct: aString asParameter!   
bitCoordinate: aPoint
        "Private - Calculate the bit coordinates of
         aPoint relative to the pane frame."
    | p font top frame xOffset line |
    font := pane font.
    top := pane topCorner.
    frame := pane rectangle.
    font fixedWidth
        ifTrue: [
            p :=
                frame leftTop
                    rightAndDown: (aPoint - top * font charSize).
            p :=
                (p rightMostAndLowest: (frame leftTop leftAndUp: font charSize))
                       leftMostAndHighest:
                         (frame rightBottom rightAndDown:  font charSize).
            ^p]

    "Theoretically, the max: and min: is not
     necessary due to clipping.  Their purpose
     here is to insure that the coordinates
     remain small integer"

        ifFalse: [
            line := pane textHolder lineAt: aPoint y.
            pane doGraphics: [ xOffset :=
                ((pane pen
                     stringWidthOf: line
                       at: aPoint x - 1)
                        - (top x - 1 * font width))].
            p :=
                frame leftTop
                    rightAndDown:  xOffset @ (aPoint y - top y * font height).

            ^(p
                rightMostAndLowest:
                    (frame leftTop leftAndUp: font charSize))
                        leftMostAndHighest:
                            (frame rightBottom rightAndDown: font charSize)]!
dragSourceNeedsObject: dragSession
        "Private - retrieve the object to be dragged."
    self dragSourceSelection: selection.
    ^super dragSourceNeedsObject: dragSession.
!   
destroyCursor: hpointer
    <api: DestroyCursor ulong boolean>
    ^self invalidArgument!   
wmRbuttonup: wParam with: lParam
        "Private - If button1down over a deactivated textPane,
        make it active but do not change the selection.  Override
        superclass implementation to circumvent Windows 95
        default wndproc popup menu handling."
    super wmRbuttonup: wParam with: lParam.
    ^0!  
addSystemMenuItems: aParent
        "Private - Add any system menu items to aParent."
    | menu sysMenu |
    menu := allMenus at: 1.
    menu numberOfItems = 0 ifTrue: [ ^self ].
    sysMenu := self class fromInteger:
        ( UserLibrary getSystemMenu: aParent asParameter revert: 0 ).
    menu window: sysMenu.
    1 to: menu numberOfItems do: [ :i |
        ( menu buildSystemItem: i menu: 1 parent: self ) isNil ifTrue: [ ^nil ] ]!   
wmMouseactivate: wParam with: lParam
        "Private - If mouse has been clicked on an inactive
         window, don't treat it as a selection."
    | hitTest |
    ( self isActive | self mainWindow mdiSelected )
        ifTrue: [ self mainWindow mdiSelected:true. ^nil ]
        ifFalse:
            [
            self mainWindow mdiSelected:true.
            CUA ifTrue:[ ^nil ].
            hitTest := lParam lowWord.
            ( hitTest = Htclient )
                ifTrue:[ ^MaActivateandeat ]
                ifFalse:[ ^nil ]
            ]!   
sampleFont: aFont
        "Set the font of the sample string to aFont."
    self propertyAt: #sampleFont put: aFont!
extractFontInfo
        "Private - Extract font information from the host system."
    | sysFontMetrics hDC hOldFont tempLogFont |
    handle isNil ifTrue: [ ^self ].
    sysFontMetrics := WinTextMetrics new.
    tempLogFont := WinLogFont new.
    hDC := graphicsMedium graphicsTool handle.
    hOldFont := GDILibrary selectObject: hDC with: handle.
    GDILibrary getObject: handle count: tempLogFont size lpObject: tempLogFont contents.
    ( GDILibrary getTextMetrics: hDC
        lpMetrics: sysFontMetrics contents )
            ifFalse: [ ^self osError ].
    self logicalFont: tempLogFont.
    self initFontInfo: sysFontMetrics!   
moveCaret: aPoint
        "Move the caret to aPoint."
    UserLibrary
        setCaretPos: aPoint x
        y: aPoint y!  
setClipboardData: aCfConstant hMem: aMemHandle
    <api: SetClipboardData ulong ulong ulongReturn>
    ^self invalidArgument!   
setFocus
        "Set the current input focus to be the receiver."
    self isHandleOk
        ifTrue: [ UserLibrary setFocus: handle ]
        ifFalse: [ self whenValid: #setFocus ]!   
enumFonts: lpLogFont lpTextMetrics: lpTextMetrics nFontType: nFontType lpData: lpData
        "Private - CallBack proc. Enumerate all the faces of the font."
    | anAddress aWinLogFont aWinTextMetrics anArray |
    anAddress := ExternalAddress fromInteger: lpLogFont.
    aWinLogFont := WinLogFont fromAddress: anAddress.
    anAddress := ExternalAddress fromInteger: lpTextMetrics.
    aWinTextMetrics := WinTextMetrics fromAddress: anAddress.
    anArray := Array new: 3.
    anArray at: 1 put: nFontType.
    anArray at: 2 put: aWinLogFont.
    anArray at: 3 put: aWinTextMetrics.
    TempFontList add: anArray.
    ^1!   
wmSyschar: wordInteger with: longInteger
        "Received a system menu key.  Check if we should process
        it as a mnemonic."
    ( self altDownInWmChar: wordInteger with: longInteger )
        ifTrue: [ ^1 ].
    ^nil    "Must be nil, or menus won't get the menu accelerator."!
initializeStructures
        "Private - initialize any SelfDefinedStructures required by the gui."
    FileDialog initialize.  "OPENFILENAME"
    FontDialog initialize.  "CHOOSEFONT"
    ColorDialog initialize.  "CHOOSECOLOR"
    PrintDialog initialize.  "PRINTDLG, DEVNAMES, DEVMODE"
    Printer initialize.  "DOCINFO"
    Bitmap initialize.  "OS2BITMAPCOREHEADER"
    Icon initialize.  "ICONINFO"!   
dragTargetOver: dragSession
        "Private - the mouse moved within the bounds of the
        receiver during a drag drop transfer."
    self isDragTarget ifFalse: [ ^nil ].
    dragSession targetSelection: self dragTargetSelection.
    self
        triggerEvent: #dragTargetOver:
        withArguments: ( Array with: dragSession )
        ifNotHandled: [ self dragTargetOverDefault: dragSession ].
    dragSession targetDrawEmphasis.
"    dragSession operation notNil ifTrue: ["
        self dragTargetSetScrollDefault: dragSession "]"!
mapVirtualKey: wordInteger mapType: mapInteger
    <api: MapVirtualKeyA ulong ulong ulongReturn>
     ^self invalidArgument!
buildSystemItem: i menu: menuNumber parent: menuBar
        "Private - Build the i'th item in the system menu indexed by
         the menuNumber of the menuBar.  Because WM_SYSCOMMAND
         reserves the right to use the first four low-order bits, the
         Second byte is shifted 4 bits.  This puts a limitation of 8 menu
         item for any given popup menu off the system menu.  However,
         There is no limitation for menu items in the system menu."
    | a item |
    item := (items at: i).
    item id: (menuNumber * 256 + (i bitShift: 4)).
    (item submenu notNil)
        ifTrue:  [(item submenu buildSystemPopupMenu: menuBar) isNil ifTrue:[^nil]].
    accel size >= i ifTrue: [
        (accel at: i) notNil ifTrue: [
            a := accel at: i.
            1 to: a size // 2 do:[:index|
                menuBar accelTable
                    at: (Array with: (a at:index * 2 - 1) with: (a at: index * 2))
                    put: (menuNumber * 256 + i)]]].
    (window insertItem: item label: item label) isNil ifTrue:[^nil].
    item id: (menuNumber * 256 + i)!
controlColor: aDeviceContext
        "Private - Set the background of the receiver."
    | brush backColor foreColor |
    ( foreColor := self foreColor ) notNil ifTrue: [
        ( GDILibrary setTextColor: aDeviceContext with: foreColor asParameter ) = 16rFFFFFFFF
            ifTrue: [ ^self osError ] ].
    ( backColor := self backColor ) isNil ifTrue: [ ^nil ].
    ( brush := WinLogicalBrush style: BsSolid color: backColor hatch: nil )
        isNil ifTrue: [ ^nil ].
    ( GDILibrary setBkColor: aDeviceContext with: backColor asParameter ) = 16rFFFFFFFF
        ifTrue: [ ^self osError ].
    ( GDILibrary setBrushOrgEx: aDeviceContext x: 0 y: 0 oldOrigin: nil )
        ifFalse: [ ^self osError ].
    ^brush!  
name
        "Private - Answer the name of the icon."
    ^name!
halfTone
        "Answer an instance of a static halftone rectangle."
    ^self new grayRectangle; yourself!
foreground
        "Answer an instance of a static foreground rectangle."
    ^self new blackRectangle; yourself!   
backgroundFrame
        "Answer an instance of a static background frame."
    ^self new whiteFrame; yourself!  
foregroundFrame
        "Answer an instance of a static foreground frame."
    ^self new blackFrame; yourself!  
halfToneFrame
        "Answer an instance of a static halftone frame."
    ^self new grayFrame; yourself!   
background
        "Answer an instance of a static background rectangle."
    ^self new whiteRect; yourself!
whiteFrame
        "Set and answer the control style for a static white frame."
	self
		removeStyle: SsBlackframe;
		removeStyle: SsBlackrect;
		removeStyle: SsWhiterect;
		removeStyle: SsGrayframe;
		removeStyle: SsGrayrect.
    ^self addStyle: SsWhiteframe!   
buildWindow: parentWindow
        "Private - Create the window for the receiver
         using parentWindow as the parent."
    | extendedStyle |
    style isNil ifTrue: [ style := self getStyle ].
    ( extendedStyle := self extendedStyle ) isNil ifTrue: [
        self extendedStyle: ( extendedStyle := self defaultExtendedStyle ) ].
    self
        create: self windowClass
        title: self initialText
        style:  style
        extendedStyle: extendedStyle
        rectangle: ( 0@0 extent: 0@0 )
        parent: self parent.
    self isHandleOk ifFalse: [ ^nil ].

    ( self class toolTipInstalled and: [ self tipText notNil ] )
        ifTrue: [ self mainWindow toolTip window: self text: self tipText ].

    self initGraphics.
    self receiveMessages.
    children size ~= 0 ifTrue: [
        self childrenInBuildOrder do: [ :each |
            ( each buildWindow: self ) isNil ifTrue: [ self close. ^nil ] ] ]!   
basicStyle
        "Private - Answer an Integer with appropriate
         constants combination for basic window style."
    ^WsOverlapped | WsClipsiblings | WsVisible!   
startUp
        "Private - register a CallBack for handling
         Print Manager print job cancellation requests"
    | callback message |
    message := Message new
        receiver: self;
        selector: #abortProc:error: ;
        yourself.
    callback := CallBack
        registerMessage: message
        parameterTypes: #( #ulong #long )
        returnType: #boolean
        callingConvention: #api.
    AbortProc := callback! 
systemMenuHandle
        "Private - answer the handle of the system menu."
    ^self
        propertyAt: #sysMenu
        ifAbsent: [
            self propertyAt: #sysMenu put: ( UserLibrary
                getSystemMenu: self asParameter
                revert: 0 ) ]!  
display
        "Private - Draw the icon"
    self minimized ifFalse: [ ^self ].
    self callDefaultProc: WmIconerasebkgnd with: self graphicsTool handle with: 0.
    self icon displayWith: self graphicsTool! 
restoreDC
        "Restore the last saved DC."
    self allHandles do: [ :h |
        ( GDILibrary restoreDC: h savedDC: -1 )
            ifFalse: [ ^self osError ] ]!   
beginDeferWindowPos: anInteger
        "Private - Defer setting window position for anInteger
         number of windows."
    <api: BeginDeferWindowPos long ulongReturn>
    ^self invalidArgument! 
resize: aRectangle deferInfo: winPosInfo
        "Private - Change the frame of the receiver pane
         to aRectangle.  Delay the drawing and collect
         the drawing information in winPosInfo."
    | posInfo |
    rectangle := self framingRectangleFor: aRectangle.
    rectangle extent: (rectangle extent max: 0@0).
    posInfo := self resizeWindow: winPosInfo.
    ^posInfo!   
itemSize
        "Answer the size of the (currently being drawn) list item."
     ^0 @ self itemHeight  "x component ignored for list items"!   
fileSpec: aFileSpec
        "Sets the initial fileName and directory of the edit control in the
         File Dialog."
    | array dir |
    array := File splitPath: aFileSpec in: DirName.
    dir := Directory pathName:
        ( String with: ( array at: 1 ) with: $: ),
        ( ( array at: 2 ) isEmpty ifTrue: [ '\' ] ifFalse: [ array at: 2 ] ).
    dir valid ifFalse: [ dir := Disk ].
    self directory: dir.
    fileName := array at: 3!  
mapClientToScreen: aWindow
        "Map the receiver from aWindow's client-area coordinates
          to screen coordinates."
    | winPoint |
    winPoint := WinPoint fromPoint: self.
    ( UserLibrary
        clientToScreen: aWindow asParameter
        point: winPoint asParameter )
            ifFalse: [ ^self osError ].
    ^winPoint asPoint.! 
insertItemInControl: item
        "Private - Insert a list item into the receiver."
	^self
		insertItemInControl: item
		at: self class listEnd!  
yield
        "Yield control to other applications"
    | hMsg lpMsg |
    ( hMsg := KernelLibrary globalAlloc: Ghnd bytes: WinMessage sizeInBytes ) = 0
        ifTrue: [ ^self osError ].
    ( lpMsg := KernelLibrary globalLock: hMsg ) = 0
        ifTrue: [ ^self osError ].
    UserLibrary peekMessage: lpMsg
        hwnd: nil
        min: 0
        max: 0
        remove: PmNoremove.
    Notifier setPeekCount: 0.
    KernelLibrary globalUnlock: hMsg.
    ( KernelLibrary globalFree: hMsg ) = 0 ifFalse: [ ^self osError ]!
fill: aRectangle rule: aRopConstant
        "Fill aRectangle in the receiver medium with foreColor
         using aRopConstant. "
    self fill: aRectangle rule: aRopConstant color: foreColor!   
dragTargetDefaultEmphasis
		"Private - answer the type of target emphasis that should be employed
		if not otherwise specified."
	^'pane'! 
reset
        "Reset the display level of the cursor back to zero."
    | level |
    Window new clearMouseCapture.
    level := self display.
    level >= 0
       ifTrue: [ level timesRepeat: [ self hide ] ]
       ifFalse: [ level abs timesRepeat: [ self display ] ].
    self class normal change!  
font: aFont
        "Set the font for the receiver to aFont."
    self fontAttribute: aFont.
    super font: aFont.
    graphicsTool notNil
        ifTrue: [ graphicsTool font: self font ].
    self isHandleOk ifTrue: [
        self invalidateRect: nil.
        self hasHorizontalScrollBarStyle
            ifTrue: [ self updateHorizontalSlider ] ]!
isDIB
        "Answer true if receiver is an instance of class
         DIB or one of its subclasses, else answer false."
    ^false!  
addMinimizeStyle
        "Add the minimize style."
    ^self addStyle: WsMinimize!  
enableUpdate
        "Enable update of the receiver window."
    UserLibrary lockWindowUpdate: nil! 
scrollTopCornerTo: aNewCorner
        "Private - Scroll topCorner to aNewCorner"
    self scrollTopCorner: self topCorner - aNewCorner + 1! 
wmChar: wordInteger with: longInteger
        "Private - Process the character input message."
    | character event leadByte wparam |
    wparam := wordInteger.
    NationalLanguage isDoubleByteCp
        ifTrue: [
            ( leadByte := self propertyAt: #lastChar ) isNil
                ifTrue: [
                    character := Character value: wordInteger.
                    character isLeadByte ifTrue: [
                        self propertyAt: #lastChar put: character.
                        ^nil ] ]
                ifFalse: [
                    character := Character leadByte: leadByte trailByte: ( Character value: wordInteger ).
                    self propertyAt: #lastChar put: nil.
                    wparam := character asInteger ] ].
    event := KeyboardInputEvent fromWmChar: wparam with: longInteger .
    self sendInputEvent: #keyboardInput: with: event.
    ( character := event character ) notNil
        ifTrue: [ self sendInputEvent: #characterInput: with: character ].
    ^nil!  
getViewportExt
        "Answer the viewport extent of the graphicsMedium
        associated with the receiver."
    | winPoint |
    ( GDILibrary
        getViewportExtEx: self handle
        extent: ( winPoint := WinPoint new ) asParameter )
            ifFalse: [ ^self osError ].
    ^winPoint asPoint! 
cleanUp
        "Private - Free chooseFontStruct."
    | printer |
    self style: self flags.
    lpLogFont free.
    chooseFontStruct contents free.
    chooseFontStruct := nil.
    ( printer := self propertyAt: #printer ) notNil
        ifTrue: [ printer release ]!  
rectangleFromUser
        "Answer a rectangle obtained from the user."
    | oldForeColor oldBackColor point1 point2 origin corner aPoint |

    oldForeColor := graphicsTool foreColor.
    oldBackColor := graphicsTool backColor.
    self setPenForTracking.

    Notifier activeMainWindow captureMouseInput.
    CursorManager crossHair changeFor: [
        Notifier consumeInputUntil: [: event |
            event selector = #button1Down:
                ifTrue: [ graphicsTool place: ( point1 := point2 := Cursor sense ) ].
            ( event selector = #button1Move: and: [ point1 notNil ] )
                ifTrue: [
                    aPoint := Cursor sense.
                    point2  ~= aPoint ifTrue: [
                        graphicsTool
                            place: point1;
                            box: point2;
                            place: point1;
                            box: aPoint.
                        point2 := aPoint ] ].
            ( event selector = #button1Up: and: [ point1 notNil ] ) ].
        graphicsTool
            place: point1;
            box: point2. ].

    graphicsTool
        foreColor: oldForeColor;
        backColor: oldBackColor.
    self resetPenFromTracking.

    UserLibrary releaseCapture ifFalse: [ ^self osError ].
    origin := ( point1 x min: point2 x ) @ ( point1 y min: point2 y ).
    corner := ( point1 x max: point2 x ) @ ( point1 y max: point2 y ).
    ^origin corner: corner!
resizeWindow: winPosInfo
        "Private - Change the size of the window
         for the receiver."
    | posInfo |
    posInfo := self handle setWindowPos: nil
        rectangle: rectangle
        fs: SwpNozorder
        deferInfo: winPosInfo.
    ^posInfo!  
addMaximizeButtonStyle
        "Add the maximize button style."
    ^self addStyle: WsMaximizebox!  
display: aRectangle
        "Display the text contained in aRectangle."
    | sourceY dest lastY sourceX minY font |
    charScanner := lastChild pen.
    font := charScanner font.
    sourceX := aRectangle origin x.
    sourceY := aRectangle origin y.
    lastY := aRectangle corner y.
    dest :=
        (frame leftTop x left: (lastChild topCorner x - 1 * font width))  @
             ((frame leftTop y
                 down: font basePoint y)
                    down:  (sourceY - lastChild  topCorner y * font height)) .

    lines size >= sourceY ifTrue: [
        (sourceY = lastY) ifTrue: [ "single line"
            lastChild doGraphics: [charScanner
                align: (lines at: sourceY)
                at: dest
                showFrom: sourceX].
            ^self].
        "display first line for multi lines"
            lastChild doGraphics: [charScanner
                align: (lines at: sourceY)
                at: dest
                showFrom: 1 "sourceX"]].
    lastChild doGraphics: [
    minY := lastY min: lines size.
    sourceY + 1 to: minY do: [ :i |
        dest y: (dest y down: font height).
        charScanner
            lineDisplay: (lines at: i)
            at: dest].
    minY < lastY
        ifTrue: [
            minY := minY max: sourceY - 1. "for case sourceY > minY"
            charScanner
                blankRestFrom:
                    (frame leftTop y
                        down:
                            (minY - lastChild topCorner y + 1 * font
height))]]! 
title: aString
        "Set the receiver's title to aString."
    title := self fixUnderScoreChar: aString! 
multiColumn
        "Add the multi-column style."
    ^self addStyle: LbsMulticolumn!   
measureControl: aMeasureItemStruct
        "Private - Set the height of an owner-drawn
         menu item."
    | aPoint |
    self ownerDrawStruct: aMeasureItemStruct.
    self triggerEvent: #measureItem:
        withArguments: ( Array with: self drawIndex )
        ifNotHandled: [ self defaultMeasureControl: aMeasureItemStruct ].
    self ownerDrawStruct: nil.
    ( aPoint := self itemSize ) notNil ifTrue: [
        aMeasureItemStruct itemHeight: aPoint y ].
    ^nil! 
showCursor: aBoolean
        "Private - Display the receiver on the screen
         if aBoolean is true else hide it; answer 
         the hide/show level of the cursor."
    ^UserLibrary showCursor: aBoolean! 
processInput
        "Make the receiver modal to its owner window.
         This method doesn't return until close has been
         sent to the receiver."
    | userIF |
    Processor currentProcessIsRecursive
        ifTrue: [ self error: 'Cannot do modal dialog during recursion.' ].
    Window new clearMouseCapture.
    owner isWindow ifTrue: [ owner disable ].
    CursorManager normal changeFor: [
        userIF := UserInterfaceProcess.
        sem := Semaphore new.
        [ CurrentProcess makeUserIF. Notifier run ] fork.
        sem notNil ifTrue: [ sem wait ].  "diag may be closed before getting here"
        userIF makeUserIF ]!
dragTargetEraseSeparatorEmphasis
		"Private - erase the previously drawn separator emphasis."
	| lastIndex rect |
	lastIndex := self dragTargetSelection.
	rect := self lineToRect: lastIndex.
	self dragTargetDrawEmphasisLineFrom: rect leftTop to: rect rightTop! 
copyItemAttributes: item from: aMenu
        "Private - Copy the 'checked' and 'disabled' attributes
         to the receiver item from the corresponding item
         in aMenu."
    | miSelf miAMenu |
    miAMenu := aMenu getMenuItem: item.
    miSelf := self getMenuItem: item.
    miSelf hasSubmenu
        ifTrue: [ ^miSelf submenu copyAttributesFrom: miAMenu submenu ].
    miSelf attribute: miAMenu attribute.
    self updateItem: miSelf attributes: MfChecked | MfGrayed!   
defExtension: aDefExtension
        "Specifies the default extension of File dialog."
    self propertyAt: #defExtension put: aDefExtension.!   
clearTextSelection
        "Clear the entry field selection from the control;
         can't use #clearSelection, because that is
         defined differently in ListBox"
     UserLibrary
        sendMessage: handle
        msg: WmClear
        wparam: 0
        lparam: 0! 
setCursor: aHandle
    <api: SetCursor ulong ulongReturn>
    ^self invalidArgument!
roundRect: aRectangle corner: aPoint
        "Private - Call GDI RoundRect function."
    self allHandles do: [ :h |
        ( GDILibrary
            roundRect: h
            x1: aRectangle origin x
            y1: aRectangle origin y
            x2: aRectangle corner x
            y2: aRectangle corner y
            x3: aPoint x
            y3: aPoint y )
                ifFalse: [ ^self osError ] ]!   
polygon: lInteger sides: sInteger
        "Draw a polygon with sInteger number of
         sides where each is of length lInteger."
    sInteger timesRepeat: [
        self
            go: lInteger;
            turn: 360 // sInteger]!  
callDefHookProc: nCode wparam: wparam lparam: lparam
        "Private - call the DefHookProc for messages that are not of
         interest to the message filter"
    ^UserLibrary
        callNextHookEx: NextMessageFilterProc asParameter
        action: nCode
        wparam: wparam
        lparam: lparam! 
fromString: aString
        "Answer a Windows Atom for the given String."
    | anInteger |
    ( anInteger := KernelLibrary globalAddAtom: aString asParameter ) = 0
        ifTrue: [ ^self osError ].
    ^self fromInteger: anInteger!   
generateJump: dword in: aCallbackAddress startingAt: index
        "Private - create the machine code instructions for jumping
         to the specified address (dword) in the specified callback
         address, starting at the specified index"
    | aLong |
    aLong := ExternalLong fromInteger: dword.
        "JMP"
    aCallbackAddress at: index put: 16rEA.       
    aCallbackAddress at: index + 1 put: ( aLong byteAtOffset: 0 ).
    aCallbackAddress at: index + 2 put: ( aLong byteAtOffset: 1 ).
    aCallbackAddress at: index + 3 put: ( aLong byteAtOffset: 2 ).
    aCallbackAddress at: index + 4 put: ( aLong byteAtOffset: 3 )!  
generateCallBackPrologIn: flatCallbackAddress
        "Private - create the machine code instructions for the
        prolog to a CallBack16 entry starting at anAddress."
    | handle ccId wmNum |
    handle := SystemWindow current handle asInteger.
    ccId := self class callingConventions at: ccType.
    wmNum := SystemWindow wmStcallback.

    self
        generatePushWord: handle in: flatCallbackAddress startingAt: 1;
        generatePushWord: slotNumber + CallBack maxNumCallBack in: flatCallbackAddress startingAt: 4;  "16-bit callbacks slots beyond end of 32-bit callbacks."
        generatePushWord: ccId in: flatCallbackAddress startingAt: 7;
        generatePushWord: self argsSize in: flatCallbackAddress startingAt: 10;
        generatePushWord: wmNum in: flatCallbackAddress startingAt: 13;
        generateJump: self class lpfnSTCallBack asInteger in: flatCallbackAddress startingAt: 16!   
allocateSlot: anInteger
        "Private - allocate host memory for the callback entry prologue."
    ^ExternalSegmentedAddress
        fromInteger: ( self class lpDataCallBackEntry + ( ( slotNumber - 1 ) * self class slotSize ) )!
release
        "Release the receiver object."
    KernelLibrary16 freeProcInstance: lpfnInstanceProc asParameter.
    self class callBackTable at: slotNumber put: nil!   
generatePushWord: word in: aCallbackAddress startingAt: index
        "Private - create the machine code instructions for pushing
         the specified word argument onto the stack in
         the specified callback address, starting at the specified index"
    "PUSH"
    aCallbackAddress at: index put: 16r68.       
    aCallbackAddress at: index + 1 put: ( word \\ 256 ).  "low byte"
    aCallbackAddress at: index + 2 put: ( word // 256 )  "high byte"! 
performWithArgs: argsStruct
        "Private - Perform the Smalltalk mesage associated with
        the receiver using argsStruct."
    | argsArray offset value sizeSelector |
    argsArray := Array new: typeArray size.
    offset := 0.
    ccType = #c
        ifTrue: [
            1 to: typeArray size do: [ :index |
                sizeSelector := self class atSelectors at: ( typeArray at: index ).
                value := argsStruct perform: ( sizeSelector at: 2 ) with:offset.
                argsArray at: index put: value.
                offset := offset + ( sizeSelector at: 1 ) ] ]
        ifFalse: [  "#pascal or #api"
            typeArray size to: 1 by: -1 do: [ :index |
                sizeSelector := self class atSelectors at: ( typeArray at: index ).
                value := argsStruct perform: ( sizeSelector at: 2 ) with:offset.
                argsArray at: index put: value.
                offset := offset + ( sizeSelector at: 1 ) ] ].

    stMessage arguments: argsArray.
    ^stMessage perform.! 
registerMessage: aSTMessage
    parameterTypes: aParameterTypeArray
    returnType: aReturnType
    callingConvention: aCCType
        "Private - Answer an instance of CallBack object for stMessage
         of ccType calling convention.  Currently, returnType is not
         needed.  Currently, CallBack object returns a double word
         to the caller.  The caller can then choose to either assume
         the return type is a word or double word."
    | emptySlot aCallbackAddress flatCallbackAddress |
    emptySlot := self class findEmptySlot.
    slotNumber := emptySlot.
    stMessage := aSTMessage.
    typeArray := aParameterTypeArray.
    ccType :=  aCCType.
    [ self class callBackTable at: emptySlot put: self ] evaluateWithoutInterrupts.
    returnType := aReturnType.

    aCallbackAddress := self allocateSlot: slotNumber.
    flatCallbackAddress := aCallbackAddress asFlatAddress.
    self generateCallBackPrologIn: flatCallbackAddress.
    lpfnInstanceProc := self class lpCodeCallBackEntry + ( ( slotNumber - 1 ) * self class slotSize ).
    flatCallbackAddress releaseFlatAddress.
    ^self!   
open
        "Private - open the receiver window."
    self label: 'SmalltalkSystem'.
    ^super open! 
makeActive
        "Private - Make the receiver window become the active window."
    UserLibrary setActiveWindow: self!
isControlPane
        "Answer whether the receiver is a kind of ControlPane."
    ^false!   
validate
        "Private - The host window for the receiver was
         just created or recreated."
    super validate.
    ( self hasActionForEvent: #changed: )
        ifTrue: [ self previousValue: self value ]!  
handlesEvent: eventName
        "Private - Answer whether the receiver handles the event
        named <eventName>.  Check old event system handlers.
        Retained for compatibility."
    | oldHandlers |
    ( oldHandlers := self handlersOrNil ) isNil ifTrue: [ ^false ].
    ^oldHandlers includesKey: eventName asSymbol!
setModifiedPrivate
        "Private - set the modified state of the host control.
        Assumes 'handle = NullHandle' is false."
    ^( UserLibrary
        sendMessageInt: handle
        msg: EmSetmodify
        wparam: modified asParameter
        lparam: 0 ) ~= 0!   
container
        "Answer the OLE Container of the receiver."

    ^self propertyAt: #container!   
button2Up: aPoint
        "Private - Trigger the right click event."
    parent triggerEvent: #rightClicked!
eventsTriggered
        "Answer all the events which can be triggered
        by instances of the receiver."
    ^Set new
        addAll: #( #drawItem: #drawFocus: #drawSelection: #measureItem: );
        yourself!   
invertedValueOutOf: aPane
    "Set the receiver's value to the inverse of contents of <aPane>."

    self setValue: aPane contents not!
invertedValueInto: aPane
    "Set the contents of <aPane> to the inverse of receiver's value."

    aPane contents: self invertedValue!
initialize
    "Private"

    self value: true!
invertedValue
    "Answer the inverse of the receiver's value."

    ^self value not!  
invertedValue: aBoolean
    "Set the receiver's value to the inverse of aBoolean."

    self setValue: aBoolean not!   
setMessageQueue: anInteger
        " Private - set the message queue size to <anInteger>. "
    <api: SetMessageQueue ulong boolean>
    ^self invalidArgument!
appendMenu: aMenuHandle
    flags: anInteger
    id: idInteger
    contentsInt: aBitmapHandle
        "Private - Perform the Win AppendMenu function.  This
         api call only handles bitmap handles."
    <api: AppendMenuA ulong ulong ulong ulong boolean>
    ^self invalidArgument!  
isWindowVisible: aWindowHandle
    <api: IsWindowVisible ulong boolean>
    ^self invalidArgument!  
wmKeydown: wordInteger with: longInteger
        "Private - Process the key down message.  WM_KEYDOWN is generated when
        a key is pressed while the ALT key IS NOT DOWN."
    | event |
	( event := KeyboardInputEvent fromWmKeydown: wordInteger with: longInteger ) isNil ifTrue: [ ^nil ].
	self sendInputEvent: #keyboardInput: with: event.
    ^nil!   
name
        "Answer the receiver's name."
    name isNil ifTrue: [ name := self class defaultPrinterName ].
    ^name!
lineToRect: anInteger
        "Private - Answer a Rectangle that surrounds the
         item in the list indexed by anInteger."
    ^0 @ ( rectangle height - ( rectangle height - ( anInteger - topCorner y * self font  height ) ) )
        extent: rectangle width @ self font height!
addVerticalScrollbarStyle
        "Add the vertical scrollbar style to the receiver."
    ^self addStyle: WsVscroll!
deleteAllSegments
        "Delete all graphics segments."
    segmentIsOpen ifTrue: [self closeSegment].
    segments do: [: segment |
        segment release].
    segments := Dictionary new.
    currentId := 0!
wrap: aBoolean
        "Set the wordwrap property of the receiver to aBoolean."
    wrap = aBoolean ifTrue: [ ^self ].  "no change."
    wrap := aBoolean.
    self isHandleOk ifTrue: [
        self getText.
        self getSelection.
        aBoolean
            ifTrue: [ self enableWordWrapFlags ]
            ifFalse: [ self disableWordWrapFlags ].
        self recreateWindow.
        self setSelection ]!  
printPage: pageIndex in: aRectangle lines: lines linesPerPage: linesPerPage
        "Private - print page # pageIndex from lines, assuming
        the given number of linesPerPage."
    | firstLine lastLine |
    firstLine := ( pageIndex - 1 ) * linesPerPage + 1.
    lastLine := ( firstLine + linesPerPage - 1 ) min: lines size.
    self pen displayLines: lines from: firstLine to: lastLine in: aRectangle! 
bell
        "Beep the speaker"
    ( UserLibrary messageBeep: -1 )
        ifFalse: [ ^self osError ]!
dragTargetNoScrollRectangle
		"Private - answer the inset rectangle within the receiver window
		outside of which drag scrolling will commence."
    ^self drawingRectangle insetBy: self class dragTargetScrollInset! 
frameRectangle
        "Answer the receiver's frame area
         as a rectangle."
    | rectStruct |
    rectStruct := WinRectangle new.
    ( UserLibrary
        getWindowRect: self asParameter
        rectangle: rectStruct asParameter )
            ifFalse: [ ^self osError ].
    ^rectStruct asRectangle! 
dragTargetDrawEmphasisRectangle: aRectangle
		"Private - draw an emphasis rectangle at the given location."
	| region |
	self doGraphics: [
		region := self pen setClipRect: self drawingRectangle.
		self pen
			setForegroundMode: MixRuleNotXor;
			setLineType: LineTypeDot;
			rectangle: aRectangle;
			setForegroundMode: MixRuleDefault;
			setLineType: LineTypeDefault;
			destroyRegion: region ]! 
insertMessage
        "Private - Answer the host message for inserting an item."
    ^CbInsertstring!   
queryCapture
        "Answer the window handle which
         has mouse input captured."
    ^self fromInteger: UserLibrary getCapture!
indexOfWholeChar: string at: widthInteger
        "Private - Answer the index of the character in
        string that covers the widthInteger."
    ( font notNil and: [ deviceContext notNil ] )
        ifTrue: [
            ^font
                indexOfWholeChar: string
                at: widthInteger
                withDC: deviceContext ]!  
redraw
        "Redraw the entire screen."
    UserLibrary
        invalidateRect: nil
        rectangle: nil
        erase: true!   
realInvalidateRect: aRectangle
        "Invalidate aRectangle in the receiver.  Causes the
         window to be repainted."
    UserLibrary
        redrawWindow: self asParameter
        rectangle: aRectangle asParameter
        region: nil
        redraw: RdwInvalidate | RdwAllchildren | RdwUpdatenow!   
toolTipInstalled
        "Answer whether ToolTip is installed."
    ^ServiceRegistry globalRegistry hasServiceNamed: #ToolTip!  
drawFocusRect: hDC rectangle: aRectangle
    <api: DrawFocusRect ulong struct boolean>
    ^self invalidArgument!   
defaultExtendedStyle
        "Private - answer the default extended style flags for the
        receiver.  Add the 3d border style."
    ^OperatingSystem versionMajor >= 4 ifTrue: [ WsExClientedge ] ifFalse: [ 0 ]! 
getWindowTextLength: aWindowHandle
    <api: GetWindowTextLengthA ulong long>
    ^self invalidArgument!
mayUndo
        "Answer true if last edit operation may be undone."
    | result |
    self isHandleOk ifTrue: [
        result := UserLibrary
            sendMessageInt: handle
            msg: EmCanundo
            wparam: 0
            lparam: 0.
        ^result ~= 0 ].
    ^false!   
runPeek
        "Private - If there is no message waiting on the system
         event queue, execute deferred events."
    [ self peek: false ] whileFalse: [
        ( DeferredRequests isEmpty and: [ CurrentEvents isEmpty ] )
            ifTrue: [ OSEventSemaphore wait ]
            ifFalse: [ self runPendingEvents ] ]!  
enableWindow: aWindowHandle enable: aBoolean
    <api: EnableWindow ulong boolean boolean>
    ^self invalidArgument!   
fontHandle
        "Answer a valid font handle. "
    ( handle isNil )
        ifTrue: [ self makeFont ].
    ^handle!
wmSyschar: wordInteger with: longInteger
        "Received a system menu key.  Check if we should process
        it as a mnemonic."
    ( self altDownInWmChar: wordInteger with: longInteger )
        ifTrue: [ ^1 ].
    ^nil    "Must be nil, or menus won't get the menu accelerator."!
dragSourceCutDefault: dragSession
		"Private - handle the source cut by removing the selection
		from the receiver."
    self cutSelection!
getCapture
   <api: GetCapture ulongReturn>
    ^self invalidArgument!  
getTopIndex
        "Answer the index of the first visible item."
    | result |
    self isHandleOk ifFalse: [ ^nil ].
    result := UserLibrary
        sendMessageInt: handle
        msg: LbGettopindex
        wparam: 0
        lparam: 0.
    ^result + 1!
appendItem: anObject
    selector: aSelector
    accelKey: aCharacter
    accelBits: afBits
        "Append an item with label aLabelString and
         selector aSelector and accelerator described
         by aCharacter and afBits to the receiver menu.
         aCharacter is the asciiValue of the accelerator key.
         afBits is one or more of the following from the
         VirtualKeyConstants pool dictionary:
            AfAlt, AfChar, AfControl, AfHelp, AfLonekey, AfShift
            AfSyscommand, AfVirtualkey."
    self
        insertItem: ( self fixUnderScoreChar: anObject )
        selector: aSelector
        accelKey: aCharacter
        accelBits: afBits
        after: nil!
fixUnderScoreChar: aString
        "Private - Replace the AuxUnderScoreChar with
         the UnderScoreChar."
    | i string |
    aString isString ifFalse: [ ^aString ].
    i := aString indexOf: AuxUnderScoreChar.
    i = 0
        ifTrue: [^aString]
        ifFalse: [
            string := aString copy.
            string at: i put: UnderScoreChar.
            ^string]!   
scrollTopCornerTo: aNewCorner
        "Private - Scroll the top left corner
         of the pane to aNewCorner.
         Display the contents of the new area."
    | oldCorner height aSelection |
    selection hideGap.
    oldCorner := topCorner.
    topCorner := (1 max: aNewCorner x) @
        (1 max: (aNewCorner y min:
        textHolder extent y)).
    oldCorner = topCorner ifTrue: [^self].
    textHolder topCorner: topCorner.
    "copy the area that's not going to change"
    self doGraphics: [
        ((oldCorner y - topCorner y) * self font height) abs <= rectangle height
            ifTrue: [graphicsTool
                selfCopyToX:
                    (rectangle leftTop  x right: (oldCorner x - topCorner x) * self font width)
                Y:
                      (rectangle leftTop y down: (oldCorner y - topCorner y * self font height))].
    " figure out gap area after copying "
    height := oldCorner y - topCorner y.
    height > 0
        ifTrue: [ "scroll up"
            aSelection :=
                self selectLines: topCorner y
                     height: height - 1]
        ifFalse: [ "scroll down"
            aSelection :=
                self selectLines: oldCorner y
                        + self charsInColumn
                    height: 0 - height].
    changedArea := aSelection.
    self displayChangesForCharInput.
    selection displayPatch: aSelection.
    selection displayGap].!  
archive
        "Private - answer the archive bits."
    ^archive!  
clearFontHandle
        "Private - Invalidate  the font handle.
        Called during startup."
    handle := nil.
    graphicsMedium := Display! 
translateAccelerator: hWnd accelTable: hAccel msg: msg
    <api: TranslateAccelerator ulong ulong ulong boolean>
    ^self invalidArgument! 
createCursor: hInstance
         xHotSpot: hotSpotX
         yHotSpot: hotSpotY
         width: width
         height: height
         andBits: andBits
         xorBits: xorBit
    <api: CreateCursor ulong long long long long struct struct ulongReturn>
    ^self invalidArgument!   
wmSize: wordInteger with: longInteger
        "Private - Process the window resizing message."
    | extent |
    extent := ( WinPoint fromInteger: longInteger ) asPoint.
    ( extent x = 0 or: [ extent y = 0 ] )
        ifFalse: [ self sizeChanged: extent ].
    ^nil!   
fromDC: hDC
        "Private - Answer a Printer object given an hDC"
    | aPrinter |
    hDC = 0 ifTrue: [ ^self error: 'Error while opening printer.' ].
    aPrinter := self new.
    aPrinter deviceContext: hDC.
    aPrinter getGraphicsTool;
        initExtent.
    ^aPrinter!
helpManager
        "Answer the receiver's HelpManager instance,
        or nil if none."
    | ownerWindow |
    ( self propertyAt: #helpManager ) notNil
        ifTrue: [ ^super helpManager ].
    ownerWindow := parent.
    ownerWindow isNil ifTrue: [ ^nil ].
    ownerWindow mainWindow isApplicationWindow
        ifTrue: [ ^ownerWindow mainWindow helpManager ].
    ^nil! 
getPicture
        "Get a StoredPicture from the clipboard; answer the instance
        of StoredPicture, or nil if none available."
    | hMem lpMetafile metafilePict storedPicture header |
    self open ifFalse: [ self close. ^nil ].
    ( self containsFormat: CfMetafilepict )
        ifFalse: [ self close. ^nil ].
    ( hMem := UserLibrary getClipboardData: CfMetafilepict ) = 0 ifTrue: [
        self osWarning.
        self close.
        ^nil ].
    ( lpMetafile := KernelLibrary globalLock: hMem ) = 0
        ifTrue: [ ^self osError ].
    lpMetafile := ExternalGlobalAddress fromInteger: lpMetafile.
    metafilePict := WinMetafilepict new.
    metafilePict fillFromAddress: lpMetafile.
    storedPicture := StoredPicture new.
    storedPicture handle: metafilePict hMF.
    header := WinMetafileheader new.
    ( metafilePict xExt = 0 or: [ metafilePict yExt = 0 ] )
        ifTrue: [ header bbox: ( 0@0 extent: Display boundingBox extent * 1000 ) ]
        ifFalse: [ header bbox: ( 0@0 extent: metafilePict xExt @ metafilePict yExt ) ].
    header inch: 1000.
    storedPicture apmHeader: header.
    KernelLibrary globalUnlock: hMem.
    self close.
    ^storedPicture!
sizeInBytes
         "Private - Answer the default size in bytes."
    ^44! 
length
    ^self uLongAtOffset: 0!   
ptMaxPosition
	^WinPoint usingBytes: ( self bytesAtOffset: 20 count: WinPoint sizeInBytes )! 
ptMinPosition
	^WinPoint usingBytes: ( self bytesAtOffset: 12 count: WinPoint sizeInBytes )! 
showCmd
    ^self uLongAtOffset: 8!  
rcNormalPosition
    ^WinRectangle usingBytes: ( self bytesAtOffset: 28 count: WinRectangle sizeInBytes )!   
flags
    ^self uLongAtOffset: 4!
dragTargetScrollDelay
        "Private - answer ms delay before drag scrolling starts."
    ^60!
readOnly: aBoolean
        "Private - Set the receiver's readOnly flag"
    readOnly := aBoolean!   
isButton
        " Answer whether the receiver is a button. "
    ^false!   
insertItem: aMenuItem label: stringOrBitmap
        "Insert aMenuItem as a menu item in the receiver."
    | id answer miFlags |
    miFlags := aMenuItem style | aMenuItem attribute.
    id := aMenuItem submenu isNil
        ifTrue:  [ aMenuItem id ]
        ifFalse: [ aMenuItem submenu window handle ].
    aMenuItem position isNil
        ifTrue: [
            answer := UserLibrary
                appendMenu: handle
                flags: miFlags
                id: id
                contents: stringOrBitmap asParameter ]
        ifFalse: [
            answer := UserLibrary
                insertMenu: handle
                position: aMenuItem position
                flags: ( miFlags + MfByposition )
                id: id
                contents: stringOrBitmap asParameter ].

    aMenuItem label: stringOrBitmap.
    answer ifFalse: [
        self osWarning.
        ^nil ]!  
current
        "Answer the current single instance of the receiver class."
    ^SmalltalkSystemWindow! 
current: aSystemWindow
        "Private - set the current single instance of the receiver class."
    SmalltalkSystemWindow := aSystemWindow!   
exit
        "Private - shut down the class."
    self current close!   
physicalFontAttribute: aPhysicalFontStructure
        "Private - Set the physical font structure for the receiver."
    physicalFont := aPhysicalFontStructure! 
isATabStop
        "Private - Answer true if the receiver is a tabstop"
    ^self hasStyle: WsTabstop!  
findRealWindow: hWnd
        "Private - Answer the Smalltalk Window
         identified by hWnd: if hWnd is the entry field of
         a comboBox, answer the comboBox."
    | theParent |
    theParent := self findWindow: ( UserLibrary getParent: hWnd asInteger ).
    ^( theParent isComboBox or: [ theParent isDropDownList ] )
        ifTrue: [ theParent ]
        ifFalse: [ self findWindow: hWnd ]! 
button1Up: aPoint
        "Private - The user let up on button1."
    super button1Up: aPoint.
    handle = WindowHandle queryCapture ifFalse: [ ^self ].
    self stopTimer: self class leftButtonScrollTimerId.
    self clearMouseCapture.
    self
        displayChanges;
        showSelection.!
entryFieldBackground
        "Answer default entry field background color.  Note that
        the Win32 platform does not distinguish entry field background
        color, so we emulate it using the window background color."
    ^self getSystemColor: ColorWindow!   
runPendingEvents
        "Private - Execute all the CurrentEvents and
        one of the DeferredRequests if any."
    | req |
    ( CurrentEvents isEmpty and: [ DeferredRequests notEmpty ] ) ifTrue: [
        [ req := DeferredRequests removeFirst ] evaluateWithoutInterrupts.
        req  perform ].
    self empty!   
fromHandle: handle
        "Answer a new instance of an appropriate subclass of
         ControlPane, for the host control window with the
         given handle"
    | winClassName style class control |
    winClassName := String new: 256.
    ( UserLibrary getClassName: handle
        buffer: winClassName
        bufSize: winClassName size ) = 0
            ifTrue: [ ^self osError ].
    winClassName := winClassName trimNullTerminator asNormalizedString.
    style := UserLibrary getWindowLong: handle index: GwlStyle.
    style := ( ExternalLong fromString: style ) asInteger.
    class := self winClassMap at: winClassName ifAbsent: [ self ].
    control := ( class fromHandle: handle style: style ).
    control
        style: style;
        "receiveMessages;"
        initGraphics.
    ^control!   
createIcon: hInstance
        width: x
        height: y
        planes: planes
        bitsPixel: bitCount
        andBits: andMaskBits
        xorBits: xorMaskBits
    <api: CreateIcon ulong long long ushort ushort struct struct ulongReturn>
    ^self invalidArgument!
scrollVertical: anInteger highlight: line
        "Private - Scroll the pane up by anInteger
         number of pixels (if positive) or down by
         the absolute value of anInteger (if negative)
         and highlight line"
    | oldCorner newCorner height locY theFont |

    theFont := self font.
    oldCorner := topCorner y.
    newCorner := 1 max: (topCorner y -
        (anInteger // theFont  height)
            min: list size).

    oldCorner = newCorner
        ifFalse: [self doGraphics: [
            "hide selection"
            topCorner y: newCorner.
            "copy the area that's not going to change"
            height := oldCorner - newCorner.
            graphicsTool
                selfCopyToX: 0
                Y: height * theFont height.
            " figure out gap area after copying "
            height > 0
                ifTrue: [ "scroll down"
                    oldCorner := newCorner.
                    locY := 0 - theFont height.
                    height := height * theFont height.
                ]
                ifFalse: [ "scroll up"
                    oldCorner := (oldCorner + self charsInColumn).
                    locY := oldCorner - newCorner - 1 * theFont height.
                    height := rectangle height - locY.
                ].
            self
                refreshFrom: topCorner x @ oldCorner
                for: height
                atX: 0
                Y: locY.
            line isNil ifTrue: [ ^self ].
            (oldCorner <= line and: [line <= (oldCorner + (height - 1 // theFont height))])
            ifTrue: [self boldLine: line]]]!  
updateHorizontalSlider
        "Private - Update the slider box in the horizontal scrollBar."
    | position totalWidth |
    totalWidth := self totalWidth.
    totalWidth = 0
        ifTrue: [position := 0]
        ifFalse: [position := ((self topCorner x - 1 * 100) // (totalWidth max: 1))].
    position = 0
        ifTrue: [self topCorner x = 1
            ifTrue: [position := 0]].
    (self topCorner x = totalWidth and: [totalWidth > 1])
        ifTrue: [position := 100].

    self updateHorizontalSliderTo: position.!   
wmCtlcolor: wparam with: lparam
        "Private - Process set control color message."
    ^self controlColor: lparam hDC: wparam!  
computedBy: layoutBlock
    "Answer an instance of the receiver that compute relative rectangles by evaluating the <layoutBlock> with the enclosing rectangle as its argument."

    ^self new block: layoutBlock! 
mandala: sInteger diameter: dInteger initDir: degreesInteger
        "Draw a one color mandala with sInteger number
        of sides and dInteger as the diameter and
        degreesInteger as the initial direction."
    | vertices radius center angle |
    center := self location.
    vertices := Array new: sInteger.
    radius := dInteger // 2.
    angle := 360 // sInteger.
    self direction: degreesInteger.
    self up.
    1 to: sInteger do: [ :i |
        vertices at: i put: (self place: center; go: radius).
        self turn: angle].
    self down.
    1 to: sInteger - 1 do: [ :j |
        j + 1 to: sInteger do: [ :i |
            self
                place: (vertices at: j);
                goto: (vertices at: i)]]!   
fromFileStreamOS2: fileStream
        "Private - Answer an instance of Icon read from aFileStream.
         The icon stored in fileStream is an OS/2 icon."
    | bitmap bitmapInfo clrBitmapInfo bits colorBits  |
    bitmapInfo := Bitmap readBitmapInfo: fileStream.
    fileStream skip: 14.    "Skip color bitmap file header."
    clrBitmapInfo := Bitmap readBitmapInfo: fileStream.
    bits := ByteArray new: (((bitmapInfo bitCount * bitmapInfo width) + 31) // 32) *
        4 * bitmapInfo height * bitmapInfo planes.
    fileStream getBytesFor: bits.

    bitmap := Bitmap new.
    bitmap bitmapInfo: bitmapInfo.
    bitmap deviceContext: Bitmap memoryContext;
        graphicsTool: (
            Pen forDC: Bitmap memoryContext medium: bitmap).
    bitmap createBitmap: bits.

    "Read color bitmap bits"
    colorBits := ByteArray new: (((clrBitmapInfo bitCount * clrBitmapInfo width) + 31) // 32) *
        4 * clrBitmapInfo height * clrBitmapInfo planes.
    fileStream getBytesFor: colorBits.

    "Create XOR mask from color bits."
    xorMask := Bitmap new.
    xorMask bitmapInfo: clrBitmapInfo.
    xorMask
        deviceContext: (Bitmap memoryContext);
        graphicsTool: (
            Pen forDC: Bitmap memoryContext medium: xorMask).
    xorMask createBitmap: colorBits.

    "Create AND mask from bitmap."
    andMask := Bitmap width: bitmap width height: bitmap height // 2.
    andMask pen                                             "only copy AND mask portion."
        copyBitmap: bitmap
        from: (0 @ 0 extent: (
                bitmap width @ (bitmap height // 2)))
        at: 0 @ 0.

    bitmap release!   
isLocalDragTarget
        "Answer whether the receiver is enabled as a local drag drop target."
    ^self isDragTarget and: [
        self dragSessionClass isNil or: [
            self dragSessionClass isLocalDragDropSession ]]!  
drawFocus: aDrawStruct
        "Private - Draw focus on the item."
    self triggerEvent: #drawFocus
        ifNotHandled: [ super drawFocus: aDrawStruct ]!   
canApplyStyle
        "Private - answer whether the receiver's style can change
        after it has been created."
    ^true! 
getWindowText: aWindowHandle text: aString maxLength: anInteger
    <api: GetWindowTextA ulong struct long long>
    ^self invalidArgument! 
freeProcInstance: lpProc
    <api: FreeProcInstance ulong none>
    ^self invalidArgument!  
button1Move: aPoint
        "Private - Button 1 is down and the
        mouse has been moved. Highlight
        the line covering aPoint."
    | sourceLocation |
    "check for drag initiation."
    ( self isDragSource and: [ self dragOnMove ] ) ifTrue: [
        ( self isDragSourceInitiation: aPoint ) ifTrue: [
            "commit the current selection before drag clients are notified."
            self selectCurrentLine.
            self triggerEvent: #clicked: with: self selectedItem.
            self event: #select.
            "start the drag transfer."
            sourceLocation := self dragSourceLocation.
            self dragOnMove: nil location: nil.
            ( self doDragDropAt: sourceLocation button: 1 ) ifTrue: [ ^self ] ].
        ^self ].

    "ignore event if we're capturing mouse input."
    handle = WindowHandle queryCapture ifFalse: [ ^self ].

    "if not a drag initiation, process selection normally."
    self highlightCursorLine: aPoint.
    self updateVerticalSlider! 
idleLoopGui
        "Private - Loop forever, because no other process wants to run."
    [ true ] whileTrue: [
        UserLibrary waitMessage ifFalse: [ ^self osError ].
        OSEventSemaphore signal ]! 
setSelection
        "Private - set the selection in the listbox control
        to correspond to value.  Assumes 'handle = NullHandle'
        is false."
    | valueCopy valueArray stream run runs |
    valueCopy := value.
    self clearSelections.
    valueCopy isNil ifTrue: [ ^self ].

    "for performance in selecting a large number of items, break the selection
    into 'runs' of consecutive indices, and notify the host control for each run."

    valueArray := valueCopy asSortedCollection asArray.
    stream := ReadStream on: valueArray.
    runs := OrderedCollection new.
    [ stream atEnd ] whileFalse: [
        run := OrderedCollection new.
        run add: stream next.
        [ stream peek = ( run last + 1 ) ] whileTrue: [
            run add: stream next ].
        runs add: run asArray ].

    runs do: [ :nextRun |
        UserLibrary
            sendMessage: handle
            msg: LbSelitemrange
            wparam: true asParameter
            lparam: ( ExternalLong lowHalf: nextRun first - 1 highHalf: nextRun last - 1 ) asInteger ]!   
dragTargetDropDefault: dragSession
        "Private - provide default handling of drop if no handler
        is provided by inserting the item into the list."
    | dragObject string dragFormats format position top |
    dragObject := dragSession objects first.
    ( dragFormats := self dragTargetFormats ) isNil
        ifTrue: [ ^self error: 'dragTargetFormats: must be specified' ].
    format := dragFormats detect: [ :s | dragObject hasFormat: s ] ifNone: [ ^nil ].
    ( self dragTargetOperations includes: dragSession operation ) ifFalse: [ ^nil ].

    string := dragObject format: format.

    string isString 
        ifTrue: [ "treat multiple lines of text as multiple list items"
            string := ( string asArrayOfSubstringsSeparatedBy: 10 asCharacter ) collect: [ :s | s trimBlanks ].
            string := string reject: [ :s | s isEmpty ] ]
        ifFalse: [ string := Array with: string ].

    top := self getTopIndex.
    position := self itemIndexFromPoint: dragSession targetLocation.
    ( dragSession source == self and: [ position < self dragSourceSelection ] )
        ifTrue: [ "backward drag internally" self dragSourceSelection: self dragSourceSelection + 1 ].
    ( position > self list size )  "beyond end of list"
        ifTrue: [ position := self list size + 1 ].
    string reverseDo: [ :s | self insertItem: s at: position ].
    self setTopIndex: top.
    self selectIndex: position!  
noWarning
        "Disables warning if no default printer selected."
    self style: ( self style | PdNowarning )!  
drawUsing: aRecordingPen
        "Use aRecordingPen to draw its contents
         on the receiver."
    self select.
    super drawUsing: aRecordingPen!  
fromColor: aColor
    | rgbColor |
    rgbColor := aColor asRGBColor.
    ^self new
        red: rgbColor red;
        green: rgbColor green;
        blue: rgbColor blue!  
sizeInBytes
    ^4!  
graphicsMedium: aGraphicsMedium
        "Private - Set the GraphicsMedium associated with
          the receiver to aGraphicsMedium."
    graphicsMedium := aGraphicsMedium!   
id: anInteger
        "Private - set the id of the receiver."
    self propertyAt: #id put: anInteger!  
windowFromPoint: aPoint
    <api: WindowFromPoint structValue ulongReturn>
    ^self invalidArgument!   
wmVScroll: wordInteger with: longInteger
        "Private - Process a WM_VSCROLL message."
    | type pos |
    type := wordInteger lowWord.
    type = SbLineup ifTrue: [
            (self verticalScrollPos > self verticalScrollMinRange) ifTrue:[
                 self scrollVertical: self amountToScrollUp]].
    type = SbLinedown ifTrue: [
            (self verticalScrollPos < self verticalScrollMaxRange) ifTrue:[
                self scrollVertical: self amountToScrollUp negated]].
    type = SbPageup ifTrue: [
            self scrollVertical: (self amountToPageUp
                min: (self verticalScrollPos - self verticalScrollMinRange)) ].
    type = SbPagedown ifTrue: [
            self scrollVertical: (self amountToPageUp
                min: (self verticalScrollMaxRange - self verticalScrollPos)) negated].
    type = SbThumbposition
        ifTrue: ["end of tracking"
            pos := ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2.
            self scrollVertical: self topCorner y - pos.
            self updateVerticalSliderTo: pos.
            ^nil].
    type = SbThumbtrack
        ifTrue: [^nil]
        ifFalse: [self updateVerticalSlider].
   ^nil!   
wmQuerydragicon: wordInteger with:longInteger
        "Private - Implemented by subclasses."
    ^nil!  
defaultStyle
        "Private - Answer a white rectangle for default static box style."
    ^SsWhiterect!   
selectMessage
        "Private - Answer the host message for selecting an item."
    ^LbSetcursel!  
buildWindow
        "Private - Create the dialog window for the receiver."
    ^self buildWindow: parent.!  
stringWidthOf: aString at: index
        "Return the width of aString up to index
         when written using the current font; expand tabs out
         to 4 spaces for calculations"
    | answer str extString size |
    index <= 0 ifTrue: [^0].
    index >= aString size
        ifTrue:   [str := aString]
        ifFalse: [str := aString copyFrom: 1 to: index].
    self font isNil
        ifTrue: [  "if font not set yet, calculate based on default font"
            extString := str asExternalString.
            size := WinPoint new.
            ( GDILibrary
                getTextExtentPoint: self handle
                string: extString asParameter
                count: extString size
                size: size asParameter )
                    ifFalse: [ ^self osError ].
            answer := size x ]
        ifFalse: [ answer := self font stringWidth: str withDC: self handle ].
    index > aString size ifTrue: [
        answer := answer + (index - aString size * font spaceWidth)].
    ^answer.!  
defaultStyle
        "Private - Answer an Integer with appropriate styles in it."
    ^WsBorder |
        WsHscroll |
        WsVscroll |
        WsClipsiblings!
asArrayOfLines: aString in: aRectangle wordWrap: wordWrapBoolean
        "Private - convert aString into an array of lines; if wordWrapBoolean
        is true, also perform word wrapping on the lines, within aRectangle."
    | line lines stream x0 x1 partialLine leftMargin rightMargin partialLineWidth index |
    stream := aString asStream.
    lines := OrderedCollection new.
    wordWrapBoolean ifTrue: [
        leftMargin := aRectangle left.
        rightMargin := aRectangle right ].
    [ stream atEnd ] whileFalse: [
        line := stream nextLine.
        wordWrapBoolean
            ifFalse: [ lines add: line ]
            ifTrue: [
                x0 := x1 := 1.
                1 to: line size do: [ :i |
                     ( ( line at: i ) asInteger = 32 and: [ ( partialLine := line copyFrom: x0 to: i ) trimBlanks notEmpty ] ) ifTrue: [
                        partialLineWidth := self stringWidthOf: partialLine.
                        ( leftMargin + partialLineWidth ) > rightMargin
                            ifTrue: [
                                partialLine := line copyFrom: x0 to: x1.
                                lines add: partialLine.
                                x0 := x1 + 1 ]
                            ifFalse: [ x1 := i ] ].
                            index := i ].
                line isEmpty
                    ifTrue: [ lines add: line ]
                    ifFalse: [
                        partialLine := line copyFrom: x0 to: index.
                        partialLineWidth := self stringWidthOf: partialLine.
                        ( leftMargin + partialLineWidth ) > rightMargin ifTrue: [
                            partialLine := line copyFrom: x0 to: x1.
                            lines add: partialLine.
                            partialLine := line copyFrom: x1 + 1 to: index ].
                        lines add: partialLine ] ] ].
    ^lines asArray!  
isKeyDown: vkConstant
        "Answer true if the key described by vkConstant is down.
         vkConstant is from VirtualKeyConstants pool dictionary."
    ^( UserLibrary getKeyState: vkConstant ) < 0! 
create: className
    title: nameString
    style: styleInteger
    extendedStyle: extendedStyleInteger
    rectangle: aRectangle
    parent: parentWindow
        "Private - Create a window in the host system whose parent is
        parentWindow with aTitleString and the given styles. The receiver's
        handle is set to the resulting window."
    | result parentHandle menuHandle |
    parentWindow notNil ifTrue: [ parentHandle := parentWindow handle ].
    ( styleInteger bitAnd: WsChild ) ~= 0 ifTrue: [ menuHandle := self id ].
    result := UserLibrary
        createWindow: className asParameter
        name: nameString asParameter
        style: styleInteger
        extendedStyle: extendedStyleInteger
        x: aRectangle origin x
        y: aRectangle origin y
        width: aRectangle width
        height: aRectangle height
        parent: parentHandle
        menu: menuHandle
        instance: OperatingSystem hInstanceExe
        param: nil.
    handle := WindowHandle fromInteger: result.
    result = 0 ifTrue: [ self osWarning. ^nil ].! 
dragTargetOverDefault: dragSession
		"Private - provide default mouse move handling (set effect flag,
        and initiate continuous scrolling if necessary) if no handler is provided."
	| operation |
	operation := self dragTargetOperationFor: dragSession.
	dragSession operation: operation!  
setViewportExt: anExtent
        "Set the viewport extent of the graphicsMedium
         associated with the receiver to anExtent."
    self allHandles do: [ :h |
        ( GDILibrary
            setViewportExtEx: h
            x: anExtent x
            y: anExtent y
            oldExtent: nil )
                ifFalse: [ ^self osError ] ]!   
getProp: hWnd name: aString
        "Private - Get item identified by aString in hWnd's
         property list."
    <api: GetPropA ulong struct ulong>
    ^self invalidArgument!
drawUsing: aRecordingPen
        "Use aRecordingPen to draw its contents
         on the receiver."
    super drawUsing: aRecordingPen.
    self stopRecording!   
doubleClickMessage
        "Private - answer the OS double-click message for the receiver."
    ^LbnDblclk! 
new
		"Answer a new instance of the receiver."
	^super new initialize!  
userFormats
        "Private - answer the list of known user-defined clipboard
         formats."
    UserFormats isNil ifTrue: [ UserFormats := Dictionary new ].
    ^UserFormats!  
userFormats: aDictionary
        "Private - set the list of known user-defined clipboard
         formats to aDictionary."
    UserFormats := aDictionary! 
startUp
        "Private - initialize the list of known user-defined clipboard
         formats."
    UserFormats := Dictionary new!   
containsText
        "Answer whether the clipboard contains text."
    ^self containsFormat: CfText!
getString
        "Answer the contents of the clipboard as a String, or an empty
         string if the clipboard is empty or cannot render a string."
    | s |
    ( s := self getStringOrNil ) isNil
        ifTrue: [ ^String new ]
        ifFalse: [ ^s ]!
containsBitmap
        "Answer whether the clipboard contains a bitmap."
    ^self containsFormat: CfBitmap!
formatNamed: aString
        "Answer the clipboard format named aString.
        Register the format if not previously defined."
    | aFormat |
    aFormat := self class userFormats at: aString ifAbsent: [ nil ].
    aFormat isNil
        ifTrue: [ aFormat := self registerFormat: aString ].
    ^aFormat! 
clear
        "Clear the contents of the clipboard."
    | result |
    self open ifFalse: [ self close. ^nil ].
    result := self empty.
    self close.
    ^result! 
hasHorizontalScrollBarStyle
        "Private - answer whether the receiver has a
        horizontal scrollbar style."
    ^self hasStyle: WsHscroll!   
wmDropfiles: wparam with: lparam
        "Private - file(s) dropped onto the receiver; default
        is do nothing."
    ^nil!   
popUpAt: aPoint in: aWindow
        "Private - Pop up the receiver at aPoint in aWindow."
    | screenPoint |
    screenPoint := aPoint mapClientToScreen: aWindow.
    ( UserLibrary
        trackPopupMenu: self asParameter
        flags: 0
        x: screenPoint x
        y: screenPoint y
        reservedInt: 0
        window: aWindow asParameter
        reservedStruct: nil )
            ifFalse: [ ^self osError ]!
createNamedControlPanes
        "Create instances of appropriate ControlPane subclasses
         for each host child control which has a corresponding name
         (string key) in the receiver's ItemIds dictionary; the host dialog
         window must have been created prior to sending this
         message (e.g. via fromModule:id:)"
    self itemIds keysDo: [:key |
        key isString ifTrue: [ self paneAt: key ] ]! 
directory
        "Answer the selected directory."
    ^DirName!
readBitmapHeader: bitmapFile
        "Private - Read the bitmap info header structure from a 
         bitmapFile. Answer an instance of WinBitmapInfoHeader."
    | bitmapInfo |
    bitmapInfo := WinBitmapInfoHeader new.
    bitmapInfo
        biSize: bitmapFile nextULong;
        width:  bitmapFile nextULong;
        height: bitmapFile nextULong;
        planes: bitmapFile nextUShort;
        bitCount: bitmapFile nextUShort;
        compression: bitmapFile nextULong;
        sizeImage: bitmapFile nextULong;
        xPelsPerMeter: bitmapFile nextULong;
        yPelsPerMeter: bitmapFile nextULong;
        clrUsed: bitmapFile nextULong;
        clrImportant: bitmapFile nextULong.
    ^bitmapInfo!  
bringToTop
        "Bring the receiver window to the top
         of its overlapping siblings and
         activate it."
    ( UserLibrary bringWindowToTop: self asParameter )
        ifFalse: [ ^self osError ]!  
dragTargetIsScrollable
		"Private - answer whether instances of the receiver are scrollable as a drag target."
    ^true!   
isSimpleList
        "Answer true if the receiver is a simple list."
    ^self hasStyle: CbsSimple! 
drawMenuBar: aWindowHandle
    <api: DrawMenuBar ulong boolean>
    ^self invalidArgument!  
indeterminate
        "Set the receiver's state to indeterminate (filled).
        Trigger changed event. "
    self setValue: nil!
nonAuto
        "Create an instance of a non-auto check box."
    ^self new threeState; yourself!   
auto
        "Create an instance of an auto three state button."
    ^self new autoThreeState; yourself!
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #indeterminate ;
        yourself!
indeterminate
        "Set the receiver's state to indeterminate (filled).
        Trigger changed event. "
    self setValue: nil!
threeState
        "Set and answer the style for three state buttons."
    self removeStyle: BsAuto3state.
    ^self addStyle: Bs3state
! 
autoThreeState
        "Set and answer the style for automatic
        three state buttons."
    self removeStyle: Bs3state.
    ^self addStyle: BsAuto3state
!  
changedEventFor: booleanOrNil
        "Private - answer the event to trigger for state booleanOrNil."
    ^booleanOrNil isNil
        ifTrue: [#indeterminate]
        ifFalse: [super changedEventFor: booleanOrNil]!
dragSource: aBoolean
        "Enable or disable the receiver as a drag drop source."
    self propertyAt: #dragSource put: ( aBoolean ifTrue: [ true ] ifFalse: [ nil ] )!  
defaultStyle
        "Private - Answer the default style for the receiver."
    ^CbsDropdown | CbsAutohscroll | WsVscroll!  
defaultExtendedStyle
        "Private - answer the default extended style flags for the
        receiver; may be reimplemented in subclasses."
    ^0! 
updateVerticalSliderTo: anInteger
       "Private - Set the slider box in the scrollbar to integer."
    | current |
    current := UserLibrary getScrollPos: self asParameter bar: SbVert.
    current = anInteger ifTrue: [ ^self ].
    UserLibrary
        setScrollPos: self asParameter
        bar: SbVert
        position: anInteger
        redraw: true!  
buildWindow: parentWindow
        "Private - Create the window for the receiver."
    (super buildWindow: parentWindow) isNil ifTrue:[^nil].
    self buildControl: parentWindow!  
relativeTo: referenceRectangle
    "Answer the rectangle described by the receiver relative to the <referenceRectangle>."

    ^(self block value: referenceRectangle) rounded!
block
    "Private"
    "Answer the block used to compute the relative rectangle."

    ^block!   
block: layoutBlock
    "Private"
    "Set the block used to compute the relative rectangle to be the <layoutBlock>."

    block := layoutBlock!   
helpModeSyscommand: wordInteger
        "Private - if we are in help mode
        request help to the HelpManager"
    |context|
    (wordInteger bitAnd: 16rFFF0 ) = ScMousemenu ifTrue:[^nil].
    self helpManager isNil ifTrue:[^nil].
    self helpManager helpMode ifFalse:[^nil].
    self mainWindow helpContext notNil
            ifTrue:[
                self helpManager displayHelp: self mainWindow helpContext key]
            ifFalse:[
                context := (Association key: (HelpManager systemContextStrings at: (wordInteger bitAnd: 16rFFF0)) value:self owner).
                self helpManager displayHelp: context key].
    self mainWindow helpContext: nil.
    ^0!
getTextAlign
        "Answer the text alignment flag currently set in the receiver."
    | result |
    ( result := GDILibrary getTextAlign: self handle ) = 16rFFFFFFFF
        ifTrue: [ self osNotification ].
    ^result!   
outputToPrinter
        "Print the receiver on a printer selected by the user."
    Printer print: self font: nil title: nil!   
font: aFont
        "Set the font for the receiver to aFont."
    | curFontHandle controlFontHandle |
    self fontAttribute: aFont.
    ( aFont isNil or: [ self isHandleOk not ] ) ifTrue: [ ^self ].
    ( ( curFontHandle := aFont fontHandle ) notNil )
        ifTrue: [
            controlFontHandle := UserLibrary
                sendMessageInt: handle
                msg: WmGetfont
                wparam: 0
                lparam: 0.
            ( curFontHandle ~= controlFontHandle
             and: [ ( controlFontHandle = 0
              and: [ aFont sameLogicalFont: SysFont ] ) not ] )
                ifTrue: [
                    UserLibrary
                        sendMessage: handle
                        msg: WmSetfont
                        wparam: aFont fontHandle
                        lparam: 1 ] ]!  
wmDisplaychange: wparam with: lparam
		"Private - handle display resolution change."
	Display setExtent.
	SessionModel current triggerEvent: #displayChanged.
	^nil!  
createWindowStructEx: exStyle
    class: classNameInteger
    nameStruct: nameString
    style: styleInteger
    x: xInteger
    y: yInteger
    width: widthInteger
    height: heightInteger
    parent: parentHandle
    menu: menuHandle
    instance: instanceHandle
    param: paramStructure
       "Private - This method only works for non-predefined window classes."
   <api: CreateWindowExA ulong struct struct ulong long long
                                            long long ulong ulong ulong struct ulongReturn>
    ^self invalidArgument!   
fileName
        "Answer the receiver's file name."
    ^'comdlg32'!
dragSourceSensitivity
        "Private - answer a Point which tunes drag-drop sensitivity:
        moving more than the x or y component of this point while
        the drag button is down initiates a drag-drop."
    ^5@5
!  
stringWidth: aString
        "Answer the width of aString using the receiver font."
     ^self stringWidth: aString 
         graphicsMedium: graphicsMedium!  
superWindow
        "Answer the non-frame parent window of the receiver."
    ^self parent! 
wmCtlcolorstatic: wparam with: lparam
        "Private - Process set control color message."
    | hbrush ctl3d |
    ( ctl3d := self class ctl3dIfEnabled ) notNil ifTrue: [
        ( hbrush := ctl3d current
            ctlColorEx: WmCtlcolorstatic
            wparam: wparam
            lparam: lparam ) ~= 0 ifTrue: [ ^hbrush ] ].
    ^self controlColor: lparam hDC: wparam!  
defaultStyle
        "Private - Answer the default style for an icon static control."
    ^SsIcon!  
sendMessage: aWindowHandle
        msg: msgInteger
        wparam: wordInteger
        lparam: longInteger
    <api: SendMessageA ulong ulong ulong long long>
    ^self invalidArgument!
locationVar
        "Private - Answer the location instance variable."
    ^location!   
popUpAt: aPoint in: aWindow
        "Private - Popup the receiver menu at aPoint in aWindow."
    | tempMenu |
    popup isNil ifTrue: [ "not cached, rebuild"
        popup := MenuWindow new.
        popup addMenu: self.
        popup buildPopupWindow].
    items size == 0 ifTrue: [^self].
    tempMenu := popup menus first window.
    tempMenu
        popUpAt: aPoint
        in: aWindow! 
isNotebookPagePane
        "Answer whether the receiver is a NotebookPagePane"

	^false!   
modifyMenu: aMenuHandle
    position: positionInteger
    flags: flagsInteger
    newId: idInteger
    newContents: stringOrInteger
        "Private - Perform the Win ModifyMenu function."
    ^stringOrInteger isInteger
        ifTrue: [ self modifyMenu: aMenuHandle position: positionInteger flags: flagsInteger newId: idInteger newContentsInt: stringOrInteger ]
        ifFalse: [ self modifyMenu: aMenuHandle position: positionInteger flags: flagsInteger newId: idInteger newContentsStruct: stringOrInteger ]!  
retainPicture: aBlock
        "Execute aBlock in retain mode
         inside a segment."
    | segId intState |
    intState := Process enableInterrupts: false.
    self closeSegment.
    self setDrawingModeToRetain.
    segId := self openSegment.
    aBlock value.
    self closeSegment.
    self setDrawingModeToDraw.
    Process enableInterrupts: intState.
    ^segId!   
deleteCurrentSegment
        "Delete the current segment."
    self deleteSegment: self currentId.
    currentId := currentId - 1! 
setDrawingModeToDraw
        "Set the drawing mode of the receiver to draw only."
    self setDrawingMode: DrawingModeDraw! 
segmentIsOpen
        "Answer true if a segment is open, else
         answer false."
    ^segmentIsOpen!  
segmentIsOpen: aBoolean
        "Private - Set the segmentIsOpen flag to aBoolean."
    segmentIsOpen := aBoolean!  
setDrawingModeToDrawandretain
        "Set the drawing mode of the receiver to draw and retain."
    self setDrawingMode: DrawingModeDrawAndRetain! 
segments: aDictionary
        "Private - Initialize the segment dictionary to
         aDictionary."
    segments := aDictionary!  
switchMediumTo: aMedium
        "Change the medium that the receiver pen
         is drawing on to aMedium and answer the
         old medium."
    | oldMedium |
    oldMedium := graphicsMedium.
    aMedium connectTo: self.
    ^oldMedium!
currentId: anInteger
        "Private - Set the current open segment to anInteger."
    currentId := anInteger! 
currentId
        "Private - Answer the id of the current open segment."
    ^currentId!
setDrawingModeToRetain
        "Set the drawing mode of the receiver to retain only."
    self setDrawingMode: DrawingModeRetain!   
openSegment
        "Open a new segment and answer its id."
    ^self openSegment: ( currentId + 1 )!   
release
        "Delete all the segments as well as all the
         pen objects from the system."
    super release.
    self deleteAllSegments! 
drawPicture: aBlock
        "Execute aBlock in draw mode inside a segment."
    | segId |
    self closeSegment.
    self setDrawingModeToDraw.
    segId := self openSegment.
    aBlock ensure: [ self closeSegment ].
    ^segId!   
drawRetainPicture: aBlock
        "Execute aBlock in draw and retain mode
         inside a segment."
    | segId intState |
    intState := Process enableInterrupts: false.
    self closeSegment.
    self setDrawingModeToDrawandretain.
    segId := self openSegment.
    aBlock value.
    self closeSegment.
    self setDrawingModeToDraw.
    Process enableInterrupts: intState.
    ^segId!   
segments
        "Private - Answer all the segments."
    ^segments!
drawingMode
        "Private - Answer the drawing mode."
    ^drawingMode!  
blue
    ^self byteAtOffset: 2!  
red
    ^self byteAtOffset: 0!   
red: anInteger
    self byteAtOffset: 0 put: anInteger!  
printOn: aStream
    aStream nextPutAll: self class name, ' { ', ( self asInteger radix: 16 ), ' } '!
blue: anInteger
    self byteAtOffset: 2 put: anInteger! 
green
    ^self byteAtOffset: 1! 
green: anInteger
    self byteAtOffset: 1 put: anInteger!
asColor
    ^Color red: self red green: self green blue: self blue!  
disableWordWrapFlags
        "Private - set the style flags to disable word wrapping."
    style isNil ifTrue: [ style := self getStyle ].
    style := style | WsHscroll | EsAutohscroll! 
removeVerticalScrollbarStyle
        "Remove the vertical scrollbar style."
    ^self removeStyle: WsVscroll!   
initialize
        "Private - Initialize chooseFontStruct."
    super initialize.
    chooseFontStruct :=  ( SelfDefinedStructure named: 'CHOOSEFONT' ).
    chooseFontStruct lStructSize: chooseFontStruct sizeInBytes.
    self sampleForeColor: ClrBlack.
    self style: CfInittologfontstruct "| CfEffects" | CfScreenfonts!   
mapPointSizeToMedium
        "Map the point size attribute to its medium."
    self pointSize: pointSize!   
scrollWindow: hWnd xAmount: anInt1 yAmount: anInt2 lpRect: aRect1 clipRect: aRect2
        updateRegion: updateRegionHandle updateRect: aRect3 scrollingFlags: flags
    <api: ScrollWindow ulong long long struct struct ulong struct ulong boolean>
    ^self invalidArgument!   
buildItem: i menu: menuNumber parent: menuBar
        "Private - Build the i'th item in the menu indexed by
         the menuNumber of the menuBar."
    | item |
    item := items at: i.
    item id: menuNumber * 256 + i.
    item submenu notNil
        ifTrue: [ item submenu buildWindow: menuBar ].
    self buildItemAccel: i menu: menuNumber parent: menuBar.
    window insertItem: item label: item label! 
getFormatRect
        "Private - Get the format rectangle for the host control.
        Assumes 'handle = NullHandle' is false."
    | rect |
    UserLibrary
        sendMessage: self handle
        msg: EmGetrect
        wparam: 0
        lparamStruct: ( rect := WinRectangle new ) asParameter.
    ^rect asRectangle!   
defWindowProc: aWindowHandle
        msg: msgInteger
        wparam: wordInteger
        lparam: longInteger
    <api: DefWindowProcA ulong ulong ulong ulong ulong>
    ^self invalidArgument!  
insertItemInControl: item at: index
        "Private - Insert a list item into the receiver at the given index (0 based)."
    | string |
    self isHandleOk ifFalse: [ ^self ].
    string := self stringForItem: item.
    ( UserLibrary sendMessageInt: handle
        msg: self insertMessage
        wparam: index
        lparamStruct: string asAsciiZ ) < 0
            ifTrue: [ ^Warning signal: 'list is full' ]
!  
multipleSelect
        "Add the multiple select style."
    self removeStyle: LbsExtendedsel.
    ^self addStyle: LbsMultiplesel!  
button1Down: aPoint
        "Private - left button was pressed; if the receiver
        is a drag source, start a drag drop transfer."
    ( self helpManager notNil and: [ self helpManager helpMode ] )
        ifTrue: [ self helpRequest. ^self ].
    ( self isDragSource and: [ self isDragButton: 1 ] ) ifTrue: [
        ( self selectionIncludesPoint: ( self characterCoordinate: aPoint ) )
            ifTrue: [ self dragOnMove: true location: aPoint ] ].
    ^true!   
queryValue: itemNumber inComboBox: itemId
        "Get the value of itemNumber in the combo box
         whose id is itemId."
    ^self sendMessage: CbGetitemdata item: itemId wparam: itemNumber lparam: 0!  
clipCursor: lpRect
    <api: ClipCursor struct boolean>
    ^self invalidArgument!  
continuousScroll: aBlock until: stopBlock
        "Private - Evaluate aBlock until the right button goes up
         or stopBlock evaluates to true.  stopBlock takes one
         argument which is the current mouse position."
    Notifier consumeInputUntil: [ :e |
        ( ( e selector = #button2Up: ) or: [
            ( e selector = #button2Move: ) and: [
                stopBlock value: ( e arguments at: 1 ) ] ] )
                    ifTrue: [
                        Margin := 0.
                        self clearMouseCapture.
                        e selector = #button2Up:
                            ifTrue: [ self stopTimer: self class rightButtonScrollTimerId ].
                        true ]
                    ifFalse: [
                        Margin := 1.
                        aBlock value.
                        "self captureMouseInput."
                        OSEventSemaphore signal.
                        self updateSliders.
                        false ] ].
    self clearMouseCapture.
    ^self updateSliders.!  
cr
        "Append a line-feed to the end
         of the  text in the pane."
    self selectAtEnd.
    self insert: ( String with: Cr with: Lf )!
deleteText
        "Delete all of the text in the control."
    UserLibrary
        sendMessage: handle
        msg: WmSettext
        wparam: 1
        lparamStruct: String new asParameter!  
setTabStops: anArray
        "Set the tab stop positions in the receiver to anArray;
         the receiver must have been created with the useTabStops
         style; tab stop positions are specified in dialog units"
    | struct |
    self isHandleOk
        ifTrue: [
            struct := ExternalBuffer new: anArray size * 4.
            1 to: anArray size do: [:i |
                struct uLongAtOffset: i - 1 * 4 put: ( anArray at: i ) ].
            UserLibrary
                sendMessage: handle
                msg: LbSettabstops
                wparam: anArray size
                lparamStruct: struct asParameter.
            self invalidateRect: nil ]
        ifFalse: [ self whenValid: #setTabStops: with: anArray ]!   
queryFocus
        "Answer the handle of the window with the input focus."
   ^self fromInteger: UserLibrary getFocus!  
defaultStyle
        "Private - Answer the default frame style for the receiver."
    ^WsMaximizebox |
        WsMinimizebox |
        WsThickframe |
        WsSysmenu |
        WsCaption |
        WsVisible!   
wmRbuttondown: wordInteger with: longInteger
        "Private - Process the right button down message."
    self class toolTipInstalled
        ifTrue: [ self relay: WmRbuttondown wparam: wordInteger lparam: longInteger ].
    self
        sendInputEvent: #button2Down:
        with:  (Point fromInteger: longInteger).
     ^nil!  
defaultStyle
        "Private - Answer the vertical style scrollbar."
    ^SbsHorz! 
winPointList: anArrayOfPoints
        "Private - answer a WinStructArray containing a list
        of POINT structures corresponding to anArrayOfPoints."
    | winPoints |
    winPoints := anArrayOfPoints collect: [ :p | WinPoint fromPoint: p ].
    ^WinStructArray fromCollection: winPoints! 
isRGBColor
        "Answer whether the receiver is an RGBColor."
    ^false!
flags
        "Private - Answers the dialog box current flags."
    ^printDlgStruct flags!  
appendSeparator
        "Append a separator line to the receiver menu."
    | mi |
    mi := MenuItem new.
    mi
        position: nil;
        style: MfSeparator;
        attribute: 0;
        id: 0;
        label: nil;
        selector: nil.
    items add: mi.
    accel add: nil.!  
setSelectEdit: itemId startingAt: startingPos endingAt: endingPos
        "Select all characters in the edit field identified
        by itemId that are between the startingPos and
        endingPos."
    self sendMessage: EmSetsel item: itemId wparam: startingPos lparam: endingPos!   
setTimer: hWnd idEvent: anInt1 elapsedTime: milliSeconds timerFunc: anAddress
    <api: SetTimer ulong ulong ulong ulong ulongReturn>
    ^self invalidArgument!
sendDlgItemMessage: hDlg
        item: nIDDlgItem
        msg: wMsg
        wparam: wParam
        lparamStruct: lParamStruct
    <api: SendDlgItemMessageA ulong long ulong ulong struct long>
    ^self invalidArgument!  
resize: aRectangle
        "Private - Change the frame of the receiver pane
         to aRectangle."
    self isHandleOk ifFalse: [ ^nil ].
    rectangle := self framingRectangleFor: aRectangle.
    rectangle extent: (rectangle extent max: 0@0).
    self resizeWindow!
addGroupStyle
        "Add the group style."
    ^self addStyle: WsGroup!   
helpMode
        "Private - Answer receiver's helpMode."
    ^helpMode! 
bitmapInfo
        "Private - answer the structure describing the meta information
        about the receiver."
    ^bitmapInfo!   
wantReturn
        "Add the want return style."
    ^self addStyle: EsWantreturn!   
curveFrom: p1 to: p3 towards: p2
        "Draw a curve from point p1 to p3
         which is curved towards p2."
    | range p1x p1y p2x p2y p3x p3y pOld xNew yNew
      r3 a b1x b1y b2x b2y dx dy dxOld dyOld |
    p1x := p1 x.
    p1y := p1 y.
    p2x := p2 x - p1 x.
    p2y := p2 y - p1 y.
    p3x := p3 x - p1 x.
    p3y := p3 y - p1 y.
    p3x >= p3y
        ifTrue: [range := p3x abs]
        ifFalse: [range := p3y abs].
    a := 3.
    b2x := a * range * p2x.
    b1x := b2x * range.
    b2y := a * range * p2y.
    b1y := b2y * range.
    r3 := range * range * range.
    self place: p1;
        goto: p1.
    pOld := p1.
    dxOld := dyOld := 0.
    1 to: range do: [:i |
        xNew := (dx := b1x - ((b2x - (i * p3x)) * i)) * i // r3 + p1x.
        yNew := (dy := b1y - ((b2y - (i * p3y)) * i)) * i // r3 + p1y.
        ((dx - dxOld) abs >= (dy - dyOld) abs)
            ifTrue: [
                pOld x = xNew ifFalse: [
                    self goto: pOld.  "so reverse will work"
                    pOld := xNew @ yNew.
                    self goto: pOld]]
            ifFalse: [
                pOld y = yNew ifFalse: [
                    self goto: pOld.  "so reverse will work"
                    pOld := xNew @ yNew.
                    self goto: pOld]].
        dxOld := dx.
        dyOld := dy]!  
addSizingBorderStyle
        "Add the sizing border style."
    ^self addStyle: WsThickframe!   
insertItem: anObject
    selector: aSelector
    accelKey: aCharacter
    accelBits: afBits
    after: anInteger
        "Insert an item with label anObject and
         selector aSelector and accelerator described
         by aCharacter and afBits to the receiver menu
         after item anInteger.  aCharacter is the asciiValue
         of the accelerator key.  afBits is one or more of
         the following from the VirtualKeyConstants pool dictionary:
            AfAlt, AfChar, AfControl, AfHelp, AfLonekey, AfShift
            AfSyscommand, AfVirtualkey.
        anObject may be either a String, a Bitmap, or an Integer
        (a 32-bit value to associate with an owner-drawn item)."
    | mi style |
    style := anObject isInteger
        ifTrue: [ MfOwnerdraw ]
        ifFalse: [
            anObject isString
                ifTrue: [ MfString ]
                ifFalse: [ MfBitmap ] ].
    mi := MenuItem new.
    mi
        position: anInteger;
        style: style;
        attribute: 0;
        id: 0;
        selector: aSelector;
        label: ( self fixUnderScoreChar: anObject ).
    items add: mi.
    accel add: ( self accelArray: aCharacter accelBits: afBits )!
extendedStyle: anInteger
        "Private - set the extended window style to anInteger."
    self propertyAt: #extendedStyle put: anInteger!
startUp
        "Private - Initialize class variables."
    self anchorDictionary: Dictionary new.
    self
        stockObject: BlackBrush;
        stockObject: WhiteBrush.
    self allInstancesPrim do: [ :each | each initHandle ].
    self threshold: 16!   
style: aStyle color: aColor hatch: hatchType
        "Answer a logical brush with specified
         aStyle, aColor, and hatchType.
         aStyle can be BsDibpattern, BsHatched, BsHollow,
         BsPattern, or BsSolid.  hatchType and be HsBdiagonal,
         HsCross, HsDiagcross, HsFdiagonal, HsHorizontal,
         or HsVertical."
    | attrib |
    attrib := Array with: BsSolid with: ClrWhite with: 0.
    aStyle isNil ifFalse: [attrib at: 1 put: aStyle].
    aColor isNil ifFalse: [attrib at: 2 put: aColor asInteger].
    hatchType isNil ifFalse: [attrib at: 3 put: hatchType].
    ^self objectWithAttributes: attrib!
fromAttributes: anArray
        "Private - Answer a logical brush with attributes
         specified in anArray."
    ^self new
        style: ( anArray at: 1 ) color: ( anArray at: 2 ) hatch: ( anArray at: 3 );
        createObject!
winStruct
        "Private - Answer the host structure for receiver."
    ^WinLogBrush new! 
getHandle
        "Private - Answer handle after creating
         the windows object."
    | aHandle aBrushStruct |
    stockObject notNil ifTrue: [ ^GraphicsTool getStockObject: stockObject ].
    aBrushStruct := WinLogBrush new
        style: style;
        color: color asParameter;
        hatch: hatch.
    ( aHandle := GDILibrary createBrushIndirect: aBrushStruct asParameter ) = 0
        ifTrue: [ ^self osError ].
    ^aHandle!  
style: aStyle color: aColor hatch: hatchType
        "Private - Set attributes to
         aStyle, aColor, and hatchType."
    style := aStyle.
    color := aColor.
    hatch := hatchType! 
attributeArray
        "Private - Answer attributes as an array."
    ^Array with: style with: color with: hatch!   
fromStruct: struct
        "Private - Answer an instance with attributes
         specified in anArray."
    style := struct style.
    color := struct color.
    hatch := struct hatch.
    self createObject!
cr
        "Move the current location down one line and
         to the left margin."
    | newy |
    newy := self location y down: font height.
    (newy isBelow: self boundingBox bottom)
        ifTrue: [newy := self boundingBox top].
    self place: 0 @ newy!
dragSourceCutDefault: dragSession
		"Private - provide default source cut if no handler is provided
		by removing the selected elements from contents."
    | oldContents newContents selections |
	selections := self selections.
	oldContents := self contents.
    newContents := OrderedCollection new.
    1 to: oldContents size do: [ :i |
		( selections includes: i ) ifFalse: [ newContents add: ( oldContents at: i ) ] ].
    self contents: newContents asArray!
wmLbuttondblclk: wordInteger with: longInteger
        "Private - Button 1 has been double clicked.  If the cursor is
        on a bracket character, match the character, otherwise pass
        it on to the host operating system."
    self getText.
    self getSelection.
    Smalltalk isRunTime ifTrue: [ ^nil ].
    self doubleClickBrackets ifTrue: [ ^0 ].
    self doubleClickSmalltalk.
    ^0!
loadIcon: hInstance nameString: resourceName
    <api: LoadIconA ulong struct ulongReturn>
    ^self invalidArgument!   
removeExtendedStyle: styleBits
        "Private - if extendedStyle is nil, initialize it appropriately:
         if #noDefaultStyle was previously sent to the receiver,
         set it to 0, otherwise set it to defaultExtendedStyle; then remove
         the given style bits from the flag.  Answer the removed
         styleBits."
    | mask |
    self extendedStyle isNil ifTrue: [ self extendedStyle: self defaultExtendedStyle ].
    mask := styleBits bitXor: 16rFFFFFFFF.
    self extendedStyle: ( self extendedStyle bitAnd: mask ).
    ^styleBits! 
reuseDDElParam: lParam msgIn: anInteger msgOut: anInteger2 low: lowWord high: highWord
    <api: PackDDElParam long ulong ulong ulong ulong long>
    ^self invalidArgument!
insertSubMenu: aMenu after: anInteger
        "Append a submenu aMenu to the receiver menu after anInteger position."
    | mi |
    mi := MenuItem new.
    mi
        position: anInteger;
        style: MfPopup + MfString;
        attribute: 0;
        id: 0;
        label: aMenu title;
        selector: nil;
        submenu: aMenu.
    items add: mi.
    accel add: nil!   
exit
        "Private - exit the receiver class."
    ( ( Smalltalk includesKey: #CallBack16 ) and: [ OperatingSystem isWindows ] )
        ifTrue: [ ( Smalltalk at: #CallBack16 ) exit ]!
putData: aBuffer
        "Private - Recreate the segment in the receiver
         from the saved graphics data. This is done
         when restarting a saved image."
    | hMetafile |
    ( hMetafile := GDILibrary
        setMetaFileBitsEx: aBuffer size
        buffer: aBuffer ) = 0
            ifTrue: [ self osWarning ].
    ^hMetafile!  
setSolidBrush: aColor
        "Set the background brush to have aColor as
         its color."
    logicalBrush :=
        WinLogicalBrush style: nil color: aColor hatch: nil.
    self selectObject: logicalBrush handle!  
wmHScroll: wordInteger with: longInteger
        "Private - Scroll the receiver horizontally.
        If the source of the message is a scroll control,
        then raise a control event."
    | w ctrlId |
    longInteger = 0 ifTrue: [ ^nil ].
    ctrlId := UserLibrary getWindowLong: longInteger index: GwlId.
    ( w := self childAtId: ctrlId ) isNil ifTrue: [ ^nil ].
    w
        syncControlEvent: wordInteger lowWord
        with: ( ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2 ).
    ^nil!
charactersBeforeLine: lineNumber
        "Answer the number of characters preceding the
		given line number."
	^UserLibrary
        sendMessageInt: handle
        msg: EmLineindex
        wparam: lineNumber - 1
        lparam: 0!  
nextPutAll: aString
        "Add aString at the end of the
         text in the pane."
    self selectAtEnd.
    self insert: aString!
wmHScroll: wordInteger with: longInteger
        "Private - Process the horizontal scroll message."
    | type slider newX |
    "if message is from a child window, call super to pass it on to the child window."
    longInteger = 0 ifFalse: [ ^super wmHScroll: wordInteger with: longInteger ].
    type := wordInteger lowWord.
    type = SbLineup ifTrue: [ self scrollHorizontal: self amountToScrollLeft].
    type = SbLinedown ifTrue: [ self scrollHorizontal: self amountToScrollLeft negated ].
    type = SbPageup ifTrue: [ self scrollHorizontal: self amountToPageLeft ].
    type = SbPagedown ifTrue: [ self scrollHorizontal: self amountToPageLeft negated ].
    type = SbThumbposition ifTrue: [
        slider := ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2.
        self updateHorizontalSliderTo: slider. ^nil ].
    type = SbThumbtrack
        ifTrue: [
            slider := ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2.
            newX := ( slider * ( self totalWidth max: 1 ) ) // 100.
            self scrollHorizontal: self topCorner x - newX ]
        ifFalse: [ self updateHorizontalSlider ].
    ^nil! 
sizeInBytes
         "Private - Answer the default size in bytes."
    ^12! 
style: brushStyle
        "Private - Set the brush style field."
    self uLongAtOffset: 0 put: brushStyle! 
style
        "Private - Answer the brush style field."
    ^self uLongAtOffset: 0! 
color
        "Private - Answer the color field."
    ^self uLongAtOffset: 4!   
color: aColor
        "Private - Set the color field."
    self uLongAtOffset: 4 put: aColor!   
hatch
        "Private - Answer the hatch field."
    ^self longAtOffset: 8!
hatch: hatchStyle
        "Private - Set the hatch field."
    self longAtOffset: 8 put: hatchStyle!
showCursor: aBoolean
    <api: ShowCursor boolean long>
    ^self invalidArgument!  
appendSubMenu: aMenu
        "Append a submenu aMenu to the receiver menu."
    | mi |
    mi := MenuItem new.
    mi
        position: nil;
        style: MfPopup + MfString;
        attribute: 0;
        id: 0;
        label: aMenu title;
        selector: nil;
        submenu: aMenu.
    items add: mi.
    accel add: nil.!  
defaultStyle
        "Private - Answer pushbutton as the default button style."
    ^BsPushbutton!  
pointFromUser: aRectangle offset: anOffset
        "Display aRectangle and answer a point selected
         by the user."
    | loc oldLoc oldCorner newCorner |
    oldLoc := Cursor sense - anOffset.
    oldCorner := oldLoc + aRectangle extent.
    graphicsTool setRop2: R2Notxorpen;
        place: oldLoc;
        box: oldCorner.
    Notifier consumeInputUntil: [: event |
        loc := Cursor sense - anOffset.
        oldCorner := oldLoc + aRectangle extent.
        newCorner := loc + aRectangle extent.
        loc ~= oldLoc
            ifTrue: [
                graphicsTool
                    place: oldLoc;
                    box: oldCorner;
                    place: loc;
                    box: newCorner.
                oldLoc := loc].
        event selector = #button1Up:].
    ^loc!   
isKeyToggled: vkConstant
        "Answer true if the key described by vkConstant is toggled.
         vkConstant is from VirtualKeyConstants pool dictionary."
    ^( ( UserLibrary getKeyState: vkConstant ) & 1 ) abs = 1!   
iconStop
        "Specify a stop sign icon."
    style := style | MbIconstop!   
extendedStyle
        "Private - answer the extended window style."
    ^self propertyAt: #extendedStyle!   
purgeUnusedBitmaps
        "Obsolete - No longer needed due to finalization."!   
save
        "Brings up the save file dialog."
    | error |
    hLibrary := CommonDialogDLL current.
    self copyStruct.
    parent isWindow ifFalse: [
        parent := Notifier findWindow: WindowHandle queryActive.
        openFileNameStruct hwndOwner: parent asParameter ].
    style notNil ifTrue: [ openFileNameStruct flags: style ].
    ( hLibrary getSaveFilename: openFileNameStruct asParameter )
        ifTrue: [ self checkFlags ]
        ifFalse: [
            fileName := nil.
            error := ( ExternalLong fromString: hLibrary commDlgExtendedError ) asInteger.
            error ~= 0 ifTrue: [
                self cleanUp.
                ^self osError: error ] ].
    self cleanUp.! 
height
        "Answer the height of the receiver."
    ^bitmapInfo height! 
getDC
        "Private - Answer a display context for the receiver."
    | dc |
    ( dc := UserLibrary getDC: self ) = 0
        ifTrue: [ ^self osError ].
    ^DeviceContext fromInteger: dc! 
displayAt: aPoint with: aPen
        "Display the receiver through aPen at the given location."
    ( UserLibrary
        drawIcon: aPen handle
        x: aPoint x
        y: aPoint y
        hIcon: self handle )
            ifFalse: [ ^self osError ]!   
width: anInteger
        "Set the width of the receiver to anInteger."
    width := anInteger!  
showWindow: aWindowHandle  command: aninteger
        <api: ShowWindow ulong long boolean>
        ^self invalidArgument!   
enumChildWindows: parent callback: callback lparam: lparam
        "Enumerate the child windows of <parent> sending each along with <lparam>
        as arguments to the <callback> message."
    <api: EnumChildWindows ulong ulong long boolean>
    ^self invalidArgument! 
setBackgroundColor
        "Private - The user selected Color/Background... from the Options
        menu; bring up a ColorDialog to select a color for the current window."
    | dialog paneWithFocus color |
    color := ( paneWithFocus := self subPaneWithFocus ) notNil
        ifTrue: [ paneWithFocus backColor ]
        ifFalse: [ nil ].
    dialog := ColorDialog new
        color: color;
        open.
    color := dialog chosen.
    ( color notNil and: [ self backColor ~= color ] ) ifTrue: [
        self backColor: color.
        self allChildrenDo: [ :pane | pane backColor: color ].
        self colorChange ]!
bitBlt: destDC
    x: x1
    y: y1
    width: srcWidth
    height: srcHeight
    srcDC: srcDC
    xSrc: x2
    ySrc: y2
    rop: aRopConstant
        "Private - Call GDI BitBlt function."
    ( GDILibrary
         bitBlt: destDC
         x: x1
         y: y1
         width: srcWidth
         height: srcHeight
         srcDC: srcDC
         xSrc: x2
         ySrc: y2
         rop: aRopConstant )
            ifFalse: [ ^self osError ]! 
dragTargetEmphasisTypesSupported
		"Private - answer a collection of emphasis types that the receiver can support."
	^#( 'pane' 'item' 'separator' )!   
dragTargetOperationFor: dragSession
        "Private - answer the operation that the reciever would perform
        for the current drag-drop transfer at the current location, or nil
        if invalid."
    | dragFormats dragOperations dragObject operation |
    self isDragTarget ifFalse: [ ^nil ].
    ( dragFormats := self dragTargetFormats ) isNil ifTrue: [ ^nil ].
    ( dragOperations := self dragTargetOperations ) isNil ifTrue: [ ^nil ].
    ( dragSession objects size > 1 and: [ self dragTargetMultipleItem not ] ) ifTrue: [ ^nil ].
    dragObject := dragSession objects first.
    ( dragFormats detect: [ :s | dragObject hasFormat: s ] ifNone: [ nil ] ) notNil ifTrue: [
        ( operation := dragSession impliedOperation ) isNil
            ifTrue: [ operation := dragSession defaultOperation ].
        ( dragOperations includes: operation ) ifFalse: [ ^nil ] ].
    ^operation!
dragTargetDrawEmphasisDefault: dragSession
		"Private - draw the target emphasis for the receiver
		given the cursor location aPoint (relative to the receiver)."
	| emphasisStyle |
	emphasisStyle := self dragTargetEmphasis.
	emphasisStyle = 'item'
		ifTrue: [ self dragTargetDrawItemEmphasis: dragSession targetLocation ]
		ifFalse: [
			emphasisStyle = 'separator'
				ifTrue: [ self dragTargetDrawSeparatorEmphasis: dragSession targetLocation ]
				ifFalse: [ self dragTargetDrawPaneEmphasis: dragSession targetLocation ] ]!  
isFont
        "Answer whether the receiver is a kind of Font."
    ^true!  
clearMessage
        "Answer the host message used to clear the clipboard
        and selection."
    ^WmClear!
setWindowPos: hwndInsertBehind
    rectangle: aRectangle
    fs: flagWord
    deferInfo: winPosInfo
        "Private - Set the window size and position of the
        receiver and defer the action until the end of resizing
        all children."
    | answer aFlagWord|

    (flagWord = 0 or:[flagWord = nil])
        ifTrue:[aFlagWord := SwpNoactivate]
        ifFalse:[ aFlagWord := flagWord].

    answer := UserLibrary
        deferWindowPos: winPosInfo
        window: self
        insertAfter: hwndInsertBehind
        x: aRectangle origin x asInteger
        y: aRectangle origin y asInteger
        cx: aRectangle width asInteger
        cy: aRectangle height asInteger
        flags: aFlagWord.
    answer = 0 ifTrue: [
        self osWarning.
        self setWindowPos: hwndInsertBehind
            rectangle: aRectangle
            fs: aFlagWord ].
    ^answer!   
button1Down: aPoint
        "Private - signal the button1 down event."
    self triggerEvent: #button1Down
        ifNotHandled: [ super button1Down: aPoint ].
    self container notNil ifTrue: [ self container deactivateInPlaceObject: aPoint ]! 
wmGetdlgcode: wparam with: lparam
        "Private - process WM_GETDLGCODE message."
    ^ DlgcWantchars!   
backColor
        "Answer an Integer representing the background color
         of the tool."
    ^backColor!  
fromHandle: handle style: style
        "Private - answer a new instance of an appropriate subclass
         of the receiver class corresponding to the given host control's
         handle and style flags"
    ^self handle: ( WindowHandle fromInteger: handle )! 
runNotifier
        "Private - initiate the main loop to execute events from the
        host system."
    Notifier run!   
setDrawingMode: aDmConstant
        "Set the drawing mode of the receiver to aDmConstant.
         aDmConstant can be one of the following:
         DmDraw - graphics are drawn immediately.
         DmRetain - graphics are stored segment.
         DmDrawandretain - graphics are both drawn on the
            receiver's device context and stored for later use."
    drawingMode := aDmConstant!  
windowClass
        "Answer the host class for all static controls."
    ^'STATIC'! 
exitWindowSystem2
        "Private - perform OS window system shutdown."
    HelpManager exit.
    Bitmap exit.
    Screen exit.
    CallBack exit.
    WinLogicalObject destroyAll.
    Font releaseAllHandles!   
defaultStyle
        "Private - Answer the default style for multiple selection."
    ^super defaultStyle | LbsMultiplesel! 
rightButtonScroll: point
        "Private - Do right button scrolling."
   ( ( rectangle containsPoint: point ) or: [ WindowHandle queryCapture ~= handle ] )
        ifTrue: [ ^self ].
   ( point y isBelow: rectangle bottom ) ifTrue: [   "scroll down"
        self continuousScroll: [ self scrollVerticalCharacters: -1 ]
            until: [ :p | ( p y isBelow: rectangle bottom ) not ] ].
   ( point y isAbove: rectangle top ) ifTrue: [   "scroll up"
        self continuousScroll: [ self scrollVerticalCharacters: 1 ]
            until: [ :p | ( p y isAbove: rectangle top ) not ] ].
   ( point x isLeftOf: rectangle left ) ifTrue: [   "scroll left"
        self continuousScroll: [self scrollHorizontalCharacters: 1]
            until: [:p| p x > rectangle left]].
   ( point x isRightOf: rectangle right ) ifTrue: [   "scroll right"
        self continuousScroll: [self scrollHorizontalCharacters: -1]
            until: [:p| p x < rectangle right]].!
postMessage: aWindowHandle
        msg: msgInteger
        wparam: wordInteger
        lparam: longInteger
    <api: PostMessageA ulong ulong ulong ulong boolean>
    ^self invalidArgument!
validate
        "Private - The host window for the receiver was
         just created or recreated."
    | currentFont |
    super validate.
    self isOwnerDrawn ifFalse: [
        ( currentFont := self font ) isNil
            ifTrue: [ currentFont := self defaultFont ].
        self itemHeight: currentFont height ].
    self setInitialContents!   
constructNotifications
        "Private - answer the mapping between host control
        notification codes and corresponding Smalltalk event
        notifications."
    ^Dictionary new
        at: SbLineup put: #notifyPreviousLine: ;
        at: SbLinedown put: #notifyNextLine: ;
        at: SbPageup put: #notifyPreviousPage: ;
        at: SbPagedown put: #notifyNextPage: ;
        at: SbEndscroll put: #notifyEndScroll: ;
        at: SbThumbtrack put: #notifySliderTrack: ;
        at: SbThumbposition put: #notifySliderPosition: ;
        at: SbTop put: #notifyHome: ;
        at: SbBottom put: #notifyEnd: ;
        yourself!   
apmHeader: aHeader
        "Private - set the metafile header for the receiver to aHeader."
    apmHeader := aHeader!   
windowTextLength
        "Answer the receiver's window text length."
    ^self isHandleOk
        ifTrue: [ UserLibrary getWindowTextLength: handle ]
        ifFalse: [ 0 ]! 
checkMenuItem: hMenu item: uItem flags: fuFlags
    <api: CheckMenuItem ulong ulong ulong boolean>
    ^self invalidArgument!   
isDragTarget
        "Answer whether the receiver is enabled as a drag drop target."
    ^( self propertyAt: #dragTarget ) notNil!  
dragTargetNeedsOperations: dragSession
        "Private - set the names of supported operations in the dragSession."
    self isDragTarget ifFalse: [ ^nil ].
    self dragTargetStopScrollTimer.
    dragSession targetEraseEmphasis.
    self
        triggerEvent: #dragTargetNeedsOperations:
        withArguments: ( Array with: dragSession )
        ifNotHandled: [ self dragTargetNeedsOperationsDefault: dragSession ]!
name: anObject
        "Private - Set the name of the icon to anObject."
    name := anObject!  
memoryContext
        "Private - Answer the device context for bitmaps."
    ^MemoryContext!
getGraphicsTool
        "Private - Answer a graphics tool for the receiver."
    | dc |
    dc := self getDC.
    graphicsTool isNil
        ifTrue: [
            graphicsTool := self graphicsToolClass forDC: dc medium: self]
        ifFalse: [
            graphicsTool restoreSegments: dc.
            firstTime := false].
    ^graphicsTool!  
dragTargetDrawPaneEmphasis: aPoint
        "Private - draw emphasis in the receiver indicating
        that the pane as a whole accepts dropped items."
    self dragTargetSelection notNil ifTrue: [ ^nil ].  "don't draw emphasis if already drawn."
    self dragTargetSelection: true.
    self dragTargetDrawEmphasisRectangle: self drawingRectangle!  
planes
        "Answer the number of planes in the receiver."
    ^bitmapInfo planes!   
charAsUpper: charValue
    <api: CharUpperA ulong ulongReturn>
    ^self invalidArgument!   
gettingFocus
        "Private - The receiver is getting the input focus."
    self container notNil ifTrue: [ ^self container gettingFocus ].
    super gettingFocus!  
defaultSampleFont
        "Private - answer the font to use for the sample string."
    ^self defaultFont!  
indexOfWholeChar: string at: widthInteger withDC: hDC
        "Answer the index of the character in
         string that covers the widthInteger. Use
         the font associated with device context hDC."
    | widthTable loc cCharWidth spaceWidth widthTableParm index |
    loc := 0.
    widthTable := ExternalBuffer new: 2.
    widthTableParm := widthTable asParameter.
    string isEmpty
        ifTrue: [index := 1]
        ifFalse: [
            1 to: (string size) do: [:i |
                ( GDILibrary
                    getCharWidth: hDC
                    firstChar: ( string at: i ) asciiValue
                    lastChar: ( string at: i ) asciiValue
                    buffer: widthTableParm )
                        ifFalse: [ ^self osNotification ].
                    cCharWidth := ( widthTable uShortAtOffset: 0 ) - self overHang.
                (loc := loc + cCharWidth) > widthInteger ifTrue: [^i].
                index := i] ].
    ( GDILibrary
        getCharWidth: hDC
        firstChar: 32
        lastChar: 32
        buffer: widthTableParm )
            ifFalse: [ ^self osNotification ].
    spaceWidth := widthTable uShortAtOffset: 0.
    [(loc := loc + spaceWidth) > widthInteger] whileFalse:
        ["beyond string"
            index := index + 1].
    ^index!  
showCaret: aBoolean
        "Show or hide the caret."
    aBoolean
        ifTrue: [ UserLibrary showCaret: self asParameter ]
        ifFalse: [ UserLibrary hideCaret: self asParameter ]!  
cleanUpHandles
        "Private - Delete unused font handles."
    | allHandlesSet oldKeys fontHandle int |
    allHandlesSet := ( self allInstances collect: [ :f | f originalHandle ] ) asSet.
    int := Process enableInterrupts: true.
    oldKeys := OrderedCollection new.
    FontHandleTable associationsDo: [ :assoc |
        ( allHandlesSet includes: ( fontHandle := assoc value ) )
            ifFalse: [
                ( GraphicsTool stockObjects includes: fontHandle )
                    ifFalse: [
                        ( GDILibrary deleteObject: fontHandle )
                            ifFalse: [ self osWarning ] ].
                oldKeys add: assoc key ] ].
    oldKeys do: [ :k | FontHandleTable removeKey: k ].
    Process enableInterrupts: int!   
dragSessionClass
        "Private - answer the class to use to model a drag drop transfer."
    ^self
		propertyAt: #dragSessionClass
		ifAbsent: [ DragDropSession defaultClass ]!   
xorMask: aBitmap
        "Private - Set the XOR mask to aBitmap."
    xorMask := aBitmap!   
isApplicationWindow
        "Answer true if receiver is a kind of ApplicationWindow."
    ^false!   
basicStyle
        "Private - Answer the basic style for the receiver."
    ^DsNoidlemsg | WsVisible!   
getBitmapWidth: aWidth height: aHeight
        "Open the clipboard and answer
         an instance of Bitmap clipped to width of aWidth and
         height of Height from the clipboard."
    | hBitmap bitmap |
    self containsBitmap ifFalse: [ ^nil ].
    self open ifFalse: [ ^nil ].
    ( hBitmap := UserLibrary getClipboardData: CfBitmap ) = 0 ifTrue: [
        self osWarning.
        self close.
        ^nil ].
    bitmap := Bitmap
        fromHandle: hBitmap
        clipWidth: aWidth
        clipHeight: aHeight.
    self close.
    ^bitmap!
hdr
    ^WinNmhdr fromBytes: ( self bytesAtOffset: 0 count: WinNmhdr sizeInBytes )!  
hwndFrom
    ^self uLongAtOffset: 0! 
idFrom
    ^self uLongAtOffset: 4!   
code
    ^self longAtOffset: 8!  
validateShow
    "Private - Perform validates and show window."

    self performWhenValids.
    children do: [ :each |
        each isApplicationWindow
            ifTrue: [ each validateShow ]
            ifFalse: [ each validate ] ].

    self zoomed ifTrue: [
        self children do: [ :each | each zoomed ifFalse: [ each hideWindow ] ] ].
    collapsed isNil ifTrue: [ collapsed := 0 ].
    self isHidden ifFalse: [
        collapsed isRectangle
            ifTrue: [ self showMaximizedWindow ]
            ifFalse: [ collapsed < 0
                ifTrue: [ self showIconicWindow ]
                ifFalse: [ self showWindow ] ] ].

    self sendDeferredEvent: #subclassRecursively.
    self sendDeferredEvent: #triggerOpenedEvent!
dragTargetMultipleItemDefault
        "Private - answer whether instances of the receiver will by default
        accept multiple item drag-drop transfers."
    ^false!   
getSavedWindows
        "Private - iterate over opened top level windows, and save them
        in the savedWindows instance variable in their creation order."
    | callback message |
    savedWindows := OrderedCollection new: Notifier windows size.
    message := Message receiver: self selector: #getSavedWindow:with: .
    callback := CallBack
        registerMessage: message
        parameterTypes: #( #ulong #long )
        returnType: #boolean
        callingConvention: #api.
    UserLibrary
        enumWindows: callback asParameter lparam: 0.
    callback release.
    savedWindows := savedWindows reversed.
    savedWindows isEmpty  "in case enum should ever fail"
        ifTrue: [ savedWindows := Notifier windows values asArray select: [ :w | w parent isNil ] ].
    ^savedWindows! 
canApplyStyle
        "Private - answer whether the receiver's style can change
        after it has been created."
    ^true! 
checksum: anInteger
    self uShortAtOffset: 20 put: anInteger!  
key
    ^self uLongAtOffset: 0!  
inch
    ^self uShortAtOffset: 14!   
key: anInteger
    self uLongAtOffset: 0 put: anInteger! 
inch: anInteger
    self uShortAtOffset: 14 put: anInteger!  
reserved
    ^self uLongAtOffset: 16!
bbox
    | leftTop rightBottom |
    leftTop := ( self shortAtOffset: 6 ) @ ( self shortAtOffset: 8 ).
    rightBottom := ( self shortAtOffset: 10 ) @ ( self shortAtOffset: 12 ).
    ^Rectangle leftTop: leftTop rightBottom: rightBottom!  
reserved: anInteger
    self uLongAtOffset: 16 put: anInteger!   
hmf
    ^self uShortAtOffset: 4! 
hmf: anInteger
    self uShortAtOffset: 4 put: anInteger!
bbox: aRectangle
    self uShortAtOffset: 6 put: aRectangle left.
    self uShortAtOffset: 8 put: aRectangle top.
    self uShortAtOffset: 10 put: aRectangle right.
    self uShortAtOffset: 12 put: aRectangle bottom!  
checksum
    ^self uShortAtOffset: 20!   
addTabStopStyle
        "Add the tab stop style."
    ^self addStyle: WsTabstop!
pointSize: anInteger
        "Set the point size of the Font for the current graphicsMedium.
         Font's point size indicates the height of the characters
         in 1/72 inch."
    self pointSize: anInteger graphicsMedium: graphicsMedium!  
filters
        "Private - answers  a string containing all filters and sets up
        the defFilterIndex property"
    | filterString count defaultFilterIndex |
    (self propertyAt: #smalltalkFileFilters) notNil ifTrue: [
        self
            addFilter: '*.cls' description: 'Class Files (*.CLS)';
            addFilter: '*.mth' description: 'Method Files (*.MTH)';
            addFilter: '*.st' description: 'Smalltalk Files (*.ST)';
            addFilter: '*.bnd' description: 'Library Bind Files (*.BND)';
            addFilter: '*.map' description: 'Library Map Files (*.MAP)';
            addFilter: '*.ini' description: 'Initialization Files (*.INI)';
            addFilter: '*.obj' description: 'Object Files (*.OBJ)';
            addFilter: '*.log' description: 'Log Files (*.LOG)' ].

    filterString := String new.
    count := 0.
    defaultFilterIndex := 0.
    filters do: [:assoc |
        count := count + 1.
        assoc key = ( self propertyAt: #defFilter ) ifTrue: [ defaultFilterIndex := count ].
        filterString := filterString, assoc value asAsciiZ, assoc key asAsciiZ ].

    self propertyAt: #defFilterIndex put: defaultFilterIndex.
    ^filterString!  
defaultStyle
        "Private - Answer the specific style flags which
         define special characteristics of this window;
         usually reimplemented in subclasses."
    ^0!  
showMaximizedWindow
        "Private - make the window visible, maximized."
    UserLibrary showWindow: self command: SwShowmaximized!  
dragTargetOperations
        "Private - answer the operations that the receiver can accept."
    ^self propertyAt: #dragTargetOperations!   
contextForItem: anInteger
        "Private - The user has highlighted a menu item"
    ^menuWindow contextForItem: anInteger!   
cleanUpAllMessages
        "Private - Execute all host messages and
         Smalltalk events until no more messages."
    [    self runPendingEvents.
        DeferredRequests isEmpty ] whileFalse:[ ].

    [ self peek: false ] whileTrue: [
        self readWinQueue.
        [    self runPendingEvents.
            DeferredRequests isEmpty ] whileFalse: [ ] ]!
ownerDrawPen
        "Private - answer the pen to be used for drawing
        owner drawn items.  When drawing owner drawn
        menu items, use the menu window's pen."
    ^menuWindow pen!   
checkFlags
        "Private - check user action and get the font and color"
    | logFont |
    self style: self flags.
    logFont := WinLogFont fromAddress: ( ExternalHeapAddress fromInteger: chooseFontStruct lpLogFont ).
    chosen :=  Font fromLogicalFont: logFont.
    chosenForeColor := GraphicsTool rgbToPalette: chooseFontStruct rgbColors.!
sendMessageInt: aWindowHandle
        msg: msgInteger
        wparamStruct: wordInteger
        lparamStruct: longInteger
    <api: SendMessageA ulong ulong struct struct long>
    ^self invalidArgument!  
selectObject: anObject
        "Select anObject into the device context and answer
          the previously selected object."
    | hPrevious |
    anObject isNil
        ifTrue: [ ^nil ]
        ifFalse: [
           self allHandles do: [ :h |
                h notNil ifTrue: [
                    hPrevious := GDILibrary selectObject: h with: anObject ] ] ].
    graphicsMedium isStoredPicture
        ifTrue: [ ^nil ]
        ifFalse: [ ^hPrevious ]!
noIntegralHeight
        "Add the no integral height style."
    ^self addStyle: LbsNointegralheight!   
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #characterTyped: ;
        add: #aboutToChange ;
        add: #changed: ;
        add: #changedIndex: ;
        add: #clicked: ;
        add: #doubleClicked: ;
        yourself!
defaultFont
        "Answer the default font for the receiver pane."
    ^ListFont! 
cursorPosition
        "Private - answer the hardware cursor position."
    | point |
    point := WinPoint new.
    ( UserLibrary  getCursorPos: point asParameter )
        ifFalse: [ ^self osError ].
    ^point asPoint!   
title: aTitle
        "Specifies the string to be placed in the title bar of the
        File dialog."
    self propertyAt: #title put: aTitle!
isColor
        "Answer whether the receiver is a Color."
    ^false!   
allOwners: anObject
        "Private - Set the owner of the receiver and all its
         submenus to anObject."
    self owner: anObject.
    items do: [ :item |
        ( item hasSubmenu ) ifTrue: [
            item submenu allOwners: anObject ] ].! 
loadCursor: instanceHandle nameString: aString
    <api: LoadCursorA ulong struct ulongReturn>
    ^self invalidArgument!   
redrawWindow: hwnd rectangle: rect region: hrgn redraw: flags
    <api: RedrawWindow ulong struct ulong ulong boolean>
    ^self invalidArgument!   
getSelection
        "Private - gets the starting and ending character positions
        of the current selection of the entry field.  The result is
        stored in the selection instance variable, and is a Point
        indicating the first selected character and the last selected
		character.  Indices are one-based."
    | start end |
    start := ExternalLong new.
    end := ExternalLong new.
    UserLibrary
        sendMessageInt: handle
        msg: EmGetsel
        wparamStruct: start asParameter
        lparamStruct: end asParameter.
    selection := ( start asInteger + 1 ) @ end asInteger.
    ^selection! 
unpackDDElParam: msg lParam: anInteger low: puInt high: puInt2
    <api: UnpackDDElParam ulong long ulong ulong boolean>
    ^self invalidArgument! 
wmKillfocus: wordInteger with: longInteger
        "Private - Process the kill focus message."
    self sendInputEvent: #losingFocus.
    ^nil!
scrollTopCorner: aPoint
        "Private - Increment the top left corner
         of the pane in the text by aPoint.
         Display the contents of the new area."
    | charExtent result |
    charExtent := aPoint // self font charSize.
    self doGraphics: [
        ( result := GDILibrary getClipBox: self pen handle rectangle: WinRectangle new asParameter ) = 0
            ifTrue: [ ^self osError ].
        ( result = Complexregion or: [ self isOffScreen ] )
            ifTrue: [ self moveTopCornerBy: charExtent ]
            ifFalse: [ self scrollTopCornerTo: topCorner - charExtent ] ]!  
setWinCursor: anInteger
        "Private - Set the mouse pointer to the host system pointer
         identified by anInteger."
    | handle |
    handle :=  self getWinCursor: anInteger.
    UserLibrary setCursor: handle!
getTabbedTextExtent: hDC
        string: lpString
        count: nCount
        nTabs: anInteger
        tabs: aWinArray
   <api: GetTabbedTextExtentA ulong struct long long struct ulongReturn>
    ^self invalidArgument!
name: aName
        "Set the receiver's printer name to aName."
    name := aName!  
refreshFrom: topLeft
    for: hInteger
    atX: xInteger
    Y: yInteger
        "Private - Display from the line pointed to by the point
         topLeft, for a height of hInteger in pixels, to
         the point (xInteger @ yInteger) in the pane."
    | firstLine lastLine maxLine loc fontHeight |
    firstLine := topLeft y.
    fontHeight := self font height.
    lastLine := firstLine + (hInteger - 1 //
        fontHeight).
    maxLine := lastLine min: list size.
    loc := xInteger @ ( yInteger + self font basePoint y ).
    self doGraphics: [firstLine to: maxLine do: [:i |
        loc y: loc y + fontHeight.
        ((loc y abs - fontHeight ) <= self height)
            ifTrue: [ self displayLine: i at: ( 1 - topLeft x * self font width ) @ loc y ] ].
    maxLine < lastLine ifTrue: [
        graphicsTool blankRestFrom: loc y + self font descender ] ]! 
allVisible
        "Private - Answer true if the receiver is completely
         within the screen."
    | hDC clipRectangle complexity |
    hDC := self getDC.
    clipRectangle := WinRectangle new.
    complexity := GDILibrary
        getClipBox: hDC
        rectangle: clipRectangle asParameter.
    self releaseDC: hDC.
    clipRectangle := clipRectangle asRectangle.
    ^complexity = Simpleregion and: [ clipRectangle = self rectangle ]!
chosenCustom
        "Public - Answers the custom colors the user defined."
    ^customColors!  
printerDefault
        "Sets the DevMode, DevNames class variables with info about the default printer"
    DevMode := DevNames := nil.
    ^self new
        style: PdReturndefault;
        open!  
endPage
        "Informs device that we are finished writing to a page."
    ( GDILibrary endPage: deviceContext ) > 0
        ifFalse: [ self osNotification ]!   
defaultPushButton
        "Set and answer the default pushbutton control style.
         Pressing 'enter' key is equivalent to selecting this
         button."
    self removeStyle: BsPushbutton.
    ^self addStyle: BsDefpushbutton! 
dragTargetDrawEmphasisLineFrom: startPoint to: endPoint
		"Private - draw an emphasis line between the given points."
	self doGraphics: [
		self pen
			setForegroundMode: MixRuleNotXor;
			setLineType: LineTypeDot;
			place: startPoint;
			line: endPoint;
			setForegroundMode: MixRuleDefault;
			setLineType: LineTypeDefault ]! 
selectionMessage
        "Private - Answer the host message for retrieving the selected item."
    ^LbGetcursel!
horizontalPixelsPerInch
        "Answer horizontal pixels per inch
        on the screen."
    ^GDILibrary
        getDeviceCaps: self deviceContext
        index: Logpixelsx!  
drawIcon: hDC x: x y: y hIcon: hIcon
    <api: DrawIcon ulong long long ulong boolean>
    ^self invalidArgument!   
getWindowWord: aWindowHandle index: anInteger
    <api: GetWindowWord ulong long ushort>
    ^self invalidArgument! 
setPenStyle: aStyle color: aColor width: aWidth
        "Set the background brush to requested attributes.
         aStyle can be PsSolid (default when nil), PsDash,
         PsDot, PsDashdot, PsDashdotdot, PsNull, or PsInsideframe.
         aColor is the pen color.
         aWidth is the pen width."
    ^self selectObject: (logicalTool :=
        WinLogicalPen style: aStyle color: aColor width: aWidth)
            handle!
removeMaximizeButtonStyle
        "Remove the maximize button style."
    ^self removeStyle: WsMaximizebox! 
sizeInBytes
         "Private - Answer the default size in bytes."
    ^40! 
hBrush
    ^self uLongAtOffset: 28!  
className
    ^self uLongAtOffset: 36!   
menuName: lpString
    self uLongAtOffset: 32 put: lpString! 
style
    ^self uLongAtOffset: 0!
hInstance
    ^self uLongAtOffset: 16!   
hInstance: aHandle
        "Private - Set the application instance handle to aHandle."
    ^self uLongAtOffset: 16 put: aHandle!
style: aStyleConstant
        "Private - Set the window style."
    self uLongAtOffset:  0 put: aStyleConstant! 
wndExtra
    ^self uLongAtOffset: 12!
hCursor
    ^self uLongAtOffset: 24! 
hCursor: aHandle
    self uLongAtOffset: 24 put: aHandle!
menuName
    ^self uLongAtOffset: 32!
hIcon
    ^self uLongAtOffset: 20!   
hIcon: aHandle
        "Private - Set the icon class handle to aHandle."
    self uLongAtOffset: 20 put: aHandle!   
clsExtra
    ^self uLongAtOffset: 8! 
windProc
        "Private - Answer the windProc address."
    ^self uLongAtOffset: 4!   
windProc: aProcAddress
        "Private - Set the winProc address."
    self uLongAtOffset: 4 put: aProcAddress!
wndExtra: aWndExtra
        "Private - Set the extra word in the window class structure
         to aWndExtra."
    ^self uLongAtOffset: 12 put: aWndExtra!
hBrush: anInteger
    self uLongAtOffset: 28 put: anInteger! 
className: lpString
        "Private - Set the window class name to lpString."
    self uLongAtOffset: 36 put: lpString!
dragSourceNeedsObjectDefault: dragSession
		"Private - provide default handling of request for item
		to be dragged."
    | dragDropObject |
	dragDropObject := dragSession objectClass new
		string: self selectedItem;
		yourself.
    dragSession objects: ( Array with: dragDropObject )!  
sizeInBytes
    ^53! 
tmAscent
    ^self longAtOffset: 4!  
tmDescent
    ^self longAtOffset: 8! 
tmFirstChar
    ^self byteAtOffset: 44!  
tmDefaultChar
    ^self byteAtOffset: 46!
tmExternalLeading
    ^self longAtOffset: 16!
tmHeight
    ^self longAtOffset: 0!  
tmInternalLeading
    ^self longAtOffset: 12!
tmOverhang
    ^self longAtOffset: 32!   
tmStruckOut
    ^self byteAtOffset: 50!  
tmWeight
    ^self longAtOffset: 28! 
tmLastChar
    ^self byteAtOffset: 45!   
tmAveCharWidth
    ^self longAtOffset: 20!   
tmItalic
    ^self byteAtOffset: 48! 
tmMaxCharWidth
    ^self longAtOffset: 24!   
tmBreakChar
    ^self byteAtOffset: 47!  
tmCharSet
    ^self byteAtOffset: 52!
tmPitchAndFamily
    ^self byteAtOffset: 51! 
tmUnderlined
    ^self byteAtOffset: 49! 
tmDigitizedAspectX
    ^self longAtOffset: 36!   
tmDigitizedAspectY
    ^self longAtOffset: 40!   
dragTargetDefaultEmphasis
		"Private - answer the type of target emphasis that should be employed
		if not otherwise specified."
	^self class dragTargetDefaultEmphasis!   
queryActive
        "Answer the handle of the window
         that is currently active."
    ^UserLibrary getActiveWindow! 
printDlg: lpPrintDlg
    <api: PrintDlgA ulong boolean>
    ^self invalidArgument!  
commDlgExtendedError
    <api: CommDlgExtendedError ulong>
    ^self invalidArgument!   
getOpenFilename: lpOpenFileName
    <api: GetOpenFileNameA ulong boolean>
    ^self invalidArgument!
getSaveFilename: lpOpenFileName
    <api: GetSaveFileNameA ulong boolean>
    ^self invalidArgument!
findText: lpFindReplace
    <api: FindTextA ulong ulongReturn>
    ^self invalidArgument!   
chooseFont: lpCommonFont
    <api: ChooseFontA ulong boolean>
    ^self invalidArgument!
chooseColor: lpCommonColor
    <api: ChooseColorA ulong boolean>
    ^self invalidArgument! 
replaceText: lpFindReplace
    <api: ReplaceTextA ulong ulongReturn>
    ^self invalidArgument! 
escape: anEscapeFunction inputData: aByteObject
        "Send anEscapeFunction with aByteObject as the
         data to the receiver device. anEscapeFunction is
         a constant from the OperatingSystemConstants pool dictionary."
    ( GDILibrary escape: deviceContext
        function: anEscapeFunction
        count: aByteObject size
        inData: aByteObject asParameter
        outData: nil ) <= 0
            ifTrue: [ ^self osError ]!
findVGAImage: aStream
        "Private - Position the stream to the beginning of the
        VGA icon image, or report an error if not found."
    | idCount bWidth bHeight bColorCount found i |
    idCount := aStream nextUShort.
    i := 0.
    found := false.
    [ found or: [ i > idCount ] ] whileFalse: [
        i := i + 1.
        bWidth := aStream nextByte.
        bHeight := aStream nextByte.
        bColorCount := aStream nextByte.
        ( ( ( bWidth = 32 ) and: [ bHeight = 32 ] ) and: [ bColorCount = 16 ] )
            ifTrue:[ found := true ]
            ifFalse: [ aStream skip: 13 ] ].
    found ifFalse: [ ^self error: 'Unsupported icon format' ].
    aStream skip: 9.! 
button1Move: aPoint
        "Private - The user moved the mouse to aPoint
         while holding down button 1."
    | sourceLocation |
    ( self isDragSource and: [ self dragOnMove and: [ self isDragSourceInitiation: aPoint ] ] ) ifTrue: [
        sourceLocation := self dragSourceLocation.
        self dragOnMove: nil location: nil.
        ( self doDragDropAt: sourceLocation button: 1 ) ifTrue: [ ^self ] ].

    "ignore event if we're capturing mouse input."
    handle = WindowHandle queryCapture ifFalse: [ ^self ].

    self selectToCursor: aPoint.
    self
        displayChanges;
        showSelection! 
enable
        "Enable the receiver and all its children.  Reimplemented
        here to support proper disabled ui behavior."
    super enable.
    self isHandleOk ifFalse: [ ^self ].
    graphicsTool foreColor: ( self propertyAt: #enabledColor ).
    self propertyAt: #enabledColor put: nil.
    self display!
fromBitmap: aBitmap andMask: andMaskBitmap
        "Private - Answer a new instance of Icon copied from aBitmap."
    | andMask xorMask extent |
    extent := self iconSize.
    andMask := Bitmap extent: extent.
    andMask pen
        copyBitmap: andMaskBitmap
        from: (0 @ 0 extent: andMaskBitmap extent)
        at: 0 @ 0.

    aBitmap isColorBitmap
        ifTrue: [xorMask := Bitmap width: extent x height: extent y planes: 1 bitCount: 4]
        ifFalse: [xorMask := Bitmap extent: extent].
    xorMask pen
        copyBitmap: aBitmap
        from: (0 @ 0 extent: aBitmap extent)
        at: 0 @ 0.
    ^super new
        initialize;
        readOnly: false;
        andMask: andMask;
        xorMask: xorMask;
        createIcon!  
sizeChanged: extent
        "Private - The size of the receiver has been changed
         to extent."
    | wp |
    self minimized ifTrue: [ ^nil ].
    self maximized ifTrue: [
        wp := WinWindowPlacement new.
        UserLibrary
            getWindowPlacement: self asParameter
            placement: wp asParameter.
        collapsed := wp rcNormalPosition asRectangle ].
    super sizeChanged: extent.!   
buildDialogItem: parentHandle
        "Private - Build the dialog item window for the receiver.
         Note - The dialog item was created using
         createDialogIndirect API call."
    | result parentFont |
    ( result := UserLibrary
        getDlgItem: parentHandle asParameter
        item: self id ) = 0
            ifTrue: [ ^self osError ].
    handle := WindowHandle fromInteger: result.

    self font isNil ifTrue: [
        self fontAttribute: ( ( parentFont := parent font ) isNil
            ifTrue: [ SysFont ]
            ifFalse: [ parentFont ] ) ].
    self event: #getContents.
    self triggerEvent: #needsContents.
    self receiveMessages.
    self buildControl: parentHandle.
    children size ~= 0 ifTrue: [
        children do: [ :each |
            ( each buildWindow: self ) isNil
                ifTrue: [ ^nil ]
                ifFalse: [ each validate ] ] ]!   
dragSourceNeedsCursors: dragSession
        "Private - retrieve the object to be dragged."

    self isDragSource ifFalse: [ ^nil ].
    self
        triggerEvent: #dragSourceNeedsCursors:
        withArguments: ( Array with: dragSession )!
losingFocus
        "Private - The receiver is losing focus. 
        Pass it on to the parent to process."
    parent losingFocus!
gettingFocus
        "Private - The receiver is getting focus. 
            Pass it on to the parent to process."
    ^parent gettingFocus!
validate
        "Private - The host window for the receiver was
         just created or recreated."
    super validate.
    self selection: value!  
graphicsToolForeColor: aColor
        "Private - Set the graphicsTool foreground color of the receiver."
    graphicsTool notNil
        ifTrue: [ graphicsTool foreColor: aColor ].
    children size ~= 0 ifTrue: [
        children do: [ :pane |
            ( pane propertyAt: #foreColor ) isNil
                ifTrue: [ pane graphicsToolForeColor: aColor ] ] ]! 
defaultMargins
        "Private - answer aPoint containing the default horizontal and vertical
        margins for a page (units in inches)."
    ^0.5@0.75!   
asRGBColorForPalette: hPalette
        "Answer the RGB equivalent of the receiver,
        using the specified palette."
    | rgb |
    rgb := WinColorref new.
    ( GDILibrary
        getPaletteEntries: hPalette
        startIndex: index
        numEntries: 1
        lpPaletteEntries: rgb asParameter ) = 0
            ifTrue: [ ^self osError ].
    ^rgb asColor! 
osEventInterruptGui
        "Private - handle an OS event (message)."
    CurrentProcess isUserIF
        ifTrue: [
            [ Notifier readWinQueue ] whileTrue: [ ].
            self enableInterrupts: true ]
        ifFalse: [ OSEventSemaphore signal ]  "which enables interrupts"!   
west
        "Set the direction of the receiver to west."

    direction :=  180!  
fromPage
        "Answers the first page number requested by the user"
    ^self propertyAt: #fromPage! 
label
        "Answer the receiver's label"
    ^self contents! 
isGroupBox
        "Answer whether the receiver is a kind of GroupBox."
    ^true!  
isTransparent
		"Private - answer whether the receiver's background
		should be painted with the same background color
		as its parent pane."
    ^true!  
setLabel: aString
        "Set the receiver's label to aString.  Answer aString."
    | newLabel |
    newLabel := ( aString isString
        ifTrue: [ aString ]
        ifFalse: [ aString isNil ifTrue: [ '' ] ifFalse: [ aString asString ] ] ).
    self label: newLabel.
    ^aString!   
label: aString
        "Set the receiver's label"
    self contents: aString!   
flipHorizontally
		"Answer a copy of the receiver flipped horizontally."
	| flippedBitmap |
	flippedBitmap := self class
		width: self width
		height: self height
		planes: self planes
		bitCount: self bitCount.
	flippedBitmap pen copyBitmapFlippedHorizontally: self.
	^flippedBitmap! 
getModified
        "Private - answer the modified state of the host control.
        Assumes 'handle = NullHandle' is false."
    ^( UserLibrary
        sendMessageInt: handle
        msg: EmGetmodify
        wparam: 0
        lparam: 0 ) ~= 0!  
grayFrame
        "Set and answer the control style for a static gray frame."
	self
		removeStyle: SsBlackframe;
		removeStyle: SsBlackrect;
		removeStyle: SsWhiteframe;
		removeStyle: SsWhiterect;
		removeStyle: SsGrayrect.
    ^self addStyle: SsGrayframe! 
isDialogTopPane
        "Answer whether the receiver is a kind of DialogTopPane."
    ^true!
chooseAFont
        "Open a dialog which lets the user choose a font.
         Answer an instance of Font."
    ^(FontDialog new open) chosen! 
getMenuString: aMenuHandle
        position: posInteger
        string: aString
        max: max
        flags: flagsInteger
    <api: GetMenuStringA ulong ulong ulong long ulong long>
    ^self invalidArgument! 
notify: aWinMessage
        "Private - Translate a host system event into the appropriate
         message sent to the window specified in the event."
    | receiver selector newWindow |
        "If the handle of the event's destination window is not present
         in the windows instance variable, it may be a newly created
         window (getting a WmCreate message)"
    ( receiver := self findWindow: aWinMessage hwnd ) isNil ifTrue: [
        ( newWindow := self class newWindow ) notNil ifTrue: [
            receiver := newWindow handle: ( WindowHandle fromInteger: aWinMessage hwnd ) ] ].
    selector := self selectorFor: aWinMessage msg.
    ( receiver isNil or: [ selector isNil ] ) ifTrue: [ ^nil ].
    ^receiver
        perform: selector
        with: aWinMessage wparam
        with: aWinMessage lparam! 
characterTyped
        "Answer the character typed.  Meaningful
         when the #characterInput event is signaled."
    ^self propertyAt: #characterTyped!   
showSelection
        "Highlight the selected line."
    self boldLine: selection!  
selectedIndex
        "Answer the index of the selected item."
    ^self selection! 
isIndexInList: itemIndex
        "Private - answer whether itemIndex is a valid index."
    ^itemIndex > 0 and: [ itemIndex <= list size ]! 
moveTopCornerBy: extent
        "Private - Move top corner by extent and
        display changes."
    self topCorner: topCorner - extent! 
selectCurrentLine
        "Private - Set selection to currentLine and
        hightlight it."
    currentLine isNil
        ifTrue: [ ^nil ]
        ifFalse: [ currentLine > list size ifTrue: [ ^nil ] ].
    self mainWindow textModified ifTrue: [
        self drawLine: currentLine.
        currentLine := selection.
        self boldLine: currentLine.
        self selectItem: self previousSelection.
        ^nil ].
    self previousSelection: selection.
    selection := currentLine !  
triggerChanged
        "Private - trigger the changed: event."
    self triggerEvent: #changed: with: self selectedItem.
    self triggerEvent: #changedIndex: with: self selectedIndex!   
restore
        "Refresh the list from the owner
         and maintain the position in the list
         without selecting it."
    topCorner == nil
        ifTrue: [topCorner := 1@1].
    self triggerEvent: #needsContents.
    self event: #getContents.
    topCorner y > list size
        ifTrue: [topCorner y: (list size max: 1)].
    selection := currentLine := nil.
    self refreshAll; updateSliders.! 
searchForLineToShow: anObject
        "Private - Search for and keep the line
         indicated by anObject showing.  anObject
         is either the index into the list or a string
         with which the list is to be searched with."
    | size index |
    list size = 0 ifTrue: [^nil].
    (anObject isInteger)
        ifTrue: [index := anObject]
        ifFalse: [
            size := list size.
            index := 1.
            [index > size or: [(list at: index) = anObject]]
                whileFalse: [index := index + 1]].
    index > list size ifTrue: [^nil].
    self isHandleOk ifTrue: [ self makeVisible: index ].
    ^index!   
selectedItem
        "Answer the selected item."
    selection isNil ifTrue: [ ^nil ].
    ^list at: selection!
isOkToChange
        "Private - answer whether it is OK to change the selection."
    ^( self hasActionForEvent: #aboutToChange )
        ifTrue: [ super isOkToChange ]
        ifFalse: [ self commitSelection ]!   
characterInput: aCharacter
        "Private - Handle typed input."
    | start string oldSelection selectionChanged |
    ( ( self hasActionForEvent: #characterTyped: ) or: [ self handlesEvent: #charInput ] )
        ifTrue: [
            self propertyAt: #characterTyped put: aCharacter.
            self event: #charInput.
            self triggerEvent: #characterTyped: with: aCharacter.
            ^self ].
    start := ( selection isNil ifTrue: [1] ifFalse: [selection + 1] ) min: list size.
    start = 0 ifTrue: [ ^self ].
    ( start to: list size ), ( 1 to: start - 1 ) do: [:i |
        string := ( self stringForItem: ( list at: i ) ) trimBlanks.
        ( string notEmpty and: [ string first asLowerCase = aCharacter asLowerCase ] ) ifTrue: [
            oldSelection := self previousSelection.
            self isOkToChange ifTrue: [
                self highlightLine: i.
                self selectCurrentLine isNil ifTrue: [^self].
                ( self makeVisible: i ) ifTrue: [
                    self refreshAll; updateSliders; boldLine: i ].
                self triggerEvent: #clicked: with: self selectedItem.
                self event: #select.
                selectionChanged := oldSelection ~= selection.
                selectionChanged ifTrue: [ self triggerChanged ].
                ^self ] ] ]!
contents: aCollection
        "Set the receiver's contents to aCollection."
    list := aCollection.
    self topCornerAttribute: self initialTopCorner.
    self selection: nil  "also causes a repaint"!
deleteItem: anItem
        "Delete anItem from the receiver's list."
    | index |
    ( index := self indexOf: anItem ) isNil ifTrue: [ ^nil ].
    self deleteIndex: index! 
setValue: anItem
        "Set the selection in the receiver's list to anItem.
        Trigger changed event if the selection has changed.
        Answer anItem."
    self setValueIndex: ( anItem isNil
        ifTrue: [ nil ]
        ifFalse: [ self indexOf: anItem ] ).
    ^anItem! 
previousSelection
		"Private - answer the index of the previous selection."
	^self propertyAt: #previousSelection!  
previousSelection: anInteger
		"Private - save the index of the previous selection."
	self propertyAt: #previousSelection put: anInteger!   
button1Up: aPoint
        "Private - Button 1 has been released.
        Let the owner process the select event."
    | oldSelection selectionChanged |
    super button1Up: aPoint.
    handle = WindowHandle queryCapture ifFalse: [ ^self ].
    self clearMouseCapture.
    oldSelection := self previousSelection.
    self isOkToChange
        ifTrue: [
            self selectCurrentLine isNil ifTrue: [ ^self ].
            selectionChanged := oldSelection ~= selection.
            self event: #select.
            self triggerEvent: #clicked: with: self selectedItem.
            selectionChanged ifTrue: [ self triggerChanged ] ]
        ifFalse: [ self selectItem: oldSelection ]!   
lineAt: index
        "Answer the line at index."
    ^list at: index!  
scrollTopCornerTo: aNewCorner
        "Private - Scroll the top left corner
         of the pane to aNewCorner.
         Display the contents of the new area."
    self scrollTopCorner: topCorner - aNewCorner
        * self font charSize!   
listFont: aFont
        "Set the receiver's font and the list pane
        font of all children to aFont."
    self font: aFont.
    super listFont: aFont!   
printSelector
        "Answer the selector which is sent to the items in list
        to format for display in the control; default = #printString."
    ^self propertyAt: #printSelector! 
printSelector: aSymbol
        "Set the selector which is sent to the items in list
        to format for display in the control; if none is set, non-String
        objects are sent #printString."
    ^self propertyAt: #printSelector put: aSymbol!   
scrollVertical: anInteger
        "Private - Scroll the pane up by anInteger
         number of pixels (if positive) or down by
         the absolute value of anInteger (if negative)."
    self scrollVertical: anInteger highlight: selection! 
deselect
        "Deselect the current selection."
    self selection notNil ifTrue: [
        self
            clearSelection;
            triggerChanged ]!
totalLength
        "Private - Answer the total number of
         lines in the list."
    ^list size! 
boldLine: anInteger
        "Private - Reverse the line indexed by
         anInteger in the receiver pane."
    | aPoint |
    ( anInteger notNil and: [ self lineInPane: anInteger ] ) ifTrue: [
        self doGraphics: [
            aPoint := ( ( self lineToRect: anInteger ) leftTop
                leftAndDown: topCorner x - 1 * self font width @ self font basePoint y ).
            graphicsTool lineDisplayHighlighted: ( self stringForItem: ( list at: anInteger ) ) at: aPoint ] ]!
display
        "Private - Display the receiver pane contents."
    self refreshAll.
    self updateSliders.
    self boldLine: currentLine!  
displayLine: lineIndex at: aPoint
        "Private - draw the line <lineIndex> at <aPoint>."
	graphicsTool
        lineDisplay: ( self stringForItem: ( list at: lineIndex ) )
        at: aPoint!
drawLine: anInteger
        "Private - Draw the line indexed by
        anInteger in the receiver pane, using the
        current foreground & background colors."
    | aPoint |
    ( anInteger notNil and: [ self lineInPane: anInteger ] ) ifTrue: [
        self doGraphics: [
            aPoint := ( ( self lineToRect: anInteger ) leftTop
                leftAndDown: topCorner x - 1 * self font width @ self font basePoint y ).
            graphicsTool lineDisplay: ( self stringForItem: ( list at: anInteger ) ) at: aPoint ] ]!
valueIndex: itemIndex
        "Set the selection in the receiver's list to the item at itemIndex."
    itemIndex isNil
        ifTrue: [ ^self clearSelection ].
    self selectIndex: itemIndex! 
list
        "Answer the list in the receiver."
    ^self contents! 
selectIndex: index
        "Select the item at itemIndex. Index starts at 1."
    self selectItem: index!   
highlightCursorLine: aPoint
        "Private - Highlight the line containing aPoint."
    self highlightLine: ( self findCurrentLine: aPoint ) !
lineInPane: anInteger
        "Private - Answer true if the line at anInteger
         is within the pane, else answer false."
    ^anInteger >= topCorner y and:
        [anInteger <=
            (topCorner y + self charsInColumn)]! 
refreshAll
        "Private - Redraw the receiver
         pane on the display screen."
    self doGraphics: [
        graphicsTool
            displayAll: ( list isNil ifTrue: [ nil ] ifFalse: [ list collect: [ :o | self stringForItem: o ] ] )
            from: topCorner y
            to: (list size min: (topCorner y + (rectangle height // self font  height)))
            at: topCorner x]! 
setValueIndex: itemIndex
        "Set the selection in the receiver's list to the item at itemIndex.
        Trigger changed event if the selection has changed.
        Answer itemIndex."
    | previousSelection anItemIndex |
    anItemIndex := itemIndex notNil
        ifTrue: [ itemIndex asInteger ]
        ifFalse: [ nil ].
    ( anItemIndex notNil
    and: [ ( self isIndexInList: anItemIndex ) not ] )
        ifTrue: [ ^nil ].  " do nothing for out-of-range index "
    previousSelection := self selectedIndex.
    self valueIndex: anItemIndex.
    self selectedIndex ~= previousSelection
        ifTrue: [ self triggerChanged ].
    ^anItemIndex! 
update
        "Refresh the list from the
         owner and display it."
    self triggerEvent: #needsContents.
    self event: #getContents.
    selection := currentLine := nil.
    topCorner := 1@1.
    self doGraphics: [
        self refreshAll.
        self updateSliders] .! 
insertItem: item at: index
        "Insert the given item into the list (and the host control)
		at the given position."
    list := list isNil
        ifTrue: [ Array with: item ]
        ifFalse: [
			index > self contents size
				ifTrue: [ list copyWith: item ]
				ifFalse: [ ( list copyFrom: 1 to: index - 1 ), ( Array with: item ), ( list copyFrom: index to: list size ) ] ].
	self isHandleOk ifTrue: [ self display ]!
topCorner: aPoint
        "Change topCorner to aPoint."
    | oldCorner |
    oldCorner := topCorner.
    topCorner := (1 max: aPoint x) @
        (1 max: (aPoint y min: list size)).
    oldCorner = topCorner
        ifFalse: [
            self refreshAll.
            self boldLine: selection]!  
highlightLine: newLine
        "Private - Set the currentLine to newLine
        and highlight it."
    newLine isNil ifTrue: [^self].
    currentLine == newLine ifFalse: [
        self drawLine: currentLine.
        currentLine := selection := newLine.
        self boldLine: currentLine]! 
button1DoubleClick: aPoint
        "Private - Button 1 has been double clicked.
        Let the owner process the event."
    self selectCurrentLine isNil ifTrue: [^self].
    Notifier consumeInputUntil: [:e| e selector = #button1Up:].
    self triggerEvent: #doubleClicked: with: self selectedItem.
    self event: #doubleClickSelect.!
commitSelection
        "Private - Answer true if list box should
        commit to selection request."
    ^[ owner commitSelection: self ]
        on: MessageNotUnderstood
        do: [ :e | self mainWindow textModified not ]! 
list: anArray
        "Set the list in the receiver."
    self contents: anArray!   
insertItem: aString
        "Append an item containing aString to the receiver's list."
    list := ( list isNil
        ifTrue: [ Array with: aString ]
        ifFalse: [ list copyWith: aString ] ).
    self isHandleOk
        ifTrue: [ self display ]!   
valueIndex
        "Answer the index of the selected item in the list."
    ^self selectedIndex!
scrollHorizontal: anInteger
        "Private - Scroll the text anInteger number
         of pixels to the left (if anInteger is
         positive) or to the right (if negative)."
    | maxLine |
    maxLine := self totalWidth * self font width.
    (anInteger < 0 and: [ maxLine <= rectangle width])
        ifFalse: [
            self topCorner: topCorner - (( anInteger / self font width ) rounded @ 0)].!   
stringForItem: item
        "Private - Answer a string for the given item (which may be
        either a string or some other object which is converted to
        a string using the current printSelector)."
    | printSelector |
    ^( printSelector := self printSelector ) isNil
        ifTrue: [ item asString ]
        ifFalse: [ printSelector evaluateFor: item ]!
indexOf: aString
        "Answer the index of the item aString."
    list isNil ifTrue: [ ^nil ].
    ^list indexOf: aString ifAbsent: [ nil ]!
maxLineBetween: x and: y
        "Private - Answer the longest line between
         line x and line y."
    | answer index |
    answer := 0.
    x to: (y min: list size) do: [:i |
        answer := ( self stringForItem: (list at: i) ) size max: answer.
        (answer = ( self stringForItem: (list at: i)) size)
            ifTrue: [index := i]].
    ^self stringForItem: ( list at: index )!   
selection
        "Answer an Integer representing the index
         of the currently selected item."
    ^selection!  
selection: anObject
        "Display the list with the line
         indicated by anObject selected.
         anObject is either the index
         into the list or a string
         with which the list is to
         be searched with."
    currentLine := self searchForLineToShow: anObject.
    selection := currentLine.
    ( self font notNil and: [ self isHandleOk ] ) ifTrue: [
        self refreshAll.
        self updateSliders.
        self boldLine: selection ]!
makeVisible: index
        "Private - Make index'th item visible if not already.
         Answer true if it was moved to be visible."
    | middle |
    (self lineInPane: index) ifTrue: [ ^false ].
    middle := index - (self charsInColumn // 2).
    middle < 1
        ifTrue: [topCorner y: 1]
        ifFalse: [topCorner y: middle].
    ^true!
restoreWithRefresh: aString
        "Refresh the list from the owner
         and keep the line equal
         to aString showing and selected."
    self triggerEvent: #needsContents.
    self event: #getContents.
    self restoreSelected: aString!
selectItem: anObject
        "Display the list with the line indicated by anObject selected.
         anObject is either the index into the list or a string with which the list is to
         be searched with."
    currentLine := self searchForLineToShow: anObject.
    selection := currentLine.
    ( self font notNil and: [ self isHandleOk ] ) ifTrue: [
        self refreshAll.
        self boldLine: selection ]!  
setList: aCollection
        "Set the receiver's list to aCollection.  Answer aCollection."
    | newList |
    newList := aCollection isString
        ifTrue: [ Array with: aCollection]
        ifFalse: [
            aCollection isNil
                ifTrue: [ Array new ]
                ifFalse: [
                    aCollection isIndexedCollection
                        ifTrue: [ aCollection ]
                        ifFalse: [ Array with: aCollection asString ] ] ].
    self list: newList.
    selection := nil.
    ^aCollection! 
totalWidth
        "Private - Answer the widest line in pane in characters."
    list size = 0 ifTrue: [^0].
    ^(self doGraphics: [graphicsTool stringWidthOf:
        (self maxLineBetween: topCorner y
            and: topCorner y + (rectangle height // self font  height))])
                // self font width!
clearSelection
        "Make no list items selected"
    self selection: nil!   
close
        "Close the receiver pane."
    super close.
    list := selection := currentLine := nil.!
contents
        "Answer the receiver's contents."
    ^list!   
deleteAll
        "Delete the whole list."
    | hasSelection |
    hasSelection := self selection notNil.
    list := Array new.
    hasSelection
        ifTrue: [ self selection: nil. self triggerChanged ]!
isIndexSelected: itemIndex
        "Private - answer whether itemIndex is selected."
    ^itemIndex = self selectedIndex!   
keyboardInput: aKeyboardInputEvent
        "Private - keyboard input was received.  Process cursor keys."
    | virtualKey newLine oldSelection selectionChanged |
    virtualKey := aKeyboardInputEvent virtualKey.
    ( virtualKey == TabKey or: [ virtualKey == BacktabKey ] )
        ifTrue: [ ^self tabKeyInput: aKeyboardInputEvent ].
    ( virtualKey == UpKey or: [ virtualKey = DownKey ] ) ifFalse: [
        ^super keyboardInput: aKeyboardInputEvent ].

    oldSelection := selection.
    self previousSelection: oldSelection.
    selection isNil ifTrue: [ ^self ].
    virtualKey == UpKey ifTrue: [
        newLine := ( selection - 1 ) max: 1.
        ( self lineInPane: newLine ) ifFalse: [
            self scrollVertical: self font  height.
            self updateVerticalSlider ] ].
    virtualKey == DownKey ifTrue: [
        newLine := ( selection + 1 ) min: list size.
        ( self lineInPane: newLine ) ifFalse: [
            self scrollVertical: 0 - self font height.
            self updateVerticalSlider ] ].
    self highlightLine: newLine.
    self selectCurrentLine isNil ifTrue: [ ^self ].

    self isOkToChange
        ifTrue: [
            selectionChanged := oldSelection ~= selection.
            self event: #select.
            self triggerEvent: #clicked: with: self selectedItem.
            selectionChanged ifTrue: [ self triggerChanged ] ]
        ifFalse: [ self selectItem: oldSelection ]!   
value
        "Answer the selected item in the list."
    ^self selectedItem!   
deleteIndex: index
        "Delete item number index from the list."
    | selectionChanged |
    selectionChanged := self isIndexSelected: index.
    list := list asOrderedCollection
        removeIndex: index;
        asArray.
    selectionChanged
        ifTrue: [ self triggerChanged ]!
hideSelection
        "Private - Turn off the reverse of the
         item indexed by selection."
    (selection notNil and:
    [self lineInPane: selection])
        ifTrue: [
            graphicsTool reverse:
                (self lineToRect: selection)]!  
value: anItem
        "Set the selection in the receiver's list to anItem."
    anItem isNil
        ifTrue: [ ^self clearSelection ].
    self selectItem: anItem!   
restoreSelected
        "Refresh the list from the owner
         and keep the old selection."
    | sel |
    sel := self selection.
    self triggerEvent: #needsContents.
    self event: #getContents.
    self refreshAll.
    self updateSliders.
    self selection: sel.
    self boldLine: selection!  
restoreSelected: anObject
        "Private - Select anObject.  Retained for compatibility."
    self
        event: #getContents;
        triggerEvent: #needsContents;
        selection: anObject! 
addClipsiblingsStyle
        "Add the clip siblings style to the receiver."
    ^self addStyle: WsClipsiblings! 
displayAt: aPoint with: aPen
        "Display the receiver using aPen at the given
         location; by default, use the printString of the
         receiver for display."
    aPen displayText: self printString at: aPoint!   
getScrollPos: aWindowHandle bar: anInteger
    <api: GetScrollPos ulong long long>
    ^self invalidArgument!   
startUp
        "Private - Initialize the class variables.  This is called
         during startup."
    DirName := Directory pathName: Disk drivePathName.!   
hasVerticalScrollBarStyle
        "Private - answer whether the receiver has a
        vertical scrollbar style."
    ^self hasStyle: WsVscroll!   
wmErasebkgnd: wordInteger with: longInteger
        "Private - Process the erase background message."
    ^nil! 
showIconicWindow
        "Private - make the window visible, as an icon."
    UserLibrary showWindow: self command: SwShowminimized!
dragSourceLocation
        "Private - answer a Point which is where dragging started."
    ^self propertyAt: #dragSourceLocation!   
owner: anOwner
        "Sets the owner of the Dialog box."
    super owner: anOwner.
    owner isWindow
        ifTrue: [ parent := owner ]
        ifFalse: [ parent := owner mainView.
                       parent isWindow ifFalse: [
                            parent := Notifier findWindow: WindowHandle queryActive ]].

    openFileNameStruct hwndOwner: parent asParameter.!   
dropDownList
        "Set and answer the control style for drop down list combo."
    self removeStyle: CbsSimple.
    self removeStyle: CbsDropdown.
    ^self addStyle: CbsDropdownlist!
notifySelected: aParameter
		"Private - the host signaled that an item was selected."
    | oldSelection newSelection selectionChanged |
    oldSelection := value.
    self doubleClickQueued ifTrue: [ ^nil ].   "do nothing if a double click queued"
    self isOkToChange
        ifTrue: [
            newSelection := self selectedIndex.
            selectionChanged := newSelection ~= oldSelection.
            self event: #select.
            self triggerEvent: #clicked: with: self selectedItem.
            selectionChanged ifTrue: [ self triggerChanged ] ]
        ifFalse: [ self selection: oldSelection ]    "restore old selection"!
isDragSource
        "Answer whether the receiver is enabled as a drag drop source."
    ^( self propertyAt: #dragSource ) notNil!  
buildDialogItem: parentHandle
        "Private - Build the dialog item window for the receiver.
            Note - The dialog item was created using
            createDialogIndirect API call."
    | hItem |
    ( hItem := UserLibrary getDlgItem: parentHandle asParameter item: self id ) = 0
        ifTrue: [ ^self osError ].
    handle := WindowHandle fromInteger: hItem.
    rectangle := Rectangle
        leftTop: ( rectangle leftTop * WindowDialog unitMultiplier )
        extent: ( rectangle extent * WindowDialog unitMultiplier ).
    self initSize: parent rectangle.
    self open.
    self font isNil ifTrue: [ self fontAttribute: SysFont ].
    self initGraphics.
    self updateRectangle.
    self receiveMessages.
    self buildControl: parentHandle.
    self display.
    children size ~= 0 ifTrue: [
        children do: [ :each |
            ( each buildWindow: self ) isNil
                ifTrue: [ ^nil ]
                ifFalse: [ each validate ] ] ]!  
copyStruct
        "Private - copies the printDlgStruct to nonSmalltalk memory"
    | temp |
    temp := ExternalAddress copyToNonSmalltalkMemory: printDlgStruct contents.
    printDlgStruct := SelfDefinedStructure named: 'PRINTDLG' atAddress: temp.
    DevMode notNil ifTrue: [
        hDevMode := ExternalAddress memoryHandleFrom: DevMode contents.
        printDlgStruct hDevMode: hDevMode ].
    DevNames notNil ifTrue: [
        hDevNames := ExternalAddress memoryHandleFrom: DevNames contents.
        printDlgStruct hDevNames: hDevNames ]!  
sizeInBytes
    ^64! 
rectangle
    ^WinRectangle fromBytes:
        ( self bytesAtOffset: 8 count: WinRectangle sizeInBytes )!   
rectangle: aByteArray
    self bytesAtOffset: 8 put: aByteArray! 
dcHandle
    ^self uLongAtOffset: 0! 
eraseFlag
    ^self uLongAtOffset: 4!
eraseFlag: anInteger
    self uLongAtOffset: 4 put: anInteger!   
fRestore
	^self booleanAtOffset: 24! 
fIncUpdate
	^self booleanAtOffset: 28!   
dcHandle: anInteger
    self uLongAtOffset: 0 put: anInteger!
rgbReserved
	^self bytesAtOffset: 32 count: 32!  
activeMainWindow
        "Answer the active main window."
    ^self findWindow: WindowHandle queryActive!   
displayAt: aPoint font: aFont
        "Output the receiver onto the display screen
         at aPoint with font aFont."
    | oldFont |
    oldFont := Display pen font.
    Display pen
        font: aFont;
        displayText: self at: aPoint.
    Display pen font: oldFont!
wmPowerbroadcast: wparam with: lparam
        "Private - handle power management notifications."
	| eventType |
	wparam = "PbApmquerysuspend" 16r0 ifTrue: [ eventType := 'suspend request' ].
	wparam = "PbApmquerystandby" 16r1 ifTrue: [ eventType := 'standby request' ].
	wparam = "PbApmquerysuspendfailed" 16r2 ifTrue: [ eventType := 'suspend request failed' ].
	wparam = "PbApmquerystandbyfailed" 16r3 ifTrue: [ eventType := 'standby request failed' ].
	wparam = "PbApmsuspend" 16r4 ifTrue: [ eventType := 'suspend' ].
	wparam = "PbApmstandby" 16r5 ifTrue: [ eventType := 'standby' ].
	wparam = "PbApmresumecritical" 16r6 ifTrue: [ eventType := 'resume critical' ].
	wparam = "PbApmresumesuspend" 16r7 ifTrue: [ eventType := 'resume suspend' ].
	wparam = "PbApmresumestandby" 16r8 ifTrue: [ eventType := 'resume standby' ].
	wparam = "PbApmbatterylow" 16r9 ifTrue: [ eventType := 'battery low' ].
	wparam = "PbApmpowerstatuschanged" 16rA ifTrue: [ eventType := 'status changed' ].
	wparam = "PbApmoemevent" 16rB ifTrue: [ eventType := 'oem' ].

	SessionModel current triggerEvent: #powerChange: with: eventType.

    ^nil! 
selectToShifted: aPoint
        "Private - Extend the selection to
         the cursor position for shifted
         mouse select button."
    | sPoint |
    sPoint := self stringCoordinate:
        aPoint.
    (rectangle containsPoint: aPoint)
        ifTrue: [
            (sPoint isBefore: selection origin)
                ifTrue: [
                    selection extendOrigin:
                        selection corner + (1@0)]
                ifFalse: [
                    selection extendOrigin:
                        selection origin]].
    ^self selectToCursor: aPoint!   
updateWindow
        "Private - Force display of the receiver window."
    ( UserLibrary updateWindow: handle )
        ifFalse: [ ^self osError ]!
wmCreate: wordInteger with: longInteger
        "Private - Process the create message."
    ^nil!   
isHandleForPopupMenu: anInteger
        "Private - Answer true if the handle of the popup menu is anInteger."
    self popup isNil ifTrue: [ ^false ].
    ^self popup window handle asInteger = anInteger!
addExtendedStyle: styleBits
        "Private - if extendedStyle is nil, initialize it appropriately:
         if #noDefaultStyle was previously sent to the receiver,
         set it to 0, otherwise set it to defaultExtendedStyle; then add the
         given style bits to the flag.  Answer the added styleBits."
    self extendedStyle isNil ifTrue: [ self extendedStyle: self defaultExtendedStyle ].
    self extendedStyle: self extendedStyle | styleBits.
    ^styleBits!
disableMenu: aMenu
    "Disable the menu <aMenu> in the receiver menu bar."
    | menuItem |
    parent isNil
        ifTrue: [ ^nil ].  "Not a menu in a menu bar"
    menuItem := aMenu menuItem.
    menuItem attribute: menuItem attribute | MfGrayed.
    UserLibrary
        enableMenuItem: self handle
        item: ( menuItem id // 256 ) - 2
        flags: menuItem attribute | MfByposition.
    UserLibrary drawMenuBar: parent asParameter! 
logicalTool: penObject
        "Private - Set the pen object to hObject."
    logicalTool := penObject! 
constructEventsTriggered
        "Private - answer the set of events that instances of the
        receiver can trigger."
    ^super constructEventsTriggered
        add: #characterTyped: ;
        add: #aboutToChange ;
        add: #changed: ;
        add: #changedIndex: ;
        add: #clicked: ;
        add: #doubleClicked: ;
        add: #drawItem: ;
        add: #drawFocus: ;
        add: #drawSelection: ;
        add: #measureItem: ;
        yourself!   
dragOnMove
		"Private - answer whether a selection has been 'picked' in
		the receiver & the next mouse move should begin a
		drag-drop transfer."
    ^self propertyAt: #dragOnMove ifAbsent: [ false ]! 
closeClipboard
    <api: CloseClipboard boolean>
     ^self invalidArgument!
leftJustified
        "Add the left-justified style."
    self
        removeStyle: EsCenter;
        removeStyle: EsRight;
        addStyle: EsLeft.
    self setStyle: self style!
pointToIndex: aPoint
        "Private - Convert a (offset in line, line) to
        offset from beginning of the text."
    | offsetToLine offsetInLine lineLength |
    offsetToLine := UserLibrary
        sendMessageInt: handle
        msg: EmLineindex
        wparam: aPoint y - 1
        lparam: 0.
    offsetToLine = -1 ifTrue: [ ^self contents size ].
    lineLength := UserLibrary
        sendMessageInt: handle
        msg: EmLinelength
        wparam: aPoint y - 1
        lparam: 0.
    offsetInLine := aPoint x.
    ^offsetToLine + offsetInLine!
initSize: aRectangle
        "Private - Initialize the frame of the receiver pane
         to aRectangle."
    rectangle := self initialRectangleFor: aRectangle.
    rectangle extent: ( rectangle extent max: 0@0 )!
enableControls
        "Private - Enable the scrollbars of the receiver
         and enable its children."
    UserLibrary enableScrollBar: handle type: SbBoth flags: EsbEnableBoth.
    self enable.
    children size ~= 0 ifTrue: [
        children do: [ :each | each enableControls ] ]! 
allPages
        "Answers whether the user has selected all pages"
    ^( self style & PdSelection ) = 0 and: [ ( self style & PdPagenums ) = 0 ]!  
setWindowLong: aWindowHandle index: anInteger long: longInteger
    <api: SetWindowLongA ulong long long long>
    ^self invalidArgument!   
sendDlgItemMessageInt: hDlg
        item: nIDDlgItem
        msg: wMsg
        wparam: wParam
        lparam: lParam
    <api: SendDlgItemMessageA ulong long ulong ulong ulong long>
    ^self invalidArgument!
boxOfSize: aPoint
        "Draw a box using the current location as one
         corner with extent aPoint."
    self box: (self location + aPoint)!   
displayHighlightedText: string at: displayPoint
        "Display the given <string> at the <displayPoint> using the system settings for
        highlight background & foreground colors, and blank out the background behind it
        (but not the rest of the pane width, like #lineDisplay:at: does)."
    | oldForeColor oldBackColor highlightForeColor highlightBackColor |
    oldForeColor := self foreColor.
    oldBackColor := self backColor.
    highlightForeColor := Color highlightText.
    highlightBackColor := Color highlightBackground.
    [ self
        foreColor: highlightForeColor;
        backColor: highlightBackColor;
        displayUnhighlightedText: string at: displayPoint ]
            ensure: [ self foreColor: oldForeColor; backColor: oldBackColor ]!  
isSubPane
        "Answer whether the receiver is a kind of SubPane."
    ^false!   
graphicsMedium
        "Answer the GraphicsMedium associated with
          the receiver."
    ^graphicsMedium!
isChecked: item
        "Answer true if item is checked.
         item can be the label or the selector."
    | mi |
    mi := self getMenuItem: item.
    ^( mi attribute bitAnd: MfChecked ) ~= 0! 
startUp
        "Private - Initialize the class."
    | aWindow |
    aWindow := self new open.
    OperatingSystemEventsExtra removeKey: WmStcallback ifAbsent: [ ].
    WmStcallback := nil.
    self wmStcallback.  "register the message, and reassign WmStcallback"
    OperatingSystemEventsExtra at: WmStcallback put: #wmStcallback:with: .
    self current: aWindow!
windowClass
        "Private - Answer the receiver's window class."
    ^'BUTTON'!  
pasteSelection
        "Paste the Clipboard contents into the control"
     UserLibrary
        sendMessage: handle
        msg: WmPaste
        wparam: 0
        lparam: 0!   
height
        "Answer the height of the receiver."
    ^height!
scrollHorizontalCharacters: anInteger
        "Private - Scroll the pane left by anInteger
         number of characters (if positive) or right by
         the absolute value of anInteger (if negative)."
    UserLibrary
        sendMessageInt: handle
        msg: EmLinescroll
        wparam: anInteger negated
        lparam: 0! 
dragTargetMultipleItem
        "Answer whether the the receiver will accept multiple
        item drag-drop transfers."
    ^self propertyAt: #dragTargetMultipleItem ifAbsent: [ self class dragTargetMultipleItemDefault ]!  
contextForPopup: anInteger
        "Private - the user has popped up a menu; answer a
        string for preview help."
    ^self popup contextForPopup: anInteger!
graphicsMedium
        "Private - Answer the graphicsMedium of the font."
    ^graphicsMedium!  
waitMessage
        "Private - Give Windows control until a message comes in."
    <api: WaitMessage boolean>
    ^self invalidArgument!   
scrollHorizontally
    "Add a horizontal scroll bar to the receiver."

    self addHorizontalScrollbarStyle!   
isButton2Down
        "Answer whether the right mouse button is down."
    ^self isKeyDown: VkRbutton!  
showDropdown: aBoolean
        "Show or hide the listbox part of the receiver."
    self isHandleOk
        ifTrue: [
            UserLibrary
                sendMessage: handle
                msg: CbShowdropdown
                wparam: aBoolean asParameter
                lparam: nil ]
        ifFalse: [ self whenValid: #showDropdown: with: aBoolean ]! 
maximized
        "Private - Answer true if the receiver is maximized."
    ^UserLibrary isZoomed: self asParameter!
isDialog
        "Answer true if the receiver is the window for a dialog box."
    ^true!   
sameLogicalFont: aFont
        "Answer true if the receiver has
         the same logical font as aFont."
    ^(aFont class == self class)
        and: [self logicalFont contents = aFont logicalFont contents]! 
text
        "Answer the text of the entry field in the combo box."
    ^self isHandleOk
        ifTrue: [ self windowText ]
        ifFalse: [ self textAttribute ]! 
entryField
        "Answer the control window for the EntryField part of the receiver."
    ^entryField!
triggerChanged
        "Private - trigger the changed event."
    self isDropDownList
        ifTrue: [ ^super triggerChanged ].
    self triggerEvent: #changed: with: self text!
isComboBox
        "Answer whether the receiver is an instance of class
         ComboBox or one of its subclasses."
    ^true!
notifyTextChanged: aParameter
		"Private - the host signaled that the text has changed."
    self event: #textChanged.
    self triggerEvent: #textChanged: with: self value!  
listValue
        "Answer the selected item in the list attached to the receiver."
    ^self selectedItem!  
previousValue
        "Answer the previous value of the receiver.
        The previous value is the value prior to any
        user changes (when there is a #changed: handler)
        or the last time previousValue was sent."
    ^self propertyAt: #previousValue!  
previousValue: aValue
        "Set the previous value of the receiver."
    ^self propertyAt: #previousValue put: aValue!   
setValue: aString
        "Set the text of the entry field in the combo box to aString.
        Trigger the changed event if the value is different.
        Answer aString. "
    | newValue |
    newValue := ( aString isString
        ifTrue: [ aString ]
        ifFalse: [ aString isNil ifTrue: [ '' ] ifFalse: [ aString asString ] ] ).
    newValue ~= self text ifTrue: [
        self
            value: newValue;
            triggerChanged;
            previousValue: newValue ].
    ^newValue!
textAttribute
        "Private - answer the stored value of the text field."
    ^text! 
textAttribute: aString
        "Private - set the text attribute of the combo box."
    text := aString!
entryField: aComboEntryField
        "Private - set the EntryField part of the receiver to aComboEntryField."
    entryField := aComboEntryField!   
notifySelected: aParameter
		"Private - the host signaled that an item was selected."
    self previousValue: self value.
    super notifySelected: aParameter!
modified: aBoolean
        "Mark the receiver as modified/not modified, depending on
        value of aBoolean."
    self textAttribute: self text.
    self propertyAt: #modified put: aBoolean! 
entryFieldClass
        "Private - answer the class of the entry field part of the receiver."
    ^ComboEntryField! 
initialize
        "Private - initialize the receiver."
    super initialize.
    self textAttribute: String new
	!   
initialText
        "Private - Answer the receiver's initial text string"
    ^self textAttribute!  
losingFocus
        "Private - Trigger changed: if the value has really changed."
    | newValue |
    self isDropDownList
        ifTrue: [^super losingFocus].
    ( self hasActionForEvent: #changed: )
        ifTrue: [
            self textAttribute: (newValue := self windowText).
            newValue ~= self previousValue
                ifTrue: [
                    self
                        modified: true;
                        triggerChanged;
                        previousValue: newValue ].
            ^self ].
    ^super losingFocus!  
hasFocus
        "Answer true if the receiver currently has the focus."
    ^super hasFocus or: [ entryField notNil and: [ entryField hasFocus ] ]! 
validate
        "Private - Create the receiver."
    super validate.
    self sendDeferredEvent: #setEntryField.
    ( self hasActionForEvent: #changed: )
        ifTrue: [ self previousValue: self value ].! 
modified
        "Answer whether the receiver has been modified."
    ( self propertyAt: #modified ifAbsent: [ false ] )
        ifTrue: [ ^true ].
    ^self textAttribute ~= self text! 
close
        "Private - close the receiver, and detach its entry field
        from the Notifier."
    entryField notNil ifTrue: [entryField stopReceivingMessages].
    super close!
text: aString
        "Set the text of the entry field in the combo box."
    self textAttribute: aString.
    self isHandleOk
        ifTrue: [ self setWindowText: aString ]!   
value
        "Answer the value in the entry field of the combo box."
    self isDropDownList
        ifTrue: [ ^super value ].
    ^self text!   
getText
        "Set the value instance variable from the host control's value.
        Assumes 'handle = NullHandle' is false."
    ^value := self windowText!
value: aString
        "Set the text of the entry field in the combo box to aString."
    | itemIndex |
    self isDropDownList
        ifTrue: [ ^super value: aString ].
    itemIndex := self list isNil
        ifTrue: [ nil ]
        ifFalse: [ self list indexOf: aString ifAbsent: [ nil ] ].
    self
        selectIndex: itemIndex;
        text: aString;
        modified: false!
close
        "Private - Close the receiver and destroy the device context."
    graphicsTool release.
    ^super close!   
offset: aPoint
        "Set the mouse cursor position to aPoint.
         Answer the new position."
    ( UserLibrary setCursorPos: aPoint x y: aPoint y )
        ifFalse: [ ^self osError ].
    ^aPoint!  
fill: aColor
        "Fill the receiver medium with aColor."
    self fill: self canvasBox color: aColor!   
destroyAcceleratorTable: haccel
    <api: DestroyAcceleratorTable ulong boolean>
    ^self invalidArgument! 
winHelp: hWnd helpFile: aString command: anInteger dataUL: aULong
    <api: WinHelpA ulong struct ulong ulong boolean>
    ^self invalidArgument!   
bitCoordinate: aPoint
        "Private - Calculate the bit coordinates of
         aPoint relative to the pane frame."
    | p f top frame xOffset line |
    f := self font.
    top := self topCorner.
    frame := self rectangle.
	line := self lineAt: aPoint y.
	self doGraphics: [
        xOffset := ( self pen stringWidthOf: line at: aPoint x "- 1"  ) - ( top x - 1 * f width ) ].
	p := frame leftTop rightAndDown: xOffset @ ( aPoint y - top y * f height ).
	( self hasStyle: WsBorder ) ifTrue: [ p := p rightAndDown: 4 ].
	p := ( p rightMostAndLowest: ( frame leftTop leftAndUp: f charSize ) )
		leftMostAndHighest: ( frame rightBottom rightAndDown: f charSize ).
	^p! 
dragTargetEmphasisTypesSupported
		"Private - answer a collection of emphasis types that the receiver can support."
	^#( 'pane' 'item' 'separator' )!   
initialSize: aSize
        "Set the initial window size to aSize."
    rectangle := aSize isRectangle
        ifTrue: [ aSize ]
        ifFalse: [
            aSize isPoint
                ifTrue: [ self boxOfSize: aSize ]
                ifFalse: [ nil ] ]! 
originalHandle
        "Private - Answer the font handle."
    ^handle! 
white
        "Set the color of the receiver to white.
          Retained for compatibility."
    self foreColor: Color white! 
saveSegments
        "Private - Do nothing since only RecordingPens have segments."! 
wmKillfocus: wordInteger with: longInteger
        "Private - Process the kill focus message."
    super wmKillfocus: wordInteger with: longInteger.
    graphicsTool notNil ifTrue: [ graphicsTool release ].
    selection destroyCaret!
changeRuntimeIcon
        "Private - Change the icon of the window class used to create
        Smalltalk windows."
    | hwnd icon |
    ( hwnd := UserLibrary
        findWindow: OperatingSystem winClassName asParameter
        windowName: nil ) = 0
        ifTrue: [ ^self osError ].
    icon := Icon runtimeIcon.
    UserLibrary
        setClassLong: hwnd asParameter
        index: GclHicon
        value: icon handle!
wmActivate: wordInteger with: longInteger
        "Private - Process the activate message synchronously."
    self sendInputEvent:
        (wordInteger lowWord = 0
            ifTrue:  [#deactivate]
            ifFalse: [#activate]).
    ^nil! 
getValue
        "Private - Get the value of the receiver as a boolean."
    | result |
    self isHandleOk ifFalse: [ ^value ].
    result := UserLibrary
        sendMessageInt: handle
        msg: BmGetcheck
        wparam: 0
        lparam: 0.
    ^value := result ~= 0!
selectToCursor: point
        "Private - Extend the selection to the
         cursor position if the Cursor is inside
         the pane, otherwise scroll the pane
         towards the cursor."
    | amount |
    (rectangle containsPoint: point) ifTrue: [
        ^selection selectToBit: point].
    self captureMouseInput.
    (point y isAbove: rectangle top)
        ifTrue: [   "scroll up"
            amount := (point y - rectangle top) abs.
            selection selectTo: (self stringCoordinate: rectangle leftTop).
            amount := amount > (8*SysFontHeight)
                ifTrue: [self amountToPageUp]
                ifFalse: [self amountToScrollUp].
            self scrollVertical: amount.
            ^self updateSliders].
   (rectangle bottom isAboveEqual: point y)
        ifTrue: [   "scroll down"
            amount := (rectangle bottom - point y) abs.
            selection selectTo: (self stringCoordinate: point).
            amount := amount > (8*SysFontHeight)
                ifTrue: [self amountToPageUp negated]
                ifFalse: [self amountToScrollUp negated].
            self scrollVertical: amount.
            ^self updateSliders].
    (point x isLeftOf: rectangle left)
        ifTrue: [   "scroll left"
            selection selectToBit: (rectangle leftBottom x @ (point y higherOf: rectangle leftBottom y)).
            ^topCorner x > 1
                ifTrue: [self scrollHorizontal: SysFontWidth]].
    (point x isRightEqualOf: rectangle right)
        ifTrue: [   "scroll right"
            selection selectToBit: rectangle right @
                (point y higherOf: rectangle leftBottom y).
            ^self scrollHorizontal: SysFontWidth negated].!  
mouseLocation
        "Answer the mouse location as of the last
         mouse input event received."
    ^mouse dpToLp: graphicsTool handle!  
mm: anInteger
    self longAtOffset: 0 put: anInteger!   
xExt
    ^self longAtOffset: 4!  
yExt
    ^self longAtOffset: 8!  
mm
    ^self longAtOffset: 0!
xExt: anInteger
    self longAtOffset: 4 put: anInteger! 
yExt: anInteger
    self longAtOffset: 8 put: anInteger! 
hMF
    ^self uLongAtOffset: 12! 
hMF: anInteger
    self uLongAtOffset: 12 put: anInteger!
contextForPopup:anInteger
        "Private - answer nil because DialogTopPane does
        not have a menu bar."
    ^nil! 
wmVScroll: wordInteger with: longInteger
        "Private - Process the vertical scroll message."
    | type slider |
    "if message is from a child window, call super to pass it on to the child window."
    longInteger = 0 ifFalse: [ ^super wmVScroll: wordInteger with: longInteger ].
    type := wordInteger lowWord.
    type = SbLineup ifTrue: [ self scrollVertical: self amountToScrollUp ].
    type = SbLinedown ifTrue: [ self scrollVertical: self amountToScrollUp negated ].
    type = SbPageup ifTrue: [ self scrollVertical: self amountToPageUp ].
    type = SbPagedown ifTrue: [ self scrollVertical: self amountToPageUp negated ].
    type = SbThumbposition ifTrue: ["end of tracking"
        slider := ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2.
        self updateVerticalSliderTo: wordInteger highWord.
        ^nil ].
    type = SbThumbtrack
        ifTrue: [
            slider := ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2.
            self isOffScreen
                ifTrue: [
                    self moveTopCornerBy: self topCorner - (self topCorner x
                        @ (slider * self totalLength // 100 + 1))]
                ifFalse: [
                    self scrollTopCornerTo: (self topCorner x
                        @ (slider * self totalLength // 100 + 1))]]
        ifFalse: [ "Do not update the bar for SbSlidertrack."
            self updateVerticalSlider].
   ^nil! 
sampleForeColor
        "Answer the foreground color of the sample string."
    ^self
        propertyAt: #sampleForeColor
        ifAbsent: [ self class defaultSampleForeColor ]!   
charAsLower: charValue
    <api: CharLowerA ulong ulongReturn>
    ^self invalidArgument!   
getMnemonicHandler: char
        "Private - Check if this control handles this mnemonic.
        Answer the receiver if it does, else nil."
    | index |
    ( label isNil or: [ self disabled ] ) ifTrue: [ ^nil ].
    ^( ( index := ( label indexOf: '\u' replaceEscapeCharacters first ) ) ~= 0
        and: [ ( label at: index + 1 ) asLowerCase == char asLowerCase ] )
        ifTrue: [ self ]
        ifFalse: [ nil ]!
isTransparent
		"Private - answer whether the receiver's background
		should be painted with the same background color
		as its parent pane."
    ^true!  
value
        "Answer the text contents of the receiver."
    ^self contents!   
value: aString
        "Set the text contents of the receiver to aString."
    self contents: aString!  
mnemonic: char typedIn: aPane
        "The receiver's mnemonic was typed in the
        sibling <aPane>.  Perform a programmatic button click."
    self
        sendInputEvent: #triggerEvent:
        with: #mnemonicTyped!
setValue: aValue
        "Set the text contents of the receiver to the string
        representing aValue.  Answer aValue."
    | newValue |
    newValue := ( aValue isString
        ifTrue: [aValue]
        ifFalse: [aValue isNil ifTrue: [ '' ] ifFalse: [aValue asString]] ).
    self value: newValue.
    ^aValue!   
sizeInBytes
    ^40! 
nextPutAll: aString
        "Display aString at the current position."
    | anInteger c stringWithoutCrs |
    stringWithoutCrs := aString zapCrs.
    anInteger := 1.
    1 to: stringWithoutCrs size do: [ :index |
        c := stringWithoutCrs at: index.
        c = Lf
            ifTrue: [
                self displayText:
                    (stringWithoutCrs copyFrom: anInteger to: index - 1).
                self cr.
                anInteger := index + 1]].
    self location x > width ifTrue: [self cr].
    self displayText:
        (stringWithoutCrs copyFrom: anInteger to: stringWithoutCrs size)! 
zoom
        "Private - Make the subpane with the focus zoom to fill the entire
        client area; if the subpane with the focus is the child of a GroupPane,
        zoom the whole (topmost) GroupPane."
    | pane bottomPane mainWindow |
    ( pane := bottomPane := self subPaneWithFocus ) isNil
        ifTrue: [ ^self ].
    mainWindow := self mainWindow.
    [ pane parent == mainWindow ]
        whileFalse: [pane := pane parent].
    pane zoom.
    bottomPane setFocus.
    self updateZoomMenu! 
wmMove: wparam with: lparam
        "Private - the receiver has been moved on the Display.  Close
        any open drop down controls (workaround for apparent Win32 bug)."
    self allChildrenDo: [ :child |
        ( child isDropDownList or: [ child isComboBox and: [ child isSimpleList not ] ] )
            ifTrue: [ child showDropdown: false ] ].
    ^nil! 
helpManager
        "Answer the receiver help Manager"
    ^self mainWindow helpManager!
destroy
        "Private - Destroy the whole window and
        release all the resources back to system."
    ( UserLibrary destroyWindow: handle )
        ifFalse: [ ^self osNotification ].
    handle := WindowHandle nullValue!
outOfMemory
        "Private - Low resource situation;
         close children already created"
    children size > 0 ifTrue: [
        children do: [ :subpane |
            subpane isHandleOk ifTrue: [ subpane close ] ] ].
    self stopReceivingMessages.
    MessageBox new
        iconStop;
        ok;
        title: 'Error';
        message: 'Unable to create window: out of\operating system resources' withCrs;
        open! 
drawAnisotropic
        "Draw the requested control item stretching to fit
        the dimensions."
     drawSelector := #anisotropic:!
anisotropic: aDrawStruct
        "Private - Draw the requested control item stretched."
    bitmap notNil ifTrue: [
        self graphicsTool
            blank: aDrawStruct boundingBox;
            copyBitmap: bitmap
                from: bitmap boundingBox
                to: aDrawStruct boundingBox ].
     ^nil!   
drawHighlight: aDrawStruct
        "Private - Highlight the item to be drawn."
    self triggerEvent: #drawSelection
        ifNotHandled: [ super drawHighlight: aDrawStruct ]!   
isotropic: aDrawStruct
        "Private - Draw the requested control item without
        stretching."
    bitmap notNil ifTrue: [
        self graphicsTool
            blank: aDrawStruct boundingBox;
            copyBitmap: bitmap
                from: bitmap boundingBox
                at: aDrawStruct boundingBox origin ].
     ^nil!
fixedSize
        "If the receiver has a bitmap for its
         label (contents), draw the bitmap
         at its fixed size."
    self drawIsotropic!   
drawItem: aDrawStruct
        "Private - Draw the requested control item."
    bitmap isNil ifTrue: [
        self event: #drawItem.
        self triggerEvent: #drawItem.
        ^true ].
    self perform: drawSelector with: aDrawStruct.
    ^true!   
initialize
        "Private - Initialize drawn button."
    super initialize.
    self drawIsotropic!  
gettingFocus
        "Private - The receiver is getting the input focus."
    self subPaneWithFocus: self.
    self triggerGettingFocus!   
drawIsotropic
        "Draw the requested control item preserving 
        bitmap dimensions."
     drawSelector := #isotropic:!   
stretchToFit
        "If the receiver has a bitmap for its
         label (contents), stretch or shrink the bitmap
         so it fills the receiver."
    self drawAnisotropic!  
contents
        "Answer the bitmap for the receiver, if any."
    ^bitmap! 
contents: aBitmap
        "Set the bitmap associated with this button to aBitmap
        and draw it."
    bitmap := aBitmap.
    self isHandleOk ifTrue: [ self invalidateRect: nil ]!   
losingFocus
        "Private - The receiver is losing focus."
    self triggerLosingFocus!  
setLabel: aBitmap
        "Set the label of the receiver to aBitmap.  Answer aBitmap."
    self contents: aBitmap.
    ^aBitmap!   
currentPrinterMode
        "Answers a DEVMODE selfDefinedStructure containing
        the current printer device name and setup"
    DevMode isNil ifTrue: [ self printerDefault ].
    ^DevMode! 
leftButtonScrollTimerId
        "Private - answer the ID of the timer to use to process left button scrolling."
    ^1! 
editMenu
        "Answer the standard Edit menu."
    ^Menu new
        title: '\uEdit' replaceEscapeCharacters;
        appendItem: '\uUndo\tCtrl+Z' replaceEscapeCharacters selector: #undo accelKey: $Z accelBits: AfControl;
        accelKey: BackspaceKey accelBits: AfAlt for: #undo;
        appendSeparator;
        appendItem: 'Cu\ut\tCtrl+X' replaceEscapeCharacters selector: #cutSelection accelKey: $X accelBits: AfControl;
        accelKey: DeleteKey accelBits: AfShift for: #cutSelection;
        appendItem: '\uCopy\tCtrl+C' replaceEscapeCharacters selector: #copySelection accelKey: $C accelBits: AfControl;
        accelKey: InsertKey accelBits: AfControl for: #copySelection;
        appendItem: '\uPaste\tCtrl+V' replaceEscapeCharacters selector: #pasteSelection accelKey: $V accelBits: AfControl;
        accelKey: InsertKey accelBits: AfShift for: #pasteSelection;
        appendSeparator;
        appendItem: 'Cl\uear\tDel' replaceEscapeCharacters selector: #clearSelection; "accelKey: DeleteKey accelBits: 0;"
        appendItem: 'Select \uAll\tCtrl+A' replaceEscapeCharacters selector: #selectAll accelKey: $A accelBits: AfControl;
        appendItem: '\uRestore\tCtrl+R' replaceEscapeCharacters selector: #restore accelKey: $R accelBits: AfControl;
        appendSeparator;
        appendItem: '\uFind/Replace...\tCtrl+F' replaceEscapeCharacters selector: #findReplace accelKey: $F accelBits: AfControl;
        appendItem: 'Find A\ugain\tCtrl+G' replaceEscapeCharacters selector: #again accelKey: $G accelBits: AfControl;
        yourself!
consumeInputUntil: aBlock
        "Consume all input events until aBlock evaluates true.  aBlock takes
        one argument which is the current Message event."
    | e |
    [ CurrentEvents isEmpty ] whileTrue: [ self readWinQueue ].
    [ e := CurrentEvents removeFirst ] evaluateWithoutInterrupts.
    [ aBlock value: e ] whileFalse: [
        [ CurrentEvents isEmpty ] whileTrue: [ self readWinQueue ].
        [ e := CurrentEvents removeFirst ] evaluateWithoutInterrupts ]!
isWindow
        "Answer true if receiver is a kind of Window."
    ^false! 
asLayoutRatio
    "Convert the receiver to a layoutFrame with variable ratios."

    ^LayoutFrame
        topRatio: self top
        leftRatio: self left
        bottomRatio: self bottom
        rightRatio: self right! 
createHostFeatures
        "Private - add host-specific features to the receiver."
    ( self paneAt: #find ) addGroupStyle!
password
        "Add the password style."
    ^self addStyle: EsPassword!  
selectStockObject: aStockObject
        "Private - Select aStockObject into the device context."
    ^self selectObject: ( self class getStockObject: aStockObject )!   
horizontalScrollMaxRange
        "Private - Answer the horizontal scrollbar's max range"
    | maxPos |
    ( UserLibrary
        getScrollRange: self handle asParameter
        bar: SbHorz
        lpMinPos: ExternalLong new asParameter
        lpMaxPos: ( maxPos := ExternalLong new ) asParameter )
            ifFalse: [ ^self osError ].
    ^maxPos asInteger!   
graphicsToolClass
        "Private - Answer the graphics tool class used by the receiver."
    ^Pen!
resize: aRectangle deferInfo: winPosInfo
        "Private - Change the frame of the receiver pane
         to aRectangle.  Delay the drawing and collect
         the drawing information in winPosInfo."
    | posInfo |
    rectangle := self deferredResizeRectangleFor: aRectangle.
    rectangle extent: ( rectangle extent max: 0@0 ).
    posInfo := self resizeWindow: winPosInfo.
    ^posInfo!  
print: aString font: aFont title: aTitle
        "Open a print dialog to allow printing of the given string
        using the given title & font; answer the receiver."
    | dialog hDCPrinter printer |
    dialog := PrintDialog new
        noSelection;
        noPages;
        open.
    ( hDCPrinter := dialog hDCPrinter ) isNil ifTrue: [ ^self ].
    printer := self fromDC: hDCPrinter.
    [ printer
        print: aString
        font: aFont
        title: aTitle
        collate: dialog collate
        copies: dialog copies
        wordWrap: false
        marginsRect: nil ] forkAt: 3!  
exists
        "Answers true if the printer is present else it answers false."
    | printerInfo cb driverName deviceName printerPort |
    "retrieve printer information from WIN.INI file."
    printerInfo := ( String new: 80 ) asParameter.
    cb := KernelLibrary getProfileString: 'windows' asParameter
        keyName:  'device' asParameter
        default: String new asParameter
        returnedString: printerInfo
        size: printerInfo size.
    printerInfo := printerInfo asNormalizedString.
    deviceName := ( printerInfo copyFrom: 1 to: ( printerInfo indexOf: $, ) - 1 ) trimBlanks.
    printerInfo := printerInfo copyFrom: ( printerInfo indexOf: $, ) + 1 to: printerInfo size.
    driverName := ( printerInfo copyFrom: 1 to: ( printerInfo indexOf: $, ) - 1 ) trimBlanks.
    printerInfo := printerInfo copyFrom: ( printerInfo indexOf: $, ) + 1 to: printerInfo size.
    printerPort := printerInfo trimNullTerminator.

    ( driverName = String new or: [ deviceName = String new or: [ printerPort = String new ] ] )
        ifTrue: [ ^false ]
        ifFalse: [ ^true ]!   
getPrinterInformation: printerNameString
        " Answer the printer information string from the WIN.INI file
        for the printer named printerNameString.  If no name is specified,
        answer the information for the default printer. "
    | printerInfo cb |
    printerInfo := ( String new: 80 ) asParameter.
    cb := KernelLibrary getProfileString: 'windows' asParameter
        keyName:  'device' asParameter
        default: ( printerNameString isNil ifTrue: [ '' ] ifFalse: [ printerNameString ] ) asParameter
        returnedString: printerInfo
        size: printerInfo size.
    ^printerInfo asNormalizedString!   
printerNames
        "Answer a collection of all known printer names."
    | printerInfo printerNames prefixChar next  |
    "retrieve printer information from WIN.INI file."
    prefixChar:= 0 asCharacter.
    printerInfo := ( String new: 80 ) asParameter.
    KernelLibrary
        getProfileString: 'devices' asParameter
        keyName: nil
        default: String new asParameter
        returnedString: printerInfo
        size: printerInfo size.
    printerInfo := printerInfo asNormalizedString asStream.
    printerNames:= OrderedCollection new.
    [ printerInfo atEnd ] whileFalse: [
        next := ( printerInfo upTo: prefixChar ) trimBlanks.
        next notEmpty ifTrue: [ printerNames add: next ] ].
    ^printerNames!   
defaultPrinterName
        "Answer the name of the default printer, or nil if none."
    | printerInfo printerName |
    printerInfo := self getPrinterInformation: nil.  " get default "
    printerName := ( printerInfo
        copyFrom: 1
        to: ( printerInfo indexOf: $, ) - 1 )
            trimBlanks.
    ^printerName size == 0 ifTrue: [ nil ] ifFalse: [ printerName ]! 
marginsRectangleFor: aRectangle
        "Private - Answer a Rectangle defining margins based on aRectangle.
        Units for aRectangle are in inches, returned margins rectangle is
        in device units (pixels)."
    | left top right bottom pixelsPerInchX pixelsPerInchY horzRes vertRes inset rectangle |
    pixelsPerInchX := GDILibrary getDeviceCaps: self deviceContext index: Logpixelsx.
    pixelsPerInchY := GDILibrary getDeviceCaps: self deviceContext index: Logpixelsy.

    aRectangle isNil
        ifTrue: [
            horzRes := GDILibrary getDeviceCaps: self deviceContext index: Horzres.
            vertRes := GDILibrary getDeviceCaps: self deviceContext index: Vertres.
            inset := self class defaultMargins.
            left := ( inset x * pixelsPerInchX ) asInteger.
            top := ( inset y * pixelsPerInchY ) asInteger.
            right := horzRes - ( inset x * pixelsPerInchX ) asInteger.
            bottom := vertRes - ( inset y * pixelsPerInchY ) asInteger ]
        ifFalse: [
            left := ( aRectangle left * pixelsPerInchX ) asInteger.
            top := ( aRectangle top * pixelsPerInchY ) asInteger.
            right := ( aRectangle right * pixelsPerInchX ) asInteger.
            bottom := ( aRectangle bottom * pixelsPerInchY ) asInteger ].
    rectangle := left @ top rightBottom: right @ bottom.
    ^rectangle!  
createDC
        "Private - Create a device context for the receiver"
    | printerInfo deviceName driverName printerPort |
    printerInfo := self class getPrinterInformation: self name.
    deviceName := ( printerInfo copyFrom: 1 to: ( printerInfo indexOf: $, ) - 1 ) trimBlanks.
    printerInfo := printerInfo copyFrom: ( printerInfo indexOf: $, ) + 1 to: printerInfo size.
    driverName := ( printerInfo copyFrom: 1 to: ( printerInfo indexOf: $, ) - 1 ) trimBlanks.
    printerInfo := printerInfo copyFrom: ( printerInfo indexOf: $, ) + 1 to: printerInfo size.
    printerPort := printerInfo trimNullTerminator.
    ( deviceContext := GDILibrary
        createDC: driverName asParameter
        deviceName: deviceName asParameter
        output: printerPort asParameter
        initData: nil ) = 0
            ifTrue: [ ^self osError ].!  
drawUsing: aRecordingPen
        "Use aRecordingPen to draw its contents
         on the receiver."
    | oldDC |
    oldDC := aRecordingPen handle.
    self startPrintJob.
    aRecordingPen handle: deviceContext.
    aRecordingPen drawChain.
    aRecordingPen handle: oldDC.
    self endPrintJob!
endPrintJob
        "End the print job.  Everything drawn between startPrintJob
         and endPrintJob will become one entry in the print queue."
    | result |
    self endPage.
    result := GDILibrary endDoc: deviceContext.
    graphicsTool deleteDC.
    deviceContext := nil.
    jobid := nil.
    result  > 0
        ifFalse: [ ^self osError ]! 
getGraphicsTool
        "Private - Set the graphics tool for the receiver."
    graphicsTool := self graphicsToolClass
        for: deviceContext
        medium: self!   
abortPrintJob
        "Abort the current print job."
    abort := true! 
print: aString
    font: aFont
    title: aTitle
    collate: collateBoolean
    copies: copiesInteger
    wordWrap: wordWrapBoolean
    marginsRect: aMarginsRect
        "Answer the receiver.  Output the receiver string to
        the printer using aFont.  A Print abort dialog box will be opened
        with aTitle.  If collateBoolean is true, collate output, otherwise
        do not.  Print copiesInteger copies of the specified string.  If
        wordWrapBoolean is true, word wrap the lines, otherwise do not.
        Left, top, right & bottom margins are specified in inches in
        aMarginsRect."
    | lines linesPerPage totalPage abortDialog marginsRect firstPage charHeight controlPrintJob printerFont |
    ( controlPrintJob := jobid isNil )
        ifTrue: [ self startPrintJob: aTitle ].
    abortDialog := PrintAbortDialog new open: aTitle printer: self.
    printerFont := self setPrinterFont: aFont.
    charHeight := self pen getCharHeight.
    marginsRect := self marginsRectangleFor: aMarginsRect.
    lines := self pen asArrayOfLines: aString in: marginsRect wordWrap: wordWrapBoolean.
    linesPerPage := marginsRect bottom - marginsRect top // charHeight.
    totalPage := lines size + linesPerPage - 1 // linesPerPage.
    firstPage := true.

    collateBoolean
        ifTrue: [
            copiesInteger timesRepeat: [
                1 to: totalPage do: [ :page |
                    abort ifTrue: [ ^self endPrintJob ].
                    firstPage ifFalse: [ self formFeed ].
                    self pen font: printerFont.
                    self printPage: page in: marginsRect lines: lines linesPerPage: linesPerPage.
                    firstPage := false ] ] ]
        ifFalse: [
            1 to: totalPage do: [ :page |
                copiesInteger timesRepeat: [
                    abort ifTrue: [ ^self endPrintJob ].
                    firstPage ifFalse: [ self formFeed ].
                    self pen font: printerFont.
                    self printPage: page in: marginsRect lines: lines linesPerPage: linesPerPage.
                    firstPage := false ] ] ].

    controlPrintJob
        ifTrue: [ self endPrintJob ].

    abort ifFalse: [ abortDialog close ]!   
release
        "Release host resources associated with the receiver."
    graphicsTool deleteDC!   
startPrintJob: aString
        "Start a print job, using aString as the job title; everything
         drawn between startPrintJob and endPrintJob will become
         one entry in the print queue."
    | docInfoStruct nameAddress title |
    deviceContext isNil ifTrue: [ self buildPrinter ].
    abort := false.
    "self setAbortProc."
    title := aString isNil ifTrue: [ WindowLabelPrefix ] ifFalse: [ aString ].
    nameAddress := ExternalAddress copyToNonSmalltalkMemory: title.
    ( docInfoStruct := SelfDefinedStructure named: 'DOCINFO' )
        cbSize: docInfoStruct sizeInBytes;
        lpszDocName: nameAddress asParameter.
    jobid := GDILibrary startDoc: deviceContext docInfo: docInfoStruct asParameter.
    nameAddress free.
    jobid  > 0 ifFalse: [ ^self osError ].
    self startPage!
initExtent
        "Private - init the width and height of GraphicsTool for the receiver."
    graphicsTool
        width: ( GDILibrary getDeviceCaps: deviceContext index: Horzres );
        height: ( GDILibrary getDeviceCaps: deviceContext index: Vertres)! 
setPrinterFont: aFont
        "Private - set a font in the receiver's medium whose characteristics
        (pointSize, etc.) match those of aFont."
    | printerFont |
    aFont notNil ifTrue: [
        printerFont := Font fromLogicalFont: aFont logicalFont graphicsMedium: self.
        printerFont pointSize: aFont pointSize graphicsMedium: self.
        printerFont makeFont.
        self pen font: printerFont ].
    ^printerFont!   
formFeed
        "Send a form feed to the printer."
    self
        endPage;
        startPage!  
buildPrinter
        "Private - create all the operating system resources needed."
    self 
        createDC; 
        getGraphicsTool; 
        initExtent!
owner: anObject
        "Sets the owner of the Dialog box."
    super owner: anObject.
    owner isWindow
        ifTrue: [ parent := owner ]
        ifFalse: [ parent := owner mainView.
                       parent isWindow ifFalse: [
                                 parent := Notifier findWindow: WindowHandle queryActive ]].
    chooseColorStruct hwndOwner: parent asParameter.!   
dragOnMove: aBoolean
		"Private - set the flag which indicates whether a selection
		has been 'picked' in the receiver & the next mouse move
		should begin a drag-drop transfer."
    self propertyAt: #dragOnMove put: aBoolean!
verticalPixelsPerInch
        "Answer vertical pixels per inch
        on the screen."
    ^GDILibrary
        getDeviceCaps: self deviceContext
        index: Logpixelsy!  
bitmap
        "Create a new StaticGraphic capable of holding a bitmap as its contents;
         under Windows, there is no static bitmap style, so answer a disabled
         DrawnButton"
    ^DrawnButton new
        disable!
dragDropCopyScroll
        "Answer the instance of the receiver class used
        to indicate a drag-drop copy with drag target scrolling."
    ^DragDropCopyScroll!  
dragOnMove: aBoolean location: aPoint
        "Private - set the flag which indicates whether a selection
        has been 'picked' in the receiver & the next mouse move
        should begin a drag-drop transfer, and save the starting point."
    self dragOnMove: aBoolean.
    self dragSourceLocation: aPoint!   
dragTargetEnterDefault: dragSession
		"Private - set default pane enter feedback flag."
	| operation |
	operation := self dragTargetOperationFor: dragSession.
	dragSession operation: operation! 
setAbortProc
        "Set the abort procedure for the print job."
    ( GDILibrary
        setAbortProc: deviceContext
        proc: AbortProc asParameter ) <= 0
            ifTrue: [ ^self osError ]! 
setCapture: aWindowHandle
    <api: SetCapture ulong ulongReturn>
    ^self invalidArgument.!   
resizeRectangleFor: aRectangle
        "Private - Answer the rectangle to
        use to resize the receiver to aRectangle."
    ^aRectangle!  
readOnly
        "Private - Answer the receiver's readOnly flag"
    ^readOnly! 
windowClass
        "Private- answer the receiver's window class; the class is
        used for all ApplicationWindows & subclasses."
    | className wndClass address answer |
    className := self class name.
    wndClass := WinWindowClass new.
    answer := UserLibrary getClassInfo: OperatingSystem hInstanceExe
        className: className asParameter
        wndClass: wndClass asParameter.
    answer ifTrue: [ ^className ].
    UserLibrary getClassInfo: OperatingSystem hInstanceExe
        className: super windowClass asParameter
        wndClass: wndClass asParameter.
    address := ExternalAddress copyToNonSmalltalkMemoryZ: className.
    wndClass hIcon: 0;
        hBrush: ( GDILibrary getStockObject: WhiteBrush );
        className: address asParameter.
    ( UserLibrary registerClass: wndClass asParameter ) = 0
        ifTrue: [ ^self osError ].
    address free.
    ^className!
faceName
        "Answer the face name of the receiver."
    ^faceName! 
jobid
        "Answer the jobid"
    ^jobid!
initializeSystemColorConstants
        "Private - the system colors have been changed or
        the image is being saved; update entries in ColorConstants
        which are dependent on the current system settings."
    ColorConstants
        at: 'ClrBackground' put: ( OperatingSystem getSystemColor: SystemColorWindowBackground );
        at: 'ClrNeutral' put: ( OperatingSystem getSystemColor: SystemColorWindowText );
        at: 'ClrDefault' put: ( OperatingSystem getSystemColor: SystemColorWindowText );
        at: 'ClrHighlight' put: ( OperatingSystem getSystemColor: SystemColorHighlightBackground );
        at: 'ClrHighlighttext' put: ( OperatingSystem getSystemColor: SystemColorHighlightText )!
openPrivate
        "Display the receiver, and answer the result corresponding
        to the user selection."
    | hwndActive hostResult |
    hwndActive := WindowHandle queryActive.
    ( Notifier findWindow: hwndActive ) isNil
        ifTrue: [ hwndActive := nil ].
    ( hostResult := UserLibrary
        messageBox: hwndActive
        withText: ( message isNil ifTrue: [ String new ] ifFalse: [ message asParameter ] )
        titled: title asParameter
        style: style ) = 0 ifTrue: [ ^self osError ].
    ^hostResult! 
grayRectangle
        "Set and answer the control style for a static gray rectangle."
	self
		removeStyle: SsBlackframe;
		removeStyle: SsBlackrect;
		removeStyle: SsWhiteframe;
		removeStyle: SsWhiterect;
		removeStyle: SsGrayframe.
    ^self addStyle: SsGrayrect! 
getMessage: aWinAddr hwnd: aHandle min: min max: max
        "Private - Get the next Windows message, waiting if necessary."
    <api: GetMessageA ulong ulong ulong ulong boolean>
    ^self invalidArgument! 
addHorizontalScrollbarStyle
        "Add the horizontal scrollbar style to the receiver."
    ^self addStyle: WsHscroll!
handle: aMetaFileHandle
        "Private - Set the receiver's metafile handle to
         aMetaFileHandle."
    hMetaFile := aMetaFileHandle!  
cleanUp
        "Private - Free openFileNameStruct."
    self style: self flags.
    lpstrFilter free.
    lpstrFile free.
    lpstrInitialDir free.
    lpstrTitle notNil ifTrue: [ lpstrTitle free ].
    lpstrDefExt notNil ifTrue: [ lpstrDefExt free ].
    openFileNameStruct contents free.

    openFileNameStruct := nil!  
recreateWindow
        "Private - recreate the host window, because something
         needs to change which cannot be changed dynamically
         by the host operating system."
    self stopReceivingMessages.
    self destroy.
    self
        buildWindow: parent;
        validate;
        resize: parent freeClientArea;
        subclassRecursively!
createDIBPalette
        "Private - Create a GDI palette from the color table of
        bitmapInfo."
    | logPalette |
    self bitCount > 8 ifTrue: [ ^nil ].
    logPalette := WinLogicalPalette fromWinLogPalette: (
        WinLogPalette fromRgbColor: bitmapInfo colorTable).
    ^logPalette! 
pie: boundingBox start: startPoint end: endPoint
        "Call GDI Pie function."
    self allHandles do: [ :h |
        ( GDILibrary pie: h
            x1: boundingBox origin x
            y1: boundingBox origin y
            x2: boundingBox corner x
            y2: boundingBox corner y
            x3: startPoint x
            y3: startPoint y
            x4: endPoint x
            y4: endPoint y )
                ifFalse: [ ^self osError ] ]!  
freeDDElParam: msg lParam: anInteger
    <api: FreeDDElParam ulong long boolean>
    ^self invalidArgument! 
dragTargetDrawEmphasisDefault: dragSession
		"Private - draw emphasis in the receiver indicating
		where a drop would occur within the receiver.  By default,
		do nothing.  Reimplemented in subclasses."!
resetPenFromTracking
        "Private - Reset the pen after mouse tracking."
    self pen
        setLineWidth: 1;
        setLineType: LineTypeDefault;
        setForegroundMode: MixRuleDefault!  
stringCoordinate: aPoint
        "Private - Convert the bit position
         aPoint within the pane to the character position
         of the nearest character gap in the TextHolder."
    | column row |
    row := aPoint y  // self font height + topCorner y.
    column := self doGraphics: [
        graphicsTool
            indexOf: (textHolder lineAt: row)
            at: (aPoint x right: (topCorner x - 1 * self font width))].
    ^( column @ row ) min: ( ( textHolder lineAt: row  ) size + 1 @ ( textHolder extent y + 1 ) )!  
leftRelativeTo: referenceRectangle
    "Private"
    "Answer the x-coordinate of the left edge of the rectangle relative to the <referenceRectangle>."

    ^((referenceRectangle left
        right: (self leftRatio * referenceRectangle width))
            right: (WindowDialog unitMultiplier x * self leftInset / WindowDialog dialogUnit x))
                rounded!   
topRelativeTo: referenceRectangle
    "Private"
    "Answer the y-coordinate of the top of the rectangle relative to the <referenceRectangle>."

    ^((referenceRectangle top
        down: (self topRatio * referenceRectangle height))
            down: (WindowDialog unitMultiplier y *  self topInset / WindowDialog dialogUnit y))
                rounded! 
bottomRelativeTo: referenceRectangle
    "Private"
    "Answer the y-coordinate of the bottom of the rectangle relative to the <referenceRectangle>."

    ^((referenceRectangle top
        down: (self bottomRatio * referenceRectangle height))
            up: (WindowDialog unitMultiplier y * self bottomInset / WindowDialog dialogUnit y))
                rounded!
rightRelativeTo: referenceRectangle
    "Private"
    "Answer the x-coordinate of the right edge of the rectangle relative to the <referenceRectangle>."

    ^((referenceRectangle left
        right: (self rightRatio * referenceRectangle width))
            left: (WindowDialog unitMultiplier x * self rightInset / WindowDialog dialogUnit x))
                rounded!
statusPane
        "Answer the receiver's statusPane"
    | ownerWindow |
    owner isNil ifTrue: [ ^nil ].
    ownerWindow := owner isWindow
          ifTrue: [ owner ]
          ifFalse: [ Notifier findWindow: owner asInteger ].
    ownerWindow isNil
        ifTrue: [ ^nil ].
    ^ownerWindow statusPane.! 
ptMaxSize
    ^WinPoint usingBytes: ( self bytesAtOffset: 8 count: 8 )!  
ptMaxSize: aWinPoint
    self bytesAtOffset: 8 put: aWinPoint contents!  
ptReserved: aWinPoint
    self bytesAtOffset: 0 put: aWinPoint contents! 
ptMaxPosition
    ^WinPoint usingBytes: ( self bytesAtOffset: 16 count: 8 )! 
ptMaxPosition: aWinPoint
    self bytesAtOffset: 16 put: aWinPoint contents! 
ptReserved
    ^WinPoint usingBytes: ( self bytesAtOffset: 0 count: 8 )! 
ptMaxTrackSize: aWinPoint
    self bytesAtOffset: 32 put: aWinPoint contents!
ptMinTrackSize: aWinPoint
    self bytesAtOffset: 24 put: aWinPoint contents!
ptMaxTrackSize
    ^WinPoint usingBytes: ( self bytesAtOffset: 32 count: 8 )!
ptMinTrackSize
    ^WinPoint usingBytes: ( self bytesAtOffset: 24 count: 8 )!
deactivate
        "Private - The receiver has been deactivated."!   
setEntryField
        "Private - Set the entry field control in the receiver."
    | child |
    ( child := self entryFieldHandle ) isNil ifTrue: [ ^self ].
    self entryField: ( self entryFieldClass handle: child ).
    self entryField parent: self.
    "don't overwrite selection if text not set"
    self textAttribute notEmpty ifTrue: [ self entryField contents: self textAttribute ].
    self entryField
        receiveMessages;
        receiveAllWindowMessages!
disable
        "If self has the focus, give it to the next tab stop."
    | nextTab |
    ( self isHandleOk and: [ self hasFocus ] ) ifTrue: [
        nextTab := self tabScope nextTabStop: self.
        nextTab == self
            ifTrue: [ parent setFocus ]
            ifFalse: [ nextTab setFocus ] ].
    ^super disable!  
measureControl: aMeasureItemStruct
        "Private - Set the height of an owner-drawn
         menu item."
    | aPoint menu |
    self ownerDrawStruct: aMeasureItemStruct.
    menu := menuWindow menuWithItemId: aMeasureItemStruct itemId.
    menu triggerEvent: #measureItem:
        withArguments: ( Array with: self drawIndex )
        ifNotHandled: [ self defaultMeasureControl: aMeasureItemStruct ].
    self ownerDrawStruct: nil.
    ( aPoint := self itemSize ) notNil ifTrue: [
        self itemSize: nil.
        aMeasureItemStruct itemHeight: aPoint y.
        aMeasureItemStruct itemWidth: aPoint x ].
    ^nil!   
defaultNib: anInteger
        "Private - Set the line width of the receiver to anInteger.
         Retained for compatibility."
    self setLineWidth: anInteger!  
enumFaces: lpLogFont lpTextMetrics: lpTextMetrics nFontType: nFontType lpData: lpData
        "Private - CallBack proc. Enumerate all the faces of the font."
    | anAddress aWinLogFont |
    anAddress := ExternalAddress fromInteger: lpLogFont.
    aWinLogFont := WinLogFont fromAddress: anAddress.
    TempFontList add: aWinLogFont szFaceName.
    ^1!
displayLines: anIndexedCollection from: startIndex to: endIndex in: aRectangle
        "Private - display Strings in anIndexedCollection starting at startIndex and
        ending at endIndex, clipped within the bounds of aRectangle."
    | charHeight ta region |
    charHeight := self getCharHeight.
    region := self setClipRect: aRectangle.
    ta := self getTextAlign.
    self setTextAlign: TaTop.
    startIndex to: endIndex do: [ :i |
        self
            displayText: ( anIndexedCollection at: i )
            at: aRectangle left @ ( aRectangle top + ( i - startIndex * charHeight ) ) ].
    self setTextAlign: ta.
    self destroyRegion: region!  
wmStcallback: wordInteger with: longInteger
        "Private - Process the Smalltalk callback message."
    ^wordInteger >= CallBack maxNumCallBack    "a 16-bit CallBack"
        ifTrue: [ self performCallBack16: wordInteger with: longInteger ]
        ifFalse: [ self performCallBack: wordInteger with: longInteger ]!
crossHair
        "Answer the cross hair cursor."
    ^CrossHair!   
height: anInteger
        "Set the height of the receiver to anInteger."
    height := anInteger!   
flags
        "Private - Answers the dialog box current flags.
        For compatibility reasons -> use style instead"
    ^openFileNameStruct flags!  
systemFont
        "Answer the system font."
    ^SysFont!  
windowClass
        "Private - Answer the window class for combo box."
    ^'COMBOBOX'! 
winHelp: hWnd helpFile: aString command: anInteger dwData: anObject
    anObject isString
        ifTrue:[ ^self winHelp: hWnd helpFile: aString command: anInteger dataStruct: anObject]
        ifFalse: [ ^self winHelp: hWnd helpFile: aString command: anInteger dataUL: anObject ]!  
deletePen
        "Delete the last pen object created."
    self selectObject: (DefaultObjects at: 'Pen').
    logicalTool initHandle! 
modifyMenu: aMenuHandle
        position: positionInteger
        flags: flagsInteger
        newId: idInteger
        newContentsStruct: aString
    <api: ModifyMenuA ulong ulong ulong ulong struct boolean>
    ^self invalidArgument!  
exit
        "Private - release the HelpHook callback before exiting"
    ( UserLibrary
        unhookWindowsHook: WhMsgfilter
        proc: HelpHookProc asParameter ) = 0
            ifTrue: [ ^self osError ].
    HelpHookProc notNil ifTrue: [ HelpHookProc release ].
    HelpHookProc := nil!  
startUp
        "Private - Smalltalk has been launched"
    self registerHelpMessage.
    self registerHookProc!   
closeHelpWindow
        "Private - Dismiss the help window."
    self winHelp: HelpQuit data: nil!  
buildMenuBar
        "Private - Add Help menu."
    applicationWindow menuWindow addMenu:  self helpMenu.!  
displayHelp: anId
        "Brings up the host system Help for the topic
        defined by anId.
        anId can be either a string, an Integer or nil"
    | contextId macro |
    contextId := anId.
    self helpMode ifTrue: [ self turnOffHelpMode ].
    contextId isNil ifTrue: [ ^self displayExtendedHelpPanel ].
    contextId isInteger ifTrue: [ ^self winHelp: HelpContext data: contextId ].

    "otherwise, contextId is a String."
    self map notNil ifTrue: [
        contextId := contextId asString.
        1 to: contextId size do: [ :i |
            ( contextId at: i ) = $: ifTrue: [ contextId at: i put: $_ ] ].
        contextId := mapDictionary at: contextId ifAbsent: [ nil ].
        ^self winHelp: HelpContext data: contextId ].

    self displayHelpIndex.  "force the help window open if not currently"
    macro := 'JumpId("', self helpFileName fileNameLessPath, '", "', contextId, '")'.
    self winHelp: HelpCommand data: macro! 
helpMenu
         "Private - Answer the Help menu."
    | menu title transcript |
    menu :=  Menu new
        owner: self;
        title: '&Help';
        appendItem: '&Contents' selector: #displayHelpIndex  accelKey: F1Key accelBits: 0;
        appendItem: '&Search for Help on...' selector: #searchHelpOn;
        appendItem: '&How to Use Help' selector: #displayHelpForHelp.
    aboutDlgClass notNil
        ifTrue: [
            title := ( ( transcript := Smalltalk at: #Transcript ifAbsent: [ nil ] ) notNil and: [ applicationWindow owner == transcript ] )
                ifTrue: [ '&About ', WindowLabelPrefix, ' for Win32...' ]
                ifFalse: [ '&About ', applicationWindow label, '...' ].
            menu
                appendSeparator;
                appendItem: title selector: #about ].
    ^menu! 
displayExtendedHelpPanel
        "Private - Brings up the host system Help
        for the default topic"
    | contextId macro |
    contextId := self extendedHelpPanelId.
    contextId isString ifTrue: [
        self map notNil
            ifTrue: [ contextId := mapDictionary at: contextId ifAbsent: [ nil ] ]
            ifFalse: [
                self winHelp: HelpContext data: 1.  "force help window open"
                macro := 'JumpId("', self helpFileName, '", "', contextId, '")'.
                ^self winHelp: HelpCommand data: macro ] ].
    contextId isNil ifTrue: [ ^self displayHelpIndex ].
    self winHelp: HelpContext data: contextId! 
map
        "Answer the receiver's map dictionary.  The keys are
        the context strings defined in the RTF help file; the
        values are integers defined in the include file used by
        the Help Compiler."
    ^mapDictionary!   
map: aDictionary
        "Set the receiver's map dictionary.  The keys are the
        context strings defined in the RTF help file; the values
        are integers defined in the include file used by the
        Help Compiler."
    mapDictionary := aDictionary!   
displayHelpIndex
        "Private - Display the Contents topic"
    self winHelp: HelpIndex data: nil!  
for: aWindow 
    title: aString
    file: aFileName
    dialogs: aCollection
    aboutDlgClass: aWindowDialogClass
        "Private - Set all info for the receiver.
         Under Windows aString and aCollection are ignored"

    helpFile := aFileName.
    applicationWindow := aWindow.
    aboutDlgClass := aWindowDialogClass.
    aWindow helpManager: self.
    helpMode := false!
displayHelpForHelp
        "Private - The user has clicked How to use Help"
    self winHelp: HelpHelponhelp data: nil! 
extendedHelpPanelId
        "Answer the default topic; it can be either a string, an integer or nil."
    ^defaultTopic!
extendedHelpPanelId: anId
        "Set the default topic to anId. anId can be either a string, an
        integer or nil."
    defaultTopic := anId!   
helpFileName: aString
        "Set the name of the help file to aString."
    helpFile := aString!  
helpFileName
        "Answer the name of the help file."
    ^helpFile! 
about
        "Private - Open a dialog window to show the product
        information."
    aboutDlgClass new open.!   
initMenu
        "Private - Initialize the menu."
    ^ nil!
blackFrame
        "Set and answer the control style for a static black frame."
	self
		removeStyle: SsBlackrect;
		removeStyle: SsWhiteframe;
		removeStyle: SsWhiterect;
		removeStyle: SsGrayframe;
		removeStyle: SsGrayrect.
    ^self addStyle: SsBlackframe!   
isDialogWindow
        "Answer whether the receiver is a kind of dialog window."
    ^true! 
isDialogWindow
        "Answer whether the receiver is a kind of dialog window."
    ^false!
updateVerticalSlider
        "Update the slider box in the vertical scrollBar."
    | position totalLength |
    totalLength := self totalLength.
    totalLength = 0
        ifTrue: [position := 0]
        ifFalse: [position := ((self topCorner y - 1 * 100) // (totalLength max: 1))].
    (self topCorner y = totalLength and: [totalLength >1])
        ifTrue: [position := 100].
    self updateVerticalSliderTo: position.!   
displayText: aString 
        "Display aString at the current location." 
    ^self displayText: aString at: self location! 
defaultSampleForeColor
        "Private - answer the default foreground color for the
        sample string."
    | color |
    ( color := self defaultForeColor ) isNil
        ifTrue: [ ^Color windowText ].
    ^color! 
basicStyle
        "Private - Answer the basic host window style for the receiver."
    ^WsVisible! 
edit
        "Open a text window with the
         receiver string as the contents."
    ApplicationWindow textWindowClass new
        label: 'Workspace';
        openOn: self! 
startUp
        "Private - Clear DevMode, DevNames variables."
    DevMode := DevNames := nil.! 
windowClass
        "Answer the class of windows for the receiver."
    ( Smalltalk includesKey: #MDISystem ) ifFalse: [ ^TopPane ].
    Smalltalk isRunTime ifFalse: [
        ( Smalltalk at: #MDISystem ) isActive
            ifTrue: [ ^Smalltalk at: #MDIChild ] ].
    ^TopPane! 
setSelection
        "Private - set the selection in the listbox control
        to correspond to value.  Assumes 'handle = NullHandle'
        is false."
    | index |
    index := ( value isNil or: [ value < 1 or: [ value > list size ] ] )
        ifTrue: [ self class listEnd ]
        ifFalse: [ value - 1 ].
    UserLibrary
        sendMessage: handle
        msg: self selectMessage
        wparam: index
        lparam: 0! 
printerSetup
        "Open a printer setup dialog, and if OK selected,
        store current printer setup."
    ^self new
        style: PdPrintsetup;
        open!
isComboBox
        "Answer whether the receiver is an instance of class
         ComboBox or one of its subclasses."
    ^false!   
graphicsTool
        "Answer the graphics tool associated with
        the receiver.  Always answer a non-nil value."
    graphicsTool isNil ifTrue: [ self buildPrinter ].
    ^graphicsTool!
startPage
        "Starts a page."
    ( GDILibrary startPage: deviceContext ) > 0
        ifFalse: [ ^self osError ].!
verticalScrollMaxRange
        "Private - Answer the vertical scrollbar's max range"
    | maxPos |
    ( UserLibrary
        getScrollRange: self handle asParameter
        bar: SbVert
        lpMinPos: ExternalLong new asParameter
        lpMaxPos: ( maxPos := ExternalLong new ) asParameter )
            ifFalse: [ ^self osError ].
    ^maxPos asInteger!   
named: aName
        "Answer a new instance of Printer which represents
         the printer named aName as specified in the host
         Control Panel."
    aName isNil ifTrue: [ ^self default ].
    ^super new name: aName!
wmQueryendsession: wordInteger with: longInteger
        "Private - Process query end session message.  This message
        is broadcast to the topmost window of each running program - the
        return value determines whether the program will allow Windows
        to continue shutdown."
    Smalltalk isRunTime ifTrue: [ ^1 ].
    "close any open dialogs which may prevent shutdown from continuing."
    PoppedModelessWindows notEmpty ifTrue: [
        ( Notifier windows select: [ :w | w isDialogTopPane ] )
            do: [ :w | w close ] ].
    "prompt for exit confirmation."
    ^( MessageBox new
        title: WindowLabelPrefix;
        message: 'Warning: Exiting without saving image.\Are you sure you want to exit?' withCrs;
        yesNo;
        defaultButton: 2;
        open )
            ifTrue: [ 1 ] ifFalse: [ 0 ]!
cleanUp
        "Private - Free chooseColorStruct."
    self style: self flags.
    lpCustColors free.
    chooseColorStruct contents free.
    chooseColorStruct := nil!
fromUser
        "Prompt the user for a rectangle and answer an
        instance of Bitmap copied from the rectangle."
    | rect |
    rect := Display rectangleFromUser.
    rect extent > (1 @ 1)
        ifTrue: [^self fromScreen: rect]
        ifFalse: [^nil]! 
exit
        "Private - free up resource before exiting Smalltalk."
    self
        deleteMemoryDC;
        deleteAuxiliaryDC!   
dragTargetScrollInset
		"Private - answer a Point which represents the amount of inset
		from the window rectangle which is the drag scrolling hot zone."
    ^SysFontWidth @ SysFontHeight!   
oemConvert
        "Add the OEM convert style."
    ^self addStyle: CbsOemconvert!  
print: aString
    font: aFont
    title: aTitle
    printDialog: printDialog
    marginsRect: aMarginsRect
        "Private - Answer the receiver.  Output the receiver string to
        the printer using aFont.  A Print abort dialog box will be opened
        with aTitle.  The printer setup info (collation, copies) is contained
        in printDialog.  left, top, right & bottom margins are specified in inches in
        aMarginsRect Rectangle."
    ^self
        print: aString
        font: aFont
        title: aTitle
        collate: printDialog collate
        copies: printDialog copies
        wordWrap: false
        marginsRect: aMarginsRect!  
setCaretPos: xInteger y: yInteger
    <api: SetCaretPos long long boolean>
    ^self invalidArgument!   
east
        "Set the direction of the receiver to east."

    direction :=  0!
asLayoutInset
    "Convert the receiver to a LayoutFrame with fixed insets."

    ^LayoutFrame
        top: self top
        left: self left
        bottom: self bottom
        right: self right!
initialize
        "Private - First time initialization. Creates the SelfDefinedStructure "
    | d |
    d := Dictionary new.
    d
        at: #lStructSize put: #(0 #ulong #yourself);
        at: #hwndOwner put: #(4 #handle #yourself);
        at: #hInstance put: #(8 #handle #yourself);
        at: #rgbResult put: #(12 #ulong #yourself);
        at: #lpCustColors put: #(16 #ulong #yourself);
        at: #flags put: #(20 #ulong #yourself);
        at: #lCustData put: #(24 #ulong #yourself);
        at: #lpfnHook put: #(28 #ulong #yourself);
        at: #lpstrTemplateName put: #(32 #ulong #yourself);
        yourself.
    SelfDefinedStructure define: 'CHOOSECOLOR' withFields: d.!   
textPaneClass
        "Return the class of the pane that contains text for this
        window."
    ^TextPane!
open
        "Brings up the open file dialog."
    | error |
    hLibrary := CommonDialogDLL current.
    self copyStruct.
    parent isWindow ifFalse: [
        parent := Notifier findWindow: WindowHandle queryActive.
        openFileNameStruct hwndOwner: parent asParameter ].
    style notNil ifTrue: [ openFileNameStruct flags: style ].
    ( hLibrary getOpenFilename: openFileNameStruct asParameter )
        ifTrue: [ self checkFlags ]
        ifFalse: [
            fileName := nil.
            error := ( ExternalLong fromString: hLibrary commDlgExtendedError ) asInteger.
            error ~= 0 ifTrue: [
                self cleanUp.
                ^self osError: error ] ].
    self cleanUp.! 
itemIdFromPosition: anInteger
        "Private - Answer the item id of the menu
         item at position anInteger in the receiver."
    | pos |
    ( pos := UserLibrary getMenuItemId: self handle position: anInteger ) = 16rFFFFFFFF  "-1"
        ifTrue: [ ^self osError ].
    ^pos!
initializeSystemColors
        "Private - the system colors have been changed or
        the image is being saved; clear the cached system colors."
    SystemColors := Dictionary new.
    self initializeSystemColorConstants!  
initPenWidth: width height: height planes: planes bitCount: bitCount forDC: aDeviceContext
        "Private - Initialize the receiver's pen."
    | bitsPel |
    bitsPel :=  ( bitCount > 8 and: [  OperatingSystem isWin32s ] )
        ifTrue: [ 24 ]    "16 and 32 bit count not supported in Win32s"
        ifFalse: [ bitCount ].
    bitmapInfo := WinBitmapInfo
        width: width
        height: height
        planes: 1
        bitCount: bitsPel.

    deviceContext := aDeviceContext.
    graphicsTool := Pen forDC: aDeviceContext medium: self.
    graphicsTool
         width: width;
         height: height!  
chordFilled: major minor: minor angles: aPoint
        "Draw a chord whose major axis is major and minor
         axis is minor. aPoint x
         is the starting angle of the arc in degrees. aPoint y is the
         sweeping angle between the starting angle and ending
         angle which goes clockwise if positive and counter-clockwise
         if negative. The interior of the chord is filled the current brush."
    | startPoint endPoint boundingBox points |
    boundingBox := (self location leftAndUp: major @ minor) corner: (
        self location rightAndDown: major @ minor).
    points := self getArcPoints: major minor: minor angles: aPoint.
    startPoint := points at: 1.
    endPoint := points at: 2.
    self chord: boundingBox
        start: startPoint
        end: endPoint!  
getMenu: aHandle
    <api: GetMenu ulong ulongReturn>
    ^self invalidArgument!
createMenu
    <api: CreateMenu ulongReturn>
    ^self invalidArgument! 
performCallBack16: slotNumber with: longInteger
        "Private - perform the 16-bit CallBack with the given <slotNumber>, and arguments
        specified by the buffer pointed to by the address <longInteger>."
    | answer address |
    answer := CallBack16
        performSlot: ( slotNumber - CallBack maxNumCallBack )
        withArgs: ( ExternalBuffer atAddress:
           ( address := ExternalAddress fromSegmentedAddress:  ( ExternalSegmentedAddress fromString: longInteger ) ) ).
    address releaseFlatAddress.
   ^answer! 
labels: aString lines: lineArray actions: actionArray
        "Answer a menu with aString for the items,
         actionArray for actions, and lines drawn
         under the item numbers contained in lineArray."
    ^self labels: aString lines: lineArray selectors: actionArray!
labels: aString selectors: selectorArray
        "Answer a menu with aString for the items and
         selectorArray for actions."
    ^self labels: aString lines: #() selectors: selectorArray! 
labelArray: labelArray lines: lineArray selectors: selectorArray
        "Answer a menu with labelArray for the items,
         selectorArray for actions, and lines drawn
         under the item numbers contained in lineArray."
    ^self new
        labels: labelArray lines: lineArray selectors: selectorArray;
        yourself!   
message: aString
        "Display aString in a MessageBox.
         Retained for compatibility."
    ^MessageBox
        titled: WindowLabelPrefix
        withText: aString
        style: MbOk | MbIconexclamation!   
labelArray: labelArray lines: lineArray actions: actionArray
        "Answer a menu with labelArray for the items,
         actionArray for actions, and lines drawn
         under the item numbers contained in lineArray."
    ^self labelArray: labelArray lines: lineArray selectors: actionArray!   
labels: aString actions: actionArray
        "Answer a menu with aString for the items and
         actionArray for actions."
    ^self labels: aString lines: #( ) selectors: actionArray!
new
		"Answer a new instance of the receiver."
	^super new initialize!  
labels: aString lines: lineArray selectors: selectorArray
        "Answer a menu with aString for the items,
         selectorArray for actions, and lines drawn
         under the item numbers contained in lineArray."
    | anArray aStream |
    selectorArray isEmpty
        ifTrue:  [anArray := Array new: (aString occurrencesOf: Lf)]
        ifFalse: [anArray := Array new: selectorArray size].
    aStream := ReadStream on: aString.
    1 to: anArray size do:
        [ :i | anArray at: i put: (aStream upTo: Lf)].
    ^self new
        labels: anArray lines: lineArray selectors: selectorArray;
        yourself!
asPopupMenu
        "Private - answer a popup menu which is copied from the receiver, with
        accelerator text stripped off of item labels."
    | popupMenu miCopy newLabel tabIndex |
    popupMenu := self class new.
    popupMenu owner: self owner.
    popupMenu title: self title.
    self items do: [ :mi |
        miCopy := mi copy.
        miCopy label notNil ifTrue: [
            newLabel := miCopy label.
            ( tabIndex := newLabel indexOf: Tab ) ~= 0
                ifTrue: [ newLabel := newLabel copyFrom: 1 to: tabIndex - 1 ].
            miCopy label: newLabel.
            miCopy submenu notNil ifTrue: [ miCopy submenu: miCopy submenu asPopupMenu ] ].
        popupMenu items add: miCopy ].
    ^popupMenu!
subMenuTitled: aString
        "Answer submenu with title aString."
    | index submenu |
    ( index := items indexOf: ( self getMenuItem: aString ) ) = 0 ifTrue: [ ^nil ].
    ( submenu := ( items at: index ) submenu ) isMenu ifFalse: [ ^nil ].
    ^submenu! 
printOn: aStream
        "Append a text representation of the receiver
         to aStream."
    aStream nextPutAll: self class name, '{', title printString, '}'! 
copyAttributesFrom: aMenu
        "Copy the 'checked' and 'disabled' attributes to the receiver
        items from aMenu.  The receiver and aMenu must have the same number of
        items. If the item is itself a Menu, recursively copy the
        corresponding attributes"
    1 to: items size do: [ :item |
        self copyItemAttributes: item from: aMenu ]!  
accelKey: aChar accelBits: afBits for: aSelector
        "Private - Add an accelerator to the receiver."
    | index |
    index := self getIndex: aSelector.
    ( accel at: index ) isNil ifTrue: [ accel at: index put: Array new ].
    accel at: index put: ( ( accel at: index ), ( self accelArray: aChar accelBits: afBits ) )!  
getIndex: object ifAbsent: aBlock
        "Private - Answer the index for object.
         Evaluate aBlock if no such object.
         object can be the label or the selector or an index."
    | tempItem plainObject |
    ( object class == String )
        ifTrue: [
            plainObject := object reject: [ :c | c = $& | ( c = $~ ) ].
            tempItem := items
                detect: [ :item |
                    item label isString
                    and: [ ( item label reject: [ :c | c = $& | ( c = $~ ) ] ) = plainObject ] ]
                ifNone: [ ^aBlock value ] ]
        ifFalse: [
            tempItem := items
                detect: [ :item | item selector = object or: [ item label = object ] ] 
                ifNone: [ object isInteger ifTrue: [ ^object ] ifFalse: [ ^aBlock value ] ] ].
    ^items indexOf: tempItem!
menuItem
        "Private - Answer the MenuItem for the receiver."
    ^menuItem!   
title
        "Answer the receiver's title."
    ^title!
changeItem: item label: aString
        "Change the label for item to aString.
         item can be the label or the selector."
    | mi |
    ( self isThere: item ) ifTrue: [
        mi := self getMenuItem: item.
        mi label: aString.
        self updateItem: mi ]!
deleteItem: item
        "Remove an item from the receiver.  item can be the label or the selector."
    | mi index |
    mi := self getMenuItem: item.
    index := items indexOf: mi.
    items removeIndex: index.
    accel removeIndex: index! 
appendItem: aLabelString
    selector: aSelector
    acceleratorString: aString
        "Append an item with label aLabelString and
         selector aSelector to the receiver menu.  Parse the
         accelerator info from aString.  aString has the following
         syntax:
            One or more of 'Ctrl', 'Alt', or 'Shift'.
            A plus sign (+).
            A single character (indicating Ctrl+S for example)
                or an integer (indicating Ctrl+Del for example).
            Examples:
                'Ctrl+S' means Control key and the S key.
                'AltShift+C' means Alt and Shift keys and the C key.
                'Ctrl+27' means Control and the Del key (VkDelete = 27)."
    | s bits bitsString key keyString |
    aString isEmpty ifTrue: [
        ^self appendItem: aLabelString selector: aSelector
            accelKey: nil accelBits: nil ].
    s := aString asStream.
    bitsString := s upTo: $+.
    keyString := s upTo: $+.
    keyString first isDigit
        ifTrue: [
            key := 0.
            1 to: keyString size do: [:i |
                key := key * 10 + ( keyString at: i ) digitValue ].
            bits := AfVirtualkey ]
        ifFalse: [
            key := keyString first.
            bits := AfChar ].
    ( bitsString includes: $C ) ifTrue: [ bits := bits | AfControl ].
    ( bitsString includes: $A ) ifTrue: [ bits := bits | AfAlt ].
    ( bitsString includes: $S ) ifTrue: [ bits := bits | AfShift ].
    ^self appendItem: aLabelString selector: aSelector
           accelKey: key accelBits: bits!  
contextForItem: id
        "Private - The user has highlighted a menu item
        Answer a string for preview help"
    ^popup contextForItem: id!
selector: aSymbol
        "Set the selector for the receiver to aSymbol.
         If the selector of a menu item that the user
         chooses is not a symbol, then the menu's
         selector (aSymbol) is performed passing the menu
         item's 'selector' as the argument."
    selector := aSymbol.
    items do: [ :item |
        item hasSubmenu ifTrue: [
            item selector: aSymbol ] ]!   
window
        "Private - Answer the receiver's MenuWindow."
    ^window!   
appendItem: anObject action: anAction commandKey: aCharacter
        "Append an item with label anObject and action anAction, and
        aCharacter as its command key equivalent (Ctrl+aCharacter
        on VOS2 & VW32)."
    ^self appendItem: anObject selector: anAction accelKey: aCharacter accelBits: AfControl!
window: aMenuWindow
        "Private - Set window to aMenuWindow."
    window := aMenuWindow!   
disableAll
        "Disable all items for the receiver."
    items do: [ :mi |
        mi hasSubmenu ifTrue: [ mi submenu disableAll ].
        self disableItem: mi selector ]!  
accel
        "Answer the receiver's accelerator table."
    ^accel!
initialize
        "Private - Initialize a new Menu."
    items := OrderedCollection new.
    title := 'Untitled'.
    accel := OrderedCollection new.!   
items
        "Return the menu items of the receiver."
    ^items!  
popUp
        "Popup the receiver menu at the current mouse
         location, wait for the user to make a selection,
         and answer the selector of the selected item
         or nil if the user selected nothing."
    | aWindow |
    aWindow := Notifier getFocusWindow.
    aWindow isNil
        ifTrue: [ aWindow := Notifier activeMainWindow ].
    aWindow isNil
        ifTrue: [ aWindow := Notifier windows detect: [ :win | win isApplicationWindow ] ].
    ^self popUpIn: aWindow!   
popup
        "Private - Answer the menu window used for a popup menu."
    ^popup! 
appendItem: anObject selector: aSelector
        "Append an item with label anObject and selector aSelector 
         to the receiver menu. anObject may be either a String, 
         a Bitmap, or an Integer (a 32-bit value to associate with 
         an owner-drawn item)."
    ^self appendItem: anObject selector: aSelector
        accelKey: nil accelBits: nil!  
changeItem: item selector: aSymbol
        "Change the selector for item to aSymbol.
         item can be the label or the selector."
    | mi |
    ( self isThere: item ) ifTrue: [
        mi := self getMenuItem: item.
        mi selector: aSymbol.
        self updateItem: mi ]!   
getIndex: item
        "Private - Answer the index for 'item'.
         item can be the label or the selector."
    ^self getIndex: item ifAbsent: [self error: 'item not in menu']!   
destroy
        "Private - destroy the popup menu."
    popup notNil ifTrue: [
        popup destroy.
        popup := nil ]! 
owner
        "Answer the receiver's owner."
    ^owner!
owner: aWindow
        "Set the receiver's owner to aWindow."
    owner := aWindow! 
helpTopicFromId: id
        "Private - Answer a String which is the context sensitive
        help panel name for for the item whose id is id.  When writing
        help files, use the selector to identify the individual menu
        item.  Include the $: in the selector."
    ^(self selectorOf: id) asString!   
appendItem: anObject action: anAction
        "Append an item with label anObject and action anAction."
    ^self appendItem: anObject selector: anAction!  
enableAll
        "Enable all items for the receiver."
    items do: [ :mi |
        mi hasSubmenu ifTrue: [ mi submenu enableAll ].
        self enableItem: mi selector ]!  
labels: itemArray lines: indexArray selectors: selectorArray
        "Private - Fill the receiver with the specified menu items."
    | selArray sel |
    selArray := selectorArray.
    ( selArray isNil or: [ selArray isEmpty ] ) ifTrue: [
        selArray := OrderedCollection new: itemArray size.
        1 to: itemArray size do: [ :i | selArray add: i ] ].
    1 to: itemArray size do: [ :i |
        ( sel := selArray at: i ) isMenu
            ifTrue: [
                sel title: ( itemArray at: i ).
                self appendSubMenu: sel ]
            ifFalse: [ self appendItem: ( itemArray at: i ) selector: sel ].
        ( indexArray includes: i ) ifTrue: [ self appendSeparator ] ]! 
isThere: item
        "Private - Answer true if item is there.
         item can be the label or the selector."
    ^( self getIndex: item ifAbsent: [ 0 ] ) > 0!  
numberOfItems
        "Answer the number of items in the receiver."
    ^items size!
toggleCheckOfItem: item
        "Toggle the checked state of an item.
        item can be the label or the selector."
    ( self isChecked: item )
        ifTrue: [ self uncheckItem: item ]
        ifFalse: [ self checkItem: item ]! 
selectorOf: id
        "Private - Answer the selector for the item whose id is id."
    ^( items at: ( id \\ 256 ) ) selector!  
helpTopic
        "Private - answer the help panel name for the menu
        itself.  When writing the help file, use the title to identify
        the whole menu."
    ^self title! 
getMenuItem: item
        "Private - Answer the MenuItem for 'item'.
         item can be the label or the selector."
    ^items at: (self getIndex: item)!
deleteAll
        "Delete all the items from the receiver."
    window notNil ifTrue: [
        items do: [ :mi | window deleteItem: mi ] ].
    items := OrderedCollection new.
    accel := OrderedCollection new.!
performMenuItem: id
        "Private - Perform the menu item whose id is id."
    popup notNil ifTrue: [^popup performMenuItem: id]!
selector
        "Private - Answer the menu's selector."
    ^selector! 
contextForPopup: id
        "Private - The user has popped up a menu;
        answer aString for preview help."
    ^popup contextForPopup: id!
isMenu
        "Answer true if receiver is an instance of class
         Menu or one of its subclasses, else answer false."
    ^true! 
charsInRow
        "Private - Answer the receiver width in characters."
    ^self rectangle width // self font width!   
button1Down: aPoint
        "Private - left button was pressed; if the receiver
        is a drag source, start a drag drop transfer."
    ( self helpManager notNil and: [ self helpManager helpMode ] )
        ifTrue: [ self helpRequest. ^false ].
    ( self isDragSource and: [ self isDragButton: 1 ] )
        ifTrue: [ self dragOnMove: true location: aPoint ].
    ^true! 
addPopupStyle
        "Add the popup style to the receiver."
    ^self addStyle: WsPopup!   
noSelection
        "Disables the print dialog's Selection radio button."
    self style: ( self style | PdNoselection )!   
owner: anOwner
        "Sets the owner of the Dialog box."
    super owner: anOwner.
    owner isWindow
        ifTrue: [ parent := owner ]
        ifFalse: [ parent := owner mainView.
                       parent isWindow ifFalse: [
                            parent := Notifier findWindow: WindowHandle queryActive ]].
    printDlgStruct hwndOwner: parent asParameter.! 
colorChange
        "Private - the receiver's colors have changed, refresh it."
    super colorChange.
    self invalidateRect: nil!   
downState
        "Answer whether the pen is down or not."
    ^downState!  
getSelection
        "Private - Answer the collection of selections."
    | count struct |
    self isHandleOk ifFalse: [ ^OrderedCollection new ].
    count := UserLibrary
        sendMessageInt: handle
        msg: LbGetselcount
        wparam: 0
        lparam: 0.
    count = LbErr ifTrue: [ ^OrderedCollection new ].
    struct := ExternalBuffer new: count * 4.
    count := UserLibrary
        sendMessageInt: handle
        msg: LbGetselitems
        wparam: count
        lparamStruct: struct asParameter.
    value := OrderedCollection new: count.
    1 to: count do: [ : i |
        value add: ( struct longAtOffset: ( i - 1 ) * 4 ) + 1 ].
    ^value!  
wmPowerbroadcast: wparam with: lparam
        "Private - handle power management notifications."
    ^nil!  
setWindowText: aWindowHandle text: aString
    <api: SetWindowTextA ulong struct boolean>
    ^self invalidArgument!
disableRedraw
        "Disable redrawing of the receiver."
    self isHandleOk
        ifTrue: [ handle disableRedraw ]
        ifFalse: [ self whenValid: #disableRedraw ]!  
initialize
        "Private - initialize the reciever class."
    self dragButtonIndex: nil. "use host settings"
    self extendedDragButtonIndex: nil.
    self operationDescriptions: ( IdentityDictionary new
        at: #move put: 'Move';
        at: #copy put: 'Copy';
        at: #link put: 'Link';
        yourself )! 
queryTextAtIndex: index inListBox: itemId
        "Answers the string at index in listbox identified by itemId."
    | answer |
    answer := String new: 256.
    self sendMessage: LbGettext item: itemId wparam: index lparamStruct: answer.
    ^answer trimNullTerminator asNormalizedString!   
notify: longInteger
        "Private - process the control notification identified by longInteger.
        This message handles control notifications that emanate from
        the WM_NOTIFY message."
    | address nmhdr selector |
    address := ExternalAddress fromInteger: longInteger.
    nmhdr := WinNmhdr atAddress: address.
    selector := self class notifications at: nmhdr code ifAbsent: [ ^nil ].
    ^self perform: selector with: address!  
dpToLp: aDeviceContext
        "Private - Call DPToLP to convert the receiver from device point
          to logical point."
    | winPoint |
    winPoint := WinPoint fromPoint: self.
    ( GDILibrary
        dpToLp: aDeviceContext
        point: winPoint asParameter
        count: 1 )
            ifFalse: [ ^self osError ].
    ^winPoint asPoint!   
displayText: aString at: aPoint
        "Display aString at aPoint."
    | str stringWidth |
    str := (aString isString)
        ifTrue: [aString]
        ifFalse: [aString printString].
    str size > 8000 ifTrue: [ "size must be < 32k"
        str := (str copyFrom: 1 to: 8000), '...etc...'].
    str := str asExternalString.
    str size = 0 ifTrue: [ ^self ].
    self allHandles do: [ :h |
        ( GDILibrary
            textOut: h
            x: aPoint x
            y: aPoint y
            text: str asParameter
            length: str size )
                ifFalse: [ ^self osError ] ].
    "metafile DCs don't support GetTextExtent API"
    stringWidth := [ self stringWidthOf: str ] on: Error do: [ 0 ].
    self place: ( self location right: stringWidth )!  
getViewportOrg
        "Answer the viewport origin of the graphicsMedium
        associated with the receiver."
    | winPoint |
    ( GDILibrary
        getViewportOrgEx: self handle
        origin: ( winPoint := WinPoint new ) asParameter )
            ifFalse: [ ^self osError ].
    ^winPoint asPoint! 
taskModal
        "Make the receiver task modal."
    style := style | MbTaskmodal! 
isDragButton: anInteger
        "Answer whether the mouse button index identified by anInteger
        is a button that initiates a drag transfer on this host."
    ^DragDropSession isDragButton: anInteger! 
isDropDownList
        "Answer true if receiver is an instance of class
         DropDownList or one of its subclasses, else answer false."
    ^false!
displayAt: aPoint
        "Display the receiver at aPoint with the Display pen."
    self displayAt: aPoint with: Display pen!  
wmHScroll: wordInteger with: longInteger
        "Private - Process a WM_HSCROLL message."
    | type pos |
    type := wordInteger lowWord.

    type = SbLineup ifTrue: [
            (self horizontalScrollPos > self horizontalScrollMinRange) ifTrue:[
                 self scrollHorizontal: self amountToScrollLeft]].
    type = SbLinedown ifTrue: [
            (self horizontalScrollPos < self horizontalScrollMaxRange) ifTrue:[
                self scrollHorizontal: self amountToScrollLeft negated]].
    type = SbPageup ifTrue: [
            self scrollHorizontal: (self amountToPageLeft
                min: (self horizontalScrollPos - self horizontalScrollMinRange)) ].
    type = SbPagedown ifTrue: [
            self scrollHorizontal: (self amountToPageLeft
                min: (self horizontalScrollMaxRange - self horizontalScrollPos)) negated].
    type = SbThumbposition
        ifTrue: ["end of tracking"
            pos := ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2.
            self updateHorizontalSliderTo: pos.
            self scrollHorizontal: self topCorner x - pos.
            ^nil].
    type = SbThumbtrack
        ifTrue: [^nil]
        ifFalse: [self updateHorizontalSlider].
    ^nil!  
printToFile
        "Answers whether the user has requested printing to a file"
     ^(self style & PdPrinttofile) ~= 0!
openTitle: aTitle fileSpec: aFileSpec showFileInButton: showFileIn
        "Private - Kept for backward compatibility.
         Create an Open... dialog box titled aTitle initialized to
         aFileSpec file specification"
     self title: aTitle;
            fileSpec: aFileSpec;
            hideReadonly;
            shareAware;
            addFilter: '*.*' description: 'All Files (*.*)';
            addFilter: '*.txt' description: 'Text Files (*.TXT)'.

    ( self propertyAt: #defFilter ) isNil ifTrue:[ self defFilter: '*.*'].
    self open.!   
getDDBits
        "Answer a ByteArray which contains the bits
         of the receiver in device dependent format."
    | bytes bits |
    bytes := self sizeInBytes.
    bits := ByteArray new: bytes.
    ( GDILibrary
        getBitmapBits: self handle
        count: bytes
        bitsStruct: bits asParameter ) = 0
            ifTrue: [ self osNotification ].  "some video drivers don't get this right, so don't make it an error"
    ^bits!  
getDC
        "Private - Answer the device context of the receiver."
    ^handle getDC! 
zoom
        "Private - Expand the pane to take up the entire area
          of its main window, or back to normal if it is
         already zoomed."
    | mainWindow unzoomedHidden unzoomedFramingBlock |
    mainWindow := self mainWindow.
    self zoomed
        ifFalse: [  "zoom"
            unzoomedHidden := Set new.
            mainWindow children do: [ :p | p isVisible ifFalse: [ unzoomedHidden add: p ] ].
            mainWindow propertyAt: #unzoomedHidden put: unzoomedHidden.
            mainWindow children do: [ :pane |
                pane == self ifFalse: [ pane hideWindow ] ].
            self propertyAt: #unzoomedFramingBlock put: self framingBlock.
            self framingBlock: [ :box | box ].
            self rectangleAttribute: mainWindow rectangle.
            self resizeWindow ]
        ifTrue: [  "unzoom"
            unzoomedHidden := mainWindow propertyAt: #unzoomedHidden.
            mainWindow propertyAt: #unzoomedHidden put: nil.
            mainWindow children do: [ :pane |
                ( pane == self or: [ unzoomedHidden includes: pane ] )
                    ifFalse: [ pane showWindow ] ].
            unzoomedFramingBlock := self propertyAt: #unzoomedFramingBlock.
            self propertyAt: #unzoomedFramingBlock put: nil.
            self framingBlock: unzoomedFramingBlock.
            self rectangleAttribute:
                ( unzoomedFramingBlock value: mainWindow rectangle ).
            self resizeWindow ].
    self zoomed: self zoomed not.
    mainWindow zoomed: mainWindow zoomed not!
collate
        "Answers whether the user has requested the copies to be collated"
     ^(self style & PdCollate) ~= 0! 
buildControl: parentWindow
        "Private - Create the Control for the receiver.
        Do Nothing."!
home
        "Center the pen on the receiver medium."
    | aPoint |
    self place: (aPoint := (width @ height) // 2).
    ^aPoint!  
validate
        "Private - The host window for the receiver was
         just created or recreated."
    | ctl3d |
    ( ctl3d := self class ctl3dIfEnabled ) notNil
        ifTrue: [ ctl3d current subclassCtl: self handle ].
    self performWhenValids.
    self font: self font.
    self isGlobalDragTarget ifTrue: [ self registerDragDrop ]!
displayText: aString
    at: aPoint
    in: aRectangle
    options: optionsInteger
    adx: anArray
        "Display aString at aPoint in aRectangle.  The
        optionsInteger contains host-dependent option settings.
        anArray defines intercharacter spacing."
    | str |
    str := aString asExternalString.
    self allHandles do: [ :h |
        GDILibrary extTextOut: h
            x: aPoint x
            y: aPoint y
            options: optionsInteger
            rect: aRectangle asParameter
            text: str asParameter
            length: str size
            dx: anArray asParameter ]! 
fromInteger: anInteger
        "Private - create a new instance of the receiver class
         from anInteger, where the low word is x and the high word
         is y."
    ^( WinPoint fromInteger: anInteger ) asPoint!
getWindowOrg
        "Answer the window origin."
    | winPoint |
    ( GDILibrary
        getWindowOrgEx: self handle
        origin: ( winPoint := WinPoint new ) asParameter )
            ifFalse: [ ^self osError ].
    ^winPoint asPoint!   
sizeInBytes
         "Private - Answer the default size in bytes."
    ^8!  
fromInteger: anInteger
        "Private - create a new instance of the receiver class
         from anInteger, where the low word is x and the high word
         is y"
    | long |
    long := ExternalLong fromInteger: anInteger.
    ^self new
        x: ( long shortAtOffset: 0 );
        y: ( long shortAtOffset: 2 );
        yourself!
fromPoint: aPoint
        "Private - Answer a WinPoint created from aPoint."
    ^self new
        x: aPoint x;
        y: aPoint y;
        yourself!   
printOn: aStream
        "Append a textual representation of the receiver to aStream."
    aStream nextPutAll: self class name, ' { ', self asPoint printString, ' } '! 
y
        "Private - Answer the y coordinate of the point."
    ^self longAtOffset: 4!  
y: anInteger
        "Private - Set the y coordinate of the point."
    self longAtOffset: 4 put: anInteger!
x
        "Private - Answer the x coordinate of the point."
    ^self longAtOffset: 0!  
x: anInteger
        "Private - Set the x coordinate of the point."
    self longAtOffset: 0 put: anInteger!
asPoint
        "Private - Answer the receiver as a Point."
    ^self x @ self y!   
dragTargetMultipleItemDefault
        "Private - answer whether instances of the receiver will by default
        accept multiple item drag-drop transfers."
    ^true!
getMapMode
        "Answer the current mapping mode. mapMode
         can be one of the following:
         MmText, MmLometric, MmHimetric, MmLoenglish,
         MmHienglish, MmTwips, MmIsotropic, MmAnisotropic"
    | mode |
    ( mode := GDILibrary getMapMode: self handle ) = 0
        ifTrue: [ ^self osError ].
    ^mode! 
validate
        "Private - The host window for the receiver was
         just created or recreated."
    self setScrollRanges.
    topCorner isNil ifTrue: [topCorner := rectangle extent // 2].
    super validate!
flags
        "Private - Answers the dialog box current flags."
    ^chooseColorStruct flags!   
bringToFront
        "Make the receiver the front window."
    self showWindowAtTop!
copyStruct
        "Private - copies the openFileNameStruct to nonSmalltalk memory"
    | aMemoryAddress temp |
    temp := ExternalAddress copyToNonSmalltalkMemory: openFileNameStruct contents.
    openFileNameStruct := SelfDefinedStructure named: 'OPENFILENAME' atAddress: temp.
    temp := fileName asAsciiZ.
    aMemoryAddress := ExternalAddress allocateMemory: 128.
    lpstrFile := aMemoryAddress
        replaceFrom: 1
        to: temp basicSize
        with: temp
        startingAt: 1.
    lpstrFilter := ExternalAddress copyToNonSmalltalkMemory: self filters asParameter.
    lpstrInitialDir := ExternalAddress copyToNonSmalltalkMemory: self directory drivePathName.
    openFileNameStruct
        lpstrFile: lpstrFile asInteger;
        nMaxFile: aMemoryAddress memorySize;
        lpstrFilter: lpstrFilter asInteger;
        nFilterIndex: ( self propertyAt: #defFilterIndex );      "set by filters"
        lpstrInitialDir: lpstrInitialDir asInteger.

    ( temp := self propertyAt: #defExtension ) notNil ifTrue: [
        lpstrDefExt := ExternalAddress copyToNonSmalltalkMemory: temp.
        openFileNameStruct lpstrDefExt: lpstrDefExt asInteger ].
    ( temp := self propertyAt: #title ) notNil ifTrue: [
        lpstrTitle := ExternalAddress copyToNonSmalltalkMemory: temp.
        openFileNameStruct lpstrTitle: lpstrTitle asInteger ]!   
doDragDropAt: aPoint
        "Private - start a drag drop transfer with the receiver as the source."
    | sessionClass |
    ( sessionClass := self dragSessionClass ) isNil
        ifTrue: [ sessionClass := DragDropSession defaultClass ].
    ( sessionClass source: self ) doDragDropAt: aPoint.
    self dragSourceSelection: nil!  
graphicsToolBackColor: aColor
        "Private - Set the graphicsTool background color of the receiver."
    graphicsTool notNil
        ifTrue: [ graphicsTool backColor: aColor ].
    children size ~= 0 ifTrue: [
        children do: [ :pane |
            ( pane propertyAt: #backColor ) isNil
                ifTrue: [ pane graphicsToolBackColor: aColor ] ] ]! 
noDefaults
        "Removes the printer dialog's default styles"
    self style: 0! 
fromCollection: aCollection
        "Answer a new instance of the receiver
         which contains copies of all the structures
         in aCollection."
    ^self new
        collection: aCollection! 
collection: aCollection
        "Private - set the collection of structures
         that the receiver contains to aCollection."
    collection := aCollection!
asParameter
        "Answer the receiver in a form suitable for passing
         to an API call: copy the contained structures
         into the contents instance variable."
    | size byteArray offset |
    size := collection inject: 0 into: [ :bytes :item |
        bytes + item contents size ].
    byteArray := ByteArray new: size.
    offset := 1.
    collection do: [ :item |
        byteArray
            replaceFrom: offset
            to: offset + item contents size - 1
            with: item contents
            startingAt: 1.
        offset := offset + item contents size ].
    contents := byteArray.
    ^contents!
collection
    ^collection!  
dragTargetSelection
		"Private - answer the last selection over which the mouse was dragged
		during a drag-drop transfer."
	^self propertyAt: #dragTargetSelection!   
dragTargetDropDefault: dragSession
        "Private - provide default handling of drop if no handler
        is provided by inserting the item into the list."
    | string dragFormats format firstPosition position top toInsert backwardDrag compensate saveIndices |
    ( dragFormats := self dragTargetFormats ) isNil
        ifTrue: [ ^self error: 'dragTargetFormats: must be specified' ].
    toInsert := dragSession objects collect: [ :obj |
        format := dragFormats detect: [ :s | obj hasFormat: s ] ifNone: [ ^nil ].
        obj format: format ].
    ( self dragTargetOperations includes: dragSession operation ) ifFalse: [ ^nil ].

    saveIndices := toInsert collect: [ :s | self indexOf: s ].
    top := self getTopIndex.
    firstPosition := self itemIndexFromPoint: dragSession targetLocation.
    position := firstPosition.
    ( position > ( self list size ) )   "drop way past end of list"
        ifTrue: [ position := self list size + 1 ].

    toInsert first isString ifTrue: [
        "treat multiple lines of text as multiple list items"
        toInsert := ( toInsert first asArrayOfSubstringsSeparatedBy: 10 asCharacter ) collect: [ :s | s trimBlanks ].
        toInsert := toInsert reject: [ :s | s isEmpty ] ].
    toInsert do: [ :item |
        string := self stringForItem: item.
        self insertItem: string at: position.
        position := position + 1 ].
    self setTopIndex: top.
    backwardDrag := ( dragSession source == self ) and: [ self dragSourceSelection > firstPosition  ].
    compensate := ( backwardDrag ifTrue: [ toInsert size ] ifFalse: [ 0 ] ).
    ( dragSession source == self )
        ifTrue: [ self setValueIndices: ( saveIndices collect: [ :i | i + compensate ] ) ]! 
wmLbuttondblclk: wordInteger with: longInteger
        "Private - Process the left button double click message."
    self
        sendInputEvent: #button1DoubleClick:
        with: ( Point fromInteger: longInteger ).
    ^nil!   
applyStyle
        "Private - apply a style change to a window which accepts it."
    UserLibrary
        setWindowLong: self handle asParameter
        index: GwlStyle
        long: self style.
    UserLibrary
        setWindowLong: self handle asParameter
        index: GwlExstyle
        long: self extendedStyle.
    self handle
        setWindowPos: nil   "to redraw the window"
        rectangle: self frameRelativeRectangle
        fs: SwpShowwindow | SwpDrawframe | SwpNozorder.! 
dragDropMoveScroll
        "Answer the instance of the receiver class used
        to indicate a drag-drop move with drag target scrolling."
    ^DragDropMoveScroll!  
dragTargetDropDefault: dragSession
        "Private - provide default handling of drop if no handler
        is provided by inserting the item into the list."
    | dragObject string dragFormats format position top |
    dragObject := dragSession objects first.
    ( dragFormats := self dragTargetFormats ) isNil
        ifTrue: [ ^self error: 'dragTargetFormats: must be specified' ].
    format := dragFormats detect: [ :s | dragObject hasFormat: s ] ifNone: [ ^nil ].
    ( self dragTargetOperations includes: dragSession operation ) ifFalse: [ ^nil ].

    string := dragObject format: format.

    string isString 
        ifTrue: [ "treat multiple lines of text as multiple list items"
            string := ( string asArrayOfSubstringsSeparatedBy: 10 asCharacter ) collect: [ :s | s trimBlanks ].
            string := string reject: [ :s | s isEmpty ] ]
        ifFalse: [ string := Array with: string ].

    top := self topCorner y.
    position := self itemIndexFromPoint: dragSession targetLocation.
    ( dragSession source == self and: [ position < self dragSourceSelection ] )
        ifTrue: [ self dragSourceSelection: self dragSourceSelection + 1 ].
    string reverseDo: [ :s | self insertItem: s at: position ].
    self topCorner: ( self topCorner x @ top ).
    self selection: position!
wmLbuttondown: wordInteger with: longInteger
        "Private - Process left button down message."
    | point |
    self class toolTipInstalled
        ifTrue: [ self relay: WmLbuttondown wparam: wordInteger lparam: longInteger ].
    point := Point fromInteger: longInteger.
    ( wordInteger bitAnd: MkShift ) ~= 0
        ifTrue: [ self sendInputEvent: #button1DownShift: with: point ]
        ifFalse: [ self sendInputEvent: #button1Down: with: point ].
    ^nil! 
dragTargetDrawEmphasis: dragSession
		"Private - draw emphasis in the receiver indicating
		where a drop would occur within the receiver.  By default,
		do nothing.  Reimplemented in subclasses."
	self isDragTarget ifFalse: [ ^nil ].
    self
        triggerEvent: #dragTargetDrawEmphasis:
		withArguments: ( Array with: dragSession )
        ifNotHandled: [ self dragTargetDrawEmphasisDefault: dragSession ].!
pushButton
        "Set and answer the pushbutton control style."
    self removeStyle: BsDefpushbutton.
    ^self addStyle: BsPushbutton! 
hasDescendant: aWindow
        "Answer whether aWindow is a child window of the receiver."
    ^UserLibrary isChild: self handle child: aWindow handle!